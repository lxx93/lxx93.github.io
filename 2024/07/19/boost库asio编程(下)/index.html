<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>boost库asio编程(下) | -lxxl-</title><meta name="author" content="lxx9339-T"><meta name="copyright" content="lxx9339-T"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. beast网络库搭建http服务器1.1 简介通过asio来实现http服务器也需要严格服从http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。一个标准的HTTP报文头通常由请求头和响应头两部分组成。 http请求头格式： 123456GET &#x2F;index.html HTTP&#x2F;1">
<meta property="og:type" content="article">
<meta property="og:title" content="boost库asio编程(下)">
<meta property="og:url" content="https://lxx93.online/2024/07/19/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8B)/index.html">
<meta property="og:site_name" content="-lxxl-">
<meta property="og:description" content="1. beast网络库搭建http服务器1.1 简介通过asio来实现http服务器也需要严格服从http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。一个标准的HTTP报文头通常由请求头和响应头两部分组成。 http请求头格式： 123456GET &#x2F;index.html HTTP&#x2F;1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxx93.online/img/12.png">
<meta property="article:published_time" content="2024-07-19T09:58:23.000Z">
<meta property="article:modified_time" content="2024-07-24T01:01:05.589Z">
<meta property="article:author" content="lxx9339-T">
<meta property="article:tag" content="asio">
<meta property="article:tag" content="异步编程">
<meta property="article:tag" content="网络编程">
<meta property="article:tag" content="粘包">
<meta property="article:tag" content="Json">
<meta property="article:tag" content="高并发">
<meta property="article:tag" content="boost">
<meta property="article:tag" content="IOServicePool">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxx93.online/img/12.png"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://lxx93.online/2024/07/19/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8B)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":390},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":"50                //字数限制","languages":{"author":"作者: lxx9339-T","link":"链接: ","source":"来源: -lxxl-","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'boost库asio编程(下)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-24 09:01:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><link rel="stylesheet" href="/css/music.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="-lxxl-" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/12.png')"><nav id="nav"><span id="blog-info"><a href="/" title="-lxxl-"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo1.png"/><span class="site-name">-lxxl-</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">boost库asio编程(下)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-19T09:58:23.000Z" title="发表于 2024-07-19 17:58:23">2024-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-24T01:01:05.589Z" title="更新于 2024-07-24 09:01:05">2024-07-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/asio%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">asio网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="boost库asio编程(下)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-beast网络库搭建http服务器"><a href="#1-beast网络库搭建http服务器" class="headerlink" title="1. beast网络库搭建http服务器"></a>1. beast网络库搭建http服务器</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>通过asio来实现http服务器也需要严格服从http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。一个标准的HTTP报文头通常由<strong>请求头</strong>和<strong>响应头</strong>两部分组成。</p>
<p>http请求头格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span>     <span class="comment">//包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</span></span><br><span class="line">Host: www.example.com        <span class="comment">//指定被请求资源的主机名或IP地址和端口号。</span></span><br><span class="line">Accept: text/html, application/xhtml+xml    <span class="comment">//指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">123.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">123.0</span>    <span class="comment">//客户端使用的浏览器类型和版本号，供服务器统计用户代理信息</span></span><br><span class="line">Cookie: sessionid=abcdefg1234567    <span class="comment">//如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要持久连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<p>http响应头格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK            <span class="comment">//包含协议版本、状态码和状态消息</span></span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span>    <span class="comment">//响应体的MIME类型</span></span><br><span class="line">Content-Length: <span class="number">1024</span>       <span class="comment">//响应体的字节数</span></span><br><span class="line">Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/      <span class="comment">//服务器向客户端发送cookie信息时使用该字段</span></span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.32</span> (Unix) mod_ssl/<span class="number">2.2</span><span class="number">.32</span> OpenSSL/<span class="number">1.0</span><span class="number">.1</span>e-fips mod_bwlimited/<span class="number">1.4</span>  <span class="comment">//服务器类型和版本号</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要保持长连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-http服务器实现"><a href="#1-2-http服务器实现" class="headerlink" title="1.2 http服务器实现"></a>1.2 http服务器实现</h2><p>首先需要重新定义boost库的命名空间，并且创建了两个函数，方便后面对程序进行检测。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = beast::http;</span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名一个作用域，程序的声明</span></span><br><span class="line"><span class="keyword">namespace</span> my_program_state &#123;    <span class="comment">//定义了两个全局函数</span></span><br><span class="line">    <span class="comment">//统计对端请求的次数</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">request_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>;  <span class="comment">//这个值初始化一次，之后访问都是之前的数据</span></span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到现在的时间戳</span></span><br><span class="line">    <span class="function">std::<span class="type">time_t</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：负责初始化ip和端口的初始化，启动上下文服务轮询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> address = net::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);   <span class="comment">//static_cast是静态转换类型</span></span><br><span class="line">        net::io_context ioc&#123; <span class="number">1</span> &#125;;   <span class="comment">//初始化一个io_context,最多支持一个线程去调度</span></span><br><span class="line">        tcp::acceptor acceptor&#123; ioc,&#123;address,port&#125; &#125;;</span><br><span class="line">        tcp::socket socket&#123; ioc &#125;;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);    <span class="comment">//调用http_server函数，进行http连接</span></span><br><span class="line">        ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_server函数实现：http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建<code>http_connection</code>类型的智能指针,并且启动服务，新连接监听对端接收和发送数据。然后http_server继续监听对端的新连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(tcp::acceptor&amp; acceptor, tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">start</span>();  <span class="comment">//创建一个http_connection的共享指针，创建好就直接启动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);   <span class="comment">//继续监听连接请求</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_connection连接类的实现：负责读取对端发来数据的请求头，并且设置响应头，通过异步方式发送回给对端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传入一个socket，构造连接,初始化socket_是通过移动构造完成的</span></span><br><span class="line">    <span class="built_in">http_connection</span>(tcp::socket socket):<span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读请求</span></span><br><span class="line">        <span class="built_in">read_request</span>();</span><br><span class="line">        <span class="comment">//判断超时，保证一个链接不要处理太长时间</span></span><br><span class="line">        <span class="built_in">check_deadline</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tcp::socket socket_;</span><br><span class="line">    beast::flat_buffer buffer_&#123; <span class="number">8192</span> &#125;;     <span class="comment">//接收数据的缓存</span></span><br><span class="line">    http::request&lt;http::dynamic_body&gt;request_;    <span class="comment">//定义一个请求</span></span><br><span class="line">    http::response&lt;http::dynamic_body&gt;response_;  <span class="comment">//定义一个回应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//steady_timer是boost提供的一种定时器类型</span></span><br><span class="line">    net::steady_timer deadline_&#123;</span><br><span class="line">        <span class="comment">//初始化调度器</span></span><br><span class="line">        socket_.<span class="built_in">get_executor</span>(), std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>)  <span class="comment">//初始化一个时钟，60秒调度一次</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;  <span class="comment">//读请求函数实现</span></span><br><span class="line">        <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>(); <span class="comment">//不能用make_shared创建，因为通过这种方法创建出来的http_connection不与外面使用的共享引用计数</span></span><br><span class="line">        <span class="comment">//read_request() 函数中的 http::async_read 调用是为了从套接字 socket_ 中异步读取数据到 buffer_ 中，然后解析这些数据到request_对象中。request_ 通常是一个HTTP请求解析器对象，用于解析HTTP请求。</span></span><br><span class="line">        <span class="comment">//参数：当前HTTP连接的套接字；存储读取的数据的缓冲区；回调函数，当异步读取操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_read</span>(socket_, buffer_, request_, [self](beast::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;  <span class="comment">//用作async_read的回调函数，参数：错误码；传输的字节数</span></span><br><span class="line">                boost::<span class="built_in">ignore_unused</span>(bytes_transferred); <span class="comment">//使用Boost库中的ignore_unused宏来告诉编译器忽略未使用的bytes_transferred变量，避免编译警告</span></span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    self-&gt;<span class="built_in">process_request</span>();    <span class="comment">//处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测定时器，判断该定时器有无超时，超时就关闭socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();   <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="comment">//异步等待，60秒后，会执行匿名函数</span></span><br><span class="line">        deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                self-&gt;socket_.<span class="built_in">close</span>(ec);  <span class="comment">//捕获的智能指针self，保证该匿名函数执行期间，http_connection没有被停止掉</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());   <span class="comment">//回应的版本，response_是回应头，回应的版本是响应头使用的版本</span></span><br><span class="line">        response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);       <span class="comment">//false表示短连接，true表示长连接</span></span><br><span class="line">        <span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;   <span class="comment">//检测请求类型</span></span><br><span class="line">        <span class="keyword">case</span> http::verb::get:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_response</span>();     <span class="comment">//创建get类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> http::verb::post:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_post_response</span>();   <span class="comment">//创建post类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::bad_request);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//回复的是纯文本类型content_type</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;Invalid request-method&#x27;&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无论请求是哪种，最后都需要回应请求</span></span><br><span class="line">        <span class="built_in">write_response</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;   <span class="comment">//如果路由是/count，就进行统计</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Request count &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;There have been &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;requests so far.&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;  <span class="comment">//如果路由是/time，就获取当前的时间戳</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Cyrrent time &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;seconds since the epoch..&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">//没有找到路由(路径地址)</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于异步发送HTTP响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());  <span class="comment">//设置HTTP响应的Content-Length 头部字段。这个字段告诉客户端响应体的大小</span></span><br><span class="line">        <span class="comment">//启动一个异步写操作，将HTTP响应发送到客户端。参数：当前HTTP连接的套接字；包含HTTP响应的HTTP消息对象；回调函数，当异步写操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_write</span>(socket_, response_, [self](beast::error_code ec, std::<span class="type">size_t</span>) &#123;</span><br><span class="line">            self-&gt;socket_.<span class="built_in">shutdown</span>(tcp::socket::shutdown_send);  <span class="comment">//首先调用 shutdown 方法关闭套接字的发送部分。参数表示关闭发送方向，但不关闭接收方向</span></span><br><span class="line">            self-&gt;deadline_.<span class="built_in">cancel</span>();    <span class="comment">//取消任何设置的超时</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();         <span class="comment">//获取HTTP请求的主体部分。</span></span><br><span class="line">            <span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());   <span class="comment">//将请求主体的缓冲区数据转换为字符串</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/json&quot;</span>);  <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/json&quot;</span></span><br><span class="line">            Json::Value root;         <span class="comment">//创建一个JSON值对象 root，用于构建响应的JSON结构</span></span><br><span class="line">            Json::Reader reader;      <span class="comment">//创建一个JSON读取器对象 reader</span></span><br><span class="line">            Json::Value src_root;     <span class="comment">//创建一个源JSON值对象 src_root，用于存储解析后的JSON数据</span></span><br><span class="line">            <span class="comment">//使用 reader 解析请求主体字符串 body_str 到 src_root，并将解析成功与否存储在 parse_success 变量中</span></span><br><span class="line">            <span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">            <span class="keyword">if</span> (!parse_success) &#123;    <span class="comment">//如果解析失败</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Failed to parse Json data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;    <span class="comment">//在响应的JSON对象中设置错误代码</span></span><br><span class="line">                std::string jsonstr = root.<span class="built_in">toStyledString</span>();    <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">                beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;    <span class="comment">//将JSON字符串写入响应主体</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果解析成功，从解析后的JSON对象中获取 &quot;email&quot; 字段的值</span></span><br><span class="line">            <span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line">            root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;                     <span class="comment">//在响应的JSON对象中设置错误代码为0，表示成功</span></span><br><span class="line">            root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];     <span class="comment">//将电子邮件地址添加到响应的JSON对象中</span></span><br><span class="line">            root[<span class="string">&quot;mag&quot;</span>] = <span class="string">&quot;receive email post success&quot;</span>;   <span class="comment">//添加一条消息到响应的JSON对象中</span></span><br><span class="line">            std::string jsonstr = root.<span class="built_in">toStyledString</span>();   <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;   <span class="comment">////将JSON字符串写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">//如果请求的目标不是 &quot;/email&quot;</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);   <span class="comment">//设置HTTP响应的状态为 404 Not Found。</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/plain</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;    <span class="comment">//将 &quot;File not found&quot; 消息写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后启动http的服务器，如果本地浏览器输入<code>127.0.0.1:8080/count</code>，进入界面后不断刷新，就可以看到严格计数的效果；如果在本地浏览器输入<code>127.0.0.1:8080/time</code>，也可以获得当前的时间戳；对于实现的post类型请求，需要结合软件完成检测。</p>
<h1 id="2-beast网络库实现websocket服务器"><a href="#2-beast网络库实现websocket服务器" class="headerlink" title="2. beast网络库实现websocket服务器"></a>2. beast网络库实现websocket服务器</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>对于如何使用Beast库实现一个WebSocket服务器，以及如何处理不同类型的请求。具体来说，这句话包含了以下几个要点：</p>
<ul>
<li><p><strong>WebSocket协议和HTTP协议的关系</strong>：WebSocket是一种长连接协议，允许服务器和客户端之间进行双向通信。虽然它是在HTTP协议之上建立的，但它在建立连接后升级为WebSocket协议。</p>
</li>
<li><p><strong>请求的区分</strong>：当在浏览器中输入一个以<code>ws://</code>开头的URL（例如<code>ws://127.0.0.1:9501</code>），浏览器会发起一个WebSocket请求，目标是本地服务器的9501端口。</p>
</li>
<li><p><strong>Beast库的作用</strong>：Beast库提供了处理WebSocket协议的功能。它允许我们在一个HTTP服务器的基础上，通过协议升级的方式来处理WebSocket请求。</p>
</li>
<li><p><strong>请求处理逻辑</strong>：当服务器收到一个请求时，需要判断该请求是普通的HTTP请求还是WebSocket请求。如果是WebSocket请求，服务器将升级协议并处理该请求；如果是普通的HTTP请求，则按HTTP请求处理。</p>
</li>
</ul>
<h2 id="2-2-websocket服务器实现"><a href="#2-2-websocket服务器实现" class="headerlink" title="2.2 websocket服务器实现"></a>2.2 websocket服务器实现</h2><p>主函数实现：负责初始化工作任务需要的内容，并启动上下文服务。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	net::io_context ioc;    <span class="comment">//初始化一个上下文</span></span><br><span class="line">	<span class="function">WebSocketServer <span class="title">server</span><span class="params">(ioc, <span class="number">10086</span>)</span></span>;    <span class="comment">//通过该ioc构建一个server,端口是10086</span></span><br><span class="line">	server.<span class="built_in">StartAccept</span>();   <span class="comment">//执行WebSocketServer的StartAccept()函数，server接收新的连接</span></span><br><span class="line">	ioc.<span class="built_in">run</span>();    <span class="comment">//ioc跑起来，启动事件服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管理类ConnectionMgr实现：在类中创建了一个无序的map容器<code>_map_cons</code>，key值是转化为字符串的uuid值，value值是对应的Connection类型的智能指针。并且定义了两个函数，对容器<code>_map_cons</code>对连接进行加入和删除操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------头文件-------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> ConnectionMgr&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;     <span class="comment">//实现单例模式</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span></span>;   <span class="comment">//加入连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RmvConnection</span><span class="params">(std::string)</span></span>;                         <span class="comment">//移出连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ConnectionMgr</span>(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;             <span class="comment">//去除拷贝构造函数</span></span><br><span class="line">	ConnectionMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;  <span class="comment">//去除赋值构造函数</span></span><br><span class="line">	<span class="built_in">ConnectionMgr</span>();</span><br><span class="line">	boost::unordered_map&lt;std::string, std::shared_ptr&lt;Connection&gt;&gt;_map_cons;   <span class="comment">//无序map,管理连接</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------------------函数初始化---------------------------</span></span><br><span class="line"><span class="function">ConnectionMgr&amp; <span class="title">ConnectionMgr::GetInstance</span><span class="params">()</span> </span>&#123;   <span class="comment">//C++11以上的版本，通过这种方式实现单例模式</span></span><br><span class="line">	<span class="type">static</span> ConnectionMgr instance;    <span class="comment">//定义一个局部变量</span></span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span> </span>&#123;</span><br><span class="line">	_map_cons[conptr-&gt;<span class="built_in">GetUid</span>()] = conptr;     <span class="comment">//将连接的uid和对应的连接通过map来进行管理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::RmvConnection</span><span class="params">(std::string id)</span> </span>&#123;</span><br><span class="line">	_map_cons.<span class="built_in">erase</span>(id);     <span class="comment">//通过id来删除</span></span><br><span class="line">&#125;</span><br><span class="line">ConnectionMgr::<span class="built_in">ConnectionMgr</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSocketServer类实现：负责不断监听对端的连接，当与对端建立连接后，就调用Connection类的AsyncAccept函数，将协议升级为了websocket。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------------------------头文件----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WebSocketServer</span>(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;     <span class="comment">//去除拷贝构造</span></span><br><span class="line">	WebSocketServer&amp; <span class="keyword">operator</span> = (<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除赋值构造</span></span><br><span class="line">	<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;          <span class="comment">//接收连接，是TCP上的接收连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	net::ip::tcp::acceptor _acceptor;    <span class="comment">//接收连接的一个接收器</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------------------函数实现-------------------------------------</span></span><br><span class="line">WebSocketServer::<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) :_ioc(ioc),</span><br><span class="line">_acceptor(ioc, net::ip::tcp::<span class="built_in">endpoint</span>(net::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;   <span class="comment">//开始连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebSocketServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> con_ptr = std::<span class="built_in">make_shared</span>&lt;Connection&gt;(_ioc);        <span class="comment">//创建一个Connection类型的智能指针</span></span><br><span class="line">	<span class="comment">//接收连接</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(con_ptr-&gt;<span class="built_in">GetSocket</span>(), [<span class="keyword">this</span>, con_ptr](error_code err) &#123; <span class="comment">//GetSocket()返回的是connection最低层的socket(tcp的socket)</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;     <span class="comment">//没有错误</span></span><br><span class="line">				con_ptr-&gt;<span class="built_in">AsyncAccept</span>();    <span class="comment">//相当于升级了，将协议升级为了websocket</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;acceptor async_accept failed, err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;  <span class="comment">//连接失败，打印原因</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">StartAccept</span>();    <span class="comment">//server接收新的连接</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;async_accept error is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Connection类实现：负责将协议生成websocketm，当与对端建立成功后，异步接收数据和异步发送数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------头文件-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;Connection&gt; &#123;  <span class="comment">//连接通过智能指针去管理，允许从内部去构造智能指针，并且与外部使用的智能指针共享引用计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(net::io_context&amp; ioc);</span><br><span class="line">	<span class="function">std::string <span class="title">GetUid</span><span class="params">()</span></span>;                <span class="comment">//返回uid</span></span><br><span class="line">	<span class="comment">//connect内部是管理websocket，而websocket底层是通过tcp来实现的，所以它底层有一个socket</span></span><br><span class="line">	net::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;   <span class="comment">//该函数返回该底层的socket(外面可能会用到)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncAccept</span><span class="params">()</span></span>;    <span class="comment">//在tcp层面建立好连接后，还要在websocket层面做一个升级，升级就可以调用这个异步的连接函数进行升级</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;           <span class="comment">//接收对端的数据的，进行收发的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncSend</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::unique_ptr&lt;stream&lt;tcp_stream&gt;&gt;_ws_ptr;   <span class="comment">//用unique_ptr管理外部websocket</span></span><br><span class="line">	std::string _uuid;      <span class="comment">//有唯一的id</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">	flat_buffer _recv_buffer;        <span class="comment">//存储接收的数据</span></span><br><span class="line">	std::queue&lt;std::string&gt;_send_que;    <span class="comment">//发送队列</span></span><br><span class="line">	std::mutex _send_mtx;      <span class="comment">//发送的一个锁</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------函数实现--------------------------------------</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>(net::io_context&amp; ioc):_ioc(ioc),</span><br><span class="line">_ws_ptr(std::make_unique&lt;stream&lt;tcp_stream&gt;&gt;(<span class="built_in">make_strand</span>(ioc)))  <span class="comment">//构造一个stream&lt;tcp_stream&gt;类型的智能指针。通过上下文构造一个strand执行器，则这里的执行器与上下文的执行器就是同一个了</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成唯一的uuid</span></span><br><span class="line">	boost::uuids::random_generator generator;   <span class="comment">//生成generator</span></span><br><span class="line">	boost::uuids::uuid uuid = <span class="built_in">generator</span>();      <span class="comment">//通过generator来生成唯一的uuid</span></span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(uuid);      <span class="comment">//为了存储该uuid,需要转换为string类型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Connection::GetUid</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">Connection::GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//socket()是会返回websocket内部管理的最底层的socket的引用，只要的wensocke不被释放，返回的socket也不会被释放</span></span><br><span class="line">	<span class="keyword">return</span> boost::beast::<span class="built_in">get_lowest_layer</span>(*_ws_ptr).<span class="built_in">socket</span>();  <span class="comment">//返回智能指针_ws_ptr所指向的websocket的最底层(是tcp类型的socket)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步的接收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//生成一个自己的智能指针，通过这种方式生成的智能指针和其它的共享指针共享引用计数</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();    <span class="comment">//其它智能指针可能也在管理connection，为了不与它们同步引用计数，所以需要shared_from_this</span></span><br><span class="line">	<span class="comment">//websocket异步接收连接,结果相当于是在tcp的基础上，将协议生成websocket</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_accept</span>([self](boost::system::error_code err) &#123;  <span class="comment">//防止回调函数在没有调用之前，connection被智能指针释放掉，所以需要它的引用计数+1</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;   <span class="comment">//没有错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">AddConnection</span>(self); <span class="comment">//添加连接，将self智能指针加到管理类来管理</span></span><br><span class="line">				self-&gt;<span class="built_in">Start</span>();             <span class="comment">//接收读写</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket accept failed,err is&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket async accept exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//异步读</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_read</span>(_recv_buffer, [self](error_code err, std::<span class="type">size_t</span> buffer_bytes) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket async read error is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			self-&gt;_ws_ptr-&gt;<span class="built_in">text</span>(self-&gt;_ws_ptr-&gt;<span class="built_in">got_text</span>());   <span class="comment">//设置传输的类型，默认是对方发什么，就回什么类型</span></span><br><span class="line">			std::string recv_data = boost::beast::<span class="built_in">buffers_to_string</span>(self-&gt;_recv_buffer.<span class="built_in">data</span>()); <span class="comment">//存储收到的数据，并将收到的buffer类型数据转成string类型</span></span><br><span class="line">			self-&gt;_recv_buffer.<span class="built_in">consume</span>(self-&gt;_recv_buffer.<span class="built_in">size</span>());    <span class="comment">//清空_recv_buffer，为下次接收准备</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket recvive msg is &quot;</span> &lt;&lt; recv_data &lt;&lt; std::endl;      <span class="comment">//打印接收的数据</span></span><br><span class="line">			<span class="comment">//发送操作</span></span><br><span class="line">			self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(recv_data));   <span class="comment">//异步发送，为了减少拷贝，用move()操作</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();        <span class="comment">//发送完，就继续监听对方发送数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;    <span class="comment">//接收异常</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;    <span class="comment">//打印错误信息</span></span><br><span class="line">			ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncSend</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(_send_mtx);    <span class="comment">//对队列加锁</span></span><br><span class="line">		<span class="type">int</span> que_len = _send_que.<span class="built_in">size</span>();            <span class="comment">//取出队列的长度</span></span><br><span class="line">		_send_que.<span class="built_in">push</span>(msg);                       <span class="comment">//往队列添加发送的数据</span></span><br><span class="line">		<span class="keyword">if</span> (que_len &gt; <span class="number">0</span>) &#123;             <span class="comment">//如果没有放入队列之前，队列长度&gt;0，说明之前数据没有发送完，直接退出</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;    <span class="comment">//执行到这里的时候，进行析构，自动解锁</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    <span class="comment">//创建一个buffer，参数是消息的首地址，长度和lambda表达式(捕获发送对方的结果)</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_write</span>(boost::asio::<span class="built_in">buffer</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()), [self](error_code err, std::<span class="type">size_t</span> nsize) &#123;   <span class="comment">//错误码 和 没有发生错误情况下，发送了多少</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (err) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;async_send err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">					ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());     <span class="comment">//通过uid移出连接</span></span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				std::string send_msg;</span><br><span class="line">				&#123;   <span class="comment">//局部作用域</span></span><br><span class="line">					std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(self-&gt;_send_mtx);   <span class="comment">//对队列加锁</span></span><br><span class="line">					self-&gt;_send_que.<span class="built_in">pop</span>();        <span class="comment">//弹出队列首元素(上面的异步发送，是发送完成才回执行到这里)，队首的元素就是刚刚发送完毕的</span></span><br><span class="line">					<span class="keyword">if</span> (self-&gt;_send_que.<span class="built_in">empty</span>()) &#123;     <span class="comment">//再判断队列是否为空</span></span><br><span class="line">						<span class="keyword">return</span>;       <span class="comment">//为空就返回</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//不为空，说明还有数据，需要继续发送</span></span><br><span class="line">					send_msg = self-&gt;_send_que.<span class="built_in">front</span>();     <span class="comment">//把队首元素进行一个拷贝</span></span><br><span class="line">				&#125;  <span class="comment">//自动解锁</span></span><br><span class="line">				self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(send_msg)); <span class="comment">//异步发送，这里的移动操作字符串对于系统来说，差别不大，如果是结构体，用move效果会明显一点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;async_send exception is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;_uuid);     <span class="comment">//通过uid将异常连接移出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-执行效果"><a href="#2-3-执行效果" class="headerlink" title="2.3 执行效果"></a>2.3 执行效果</h2><p>1.启动服务器后，会跳出如下页面，这也表示服务器开始监听对端发来的连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_7.png"></p>
<p>2.在WebSocket的一个在线测试网站进行测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_8.png"></p>
<p>3.点击发送，接收服务器发送来的信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_9.png"></p>
<p>4.服务器终端情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_10.png"></p>
<h1 id="3-windows配置和使用grpc"><a href="#3-windows配置和使用grpc" class="headerlink" title="3. windows配置和使用grpc"></a>3. windows配置和使用grpc</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>当在windows环境配置好grpc，接下来是使用visual studio配置grpc，可以将之前编译好的库配置到项目中来完成grpc通信。</p>
<h2 id="3-2-项目配置"><a href="#3-2-项目配置" class="headerlink" title="3.2 项目配置"></a>3.2 项目配置</h2><p>1.创建Grpc-Server项目，在项目的根目录下创建一个名字为<code>demo.proto</code>的文件，编写程序如下：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span>(HelloReply)</span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在<code>demo.proto</code>所在文件打开Powershell窗口(终端好像也可)，然后利用grpc编译后生成的<code>proc.exe</code>生成proto的头文件和源文件，即执行如下命令生成<code>demo.grpc.pb.h</code>和<code>demo.grpc.pb.cc</code>文件(这两个文件是为grpc服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe  <span class="literal">-I</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--grpc_out</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--plugin</span>=protoc<span class="literal">-gen-grpc</span>=<span class="string">&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</span> <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li><p><code>C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe</code>：是存放protoc.exe所在的路径，也可以将其配置到环境变量，然后直接使用protoc.exe就行</p>
</li>
<li><p><code>-I=&quot;.&quot;</code> ：指定 <code>demo.proto</code>所在的路径为当前路径</p>
</li>
<li><p><code>--grpc_out=&quot;.&quot;</code> ：表示生成的pb.h和pb.cc文件的输出位置为当前目录</p>
</li>
<li><p><code>--plugin=protoc-gen-grpc=&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</code>：表示要用到的插件是<code>protoc-gen-grpc</code>，位置在<code>C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe</code></p>
</li>
<li><p><code>&quot;demo.proto&quot;</code>：要编译的proto文件</p>
</li>
</ul>
<p>3.因为要序列化数据，所以需要生成grpc类需要的pb文件，即在demo.proto所在目录下打开powershell窗口，执行如下命令，就会生成demo.pb.h和demo.pb.cc文件(这两个文件是为消息服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe <span class="literal">--cpp_out</span>=. <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>4.为项目中配置grpc库的包含目录和库目录。先配置Debug版本，方便调试。</p>
<p>右键vs里面的项目，选择：属性 —&gt; c&#x2F;c++ — &gt; 常规 —&gt; 附加包含目录 —&gt; 编辑</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_11.png"></p>
<p>点击编辑后，在弹出的窗口中添加如下文件目录(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\include</span><br><span class="line">C:\cppsoft\grpc\third_party\protobuf\src</span><br><span class="line">C:\cppsoft\grpc\third_party\abseil-cpp</span><br><span class="line">C:\cppsoft\grpc\third_party\address_sorting\include</span><br><span class="line">C:\cppsoft\grpc\third_party\re2</span><br></pre></td></tr></table></figure>

<p>5.再配置库路径, 选择：链接器 —&gt; 常规 —&gt; 附加库目录 —&gt; 编辑</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_12.png"></p>
<p>点击编辑后，在弹出的窗口添加以下路径(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\re2\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\types\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\synchronization\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\status\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\random\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\flags\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\debugging\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\container\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\hash\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\boringssl-with-bazel\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\numeric\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\time\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\base\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\strings\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\zlib\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\cares\cares\lib\Debug</span><br></pre></td></tr></table></figure>

<p>6.配置好库目录后，还要将要使用的库链接到项目。选择：链接器 —&gt; 输入 —&gt; 附加依赖项 —&gt; 编辑</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_13.png"></p>
<p>点击编辑后，在弹出的窗口添加依赖的库名字(以下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">libprotobufd.lib</span><br><span class="line">gpr.lib</span><br><span class="line">grpc.lib</span><br><span class="line">grpc++.lib</span><br><span class="line">grpc++_reflection.lib</span><br><span class="line">address_sorting.lib</span><br><span class="line">ws2_32.lib</span><br><span class="line">cares.lib</span><br><span class="line">zlibstaticd.lib</span><br><span class="line">upb.lib</span><br><span class="line">ssl.lib</span><br><span class="line">crypto.lib</span><br><span class="line">absl_bad_any_cast_impl.lib</span><br><span class="line">absl_bad_optional_access.lib</span><br><span class="line">absl_bad_variant_access.lib</span><br><span class="line">absl_base.lib</span><br><span class="line">absl_city.lib</span><br><span class="line">absl_civil_time.lib</span><br><span class="line">absl_cord.lib</span><br><span class="line">absl_debugging_internal.lib</span><br><span class="line">absl_demangle_internal.lib</span><br><span class="line">absl_examine_stack.lib</span><br><span class="line">absl_exponential_biased.lib</span><br><span class="line">absl_failure_signal_handler.lib</span><br><span class="line">absl_flags.lib</span><br><span class="line">absl_flags_config.lib</span><br><span class="line">absl_flags_internal.lib</span><br><span class="line">absl_flags_marshalling.lib</span><br><span class="line">absl_flags_parse.lib</span><br><span class="line">absl_flags_program_name.lib</span><br><span class="line">absl_flags_usage.lib</span><br><span class="line">absl_flags_usage_internal.lib</span><br><span class="line">absl_graphcycles_internal.lib</span><br><span class="line">absl_hash.lib</span><br><span class="line">absl_hashtablez_sampler.lib</span><br><span class="line">absl_int128.lib</span><br><span class="line">absl_leak_check.lib</span><br><span class="line">absl_leak_check_disable.lib</span><br><span class="line">absl_log_severity.lib</span><br><span class="line">absl_malloc_internal.lib</span><br><span class="line">absl_periodic_sampler.lib</span><br><span class="line">absl_random_distributions.lib</span><br><span class="line">absl_random_internal_distribution_test_util.lib</span><br><span class="line">absl_random_internal_pool_urbg.lib</span><br><span class="line">absl_random_internal_randen.lib</span><br><span class="line">absl_random_internal_randen_hwaes.lib</span><br><span class="line">absl_random_internal_randen_hwaes_impl.lib</span><br><span class="line">absl_random_internal_randen_slow.lib</span><br><span class="line">absl_random_internal_seed_material.lib</span><br><span class="line">absl_random_seed_gen_exception.lib</span><br><span class="line">absl_random_seed_sequences.lib</span><br><span class="line">absl_raw_hash_set.lib</span><br><span class="line">absl_raw_logging_internal.lib</span><br><span class="line">absl_scoped_set_env.lib</span><br><span class="line">absl_spinlock_wait.lib</span><br><span class="line">absl_stacktrace.lib</span><br><span class="line">absl_status.lib</span><br><span class="line">absl_strings.lib</span><br><span class="line">absl_strings_internal.lib</span><br><span class="line">absl_str_format_internal.lib</span><br><span class="line">absl_symbolize.lib</span><br><span class="line">absl_synchronization.lib</span><br><span class="line">absl_throw_delegate.lib</span><br><span class="line">absl_time.lib</span><br><span class="line">absl_time_zone.lib</span><br><span class="line">absl_statusor.lib</span><br><span class="line">re2.lib</span><br></pre></td></tr></table></figure>

<p>当完成这些配置，就可以通过grpc来进行服务器和客户端的通信了。</p>
<h1 id="4-grpc通信"><a href="#4-grpc通信" class="headerlink" title="4. grpc通信"></a>4. grpc通信</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>gRPC(Remote Procedure Call)是一种高性能、开源的远程过程调用(RPC)框架。它能够在不同的环境中进行跨语言的通信，并且使用HTTP&#x2F;2作为其传输协议，提供诸如负载均衡、跟踪、健康检查和认证等功能。</p>
<p>gRPC通信过程包括服务器端和客户端的代码，其中通过协议定义文件(proto文件)来定义消息格式和服务接口。</p>
<h2 id="4-2-proto文件"><a href="#4-2-proto文件" class="headerlink" title="4.2 proto文件"></a>4.2 proto文件</h2><p>proto文件定义了通信协议的消息格式和服务接口。在这里的proto文件定义了一个名为<code>hello</code>的包，包含一个<code>Greeter</code>服务和两个消息类型<code>HelloRequest</code>和<code>HelloReply</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line">service Greeter&#123;</span><br><span class="line">	<span class="function">rpc <span class="title">SayHello</span><span class="params">(HelloRequest)</span> <span class="title">returns</span><span class="params">(HelloReply)</span></span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">	string message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line">message HelloReply&#123;</span><br><span class="line">	string message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-服务器实现"><a href="#4-3-服务器实现" class="headerlink" title="4.3 服务器实现"></a>4.3 服务器实现</h2><p>服务器代码实现了proto文件中定义的<code>Greeter</code>服务。服务器启动后，监听指定的端口，等待客户端的请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用grpc的一些作用域</span></span><br><span class="line"><span class="keyword">using</span> grpc::Server;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerBuilder;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerContext;      <span class="comment">//server上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> hello::Greeter;   <span class="comment">//要用到的一个服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final表示终极的继承，GreeterServicelmpl继承public Greeter::Service后，其它的类就不能再继承了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreeterServicelmpl</span> <span class="keyword">final</span> :<span class="keyword">public</span> Greeter::Service &#123;</span><br><span class="line">    <span class="comment">//Status是返回的一个状态，grpc服务给别人提供调用的接口，都会返回一个状态</span></span><br><span class="line">    ::<span class="function">grpc::Status <span class="title">SayHello</span><span class="params">(::grpc::ServerContext* ccontext, <span class="type">const</span>::hello::HelloRequest* request, ::hello::HelloReply* response)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">prefix</span><span class="params">(<span class="string">&quot;llfc grpc server has received:&quot;</span>)</span></span>;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(prefix + request-&gt;<span class="built_in">message</span>());    <span class="comment">//修改一下回应(进行拼接)</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;     <span class="comment">//返回一个状态</span></span><br><span class="line">    &#125;  <span class="comment">//重写了父类Greeter的一个Service函数接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    GreeterServicelmpl service;</span><br><span class="line">    ServerBuilder builder;    <span class="comment">//创建服务的时候，需要ServerBuilder(规则)</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());   <span class="comment">//绑定端口。</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);     <span class="comment">//注册服务，将该服务注册给builder。服务就可以在后台执行了</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Server&gt;<span class="built_in">server</span>(builder.<span class="built_in">BuildAndStart</span>());   <span class="comment">//将端口和服务都绑定好的builder传递给server，</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();    <span class="comment">//阻塞，底层轮询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RunServer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补：<code>127.0.0.1</code>和<code>0.0.0.0</code>的区别：<code>127.0.0.0</code>是本地回路地址，不能网络，如果是本地客户端请求本地服务器，是可以的，但其它客户端访问不到。</p>
<h2 id="4-4-客户端实现"><a href="#4-4-客户端实现" class="headerlink" title="4.4 客户端实现"></a>4.4 客户端实现</h2><p>客户端代码创建一个与服务器通信的通道，通过这个通道，客户端可以调用服务器提供的服务(如<code>SayHello</code>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> grpc::ClientContext;     <span class="comment">//Clinent的上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;         <span class="comment">//发送消息，需要通道，通过该通道与服务器通信</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端不用继承服务，直接写即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//参数是通道类型，利用通道与服务端通信</span></span><br><span class="line">    <span class="built_in">FCClient</span>(std::shared_ptr&lt;Channel&gt;channel) :<span class="built_in">stub_</span>(Greeter::<span class="built_in">NewStub</span>(channel)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">SayHello</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        ClientContext context;       <span class="comment">//构造客户端的上下文</span></span><br><span class="line">        HelloReply reply;            <span class="comment">//回复</span></span><br><span class="line">        HelloRequest request;        <span class="comment">//请求</span></span><br><span class="line">        request.<span class="built_in">set_message</span>(name);     <span class="comment">//设置消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置好请求，下面是发过去</span></span><br><span class="line">        <span class="comment">//客户端发送消息，把request字符串通过protobuf序列化发送给服务器，服务器把数据修改好后，传回来，客户端收到数据后存到reply里</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">SayHello</span>(&amp;context, request, &amp;reply);   <span class="comment">//调用的是服务端的SayHello,对reply进行了修改，所以这里第三个参数传的是地址</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> reply.<span class="built_in">message</span>();    <span class="comment">//收到对方回应，如果是正常的就返回字符串即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;failure &quot;</span> + status.<span class="built_in">error_message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Greeter::Stub&gt;stub_;    <span class="comment">//stub_可以理解为客户端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行通信就必须创建channel管道，相当于是asio里面的端点，与谁通信</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;127.0.0.1:50051&quot;</span>, grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="function">FCClient <span class="title">client</span><span class="params">(channel)</span></span>;</span><br><span class="line">    <span class="comment">//客户端调用了SayHello函数，把参数(字符串消息)传给了服务器，返回服务器的发过来的数据</span></span><br><span class="line">    std::string result = client.<span class="built_in">SayHello</span>(<span class="string">&quot;hello lxx93.online!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get result [%s]\n&quot;</span>, result.<span class="built_in">c_str</span>());   <span class="comment">//打印获取的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-通信过程"><a href="#4-5-通信过程" class="headerlink" title="4.5 通信过程"></a>4.5 通信过程</h2><p>1.定义服务接口和消息格式</p>
<ul>
<li>在proto文件中，定义了一个名为<code>Greeter</code>的服务，包含一个RPC方法<code>SayHello</code>，该方法接受一个<code>HelloRequest</code>消息并返回一个<code>HelloReply</code>消息。</li>
</ul>
<p>2.生成代码</p>
<ul>
<li>使用protoc编译器从proto文件生成C++代码，包括消息类(如<code>HelloRequest</code>和<code>HelloReply</code>)和服务接口类(如<code>Greeter::Service</code>)</li>
</ul>
<p>3.实现服务器逻辑</p>
<ul>
<li>在服务器端，继承生成的<code>Greeter::Service</code>类，并实现<code>SayHello</code>方法。这个方法接收客户端的请求(<code>HelloRequest</code>)，处理后返回响应(<code>HelloReply</code>)。</li>
</ul>
<p>4.启动服务器</p>
<ul>
<li>服务器代码使用<code>ServerBuilder</code>配置和启动gRPC服务器，并在指定端口上监听客户端请求。</li>
</ul>
<p>5.客户端调用</p>
<ul>
<li>客户端创建一个通道，通过这个通道与服务器通信。客户端创建一个<code>Greeter::Stub</code>对象，这是一个客户端代理，通过它调用服务器端的<code>SayHello</code>方法。</li>
</ul>
<ul>
<li>在客户端调用<code>SayHello</code>方法时，客户端将<code>HelloRequest</code>消息序列化并发送给服务器。服务器接收请求后，处理并返回<code>HelloReply</code>消息。客户端接收响应并解码得到结果。</li>
</ul>
<h2 id="4-6-为什么客户端可以调用服务端的函数"><a href="#4-6-为什么客户端可以调用服务端的函数" class="headerlink" title="4.6 为什么客户端可以调用服务端的函数"></a>4.6 为什么客户端可以调用服务端的函数</h2><p>客户端并不直接调用服务端的函数，而是通过gRPC框架生成的客户端存根(stub)来间接调用。客户端调用存根的<code>SayHello</code>方法，gRPC框架负责处理网络通信，将请求发送到服务器，并接收服务器的响应。</p>
<p>步骤如下(结合上面编写的服务器和客户端)：</p>
<ol>
<li><p>客户端构建请求：创建并填充<code>HelloRequest</code>消息。</p>
</li>
<li><p>发送请求：通过调用<code>stub_-&gt;SayHello</code>将请求发送到服务器。</p>
</li>
<li><p>服务器处理请求：服务器接收请求，调用<code>GreeterServiceImpl::SayHello</code>方法进行处理，并构建<code>HelloReply</code>响应。</p>
</li>
<li><p>发送响应：服务器将响应发送回客户端。</p>
</li>
<li><p>客户端接收响应：客户端接收并解析<code>HelloReply</code>消息，从而得到服务器处理后的结果</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxx93.online">lxx9339-T</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxx93.online/2024/07/19/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8B)/">https://lxx93.online/2024/07/19/boost库asio编程(下)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lxx93.online" target="_blank">-lxxl-</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/asio/">asio</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a><a class="post-meta__tags" href="/tags/%E7%B2%98%E5%8C%85/">粘包</a><a class="post-meta__tags" href="/tags/Json/">Json</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a><a class="post-meta__tags" href="/tags/boost/">boost</a><a class="post-meta__tags" href="/tags/IOServicePool/">IOServicePool</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a></div><div class="post_share"><div class="social-share" data-image="/img/12.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/19/butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/" title="butterfly主题美化"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/13.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">butterfly主题美化</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/11/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%AD)/" title="boost库asio编程(中)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/11.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">boost库asio编程(中)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/11/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%AD)/" title="boost库asio编程(中)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/11.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-11</div><div class="title">boost库asio编程(中)</div></div></a></div><div><a href="/2024/07/08/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8A)/" title="boost库asio编程(上)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-08</div><div class="title">boost库asio编程(上)</div></div></a></div><div><a href="/2024/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Blibevent/" title="高并发网络编程libevent"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">高并发网络编程libevent</div></div></a></div><div><a href="/2024/07/24/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9C%A8%E7%BA%BF%E8%AF%8D%E5%85%B8/" title="linux网络编程小项目-在线词典"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/15.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">linux网络编程小项目-在线词典</div></div></a></div><div><a href="/2024/07/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="title">网络编程</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lxx9339-T</div><div class="author-info__description">即使身处阴沟,也能仰望星空。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2235221711@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2235221711&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-beast%E7%BD%91%E7%BB%9C%E5%BA%93%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">1. beast网络库搭建http服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 http服务器实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-beast%E7%BD%91%E7%BB%9C%E5%BA%93%E5%AE%9E%E7%8E%B0websocket%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">2. beast网络库实现websocket服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-websocket%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 websocket服务器实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C"><span class="toc-text">2.3 执行效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-windows%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8grpc"><span class="toc-text">3. windows配置和使用grpc</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-text">3.2 项目配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-grpc%E9%80%9A%E4%BF%A1"><span class="toc-text">4. grpc通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-proto%E6%96%87%E4%BB%B6"><span class="toc-text">4.2 proto文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.3 服务器实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.4 客户端实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">4.5 通信过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">4.6 为什么客户端可以调用服务端的函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AEc++%E5%85%A8%E6%A0%88/" title="聊天项目c++全栈"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/26.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="聊天项目c++全栈"/></a><div class="content"><a class="title" href="/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AEc++%E5%85%A8%E6%A0%88/" title="聊天项目c++全栈">聊天项目c++全栈</a><time datetime="2024-09-03T07:34:24.000Z" title="发表于 2024-09-03 15:34:24">2024-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc++/" title="设计模式c++"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式c++"/></a><div class="content"><a class="title" href="/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fc++/" title="设计模式c++">设计模式c++</a><time datetime="2024-08-29T07:34:24.000Z" title="发表于 2024-08-29 15:34:24">2024-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7c++11/" title="新特性c++11"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/24.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="新特性c++11"/></a><div class="content"><a class="title" href="/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7c++11/" title="新特性c++11">新特性c++11</a><time datetime="2024-08-26T10:34:13.000Z" title="发表于 2024-08-26 18:34:13">2024-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/" title="Http高并发服务器项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Http高并发服务器项目"/></a><div class="content"><a class="title" href="/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/" title="Http高并发服务器项目">Http高并发服务器项目</a><time datetime="2024-08-20T14:09:56.000Z" title="发表于 2024-08-20 22:09:56">2024-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/" title="Qt斗地主项目(下)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt斗地主项目(下)"/></a><div class="content"><a class="title" href="/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/" title="Qt斗地主项目(下)">Qt斗地主项目(下)</a><time datetime="2024-08-08T09:24:35.000Z" title="发表于 2024-08-08 17:24:35">2024-08-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> lxx9339-T</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true       //软加载打开，可以提高网址性能) {
    if (true       //软加载打开，可以提高网址性能) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="12221117397" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script> - <script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'a24c62babc5b484d932b02c4747b0f56';
  var gaud_map_key = '9bcdd4b88228b310aa9787a1153666fd';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '103.719156,36.104195';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>