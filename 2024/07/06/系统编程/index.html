<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>系统编程 | -lxxl-</title><meta name="author" content="lxx9339-T"><meta name="copyright" content="lxx9339-T"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.基础入门1.1基本函数open()函数：打开一个文件 int open(char *pathname , int flags , mode_t mode)  参数：  pathname：想要打开的文件路径名  flags(头文件#include )：文件打开方式：O_CREAT|OAPPEND|…   mode：权限，当第二个参数设置了O_CREAT，就需要写该参数     mode:设置文件">
<meta property="og:type" content="article">
<meta property="og:title" content="系统编程">
<meta property="og:url" content="https://lxx93.online/2024/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="-lxxl-">
<meta property="og:description" content="1.基础入门1.1基本函数open()函数：打开一个文件 int open(char *pathname , int flags , mode_t mode)  参数：  pathname：想要打开的文件路径名  flags(头文件#include )：文件打开方式：O_CREAT|OAPPEND|…   mode：权限，当第二个参数设置了O_CREAT，就需要写该参数     mode:设置文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxx93.online/img/9.jpeg">
<meta property="article:published_time" content="2024-07-06T06:56:33.000Z">
<meta property="article:modified_time" content="2025-03-18T10:04:34.364Z">
<meta property="article:author" content="lxx9339-T">
<meta property="article:tag" content="系统编程">
<meta property="article:tag" content="进程">
<meta property="article:tag" content="线程">
<meta property="article:tag" content="管道">
<meta property="article:tag" content="信号">
<meta property="article:tag" content="pthread">
<meta property="article:tag" content="signal">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxx93.online/img/9.jpeg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="https://lxx93.online/2024/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":390},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":"50                //字数限制","languages":{"author":"作者: lxx9339-T","link":"链接: ","source":"来源: -lxxl-","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '系统编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-18 18:04:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><link rel="stylesheet" href="/css/music.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="-lxxl-" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/9.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="-lxxl-"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo1.png"/><span class="site-name">-lxxl-</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">系统编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-06T06:56:33.000Z" title="发表于 2024-07-06 14:56:33">2024-07-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-18T10:04:34.364Z" title="更新于 2025-03-18 18:04:34">2025-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux%E7%9F%A5%E8%AF%86/">linux知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="系统编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-基础入门"><a href="#1-基础入门" class="headerlink" title="1.基础入门"></a>1.基础入门</h1><h2 id="1-1基本函数"><a href="#1-1基本函数" class="headerlink" title="1.1基本函数"></a>1.1基本函数</h2><p>open()函数：打开一个文件</p>
<p>int open(char *pathname , int flags , mode_t mode)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pathname：想要打开的文件路径名</p>
</li>
<li><p>flags(头文件#include <fcntl>)：文件打开方式：O_CREAT|OAPPEND|… </fcntl></p>
</li>
<li><p>mode：权限，当第二个参数设置了O_CREAT，就需要写该参数</p>
</li>
</ul>
</li>
</ul>
<p>mode:设置文件的权限(参数3使用前提：参数2指定了O_CREAT)</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：打开文件所得到对应的文件描述符(整数)</p>
</li>
<li><p>失败：-1,设置errno</p>
</li>
</ul>
</li>
</ul>
<p>read()函数：往一个文件读内容</p>
<p>ssize_t read(int fd , void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：存数据的缓冲区</p>
</li>
<li><p>count设置读字节数大小</p>
</li>
</ul>
</li>
</ul>
<p>count：缓冲区大小</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：读到的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>write()函数</p>
<p>ssize_t write(int fd , const void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：待写出数据的缓冲区</p>
</li>
<li><p>count：写入数据字节数大小</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：写入的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文件cp一份</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">3</span>];                           <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);      <span class="comment">//只读方式打开文件argv[1]</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);  <span class="comment">//读写|文件不存在就创建出来|文件存储就覆盖；权限</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">3</span>)) != <span class="number">0</span>)&#123;     <span class="comment">//一次循环最多读3字节，n是每次读到的字节数</span></span><br><span class="line">                write(fd2,buf,n);              <span class="comment">//一次循环写入n个字节，也就是上面读到的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>,fd2);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        close(fd1);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        close(fd2);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2基本知识"><a href="#1-2基本知识" class="headerlink" title="1.2基本知识"></a>1.2基本知识</h2><p>1.PCB进程控制块：本质是结构体，每个进程都有一个唯一的 PCB。</p>
<ul>
<li>成员：文件描述符表——&gt;文件描述符：0&#x2F;1&#x2F;2&#x2F;3&#x2F;…&#x2F;1023</li>
</ul>
<p>key   value(指针：指向一个结构体)</p>
<p>0 – STDIN_FILENO ——–&gt;标准输入</p>
<p>1 – STDOUT_FILENO —–&gt;标准输出</p>
<p>2 – STDERR_FILENO ——&gt;标准错误</p>
<p>注意：每次得到的文件描述符默认是表中可用最小的</p>
<p>2.阻塞、非阻塞</p>
<p>是设备文件、网络文件的属性。产生阻塞的场景：读设备文件、读网络文件(读常规文件无阻塞概念)</p>
<p>dev&#x2F;tty：终端文件。标准输入、标准输出、标准错误都在终端显示</p>
<p>非阻塞设置：open(“&#x2F;dev&#x2F;tty”,..|O_NONBLOCK)</p>
<ul>
<li>此时若返回-1，并且errno &#x3D; EAGIN或EWOULDBLOCK，说明不是read失败，而是read在以非阻塞方式读一个设备文件或网络文件，并且文件无数据(默认是阻塞状态)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];                         <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);    <span class="comment">//以只读方式|非阻塞方式 打开文件/dev/tty</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open /dev/tty&quot;</span>);              <span class="comment">//如果fd&lt;0，说明打开文件失败，打印错误信息，并退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(fd,buf,<span class="number">10</span>);                <span class="comment">//从/dev/tty读数据存到buf(最多读10字节),/dev/tty是键盘输入</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，某些异常造成</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//=EAGAIN是阻塞情况下无数据读，输出try again到终端继续等待键盘输入</span></span><br><span class="line">                        write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                        sleep(<span class="number">2</span>);        <span class="comment">//2秒钟执行一次</span></span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);      <span class="comment">//在2秒钟内读到数据就直接输出到终端</span></span><br><span class="line">        close(fd);                       <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.参数</p>
<ul>
<li><p>传入参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>有const关键字修饰</p>
</li>
<li><p>指针指向有效区域，在函数内部做读操作</p>
</li>
</ul>
</li>
<li><p>传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间可以无意义，但必须有效</p>
</li>
<li><p>在函数内部，做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
<li><p>传入传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间有实际意义</p>
</li>
<li><p>在函数内部，先做读操作，后做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
</ul>
<p>4.文件存储</p>
<ul>
<li><p>dentry：目录项，其本质是结构体，重要成员变量有两个{文件名，inode,…}，而文件内容(data)保存在磁盘块中。</p>
</li>
<li><p>inode：其本质是结构体，存储文件的属性信息。如权限、类型、大小、盘块位置…。大多数的inode都存储在磁盘上，少数常用、近期使用的inode会被存储在内存上。</p>
</li>
</ul>
<h2 id="1-3进阶函数"><a href="#1-3进阶函数" class="headerlink" title="1.3进阶函数"></a>1.3进阶函数</h2><p>1.fcntl函数</p>
<ul>
<li><p>获取文件状态：F_GETFL</p>
</li>
<li><p>设置文件状态：F_SETFL</p>
</li>
</ul>
<p>获取fd描述符的stdin属性信息：int flgs &#x3D; fcntl(fd,F_GETFL);</p>
<p>添加非阻塞状态：flgs |&#x3D; O_NONBLOCK;</p>
<p>把设置的状态信息设置到终端设备的状态信息中：fcntl(fd,F_SETFL,flgs)；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>               <span class="comment">//定义宏变量</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> flags,n;</span><br><span class="line">        flags = fcntl(STDIN_FILENO,F_GETFL); <span class="comment">//获取stdin属性信息(获取标准输入对应的终端设备的状态信息) STDIN_FILENO对应终端设备</span></span><br><span class="line">        <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= O_NONBLOCK;     <span class="comment">//添加非阻塞状态</span></span><br><span class="line">        <span class="type">int</span> ret = fcntl(STDIN_FILENO,F_SETFL,flags);    <span class="comment">//把设置的状态信息设置到终端设备的状态信息中</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，不是因为没有数据</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        sleep(<span class="number">3</span>);</span><br><span class="line">                        write(STDOUT_FILENO,MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.lseek函数</p>
<p>off_t lseek(int fd , off_t offset , int whence);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd: 文件描述符</p>
</li>
<li><p>offset：偏移量</p>
</li>
<li><p>whence：偏移位置：SEEK_SET(起点)&#x2F;SEEK_CUR(当前位置)&#x2F;SEEK_END(终点)</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：较起始位置偏移量</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>文件的读和写使用同一偏移位置(读和写都改变偏移位置)</p>
</li>
<li><p>使用lseek获取文件大小</p>
</li>
<li><p>使用lseek拓展文件大小(要想使文件大小真正拓展，必须引起IO操作)</p>
</li>
</ul>
<p>补：可以使用truncate函数，直接拓展文件大小 </p>
<ul>
<li>如int ret &#x3D; truncate(“dict.txt”,250);</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试文件的读和写使用同一偏移位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;It&#x27;s a test4 for lseek\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);     <span class="comment">//以读写方式打开|不存在就创建</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open lseek.txt error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd,msg,<span class="built_in">strlen</span>(msg));     <span class="comment">//使用fd对打开文件进行写操作，此时读写位置位于文件结尾处</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时读写指针位于结尾处了，没有下面这行，将只能写数据到文件中，但不能执行下面的读(读出数据)</span></span><br><span class="line">        lseek(fd,<span class="number">0</span>,SEEK_SET);         <span class="comment">//将读写指针设置到文件开头-----&gt;读写指针；偏移量为0；开始偏移的位置为起始位置</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd,&amp;ch,<span class="number">1</span>)))&#123;    <span class="comment">//读，以一个变量为缓冲区，缓冲区大小为1</span></span><br><span class="line">                <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,&amp;ch,n);     <span class="comment">//将文件内容按字节读出，写到屏幕上</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lseek获取文件大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR);    <span class="comment">//以读写打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时读写指针位于文件开头</span></span><br><span class="line">        <span class="type">int</span> lenth = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//偏移量为0，偏移位置为文件末，所以读写指针从文件头到文件尾，返回偏移了多少 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%d\n&quot;</span>,lenth);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.stat&#x2F;lstat函数</p>
<p>stat底层是一个结构体，里面有文件的信息</p>
<p>int stat(const char *path , struct stat *buf);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path:文件或目录路径 </p>
</li>
<li><p>buf：(传出参数)存放文件属性</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：0</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>系统提供函数</p>
<ul>
<li><p>获取文件大小：buf.st_size</p>
</li>
<li><p>获取文件类型：buf.st_mode</p>
</li>
<li><p>获取文件权限：buf.st_mode</p>
</li>
</ul>
<p>符号穿透：stat会；lstat不会</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = stat(<span class="string">&quot;document&quot;</span>,&amp;sbuf);     <span class="comment">//查看的目录或文件路径；传出参数(接受该文件的stat结构体)</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%ld\n&quot;</span>,sbuf.st_size);    <span class="comment">//打印该文件的st_size信息</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a regular\n&quot;</span>);    <span class="comment">//这是一个普通文件</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a dir\n&quot;</span>);         <span class="comment">//这是一个目录</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a pipe\n&quot;</span>);      <span class="comment">//这是一个管道</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a sym link\n&quot;</span>);    <span class="comment">//这是一个软连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.link&#x2F;unlink函数</p>
<p>link函数：可以为已经存在的文件创建目录项(硬链接)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;b.txt&quot;</span>);    <span class="comment">//旧文件；新文件</span></span><br><span class="line">unlink(<span class="string">&quot;a.txt&quot;</span>);          <span class="comment">//删除旧的,新的可以继续用</span></span><br></pre></td></tr></table></figure>

<p>unlink函数：删除一个文件的目录项。从某种意义上说，只是让文件具备了释放的条件。</p>
<p>unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放(只是目录中我们看不到该文件了而已)，要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> *p = <span class="string">&quot;test of unlink\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *p2 = <span class="string">&quot;after write something\n&quot;</span>;</span><br><span class="line">        fd = open(<span class="string">&quot;temp.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);    <span class="comment">//打开文件temp.txt，没有就创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open temp error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">5</span>);                            <span class="comment">//这些时间可以看到该文件</span></span><br><span class="line">        <span class="type">int</span> ret = unlink(<span class="string">&quot;temp.txt&quot;</span>);        <span class="comment">//具备了被释放的条件，在目录中我们看不到了</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;                                        <span class="comment">//虽然unlink了，但后面还能进行写内容</span></span><br><span class="line">        ret = write(fd,p,<span class="built_in">strlen</span>(p));             <span class="comment">//往fd里面写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;--------write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hi! I&#x27;m lxx\n&quot;</span>);</span><br><span class="line">        ret = write(fd,p2,<span class="built_in">strlen</span>(p2));          <span class="comment">//往fd里面继续写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;------Write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter anykey continue\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.readlink()函数</p>
<p>作用：读取符号链接(软链接)文件本身内容，得到链接所指向的文件名。</p>
<p>如有软链接：t.soft -&gt; &#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>终端执行：readlink t.soft    得到：&#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>6.目录操作函数</p>
<p>DIR * opendir(char *name);</p>
<p>int closedir(DIR *dp)</p>
<p>struct dirent *readdir(DIR *dp);</p>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">	inode</span><br><span class="line">	<span class="type">char</span> dname[<span class="number">256</span>]</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span>       <span class="comment">//dirent是目录项类型，相当于dentry</span></span><br><span class="line">        dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            	<span class="comment">//去掉目录项文件名是.和..的目录项</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span>)||(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);      <span class="comment">//打印每个目录项的文件名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：递归遍历目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>;    <span class="comment">//申明isFile函数</span></span><br><span class="line"><span class="comment">//打开目录读取，处理目录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_dir</span><span class="params">(<span class="type">char</span> *dir)</span>&#123;   <span class="comment">//是目录，就打开其目录项</span></span><br><span class="line">        <span class="type">char</span> path[<span class="number">256</span>];    <span class="comment">//用于后面拼接路径</span></span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">        dp = opendir(dir);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取目录项</span></span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;   </span><br><span class="line">                        <span class="keyword">continue</span>;       <span class="comment">////不排除这个，会进入死循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//目录项本身不可访问，拼接目录</span></span><br><span class="line">                <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">                <span class="comment">//判断文件类型，目录递归进入，文件显示名字/大小</span></span><br><span class="line">                isFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span>            <span class="comment">//stat是一个结构体，里面包含对应文件的信息</span></span><br><span class="line">        ret = stat(name,&amp;sb);      <span class="comment">//获取文件属性，判断文件类型</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;   <span class="comment">//是否目录</span></span><br><span class="line">                read_dir(name);    <span class="comment">//是目录，进入read_dir函数，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是普通文件，打印名字和大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;               <span class="comment">//如果没有传入参数，就遍历当前目录下的内容</span></span><br><span class="line">                isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                isFile(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.dup&#x2F;dup2函数</p>
<p>int dup(int oldfd);</p>
<ul>
<li><p>参数：oldfd：已有文件描述符</p>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<p>int dup2(int oldfd,int newfd);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>oldfd：原文件描述符 </p>
</li>
<li><p>newfd：新文件描述符—–&gt;指向源文件描述符所指向的文件</p>
</li>
</ul>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd1--&gt;3</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd2--&gt;4</span></span><br><span class="line">        <span class="type">int</span> fdret = dup2(fd1,fd2);        <span class="comment">//fd2与fd1指向的是同一个内存空间了,返回新文件描述符fd2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdret = %d\n&quot;</span>,fdret);</span><br><span class="line">        <span class="type">int</span> ret = write(fd2,<span class="string">&quot;1234567&quot;</span>,<span class="number">7</span>);  <span class="comment">//通过fd2来写内容，内容写在的是第一个文件中</span></span><br><span class="line">        dup2(fd1,STDOUT_FILENO);   <span class="comment">//令屏幕输入(fd=1)重定向给fd1所指向的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------886\n&quot;</span>);  <span class="comment">//向屏幕输出的内容都写到文件描述符3所在的内存空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fcntl函数是实现dup</p>
<p>int fcntl(int fd,int cmd,…);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：原文件描述符</p>
</li>
<li><p>cmd：F_DUPFD(特定参数)</p>
</li>
<li><p>参数3：指定文件描述符号。被占用的，返回最小可用的；未被占用的，返回&#x3D;该值的文件描述符</p>
</li>
</ul>
</li>
<li><p>返回值：返回新的文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fcntl也可以像dup那些使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);      <span class="comment">//读写方式打开文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);            <span class="comment">//打印文件描述符fd1的值，是3</span></span><br><span class="line">        <span class="comment">//原文件描述符；特定参数；新的文件描述符号(已经存在的话，系统就按正常给)</span></span><br><span class="line">        <span class="type">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>); <span class="comment">//0被占用，fcntl使用文件描述符表中可用的最小文件描述符来返回，即newfd=4</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd);       <span class="comment">//newfd的值是4</span></span><br><span class="line">        <span class="type">int</span> newfd2 = fcntl(fd1,F_DUPFD,<span class="number">7</span>);  <span class="comment">//7未被占用，返回文件描述符7(如果存在7，就返回更大的号)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd2);</span><br><span class="line">        <span class="type">int</span> ret = write(newfd2,<span class="string">&quot;yyyyyy&quot;</span>,<span class="number">6</span>);    <span class="comment">//写在的是fd1文件描述符所在的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h2 id="2-1进程与程序"><a href="#2-1进程与程序" class="headerlink" title="2.1进程与程序"></a>2.1进程与程序</h2><p>程序：死的，只占用磁盘空间    —剧本</p>
<p>进程：活的，运行起来的程序，占用内存、cpu等系统资源   —戏剧</p>
<p>1.进程控制块PCB</p>
<p>我们知道，每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>内部成员：</p>
<ul>
<li><p>进程id：系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数；</p>
</li>
<li><p>进程的状态：有初试、就绪、运行、挂起和停止五种状态</p>
</li>
<li><p>进程切换时想要保存和恢复的一些CPU寄存器；(了解)</p>
</li>
<li><p>描述虚拟地址空间的信息；(了解)</p>
</li>
<li><p>描述控制终端的信息；(了解)</p>
</li>
<li><p>当前所处工作目录；</p>
</li>
<li><p>umask掩码：rwx对应124，当umask为022时，在你创建文件和目录时，默认权限是777-022&#x3D;755，即rwxr_xr_x；(了解)</p>
</li>
<li><p>文件描述符表：是map结构，key为正整数，value为指针，指针指向结构体；它包含很多指向file结构体的指针(每个进程都有文件描述符表)</p>
</li>
<li><p>和信号相关的信息；</p>
</li>
<li><p>用户id和组id；</p>
</li>
<li><p>会话和进程组；(了解)</p>
</li>
<li><p>进程可用使用的资源上限；(了解)</p>
</li>
</ul>
<p>2.进程共享</p>
<p>父进程在fork()之后：</p>
<p>相同：全局变量、data段、text段、栈、堆、环境变量、用户id、宿主目录、进程工作目录、信号处理方式…</p>
<p>不相同：进程id、fork返回值、父进程id、进程运行时间、闹钟(定时器)、未决信号集</p>
<p>注：对于全局变量，父子进程间遵循<strong>读时共享写时复制</strong>的原则</p>
<p>3.孤儿进程&#x2F;僵尸进程</p>
<ul>
<li><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程(回收)</p>
</li>
<li><p>僵尸进程：子进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程。(kill对其无效)</p>
</li>
</ul>
<h1 id="3-相关函数"><a href="#3-相关函数" class="headerlink" title="3.相关函数"></a>3.相关函数</h1><h2 id="3-1fork-函数"><a href="#3-1fork-函数" class="headerlink" title="3.1fork()函数"></a>3.1fork()函数</h2><p>功能：是创建一个新的进程</p>
<p>pid_t fork(void);</p>
<ul>
<li>返回值：对应文件的子进程id号</li>
</ul>
<p>注意：创建出来的子进程可用执行父进程中fork()函数下面的代码。在父进程中，fork返回的是子进程id号；在子进程中，fork返回的是0；</p>
<p>补：getpid()返回的是当前进程；getppid()返回的是父进程；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过fork()函数来生成子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程会执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child is created,pid = %d,parent-pid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//fork成功的话，父进程里返回的是子线程的id，所以父线程执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent process: my child is %d,my pid = %d,my parent pid = %d\n&quot;</span>,pid,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======================end of file\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);  <span class="comment">//防止父进程结束了，子进程还没有打印内容，当父进程结束后，退出程序，而子进程就没有父进程了，打印的父进程就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，子进程和父进程都会执行sleep(3)这行代码，不是说只有让父进程执行，而子进程不执行，sleep(3)只是防止父进程结束退出程序了，子进程还没有打印父进程。如果父进程结束了，子进程才打印父进程，则父进程是1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环创建5个子线程，且有序打印出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;   <span class="comment">//子线程创建好了与0做对比，直接跳出循环，但父进程还需要继续执行</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//当第1个子进程创建好后，此时i=0;当第2个子进程创建好后，此时的i=1;.....</span></span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-execlp-函数"><a href="#3-2-execlp-函数" class="headerlink" title="3.2 execlp()函数"></a>3.2 execlp()函数</h2><p>功能：指定进程执行相应的程序</p>
<p>int execlp(const *file , const *arg , …);</p>
<ul>
<li><p>参数:</p>
<ul>
<li><p>file：要加载(执行)的程序名字</p>
</li>
<li><p>arg以及后面：调用该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数常用来调用系统程序。如ls、date、cp、cat等命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execlp()：是让子线程不执行父线程的代码，而是执行/execlp所指定的代码或函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">//ls：要执行的系统函数名；ls -l -d -h：是执行的代码(命令)；NULL：是哨兵，代表着-l、-d等参数的结束</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);   <span class="comment">//当子线程调用execlp失败时，执行下面代码</span></span><br><span class="line">                <span class="comment">//execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3-execl函数"><a href="#3-3-execl函数" class="headerlink" title="3.3 execl函数"></a>3.3 execl函数</h2><p>功能：既可以执行自己写的程序，也可用执行系统程序</p>
<p>int execl(const char* path , const char *arg , ….);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path：程序的路径</p>
</li>
<li><p>arg以及后面：执行该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数是通过 路径+程序名 来加载进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//execl()：是让子线程不执行父线程的代码，而是执行execl所指定的文件</span></span><br><span class="line"><span class="comment">//注：execl()也能像execlp()函数那些去执行系统的一些程序，如date、ls等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">// ./execlp：是路径；./execlp是命令</span></span><br><span class="line">                <span class="comment">//execlp(&quot;./execlp&quot;,&quot;./execlp&quot;,NULL);    //子线程去执行execlp程序里面的代码</span></span><br><span class="line">                execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例：让ps aux输出的内容写到自定义的文件中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">	fd = <span class="built_in">open</span>(<span class="string">&quot;ps.out&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC,<span class="number">0644</span>);   <span class="comment">//打开或创建一个文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open ps.out,error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dup2</span>(fd,STDOUT_FILENO);      <span class="comment">//让屏幕输出指向与fd所处的文件</span></span><br><span class="line">    <span class="built_in">execlp</span>(<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ps&quot;</span>,<span class="string">&quot;ax&quot;</span>,<span class="literal">NULL</span>);    <span class="comment">//在屏幕输出的内容写到了fd所处的文件中(这里一旦执行成功，就不会执行下面的代码u了)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4wait-函数"><a href="#3-4wait-函数" class="headerlink" title="3.4wait()函数"></a>3.4wait()函数</h2><blockquote>
<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态；如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个过程。</p>
</blockquote>
<p>该函数的三个功能：</p>
<ul>
<li><p>阻塞等待子进程退出；</p>
</li>
<li><p>回收子进程残留资源</p>
</li>
<li><p>获取子进程结束状态(退出原因)</p>
</li>
</ul>
<p>pid_t wait(int *status);</p>
<ul>
<li><p>参数：status是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>返回值：成功：回收子进程的id号；失败：-1(没有子进程)</p>
</li>
</ul>
<p>可使用wait函数传出的参数status来保存进程的退出状态：</p>
<ul>
<li><p>WIFEXITED(status)为非0，表示进程正常结束</p>
<ul>
<li>如上正常退出，使用WEXITSTATUS(status)来获取进程的退出状态(正常的参数)</li>
</ul>
</li>
<li><p>WIFSIGNALED(status)为非0，表示进程异常终止</p>
<ul>
<li>如上异常退出，使用WTERMSIG(status)来获取使进程终止的那个信号的编号</li>
</ul>
</li>
<li><p>WIFSTOPPED(status)为非0，表示进程处于暂停状态</p>
<ul>
<li>如上为暂停状态，使用WSTOPSIG(status)来取得使进程暂停的那个信号的编号</li>
</ul>
</li>
<li><p>WIFCONTINUED(status)为真，表示进程暂停后已经继续运行</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试：wait函数只有在子线程执行完后才会回收，然后继续向下执行；否则就阻塞在该处，等子线程执行完</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child,my id = %d,going to sleep 3s\n&quot;</span>,getpid());</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent wait finish:%d\n&quot;</span>,wpid);    <span class="comment">//等子线程执行完后，才会执行该函数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试：通过系统提供的宏函数来查看子线程的退出状态信息等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子线程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">93</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//wpid = wait(NULL);      //不关心子进程结束的原因</span></span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))&#123;    <span class="comment">//该子线程是否正常终止</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;我是正常终止,返回%d\n&quot;</span>,WEXITSTATUS(status));<span class="comment">//打印的值是93，即子线程执行完的返回值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))&#123;   <span class="comment">//该子线程是否被信号终止(一切异常终止都是因为信号)</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>,WTERMSIG(status));  <span class="comment">//打印导致异常退出的信号编号</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;父线程等待完毕，回收的子线程是%d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5waitpid-函数"><a href="#3-5waitpid-函数" class="headerlink" title="3.5waitpid()函数"></a>3.5waitpid()函数</h2><p>pid_t waitpid(pid_t pid , int *status , int optains)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pid：指定某个子进程进行回收(大于0：回收指定ID的子进程；-1：回收任意子进程，相当于wait；0：回收和当前调用waitpid一个组的所有子进程；小于-1：回收指定进程组内的任意子进程)</p>
</li>
<li><p>status：是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>options：通过特定参数，可以完成特定功能，如WNOHANG指以非阻塞方式回收</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>大于0：表示成功回收的子进程pid</p>
</li>
<li><p>等于0：参3指定了WNOHANG，并且没有子进程结束会返回0(非阻塞方式)</p>
</li>
<li><p>-1：失败，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>waitpid()与wait()的区别是：waitpid能指定某个进程进行回收</p>
<p>注意：一次wait&#x2F;waitpid函数调用，只能回收一个子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试：指定回收某个子线程，且子线程有序打印</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid,tmpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                        tmpid = pid;    <span class="comment">//此时pid是第三个子线程的pid</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;指定回收的子线程 = %d\n&quot;</span>,tmpid);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);   <span class="comment">//如果是不阻塞状态，给主线程添加睡眠，会成功回收指定子线程</span></span><br><span class="line">                <span class="comment">//wpid = waitpid(tmpid,NULL,WNOHANG);   //指定回收子进程tmpid,并且不阻塞</span></span><br><span class="line">                wpid = waitpid(tmpid,<span class="literal">NULL</span>,<span class="number">0</span>);   <span class="comment">//指定回收子进程tmpid,并且是阻塞状态</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收子线程：%d\n&quot;</span>,wpid);  <span class="comment">//如果不阻塞状态，指定回收的子线程没有结束，则回收没有成功，waitpid会返回0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);    <span class="comment">//有序打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试：回收多个子线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">/*while(wpid = waitpid(-1,NULL,0))&#123;   //循环回收每个子线程,并且是阻塞状态 后面回收完，会返回-1，一直循环</span></span><br><span class="line"><span class="comment">                        printf(&quot;成功回收子线程：%d\n&quot;,wpid);</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">                <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG)) != <span class="number">-1</span>)&#123;    <span class="comment">//以非阻塞状态进行回收</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)&#123;    <span class="comment">//当成功回收时</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;成功回收：%d\n&quot;</span>,wpid);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;    <span class="comment">//当没有成功回收时，先睡眠1秒</span></span><br><span class="line">                                sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-IPC方法"><a href="#4-IPC方法" class="headerlink" title="4.IPC方法"></a>4.IPC方法</h1><blockquote>
<p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC)。</p>
</blockquote>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。现在常用的进程间通信方式有：</p>
<ul>
<li><p>管道(使用最简单)</p>
</li>
<li><p>信号(开销最小)</p>
</li>
<li><p>共享映射区(无血缘关系)</p>
</li>
<li><p>本地套接字(最稳定)</p>
</li>
</ul>
<h2 id="4-1管道"><a href="#4-1管道" class="headerlink" title="4.1管道"></a>4.1管道</h2><blockquote>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
</blockquote>
<ul>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端(可以有多个)，一个表示写端</p>
</li>
<li><p>规定数据从管道的写端流入管道，借助内核缓冲区(4k)实现</p>
</li>
</ul>
<p>1.管道的局限性：</p>
<ul>
<li><p>数据不能进程自己写，自己读</p>
</li>
<li><p>管道中数据不可以反复读取，一旦读走，管道中不再存在</p>
</li>
<li><p>采用半双工通信方式，数据只能在单方向上流动</p>
</li>
<li><p>只能在有公共祖先的进程间使用管道。</p>
</li>
</ul>
<p>2.常见的通信方式有：单工通信、半双工通信、全双工通信</p>
<p>3.pipe函数</p>
<p>int pipe(int fd[2]);   —&gt; 创建，并打开管道</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd[0]：读端</p>
</li>
<li><p>fd[1]：写端</p>
</li>
</ul>
</li>
<li><p>返回值：成功：0；失败：-1，设置errno</p>
</li>
</ul>
<p>4.管道的读写行为：</p>
<ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据：(A)管道写端被全部关闭，read返回0(表示读到文件结尾)；(B)写端没有全部被关闭，read阻塞等待(不久的将来可能有数据写入)，此时会让出CPU</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道读端全部被关闭：进程异常终止(也可以使用SIGPIPE信号，使进程不终止)</p>
</li>
<li><p>管道读端没有全部关闭：若管道已满，write阻塞；若管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试pipe管道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;           <span class="comment">//主线程负责写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);    <span class="comment">//关闭读端</span></span><br><span class="line">                write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">                sleep(<span class="number">1</span>);        <span class="comment">//主线程睡眠1秒，防止主线程先结束</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//写完后，关闭写端</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子线程负责读</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//子线程关闭写端</span></span><br><span class="line">                ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));     <span class="comment">//将主线程写在缓冲区的内容读到buf里面    </span></span><br><span class="line">                write(STDOUT_FILENO,buf,ret);         <span class="comment">//将buf的内容打印到屏幕，其中ret为buf读到的字节数</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);     <span class="comment">//结束后，关闭读端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用管道实现父子进程间通信，完成ls | wc -l，假定子进程实现ls，父进程实现wc</p>
<p>ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;    <span class="comment">//负责出错时，打印错误</span></span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="comment">//当父进程执行ls时，子进程会永远执行在后面，所以父进程会先结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;       <span class="comment">//子线程</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);       <span class="comment">//关闭读端</span></span><br><span class="line">                <span class="comment">//重定向，相当于屏幕上的内容输入到管道的写端</span></span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);    <span class="comment">//重定向，让标准输出指向管道的读端，这样输出在屏幕上的就可以写到管道中</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);       <span class="comment">//父进程执行ls命令</span></span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//父线程</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);      <span class="comment">//关闭写端</span></span><br><span class="line">                <span class="comment">//重定向，相当于从管道读端读到的内容写到了标准输入(相当于键盘输入)</span></span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);     <span class="comment">//重定向，让标准输入指向管道的读端，从管道读取数据</span></span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：ls命令正常会将结果集写出到stdout，但现在会写入管道的写端；wc -l正常应该会从stdin读取数据，但此时会从管道的读端读。</p>
<p>案例：使用管道实现兄弟进程间通信，兄：ls，弟：wc -l，父：等待回收子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用兄弟进程实现</span></span><br><span class="line"><span class="comment">//ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);   <span class="comment">//一个出错处理函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;    <span class="comment">//父进程回收两个子线程</span></span><br><span class="line">                <span class="comment">//父进程必须关闭管道的读和写端，因为管道是单向的，而两个子线程已经占用了读和写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;    <span class="comment">//兄线程执行</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;    <span class="comment">//弟进程执行</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-FIFO"><a href="#4-2-FIFO" class="headerlink" title="4.2 FIFO"></a>4.2 FIFO</h2><blockquote>
<p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程；但通过FIFO，不相关的进程也能交换数据。FIFO是Linux基础文件类型中的一种。但FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道，这样就实现了进程间通信，并且可以有多个写端和多个读端，但读完就没有了。</p>
</blockquote>
<p>创建管道方式：</p>
<ul>
<li><p>终端：mkfifo 命名管道文件名</p>
</li>
<li><p>代码：int ret &#x3D; mkfifo(“my_mkfifo”,0664);返回-1未成功创建</p>
</li>
</ul>
<p>注意：可以通过终端mkfifo 命名管道文件名 来创建，也可以通过c程序</p>
<p>写端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,i;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_WRONLY);     <span class="comment">// 以只写的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello lxx %d\n&quot;</span>,i++);     <span class="comment">//将要写的内容存入buf</span></span><br><span class="line">                write(fd,buf,<span class="built_in">strlen</span>(buf));             <span class="comment">//将buf中的内容写到命名管道(文件)中</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,len;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_RDONLY);     <span class="comment">// 以只读的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                len = read(fd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//将从命名管道中读到的数据放到buf中</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);      <span class="comment">//将buf中的内容读到标准输出(屏幕)</span></span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3存储映射I-O"><a href="#4-3存储映射I-O" class="headerlink" title="4.3存储映射I&#x2F;O"></a>4.3存储映射I&#x2F;O</h2><blockquote>
<p>存储映射I&#x2F;O使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样就可以在不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作。</p>
<p>使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现</p>
</blockquote>
<p>1.创建映射区</p>
<p>void *mmap(void * addr , size_t length , int prot , int flags , int fd , off_t offset);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>addr：指定映射区的首地址。通常传NULL，表示让系统自动分配</p>
</li>
<li><p>length：共享内存映射区的大小。(&lt;&#x3D;文件的实际大小)</p>
</li>
<li><p>prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE</p>
</li>
<li><p>flags：标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE(私有：对内存的操作不会反映到物理磁盘上)</p>
</li>
<li><p>fd：用于创建共享内存映射区的那个文件的文件描述符。</p>
</li>
<li><p>offset：默认0，表示映射文件全部。偏移位置需是4K的整数倍。</p>
</li>
</ul>
</li>
<li><p>返回值：成功：映射区的首地址；失败：MAP_FAILED，设置errno</p>
</li>
</ul>
<p>2.释放映射区</p>
<p>int munmap(void *addr  , size_t length);</p>
<p>参数：</p>
<ul>
<li><p>addr：mmap的返回值</p>
</li>
<li><p>length：大小</p>
</li>
</ul>
<p>3.使用注意事项：</p>
<ul>
<li><p>用于创建映射区的文件大小为0，实际指定非0大小创建映射区，出“总线错误”；</p>
</li>
<li><p>用于创建映射区的文件大小为0，实际指定0大小创建映射区，出“无效参数”；</p>
</li>
<li><p>用于创建映射区的文件读写属性为只读，映射区属性为读、写，出“无效参数”；</p>
</li>
<li><p>创建映射区，需要read权限(因为创建时，需要查看映射指定的文件)；当访问权限指定为MAP_SHARED(共享)时，mmap的读写属性应该&lt;&#x3D;文件的open权限(只给mmap写属性不可以)–&gt;因为共享时，对内存操作都会同样的对磁盘(文件)操作；</p>
</li>
<li><p>文件描述符fd，在mmap创建映射区完成即可关闭，后续访问文件用地址访问；</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，在需要open文件时，有读权限来创建映射区即可；</p>
</li>
</ul>
<p>4.mmap函数的保险调用：</p>
<ul>
<li><p>fd &#x3D; open(“文件名”,O_RDWR);</p>
</li>
<li><p>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试创建一个映射区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(<span class="string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*lseek(fd,19,SEEK_END);</span></span><br><span class="line"><span class="comment">        write(fd,&quot;\0&quot;,1);    */</span>        <span class="comment">//这两行函数与下面的ftruncate()一样</span></span><br><span class="line">        ftruncate(fd,<span class="number">20</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//系统自动分配映射区首地址；映射区的大小；创建的映射区可读可写；映射区是共享的(内存内改，磁盘也改)；文件描述符；默认0</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用p对文件进行读写操作</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);         <span class="comment">//写操作,将hello maap写到映射区(磁盘)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------%s\n&quot;</span>,p);     <span class="comment">//将映射区内的东西写到屏幕</span></span><br><span class="line">        <span class="type">int</span> ret = munmap(p,len);          <span class="comment">//对映射区进行释放</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;imunmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.mmap进程通信</p>
<ul>
<li><p>父子进程通信</p>
<ul>
<li>父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：<ul>
<li>MAP_PRIVATE(私有映射)：父子进程各自独占映射区(修改，互相都看不到)；</li>
<li>MAP_SHARED(共享映射)：父子进程共享映射区；</li>
</ul>
</li>
</ul>
</li>
<li><p>无血缘关系间的进程通信</p>
<ul>
<li>两个进程打开同一个文件(创建的映射区)；一个进程写入，另外一个进程读出。</li>
</ul>
</li>
</ul>
<p>mmap：数据可以重复读取(当创建的映射区为4字节时，只要读的速度快于写的速度，那么可以重复读同一个正整数多次，直到新数据写入)；而fifo只能读取数据一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父子进程实现mmap映射区之间的通信</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;temp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">                <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ftruncate(fd,<span class="number">4</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//MAP_SHARED如果是私有的话，表示映射区归父进程私有,也归子进程私有，对其修改，互相都收不到</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);      <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line">        pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                *p = <span class="number">2000</span>;      <span class="comment">//子进程写共享内存</span></span><br><span class="line">                var = <span class="number">1000</span>;     <span class="comment">//对全部变量，读时共享，写时复制</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);   <span class="comment">//等子进程写完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">                wait(<span class="literal">NULL</span>);     <span class="comment">//回收子进程</span></span><br><span class="line">                <span class="type">int</span> ret = munmap(p,<span class="number">4</span>);     <span class="comment">//释放映射区</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">                       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果是：</span></span><br><span class="line">child,*p = <span class="number">2000</span>,var = <span class="number">1000</span></span><br><span class="line">parent,*p = <span class="number">2000</span>,var = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5.信号"></a>5.信号</h1><blockquote>
<p>信号是一种软件中断，通知程序某种事件的发生。常见的信号有SIGABRT(当进程调用abort函数的时候自动发送), SIGALRM(当timer被触发的时候自动发送)，等等。</p>
</blockquote>
<h2 id="5-1常识"><a href="#5-1常识" class="headerlink" title="5.1常识"></a>5.1常识</h2><p>1.信号的共性：简单、不能携带大量信息、满足条件才发送</p>
<p>2。信号的特质：信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。所有信号的产生及处理全部都是由内核完成的</p>
<p>3.产生信号</p>
<ul>
<li><p>按键产生，如Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如kill、raise、abort</p>
</li>
<li><p>软件条件产生，如定时器alarm</p>
</li>
<li><p>硬件异常产生，如非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生：如kill命令</p>
</li>
</ul>
<p>4.信号的状态</p>
<ul>
<li><p>递达：产生并且到达进程，可以直接被内核处理掉</p>
</li>
<li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态</p>
</li>
</ul>
<p>5.信号处理的方式：执行默认动作、忽略(丢弃)、捕抓(自定义)</p>
<p>6.阻塞信号集(信号屏蔽字)：本质就是位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，再解除屏蔽前，就一直处于未决态</p>
<p>7.未决信号集：本质就是位图。用来记录信号的处理状态，该信号集中的信号表示已经产生，但尚未被处理</p>
<h2 id="5-2信号四要素及常规信号"><a href="#5-2信号四要素及常规信号" class="headerlink" title="5.2信号四要素及常规信号"></a>5.2信号四要素及常规信号</h2><p>信号使用之前，应先确定其四要素，而后再用。即信号编号、信号名称、信号对应事件、信号默认处理动作。</p>
<p>1.常规信号：</p>
<ul>
<li><p>1)SIGHUP：当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程。</p>
</li>
<li><p>2)SIGINT：当用户按下了&lt;Ctrl+c&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>3)SIGQUIT：当用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>5)SIGTRAP：该信号由断点指令或其他trap指令产生，默认动作为终止进程，并产生core文件。</p>
</li>
<li><p>6)SIGABRT：调用abort函数时产生该信号，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>7)SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>8)SIGFPE：在发生致命的运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>9)SIGKILL：无条件终止进程，本信号不能被忽略处理和阻塞，默认动作为终止进程，它向系统管理员提供了可以杀死任何进程的方法。</p>
</li>
<li><p>10)SIGUSR1：用户定义的信号，即程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>11)SIGSEGV：指示进程进行了无效内存访问，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>12)SIGUSR2：用户自定义信号，程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>13)SIGPIPE：Broken pipe向一个没有读端的管道写数据，默认动作为终止进程。</p>
</li>
<li><p>14)SIGALRM：定时器超时，超时的时间由系统调用alarm设置，默认动作为终止进程。</p>
</li>
<li><p>15)SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止，通常用来要示程序正常退出，执行shell命令kill时，缺省产生这个信号，默认动作为终止进程。</p>
</li>
<li><p>17)SIGCHLD：子进程状态发生变化时，父进程会收到这个信号，默认动作为忽略这个信号。</p>
</li>
<li><p>18)SIGCONT：如果进程已停止，则使其继续运行，默认动作为继续&#x2F;忽略。</p>
</li>
<li><p>19)SIGSTOP：停止进程的执行，信号不能被忽略处理和阻塞，默认动作为暂停进程。</p>
</li>
</ul>
<p>注意：只有每个信号所对应的事情发生了，该信号才会被递送(但不一定递达)，不应该乱发信号。</p>
<p>2.kill函数与kill命令</p>
<ul>
<li>kill函数：给指定进程发送指定信号(不一定是杀死)</li>
</ul>
<p>int kill(pid_t pid , int signum);</p>
<ul>
<li>参数pid：   &gt;0：发送信号给指定进程。&#x3D;0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。&lt;-1：取绝对值，发送信号给该绝对值所对应的进程组的所有组员。&#x3D;-1：发送信号给，有权限发送的所有进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试用kill杀死子进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,pid = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);    <span class="comment">//父进程一直循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                kill(getppid(),SIGKILL);      <span class="comment">//发送 SIGKILL 信号给其父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kill命令：如杀死一个进程(kill -9 进程号)</p>
<h2 id="5-3-alarm函数"><a href="#5-3-alarm函数" class="headerlink" title="5.3 alarm函数"></a>5.3 alarm函数</h2><blockquote>
<p>设置定时器(闹钟)，在指定seconds后，内核会给当前进程发送SIGALRM(14)信号，进程收到该信号，默认终止动作。</p>
<p>每个进程都有且只有唯一个定时器。</p>
</blockquote>
<p>unsigned int alarm(unsigned int seconds);</p>
<ul>
<li><p>参数：定时秒数</p>
</li>
<li><p>返回值：上次定时剩余秒数，无错误现象。</p>
</li>
</ul>
<p>常用：取消定时器alarm(0)，返回旧闹钟剩余的秒数</p>
<p>注意：定时与进程状态无关，无论进程处于何种状态，alarm都计时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用alarm测试1秒可以数多少次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[补]使用time命令查看程序执行的时间(如time .&#x2F;alarm_count)，alarm_count是上面代码的函数</p>
<p>得出：实际执行时间 &#x3D; 系统时间+用户时间+等待时间(最多)—-&gt;程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
<h2 id="5-4setitimer函数"><a href="#5-4setitimer函数" class="headerlink" title="5.4setitimer函数"></a>5.4setitimer函数</h2><blockquote>
<p>setitimer函数可以替代alarm函数，精度到微妙，还可以实现周期定时</p>
</blockquote>
<p>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>new_value：定时秒数(结构体类型见代码)</p>
</li>
<li><p>old_value：传出参数，上次定时剩余时间</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：0；失败：-1，设置errno</li>
</ul>
</li>
</ul>
<p>提示：</p>
<ul>
<li><p>it_interval：用来设定两次定时任务之间间隔时间</p>
</li>
<li><p>it_value：定时的时长</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>,<span class="title">oldit</span>;</span></span><br><span class="line">        signal(SIGALRM,myfunc);      <span class="comment">//注册SIGALRM 信号的捕抓处理函数</span></span><br><span class="line"></span><br><span class="line">        it.it_value.tv_sec = <span class="number">2</span>;      <span class="comment">//设置定时器闹钟为2秒</span></span><br><span class="line">        it.it_value.tv_usec = <span class="number">0</span>;     <span class="comment">//这是设置微妙的</span></span><br><span class="line"></span><br><span class="line">        it.it_interval.tv_sec = <span class="number">5</span>;   <span class="comment">//周期为5秒，每5秒提醒一次</span></span><br><span class="line">        it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it,&amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//循环一直停留在终端,方便观看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5信号集和未决信号集"><a href="#5-5信号集和未决信号集" class="headerlink" title="5.5信号集和未决信号集"></a>5.5信号集和未决信号集</h2><p>1.信号集操作函数</p>
<ul>
<li><p>自定义信号集(用于和mask发生或与关系)：sigset_t set; </p>
</li>
<li><p>清空信号集(全置为0)：sigemptyset(sigset_t *set);   </p>
</li>
<li><p>信号集全置1：sigfillset(sigset_t *set);</p>
</li>
<li><p>将一个信号添加到集合中：sigaddset(sigset_t *set,int signum);</p>
</li>
<li><p>将一个信号从集合中移除：sigdelset(sigset_t *set,int signum);</p>
</li>
<li><p>判断一个信号是否在集合中(在是1，不在是0)：sigismember(const sigset_t *set,int signum);</p>
</li>
</ul>
<p>2.设置信号屏蔽字和解除屏蔽</p>
<p>int sigprocmask(int how , const sigset_t *set , sigset_t *oldset);</p>
<ul>
<li><p>how：SIG_BLOCK是设置阻塞；SIG_UNBLOCK是取消阻塞；SIG_SETMASK是用自定义set替换mask</p>
</li>
<li><p>set：自定义set</p>
</li>
<li><p>oldset： 旧有的mask</p>
</li>
</ul>
<p>用来屏蔽信号、解除屏蔽也使用该函数。其本质是读取或修改进程的信号屏蔽字(PCB中)</p>
<p>注意：屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略是表示将信号丢弃处理</p>
<p>3.查看未决信号集</p>
<p>int sigpending(sigset_t *set);</p>
<ul>
<li>set：传出的未决参数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/System_programming/1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对信号2设置了阻塞，并查看了未决信号集,Ctrl+c可以进行查看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>&#123;     <span class="comment">//自定义函数打印位图</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sigismember(<span class="built_in">set</span>,i))&#123;     <span class="comment">//信号i是否在信号集set上</span></span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>,oldset,pedset;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);    <span class="comment">//清空信号集(置为0)</span></span><br><span class="line">        <span class="comment">//将信号添加到自定义集合中(在自定义集合中，将对应信号置为1)</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGINT);      <span class="comment">// Ctrl+c对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);     <span class="comment">// Ctrl+\对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGKILL);     <span class="comment">// 由于信号9不能被修改，所以不能被处理,可以通过kill -9 该程序对应进程号 来终止该进程</span></span><br><span class="line">        ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);     <span class="comment">//设置阻塞；自定义集合的地址，传出参数</span></span><br><span class="line">        <span class="comment">//通过上一行代码，对信号2进行了阻塞，只有解除阻塞，否则信号2一直未决，即在未决信号集中，信号2一直为1</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                ret = sigpending(&amp;pedset);   <span class="comment">//查看未决信号集,参数是传出参数，是该进程的一个未决信号集</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                print_set(&amp;pedset);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;  <span class="comment">//当i执行到10的时候，解除屏蔽字的阻塞，此时ctrl+c信号递达，退出程序</span></span><br><span class="line">                        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6sigaction函数"><a href="#5-6sigaction函数" class="headerlink" title="5.6sigaction函数"></a>5.6sigaction函数</h2><blockquote>
<p>signal函数和sigaction函数都是只注册一个信号的捕抓函数，捕抓是有内核来完成的</p>
</blockquote>
<p>int sigaction (int signum , const struct sigaction *act , struct sigaction *oldact);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>singum：捕抓的信号</p>
</li>
<li><p>act：传入参数，新的处理方式</p>
</li>
<li><p>oldact：传出参数，旧的处理方式</p>
</li>
</ul>
</li>
</ul>
<p>信号捕抓的特性：</p>
<ul>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为#，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由#来指定，而是用sa_mask来指定，调用完信号处理函数，再恢复为#。</p>
</li>
<li><p>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs&#x3D;0)。</p>
</li>
<li><p>捕捉函数执行期间，被屏蔽信号多次发生，解除屏蔽后只处理一次</p>
</li>
</ul>
<p>案例：用signal()函数对信号2进行捕抓</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        signal(SIGINT,sig_cath);      <span class="comment">//当信号SIGINT产生时，对其捕抓，去执行对应捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：用sigaction()函数对信号2进行捕抓(可以设置多个函数的捕抓)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="keyword">if</span>(signo == SIGINT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGQUIT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---catch you---%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span>     <span class="comment">//定义两个结构体</span></span><br><span class="line">        act.sa_handler = sig_cath;     <span class="comment">//设置回调函数(捕抓函数)</span></span><br><span class="line">        sigemptyset(&amp;(act.sa_mask));    <span class="comment">//将sa_mask屏蔽字置为0，这个只在sig_catch函数工作时有效</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;               <span class="comment">//默认值(在一个信号的捕抓函数执行时，默认蒙蔽该信号，防止再来)</span></span><br><span class="line">        <span class="type">int</span> ret = sigaction(SIGINT,&amp;act,&amp;oldact);     <span class="comment">//注册信号捕抓函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = sigaction(SIGQUIT,&amp;act,&amp;oldact);   <span class="comment">//注册第二个信号捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过信号捕捉回收子进程(当一个时间点有多个进程死亡时，此时只能处理一个，其他死亡的子进程没有回收就会是僵尸进程)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signo)</span>&#123;      <span class="comment">//有子进程终止，发送SIGCHLD信号时，该函数会被内核回调</span></span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>))!=<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;---catch child id %d,ret = %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="comment">//阻塞(防止父线程还没有注册完成，部分子线程就已经结束了，这样就来不及回收那些结束的子进程)</span></span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>;    <span class="comment">//自定义阻塞信号集</span></span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);   <span class="comment">//将自定义阻塞信号集的SIGCHLD信号置1，使其与pcd里面的阻塞信号集作用，让该信号阻塞</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);     <span class="comment">//使其与pcd的阻塞信号集作用</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                <span class="comment">//初始化act结构体</span></span><br><span class="line">                act.sa_handler = catch_child;     <span class="comment">//捕捉函数</span></span><br><span class="line">                sigemptyset(&amp;act.sa_mask);        <span class="comment">//设置捕捉函数执行期间的屏蔽信号集，全置为0</span></span><br><span class="line">                act.sa_flags = <span class="number">0</span>;                 <span class="comment">//设置默认属性，本信号自动屏蔽</span></span><br><span class="line">                sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);     <span class="comment">//子进程状态发生改变就触发捕捉函数</span></span><br><span class="line">                <span class="comment">//解除阻塞(父进程注册完毕，可以开始接收子线程结束后，内核传给父进程的信号了)</span></span><br><span class="line">                sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);   <span class="comment">//如果没有解除阻塞步骤，回调函数没有执行的机会(因为pcd的mask对该信号是屏蔽状态)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">                <span class="comment">//sleep(i);    //可以用sleep进行一个一个回收</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-会话与守护进程"><a href="#6-会话与守护进程" class="headerlink" title="6.会话与守护进程"></a>6.会话与守护进程</h1><h2 id="6-1进程组和会话"><a href="#6-1进程组和会话" class="headerlink" title="6.1进程组和会话"></a>6.1进程组和会话</h2><blockquote>
<p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化对多个进程的管理。当父进程，创建子进程的时候，默认子进程与父进程属于同一个进程组。进程组ID &#x3D; 第一个进程ID(组长进程)。所以，组长进程标识，其进程组ID &#x3D; 其进程ID。</p>
<p>而会话就是进程组的集合。</p>
</blockquote>
<p>1.创建一个会话需要注意以下6点：</p>
<ul>
<li>调用进程不能是进程组组长，该进程变成新会话的首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要root权限 (Ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>如果该进程调用的是组长进程，则出错返回</li>
<li>建立新会话时，先调用fork，父进程终止，子进程调用setsid（）</li>
</ul>
<p>2.getsid()函数：获取进程所属的会话ID</p>
<p>pid_t getsid(pid_t pid);</p>
<ul>
<li><p>参数：pid为所需要获取的进程</p>
</li>
<li><p>返回值：成功(返回调用进程的会话ID)；失败(返回-1，设置errno)</p>
</li>
</ul>
<p>注意：组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程</p>
<p>3.setsid()函数：创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</p>
<p>pid_t setsid(void); </p>
<p>返回值：成功(返回调用进程的会话ID)；失败(返回-1)</p>
<p>注意：调用setsid函数的进程，既是新的会长，也是新的组长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子进程成立新会话(父进程不能创建会话)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子进程执行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id(父进程的)---&gt;0为默认调用该程序的进程组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id(有可能是父进程的，也可能是父进程的父进程的)</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                setsid();   <span class="comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程(子进程id=组进程id=会话进程id)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;changed:\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id</span></span><br><span class="line">               sleep(<span class="number">20</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2守护进程"><a href="#6-2守护进程" class="headerlink" title="6.2守护进程"></a>6.2守护进程</h2><blockquote>
<p>daemon进程。通常运行于操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发送或周期性执行某一动作。不受用户登录注销影响，通常采用以d结尾的命名方式。</p>
</blockquote>
<p>1.创建守护进程，最关键的一步是调用setsid函数，创建一个新的Session，并成为Session leader。</p>
<p>2.守护进程的创建步骤：</p>
<ul>
<li><p>fork子进程，让父进程终止</p>
</li>
<li><p>子进程调用setsid()创建新会话</p>
</li>
<li><p>通常根据需要，改变工作目录位置chdir()</p>
</li>
<li><p>通常根据需要，重设umask文件权限掩码</p>
</li>
<li><p>通常根据需要，关闭&#x2F;重定向文件描述符012</p>
</li>
<li><p>守护进程 业务逻辑。—-&gt;while()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//守护进程的创建(运行在后台)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> ret,fd;</span><br><span class="line">        <span class="comment">//1、创建子进程，父进程终止</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//父进程终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、子进程创建新会话</span></span><br><span class="line">        <span class="comment">//printf(&quot;---------------------\n&quot;);</span></span><br><span class="line">        pid = setsid();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、改变工作目录位置</span></span><br><span class="line">        ret = chdir(<span class="string">&quot;/home/c_c++后端/系统编程/session_dir&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、改变文件访问权限掩码</span></span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line">        <span class="comment">//5、关闭文件描述符 (此时就可用的最小文件描述符是3)</span></span><br><span class="line">        close(STDIN_FILENO);     <span class="comment">//关闭文件描述符0</span></span><br><span class="line">        fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);   <span class="comment">//读写打开dev/null文件 -----&gt;fd=0</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);    <span class="comment">//将文件描述符1指向fd</span></span><br><span class="line">        dup2(fd,STDERR_FILENO);    <span class="comment">//将文件描述符2指向fd</span></span><br><span class="line">        <span class="comment">//6 一直运行，等待接收命令</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//模拟守护进程业务</span></span><br><span class="line">        <span class="comment">//printf(&quot;------------------\n&quot;);       </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-线程"><a href="#7-线程" class="headerlink" title="7.线程"></a>7.线程</h1><blockquote>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位，同一进程中的多条线程将共享该进程中的全部系统资源，但同一进程中的多个线程有各自的调用栈、寄存器环境和线程本地存储。</p>
</blockquote>
<p>1.线程与进程区别：</p>
<ul>
<li><p>进程：有独立的进程地址空间，有独立的pcb</p>
</li>
<li><p>线程：有独立的pcb，没有独立的进程地址空间—&gt;是轻量级进程LWP</p>
</li>
</ul>
<p>注意：线程是最小的执行单位；进程是最小分配资源单位，可看成是只有一个线程的进程。进程里创建线程后，进程也叫线程了</p>
<p>2.查看某个进程里的线程：</p>
<ul>
<li>ps -Lf 进程pid：线程号是LWP那一栏(相当于进程号，线程号是接在进程号后面的)</li>
</ul>
<p>3.线程共享资源：文件描述符、每种信号的处理的方式、当前工作目录、用户ID和组ID、内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)、全局变量；</p>
<p>4.线程非共享资源：线程id、处理器现场和栈指针(内核栈)、独立的栈空间(用户空间栈)、errno变量、信号屏蔽字、调度优先级</p>
<p>5.线程优缺点</p>
<ul>
<li><p>优点：提高程序并发性、开销小、数据通信、共享数据方便；</p>
</li>
<li><p>缺点：是库函数，不稳定、调试、编写困难、对信号支持不好</p>
</li>
</ul>
<h2 id="7-1线程控制原语"><a href="#7-1线程控制原语" class="headerlink" title="7.1线程控制原语"></a>7.1线程控制原语</h2><p>1.线程函数</p>
<p><code>pthread_t pthread_self(void);</code></p>
<ul>
<li><p>返回值：本线程id号</p>
</li>
<li><p>作用：获取线程id，线程id是在进程地址空间内部用来标识线程身份的</p>
</li>
</ul>
<p>注意：线程ID是在进程中来标识线程身份的，进程通过线程ID来对其加以区分；而LWP是线程号，标识线程身份给CPU用的(CPU用线程号来划分时间片)</p>
<p>2.创建线程</p>
<p><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void*),void *arg);</code></p>
<ul>
<li><p>参1：传出参数，表示新创建的子线程id</p>
</li>
<li><p>参2：线程属性，传NULL表示使用默认属性</p>
</li>
<li><p>参3：子线程回调函数，若创建成功，pthread_create函数返回时，该函数会被自动调用</p>
</li>
<li><p>参4：参数3函数的参数，没有的话就传NULL</p>
</li>
<li><p>返回值：成功(返回0)；失败(errno)</p>
</li>
</ul>
<p>注意：<code>主函数利用pthread_create()创建新线程时，主函数会立即返回值并执行下面代码，不会因为新线程没有执行完回调函数而阻塞。</code></p>
<p>当新线程启动后，它会在后台执行回调函数，同时主线程继续执行自己的任务。如果回调函数执行时间较长，主线程仍然不会被阻塞，它会继续往下执行，直到遇到需要等待新线程完成任务的代码段。</p>
<p>3.退出当前线程</p>
<p><code>void pthread_exit(void *retval);</code></p>
<ul>
<li>参数：退出值，无退出值时，NULL</li>
</ul>
<p>注意：exit()是退出当前进程；return;是返回到调用者那里去</p>
<p>pthread_exit(NULL)的作用是在线程中显式地退出线程的函数调用。它用于终止当前线程的执行，并将线程的退出状态设置为NULL。当调用pthread_exit(NULL)时，当前线程会立即退出，并将控制返回给创建该线程的线程。这意味着线程的执行会终止，但其他线程仍然可以继续执行。</p>
<p>4.阻塞等待线程退出，获取线程退出状态</p>
<p><code>int pthread_join(pthread_t thread,void** retval);</code></p>
<ul>
<li><p>参1：要回收的线程id</p>
</li>
<li><p>参2：传出参数，存储线程退出的状态，线程正常退出，得到来自该线程在回调函数中返回的信息；线程异常退出，返回-1.</p>
</li>
<li><p>返回值：成功回收(返回0)，失败(errno)</p>
</li>
</ul>
<blockquote>
<p>注意：在进程中，进程结束是exit(1)，退出状态是int型，所以回收进程wait的参数是<code>int*</code>型；在线程中，线程结束是<code>pthread_exit(void*)</code>，退出状态是<code>void*</code>型，所以回收线程pthread_join参数是<code>void**</code>型。</p>
</blockquote>
<p>5.杀死(取消)线程，类似于进程中的kill()</p>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
<ul>
<li><p>参数：待杀死的线程id</p>
</li>
<li><p>返回值：成功(0)；失败(errno)</p>
</li>
</ul>
<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>如果子线程没有到达取消点，那么使用pthread_cancel无效。我们可以在程序中。手动添加一个取消点，使用pthread_testcancel()。</p>
<p>取消点：通常是一些系统调用creat,open,pause,close,read,write。(可以理解为是线程有进入内核，如果线程执行的内容是if,while,for这些则不能用pthread_cancel()杀死)</p>
<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<p>6.线程出错要用这个函数打印</p>
<p><code>char *strerror(int errnum);</code></p>
<ul>
<li>使用：fprintf(stderr,”pthread_join error:%s”,strerror(ret));</li>
</ul>
<p>7.实现线程分离</p>
<p><code>int pthread_detach(pthread_t thread); </code></p>
<ul>
<li><p>参数：待分离的线程id</p>
</li>
<li><p>返回值：成功(0),失败(errno)</p>
</li>
</ul>
<p>注意：pthread_detach不能与pthread_join一起用，当使用线程分离时，被分离的子线程就不归主线程管了，子线程执行完由系统回收，不需要主线程再调用pthread_join来回收，如果调用，会回收失败。</p>
<p>8.线程属性，用来设置分离属性</p>
<ul>
<li><p><code>pthread_attr_t attr;            //创建一个线程属性结构体变量</code></p>
</li>
<li><p><code>pthread_attr_init(&amp;attr);       //初始化线程属性</code></p>
</li>
<li><p><code>pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);    //设置</code></p>
</li>
<li><p><code>pthread_create(&amp;tid,&amp;attr,tfn,NULL);                //设置线程属性，创建为分离态</code></p>
</li>
<li><p><code>pthread_attr_destroy(&amp;attr);                       //销毁线程属性</code></p>
</li>
</ul>
<p>案例：创建一个线程执行回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时：后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程，先慢慢执行\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，先结束了\n&quot;</span>);</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：循环创建多个子线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用pthread_exit()函数来退出子线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//exit(0);      //表示退出进程，所以i=2后的线程都执行不了</span></span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);    <span class="comment">//将当前线程退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_join()回收子线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> var;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;     <span class="comment">//方法2：通过在主函数中定义一个结构体变量来实现</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">tval</span> =</span> (<span class="keyword">struct</span> thrd *)arg;</span><br><span class="line">        tval-&gt;var = <span class="number">93</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(tval-&gt;str,<span class="string">&quot;hello lxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)tval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">/*struct thrd *retval;  </span></span><br><span class="line"><span class="comment">        int ret = pthread_create(&amp;tid,NULL,tfn,NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> <span class="title">arg</span>;</span>     <span class="comment">//定义一个结构体变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">retval</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)&amp;arg);</span><br><span class="line">    	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(tid,(<span class="type">void</span> **)&amp;retval);    <span class="comment">//回收子线程(阻塞)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child thread exit with var = %d,str = %s\n&quot;</span>,retval-&gt;var,retval-&gt;str);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);   <span class="comment">//线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_cancel()终止子线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        ret = pthread_cancel(tid);       <span class="comment">//终止子线程</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_cancel error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while(1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_detach()设置线程分离</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_detach(tid);            <span class="comment">//设置线程分离</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_detach error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        ret = pthread_join(tid,<span class="literal">NULL</span>);     <span class="comment">//接收失败会返回非0值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;join ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_join error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过线程属性设置分离属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过线程属性设置来使子线程分离，这样就可以创建一个是一个了，而不需要后面手动一个一个设置</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">pthread_attr_t</span> attr;     <span class="comment">//定义属性结构体</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = pthread_attr_init(&amp;attr);    <span class="comment">//初始化属性结构体(传出参数)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_init error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);      <span class="comment">//设置线程属性为 分离属性</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_setdetachastate error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s&quot;</span>,strerror(ret));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        ret = pthread_attr_destroy(&amp;attr);    <span class="comment">//销毁属性结构体</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_destroy error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 returning\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn3</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 3 returning\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pthread_testcancel();   //自动添加取消点</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *tret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn3,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code = %d\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2线程使用注意事项"><a href="#7-2线程使用注意事项" class="headerlink" title="7.2线程使用注意事项"></a>7.2线程使用注意事项</h2><p>线程使用注意事项：</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应该调用pthread_exit()</p>
</li>
<li><p>避免僵尸线程，使用pthread_join、pthread_detach、pthread_create(指定分离属性)</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放(线程共享堆)</p>
</li>
<li><p>应该避免在多线程模型中调用fork。除非马上exec。因为如果调用fork，则子进程中只有调用fork的线程存在，其他线程在子进程中均默认被pthread_exit</p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
</li>
</ul>
<h1 id="8-线程同步"><a href="#8-线程同步" class="headerlink" title="8.线程同步"></a>8.线程同步</h1><p>协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误。</p>
<p>锁的使用：建议锁，对公共数据进行保护。所有线程应该在访问公共数据前先拿锁再访问。但锁本身不具备强制性。</p>
<h2 id="8-1互斥锁mutex"><a href="#8-1互斥锁mutex" class="headerlink" title="8.1互斥锁mutex"></a>8.1互斥锁mutex</h2><p>1.使用互斥锁的一般步骤：</p>
<ul>
<li><p><code>pthread_mutex_t lock;         //创建锁</code></p>
</li>
<li><p><code>pthread_mutex_init;           //初始化</code></p>
</li>
<li><p><code>pthread_mutex_lock;           //加锁</code></p>
</li>
<li><p>访问共享数据(stdout)</p>
</li>
<li><p><code>pthread_mutex_unlock();      //解锁</code></p>
</li>
<li><p><code>pthread_mutex_destroy;       //销毁锁</code></p>
</li>
</ul>
<p>补：restrict关键字：用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成。</p>
<p>2.初始化互斥锁的两种方法： </p>
<ul>
<li><p><code>pthread_mutex_t mutex;                             //定义一把锁</code></p>
</li>
<li><p><code>pthread_mutex_t_init(&amp;mutex,NULL);                 //动态初始化</code></p>
</li>
<li><p><code>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;   //静态初始化</code></p>
</li>
</ul>
<p>注意：尽量保证锁的粒度(范围)，越小越好。访问共享数据前加锁，访问结束立即解锁。</p>
<p>方便记忆：互斥锁，本质是结构体。我们可以看成整数，初值为1，即pthread_mutex_init()调用成功；加锁理解为–操作，阻塞线程；解锁理解为++操作，唤醒阻塞在锁上的线程。</p>
<p>try锁：尝试加锁，成功–操作；失败就返回，同时设置错误号EBUSY。</p>
<p>案例：通过互斥锁进行对公共区域的访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;          <span class="comment">//定义一把互斥锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);        <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);            <span class="comment">//模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lxx\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);      <span class="comment">//解锁              </span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> ret = pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);     <span class="comment">//对锁进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;mutex init error:%s\n&quot;</span>,strerror(ret));  <span class="comment">//打印错误信息</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);     <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                <span class="comment">//这里睡眠了1到3秒，但因为有加锁，输出依然是完整的HELLO WORLD</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);   <span class="comment">//解锁</span></span><br><span class="line">            	sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);         <span class="comment">//销毁锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2读写锁"><a href="#8-2读写锁" class="headerlink" title="8.2读写锁"></a>8.2读写锁</h2><blockquote>
<p>锁只有一把，以读方式给数据加锁为读锁；以写方式给数据加锁为写锁。相较于互斥量(互斥锁)而言，当读线程多的时候，读写锁可以提高访问效率。</p>
</blockquote>
<p>1.读写锁的特性</p>
<ul>
<li><p>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求，优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</p>
</li>
</ul>
<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。即写独占，读共享</p>
<p>2.主要应用函数</p>
<ul>
<li><p><code>pthread_rwlock_init                  //自定义读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_destroy               //销毁读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_rdlock                //读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_wrlock                //写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_tryrdlock            //尝试读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_trywrlock            //尝试写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_unlock               //读写锁解锁(通用)</code></p>
</li>
</ul>
<p>以上函数的返回值都是：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_rwlock_t rwlock             //定义一个读写锁变量rwlock</code></li>
</ul>
<p>3.死锁</p>
<p>是使用锁不恰当导致的现象，如：</p>
<ul>
<li><p>对一个锁反复lock</p>
</li>
<li><p>两个线程，各自持有一把锁，请求另一把</p>
</li>
</ul>
<p>案例：模拟3个线程不定时写同一个全局资源，5个线程不定时读同一个全局资源</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter;                  <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;      <span class="comment">//全局的读写锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;    <span class="comment">//写的回调函数</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传进来的参数进行转换</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_wrlock(&amp;rwlock);   <span class="comment">//写锁加锁</span></span><br><span class="line">                t = counter;    <span class="comment">//方便后面打印先前一个数</span></span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;======Write %d:%lu:counter = %d ++counter = %d\n&quot;</span>,i,pthread_self(),t,++counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);   <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;           <span class="comment">//读的回调函数</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_rdlock(&amp;rwlock);    <span class="comment">//读锁加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------Read %d: %lu: %d\n&quot;</span>,i,pthread_self(),counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);    <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pthread_t</span> tid[<span class="number">8</span>];                     <span class="comment">//定义一个线程组</span></span><br><span class="line">        pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);    <span class="comment">//初始化读写锁</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i],<span class="literal">NULL</span>,th_write,(<span class="type">void</span> *)i);         <span class="comment">//前面三个线程负责写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i+<span class="number">3</span>],<span class="literal">NULL</span>,th_read,(<span class="type">void</span> *)(i+<span class="number">3</span>));    <span class="comment">//后面五个线程负责读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                pthread_join(tid[i],<span class="literal">NULL</span>);                 <span class="comment">//主线程回收子线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_destroy(&amp;rwlock);                   <span class="comment">//销毁读写锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3条件变量"><a href="#8-3条件变量" class="headerlink" title="8.3条件变量"></a>8.3条件变量</h2><blockquote>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用。</p>
</blockquote>
<p>1.主要应用函数：</p>
<ul>
<li><p><code>pthread_cond_init函数      //初始化条件变量</code></p>
</li>
<li><p><code>pthread_cond_destroy函数   //销毁条件变量</code></p>
</li>
<li><p><code>pthread_cond_wait函数      //等待条件满足</code></p>
</li>
<li><p><code>pthread_cond_timewait函数  //等待条件满足(超时不等)</code></p>
</li>
<li><p><code>pthread_cond_signal函数    //唤醒阻塞在条件变量的线程(一个)</code></p>
</li>
<li><p><code>pthread_cond_broadcast函数   //唤醒阻塞在条件变量的线程(多个)</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_cond_t cond;       //定义一个条件变量cond</code></li>
</ul>
<p>2.初始化条件变量的两种方法：</p>
<p><code>pthread_cond_t cond;                     //定义一个条件变量</code></p>
<ul>
<li><p><code>pthread_cond_t_init(&amp;cond,NULL);                //动态初始化</code></p>
</li>
<li><p><code>pthread_cond_t cond=PTHREAD_MUTEX_INITIALIZER; //静态初始化</code></p>
</li>
</ul>
<p>3.pthread_cond_wait函数作用：</p>
<ul>
<li><p>阻塞等待条件变量cond(参1)满足</p>
</li>
<li><p>释放已掌握的互斥锁，相当于pthread_mutex_unlock(&amp;mutex)。</p>
</li>
</ul>
<p>注意：上面两步为一个原子操作(中间不会分开执行)</p>
<ul>
<li>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex)</li>
</ul>
<p>案例：模拟一个消费者-生产者模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">err_thread</span><span class="params">(<span class="type">int</span> ret,<span class="type">char</span>*str)</span>&#123;        <span class="comment">//线程创建失败调用的打印错误信息的函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s:%s\n&quot;</span>,str,strerror(ret));</span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span>                      <span class="comment">//定义一个结构体来存放信息</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;     <span class="comment">//定义并初始化一个互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_data = PTHREAD_COND_INITIALIZER;     <span class="comment">//定义并初始化一个条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">produser</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//生产者的回调函数：生产数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));    <span class="comment">//创建一个节点</span></span><br><span class="line">                mp-&gt;num = rand()%<span class="number">1000</span>+<span class="number">1</span>;                        <span class="comment">//模拟随机产生一个数值</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------produce %d\n&quot;</span>,mp-&gt;num);         <span class="comment">//打印生产者产生的数据</span></span><br><span class="line">                <span class="comment">//后插法生产数据(将数据结点连起来)</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);                    <span class="comment">//加锁，互斥锁</span></span><br><span class="line">                mp-&gt;next = head;</span><br><span class="line">                head = mp;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);                  <span class="comment">//解锁互斥锁</span></span><br><span class="line"></span><br><span class="line">                pthread_cond_signal(&amp;has_data);                <span class="comment">//唤醒阻塞在条件变量 has_data上的线程</span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                               <span class="comment">//随机睡眠</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//消费者的回调函数：消费数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);           <span class="comment">//加锁，互斥量</span></span><br><span class="line">                <span class="keyword">while</span>(head == <span class="literal">NULL</span>)&#123;    <span class="comment">//当是空的时候，才对消费者进行阻塞等待，阻塞期间，会解锁，让生产者拿锁生产数据(如果是只有一个消费者可以是if，多个消费者则需要while)</span></span><br><span class="line">                        pthread_cond_wait(&amp;has_data,&amp;mutex);   <span class="comment">//阻塞等待条件变量，当有数据时，消费者就会被激活，且自动加锁</span></span><br><span class="line">                &#125;  <span class="comment">//如果有多个消费者，而用的是if，则会出现没有数据时，消费者还在消费，即吐核问题</span></span><br><span class="line">                mp = head;</span><br><span class="line">                head = mp-&gt;next;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-------------cconsumer id:%lu : %d\n&quot;</span>,pthread_self(),mp-&gt;num);</span><br><span class="line">                <span class="built_in">free</span>(mp);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid1,cid2;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;pid,<span class="literal">NULL</span>,produser,<span class="literal">NULL</span>);     <span class="comment">//创建一个生产者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create produser error&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid1,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第一个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer1 error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid2,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第二个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer2 error&quot;</span>);</span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);          <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid1,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid2,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9.信号量"></a>9.信号量</h1><blockquote>
<p>应用于线程、进程间同步，因为互斥锁对于多个线程访问同一个公共内存空间时，只能一个一个访问，虽然保证了数据正确性的目的，但导致了线程的并发性下降。</p>
<p>信号量是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
</blockquote>
<p>1.主要应用函数</p>
<ul>
<li><p><code>sem_init           //信号量初始化</code></p>
</li>
<li><p><code>sem_destroy        //信号量销毁</code></p>
</li>
<li><p><code>sem_wait           //信号量加锁</code></p>
</li>
<li><p><code>sem_trywait  </code></p>
</li>
<li><p><code>sem_timedwait</code></p>
</li>
<li><p><code>sem_post          //信号量解锁</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(-1)</p>
<p>2.int sem_init(sem_t *sem,int pshared,unsigned int value);</p>
<ul>
<li><p>参1：信号量</p>
</li>
<li><p>参2：0—&gt;用于线程间同步；1—&gt;用于进程间同步</p>
</li>
<li><p>参3：N值(指定同时访问的线程数)</p>
</li>
</ul>
<p>3.sem_wait()：一次调用，做一次–操作，当信号量的值为0时，再次–就会阻塞(对比pthread_mutex_lock)</p>
<p>4.sem_post()：一次调用，做一次++操作，当信号量的值为N时，再次++就会阻塞(对比pthread_mutex_unlock)</p>
<p>案例：用信号量实现生产者-消费者模式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                      <span class="comment">//全局数值实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number,product_number;   <span class="comment">//空格子信号量，产品信号量</span></span><br><span class="line"><span class="comment">//开始时，空格子为N，产品格子为0</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;blank_number);   <span class="comment">//生产者将格子数--，为0则阻塞等待(说明产品满了)</span></span><br><span class="line">                <span class="built_in">queue</span>[i]=rand()%<span class="number">100</span>+<span class="number">1</span>;     <span class="comment">//生产一个产品</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;------produce------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                sem_post(&amp;product_number);     <span class="comment">//将产品数++</span></span><br><span class="line"></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;        <span class="comment">//借助下标实现环形</span></span><br><span class="line">                sleep(rand()%<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;product_number);   <span class="comment">//消费者将产品数--，为0则阻塞等待(说明还没有产品可以消费)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-----consumer------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                <span class="built_in">queue</span>[i]=<span class="number">0</span>;                 <span class="comment">//消费一个产品</span></span><br><span class="line">                sem_post(&amp;blank_number);    <span class="comment">//消费掉以后，将空格子数++</span></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid;</span><br><span class="line">        sem_init(&amp;blank_number,<span class="number">0</span>,NUM);    <span class="comment">//初始化空格子信号量为5，0表示线程间同步</span></span><br><span class="line">        sem_init(&amp;product_number,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//初始化产品数信号量为0</span></span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;pid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);   <span class="comment">//创建生产者</span></span><br><span class="line">        pthread_create(&amp;cid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);   <span class="comment">//创建消费者</span></span><br><span class="line"></span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(cid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;blank_number);</span><br><span class="line">        sem_destroy(&amp;product_number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lxx93.online">lxx9339-T</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lxx93.online/2024/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">https://lxx93.online/2024/07/06/系统编程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lxx93.online" target="_blank">-lxxl-</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><a class="post-meta__tags" href="/tags/%E7%AE%A1%E9%81%93/">管道</a><a class="post-meta__tags" href="/tags/%E4%BF%A1%E5%8F%B7/">信号</a><a class="post-meta__tags" href="/tags/pthread/">pthread</a><a class="post-meta__tags" href="/tags/signal/">signal</a></div><div class="post_share"><div class="social-share" data-image="/img/9.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">网络编程</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/06/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/" title="静态库与动态库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">静态库与动态库</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lxx9339-T</div><div class="author-info__description">即使身处阴沟,也能仰望星空。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2235221711@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2235221711&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-text">1.基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-text">1.1基本函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">1.2基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E8%BF%9B%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">1.3进阶函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B"><span class="toc-text">2.进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.1进程与程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-text">3.相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1fork-%E5%87%BD%E6%95%B0"><span class="toc-text">3.1fork()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-execlp-%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 execlp()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-execl%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 execl函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4wait-%E5%87%BD%E6%95%B0"><span class="toc-text">3.4wait()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5waitpid-%E5%87%BD%E6%95%B0"><span class="toc-text">3.5waitpid()函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-IPC%E6%96%B9%E6%B3%95"><span class="toc-text">4.IPC方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E7%AE%A1%E9%81%93"><span class="toc-text">4.1管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-FIFO"><span class="toc-text">4.2 FIFO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84I-O"><span class="toc-text">4.3存储映射I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7"><span class="toc-text">5.信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%B8%B8%E8%AF%86"><span class="toc-text">5.1常识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E4%BF%A1%E5%8F%B7%E5%9B%9B%E8%A6%81%E7%B4%A0%E5%8F%8A%E5%B8%B8%E8%A7%84%E4%BF%A1%E5%8F%B7"><span class="toc-text">5.2信号四要素及常规信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-alarm%E5%87%BD%E6%95%B0"><span class="toc-text">5.3 alarm函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4setitimer%E5%87%BD%E6%95%B0"><span class="toc-text">5.4setitimer函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">5.5信号集和未决信号集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6sigaction%E5%87%BD%E6%95%B0"><span class="toc-text">5.6sigaction函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.会话与守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-text">6.1进程组和会话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.2守护进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%BA%BF%E7%A8%8B"><span class="toc-text">7.线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD"><span class="toc-text">7.1线程控制原语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">7.2线程使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">8.线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E4%BA%92%E6%96%A5%E9%94%81mutex"><span class="toc-text">8.1互斥锁mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">8.2读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">8.3条件变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">9.信号量</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/git%E5%AD%A6%E4%B9%A0/" title="git学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/36.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git学习"/></a><div class="content"><a class="title" href="/2025/03/26/git%E5%AD%A6%E4%B9%A0/" title="git学习">git学习</a><time datetime="2025-03-26T13:25:44.000Z" title="发表于 2025-03-26 21:25:44">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/Qt%E6%93%8D%E4%BD%9C/" title="Qt操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/35.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt操作"/></a><div class="content"><a class="title" href="/2025/03/26/Qt%E6%93%8D%E4%BD%9C/" title="Qt操作">Qt操作</a><time datetime="2025-03-26T04:21:04.000Z" title="发表于 2025-03-26 12:21:04">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/15/%E8%A1%8C%E6%B5%8B/" title="行测"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/34.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="行测"/></a><div class="content"><a class="title" href="/2025/03/15/%E8%A1%8C%E6%B5%8B/" title="行测">行测</a><time datetime="2025-03-15T10:02:28.000Z" title="发表于 2025-03-15 18:02:28">2025-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/04/protobuf/" title="protobuf"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/33.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="protobuf"/></a><div class="content"><a class="title" href="/2025/03/04/protobuf/" title="protobuf">protobuf</a><time datetime="2025-03-04T05:48:23.000Z" title="发表于 2025-03-04 13:48:23">2025-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/" title="数据库mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/32.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库mysql"/></a><div class="content"><a class="title" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/" title="数据库mysql">数据库mysql</a><time datetime="2025-01-10T06:46:50.000Z" title="发表于 2025-01-10 14:46:50">2025-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> lxx9339-T</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true       //软加载打开，可以提高网址性能) {
    if (true       //软加载打开，可以提高网址性能) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="12221117397" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script> - <script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'a24c62babc5b484d932b02c4747b0f56';
  var gaud_map_key = '9bcdd4b88228b310aa9787a1153666fd';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '103.719156,36.104195';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>