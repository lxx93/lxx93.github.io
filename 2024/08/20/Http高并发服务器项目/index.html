<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Http高并发服务器项目 | -lxxl-</title><meta name="author" content="lxx9339-T"><meta name="copyright" content="lxx9339-T"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 简介该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。 过程： 客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会">
<meta property="og:type" content="article">
<meta property="og:title" content="Http高并发服务器项目">
<meta property="og:url" content="http://lxxl9313.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/index.html">
<meta property="og:site_name" content="-lxxl-">
<meta property="og:description" content="1. 简介该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。 过程： 客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lxxl9313.online/img/22.jpg">
<meta property="article:published_time" content="2024-08-20T14:09:56.000Z">
<meta property="article:modified_time" content="2025-05-11T13:00:42.612Z">
<meta property="article:author" content="lxx9339-T">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="Http">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lxxl9313.online/img/22.jpg"><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://lxxl9313.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":390},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":"50                //字数限制","languages":{"author":"作者: lxx9339-T","link":"链接: ","source":"来源: -lxxl-","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Http高并发服务器项目',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-11 21:00:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script async data-pjax src="/js/anzhiyu.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><link rel="stylesheet" href="/css/music.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="-lxxl-" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/22.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="-lxxl-"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/logo1.png"/><span class="site-name">-lxxl-</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis"><i class="fa-fw fas fas fa-video"></i><span> 追番</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Http高并发服务器项目</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-20T14:09:56.000Z" title="发表于 2024-08-20 22:09:56">2024-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-11T13:00:42.612Z" title="更新于 2025-05-11 21:00:42">2025-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/">小项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Http高并发服务器项目"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。</p>
<p>过程：</p>
<p>客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会自动下载到本地，如果能够展示，它在本地指定的下载目录是不会有对应文件的，因为它下载到本地之后，就直接将内容显示到窗口上了，可以理解为它下载下来的只是一个缓存，该缓存能够支撑它在浏览器上把内容显示出来，当数据显示完成之后，浏览器会定期地清除缓存，那么该资源也就不存在了。</p>
<h1 id="2-单反应堆的服务器模型"><a href="#2-单反应堆的服务器模型" class="headerlink" title="2. 单反应堆的服务器模型"></a>2. 单反应堆的服务器模型</h1><p>在网络编程中，为了提高访问通信的效率，就可以使用单反应堆的服务器模型，它是IO多路复用与多线程相结合的一种技术。</p>
<p>设计思路：</p>
<p>在主线程里面，服务器绑定本地的ip和端口来得到一个通信的套接字，因为通信的套接字需要监听它的读事件，所以就将它的读事件注册给Reactor，也就是反应堆模型。该反应堆模型底层用到的是poll、epoll或select，这三种IO多路转接技术不是同时用，而是选择其中的某一种。在选择了底层的IO模型之后，把用于监听的文件描述符的读事件注册给该模型，然后内核就可以帮助我们检测这用于监听的文件描述符的读事件是否被激活了。如果被激活了，说明有新连接到达，那么我们就需要调用用于监听的文件描述符对应的处理函数，该处理函数其实就是负责与对端建立新连接，主要的处理核心动作核就是调用accept()函数，因此就能得到一个用于通信的文件描述符，然后对该通信描述符进行一个封装。在封装的时候，给该用于通信的文件描述符指定了读回调和写回调，至于为什么要指定读写回调，是因为反应堆模型就是基于回调的。TcpConnection模型当检测到了对应的文件描述符它的读事件或写事件被触发了之后，该框架就会自动的调用这个事件的处理函数，这种机制就称为反应堆机制。其实本质就是回调函数。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_10.png" style="zoom:67%;">

<h1 id="3-多反应堆的服务器模型"><a href="#3-多反应堆的服务器模型" class="headerlink" title="3. 多反应堆的服务器模型"></a>3. 多反应堆的服务器模型</h1><p>对于多反应堆模型，反应堆的数量取决于线程的数量。</p>
<p>在主线程里面，它是有一个用于监听的套接字Listener，我们需要将它注册给主线程的MainReactor反应堆模型。在主线程的反应堆模型里面可以选择poll、epoll或select，它们就能帮助我们检测对应的监听文件描述符的读事件是否被触发。如果被触发了，就需要建立一个新连接，调用accept()函数得到一个新的用于通信的文件描述符connfd。然后对它进行封装，封装时为它指定一个读回调和写回调。又因为这是一个多反应堆模型，在得到了用于通信的套接字之后，就不要在主线程里面做通信了，把通信交给主线程的线程池，在主线程的线程池里面有多个子线程，每个子线程里面也有一个反应堆模型，该反应堆模型里面主要就是指定的IO多路转接poll、epoll或select。</p>
<p>然后我们只需要把用于通信的文件描述符的事件注册给到对应的子线程的反应堆模型(随机给的)，因为这个过程是做了注册的，所以当用于通信的套接字，它的读事件或写事件触发了，对应的回调函数就会知道。当真正的事件被触发之后，子线程里的反应堆模型就会调用响应的处理函数。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_11.png" style="zoom:67%;">

<h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-http请求"><a href="#4-1-http请求" class="headerlink" title="4.1 http请求"></a>4.1 http请求</h2><p>属于应用层协议，位于最上层，通过这个协议就可以对通信的数据进行封装。如果网络模型是B&#x2F;S结构，就必须使用<code>http</code>协议，<code>https</code>协议是在<code>http</code>协议的基础上做了加密。</p>
<p>在数据发送之前，使用协议对数据进行封装，接收到数据之后，按照协议格式解析接收到的数据。</p>
<p>Http协议分为两部分：</p>
<p>1.http请求</p>
<ul>
<li><p>客户端给服务器发送数据，叫<code>http</code>请求，有两种请求方式</p>
<ul>
<li><p>get请求</p>
</li>
<li><p>post请求</p>
</li>
</ul>
</li>
</ul>
<p>2.http响应</p>
<ul>
<li>服务器给客户端回复数据叫做<code>http</code>响应</li>
</ul>
<p><code>http</code>协议封装好数据之后是一个数据块，得到若干行数据，使用的换行符是<code>\r\n</code>。通过这个<code>\r\r</code>进行判断，就知道这行是否结束了。</p>
<blockquote>
<p>http请求消息分为四部分：</p>
<p>1.请求行</p>
<ul>
<li>不管get请求还是post请求，请求行是分为三部分</li>
</ul>
<p>2.请求头</p>
<p>3.空行</p>
<p>4.客户端向服务器提交的数据</p>
</blockquote>
<p>如果使用get方式提交数据，第四部分是空的。</p>
<p>get与post分析比较:</p>
<ol>
<li><p>从给服务器发送的数据的量上来分析</p>
<ul>
<li>get：主要是向服务器索取数据，提交的数据量比较少</li>
<li>post：上传文件一般都会使用post，可以提交的数据量是非常大的</li>
</ul>
</li>
<li><p>从上传的数据安全性来分析</p>
<ul>
<li>get：提交的数据不安全，提交的数据会显示到地址栏中，数据容易被泄露</li>
<li>post：提交的数据并不会显示到地址栏中，完全不可见的，因此更安全</li>
</ul>
</li>
</ol>
<h2 id="4-2-get请求"><a href="#4-2-get请求" class="headerlink" title="4.2 get请求"></a>4.2 get请求</h2><p>下面是浏览器对用户的请求数据进行了封装之后，得到的原始的http请求数据：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93:9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>第1行是请求行：分为3部分，</p>
<ul>
<li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p>
</li>
<li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p>
</li>
<li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p>
</li>
</ul>
<p>第2-8行是请求头：由若干个键值对组成：</p>
<ul>
<li><p>Host表示要连接的服务器是192.168.88.93，绑定的端口是9393；</p>
</li>
<li><p>Connection的keep-alive表示客户端想要与服务器一直保持连接</p>
</li>
<li><p>User-Agent表示浏览器的版本，指的是内核版本</p>
</li>
<li><p>Accept-Encoding设置压缩的方式使用的是gzip</p>
</li>
<li><p>Accept-Language设置默认的语言</p>
</li>
</ul>
<p>注意：如果我们使用的是get请求，并且get请求里面携带了一些动态数据，这些数据会出现在浏览器的地址栏里面，而该地址栏它的缓存是有上限的，因此如果携带的数据量很多，后面的数据就会丢失。</p>
<p>第9行是空行，空行完之后，就是通过这个请求协议给服务器提交的数据。如果是get请求，这部分内容是空的。因为如果通过get请求向服务器提交动态数据，这个动态数据也不会出现在请求协议的第4部分，而是出现在请求行的第2部分，即：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_12.png" style="zoom:67%;">

<h2 id="4-3-post请求"><a href="#4-3-post请求" class="headerlink" title="4.3 post请求"></a>4.3 post请求</h2><p>下面是post请求数据的格式</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93：9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>98</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">username</span>=subwen%<span class="number">40</span>qq.com&amp;phon=<span class="number">111111</span>&amp;email=sub%<span class="number">40</span>qq.com&amp;date=<span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>&amp;sex=male&amp;class=<span class="number">1</span>&amp;rule=<span class="literal">on</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们通过post向服务器提交数据，那么这个数据肯定是动态的，即请求的数据在服务器上是不存在的。如注册账号，向服务器提供用户名和密码等信息。</p>
<p>第1行是请求行：分为3部分，</p>
<ul>
<li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p>
</li>
<li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p>
</li>
<li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p>
</li>
</ul>
<p>第2-12行是请求头：由若干个键值对组成：</p>
<ul>
<li>Content-Length表示提交的内容长度</li>
<li>Content-Type表示客户端向服务器提交的数据块的格式(还有其它很多种格式)</li>
</ul>
<p>第13行是空行\r\n</p>
<p>第14行是客户端向服务器提交的数据块</p>
<h2 id="4-4-http响应"><a href="#4-4-http响应" class="headerlink" title="4.4 http响应"></a>4.4 http响应</h2><blockquote>
<p>服务器给客户端回复数据，称之为http响应，协议的格式分为四部分：：<br>1.状态行</p>
<p>2.消息报头&#x2F;响应头</p>
<p>3.空行</p>
<p>4.回复给客户端的数据块</p>
<ul>
<li>http响应消息也是一个数据块，若干行组成，换行是\r\n</li>
</ul>
</blockquote>
<p>响应消息(Response)</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Http/1.1 200 Ok</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>micro_httpd</span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Fri, 18 Jul 2014 14:34:26 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain; charset=iso-8859-1 (必选项)</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>32</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://www.lxx93.online</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>zh-CN</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 18 Jul 2014 08:36:36 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;hello world!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第1行是状态行，分为3部分：</p>
<ol>
<li><p>Http的版本</p>
</li>
<li><p>服务器对客户端请求的处理状态(状态码)，200就代表处理成功了</p>
</li>
<li><p>是对状态码的描述</p>
</li>
</ol>
<p>第2到9行是响应头，由一系列的键值对组成：</p>
<ul>
<li>Content-Type：表示的是http响应消息，响应的数据块的格式，text&#x2F;plain代表的是一个纯文本，charset表示使用的字符编码</li>
<li>Content-Length：表示服务器给客户端回复的数据块的大小(要准确，不确定的话就不写)</li>
</ul>
<p>第10行是空行</p>
<p>第11到16行是http响应给客户端的信息</p>
<p>http状态码类别：</p>
<p>状态码有三位数字组成，第一个数字定义了响应的类别，共分5种类别：</p>
<ul>
<li>1xx：指示信息–表示请求已经被接收，没有处理完，还正在处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作(网络地址的重新访问)</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<p>常见的状态码：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">状态描述</th>
<th align="center">文字描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="center">客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="center">请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">请求资源不存在，如：输入了错误的URL</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器发送不可预期的错误</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Server Unavailable</td>
<td align="center">服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody></table>
<p>整个处理流程：</p>
<p>首先调用threadPoolInit()函数，得到线程池的实例，得到该实例后，调用threadPoolRun()把线程池启动起来，即把线程池里面的子线程启动起来。然后就可以通过takeWorkerEventLoop()从线程池里面取出某一个子线程，得到子线程就能够得到对应的反应堆evLoop实例，将其返回给函数的调用者。调用者就可以通过这个evLoop实例往它的任务队列里面添加任务，当任务添加到evLoop对应的任务队列过后，就可以开始处理这个任务队列了，再根据这个任务队列节点的类型来处理这个dispatcher的检测集合。有3种情况，第1种是往检测集合里面添加新的节点；第2种是往检测集合里面删除节点；第3种情况就是修改检测集合里面某个文件描述符对应的事件。dispatcher这个检测集合处理完毕之后，对应的反应堆模型就开始进行循环了，它需要循环的调用底层的poll、epoll_wait或select来检测这个集合里面有没有激活的文件描述符。如果有激活的文件描述符，那么就通过这个文件描述符找到对应的channel，找到chennel后，然后再基于激活的事件，调用事件对应的回调函数，该回调函数调用完之后，对应的事件也就处理完毕了。</p>
<h1 id="5-多反应堆-线程池高并发服务器"><a href="#5-多反应堆-线程池高并发服务器" class="headerlink" title="5. 多反应堆+线程池高并发服务器"></a>5. 多反应堆+线程池高并发服务器</h1><p>该项目的结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/.online//图床数据\project\6_23.png"></p>
<p>在main()函数中，接收外部传来的两个参数，即<code>监听的端口</code>和<code>资源目录</code>，通过传入端口和指定线程池中子线程的个数，得到一个TcpServer服务器实例，并对其进行启动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out port path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);      <span class="comment">//将端口进行类型转换</span></span><br><span class="line">    <span class="built_in">chdir</span>(argv[<span class="number">2</span>]);                   <span class="comment">//切换服务器的工作路径，切换为资源文件</span></span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TcpServer</span>* server = <span class="built_in">tcpServerInit</span>(port, <span class="number">4</span>);     <span class="comment">//得到一个tcp服务器实例</span></span><br><span class="line">    <span class="built_in">tcpServerRun</span>(server);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1反应堆模型"><a href="#5-1反应堆模型" class="headerlink" title="5.1反应堆模型"></a>5.1反应堆模型</h2><h3 id="文件描述符封装类channel"><a href="#文件描述符封装类channel" class="headerlink" title="文件描述符封装类channel"></a>文件描述符封装类channel</h3><p>头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*handleFunc)</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FDEvent</span> &#123;</span><br><span class="line">	TimeOut = <span class="number">0x01</span>,                <span class="comment">//二进制：1</span></span><br><span class="line">	ReadEvent = <span class="number">0x02</span>,              <span class="comment">//二进制：10</span></span><br><span class="line">	WriteEvent = <span class="number">0x04</span>              <span class="comment">//二进制：100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">	<span class="comment">//文件描述符</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="comment">//事件</span></span><br><span class="line">	<span class="type">int</span> events;</span><br><span class="line">	<span class="comment">//回调函数</span></span><br><span class="line">	handleFunc readCallback;</span><br><span class="line">	handleFunc writeCallback;</span><br><span class="line">	handleFunc destroyCallback;         <span class="comment">//回收资源的回调函数(释放tcpConnection)</span></span><br><span class="line">	<span class="comment">//回调函数的参数</span></span><br><span class="line">	<span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个channnel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* <span class="built_in">channelInit</span>(<span class="type">int</span> fd, <span class="type">int</span> events, handleFunc readFunc, handleFunc writeFunc, handleFunc destroyFunc, <span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = (<span class="keyword">struct</span> Channel*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel));</span><br><span class="line">	channel-&gt;arg = arg;</span><br><span class="line">	channel-&gt;fd = fd;</span><br><span class="line">	channel-&gt;events = events;</span><br><span class="line">	channel-&gt;readCallback = readFunc;</span><br><span class="line">	channel-&gt;writeCallback = writeFunc;</span><br><span class="line">	channel-&gt;destroyCallback = destroyFunc;</span><br><span class="line">	<span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对channel封装的描述符是否添加监听写事件功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeEventEnable</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		channel-&gt;events |= WriteEvent;                <span class="comment">//往events里面追加写事件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		channel-&gt;events = channel-&gt;events &amp; ~WriteEvent;      <span class="comment">//将第3位标志位清0，这样就不做写事件检测了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回channel封装fd是否有监听写事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWriteEventEnable</span><span class="params">(<span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> channel-&gt;events &amp; WriteEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装channel的容器类ChannelMap"><a href="#封装channel的容器类ChannelMap" class="headerlink" title="封装channel的容器类ChannelMap"></a>封装channel的容器类ChannelMap</h3><p>头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该结构体主要就是想通过list下标，即fd来找到对应的channel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span> &#123;</span><br><span class="line">	<span class="type">int</span> size;         <span class="comment">//记录指针指向的数组的元素总个数</span></span><br><span class="line">	<span class="comment">//list是一个指针数组(数组里面全部是指针)，数组的下标对应的是文件描述符的值，如果文件描述符为9，那么其数组下标就为9，一一对应的</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>** list; <span class="comment">//相当于是一个数组list,里面存的是struct Channel*类型的指针，即struct Channel* list[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化channelmap容器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* <span class="built_in">channelMapInit</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* map = (<span class="keyword">struct</span> ChannelMap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ChannelMap));</span><br><span class="line">	map-&gt;size = size;</span><br><span class="line">	map-&gt;list = (<span class="keyword">struct</span> Channel**)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel*));</span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空channelmap容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChannelMapClear</span><span class="params">(<span class="keyword">struct</span> ChannelMap* map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="literal">NULL</span>) &#123;                         <span class="comment">//判断map如果不为空，就清理map数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; map-&gt;size; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map-&gt;list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="built_in">free</span>(map-&gt;list[i]);            <span class="comment">//数组里面的元素指向的内存不为空就释放掉</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(map-&gt;list);                       <span class="comment">//数组对应的内存地址也要释放掉</span></span><br><span class="line">		map-&gt;list = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	map-&gt;size = <span class="number">0</span>;                    <span class="comment">//所有的释放掉后，map里面的大小就变为了0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数：fd-channel数组；需要插入的fd；每个元素占的大小</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">makeMapRoom</span><span class="params">(<span class="keyword">struct</span> ChannelMap* map, <span class="type">int</span> newSize, <span class="type">int</span> unitSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (map-&gt;size &lt; newSize) &#123;                <span class="comment">//如果map中的size比newsize小，才做扩容操作</span></span><br><span class="line">		<span class="type">int</span> curSize = map-&gt;size;              <span class="comment">//取出当前map的size容量</span></span><br><span class="line">		<span class="comment">//容量每次扩大原来的1倍</span></span><br><span class="line">		<span class="keyword">while</span> (curSize &lt; newSize) &#123;             <span class="comment">//当cursize扩容到比newSize大时，就退出循环</span></span><br><span class="line">			curSize *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//扩容realloc -----&gt;参1是需要扩容的起始地址；参2是要扩容的大小</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Channel</span> ** temp = <span class="built_in">realloc</span>(map-&gt;list, curSize * unitSize);    <span class="comment">//返回的是扩容成功之后，对应的起始地址</span></span><br><span class="line">		<span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;                       <span class="comment">//如果为空，说明没有扩容成功，就返回false</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		map-&gt;list = temp;                       <span class="comment">//更新将list指向起始地址</span></span><br><span class="line">		<span class="comment">//将参1所指的内存前参3的字节设置为参2(参1指向的是原来空间个数的大小所对应的地址，并将其后面的地址空间初始化，即扩容的部分)</span></span><br><span class="line">		<span class="built_in">memset</span>(&amp;map-&gt;list[map-&gt;size], <span class="number">0</span>, (curSize - map-&gt;size) * unitSize);       <span class="comment">//将扩展的地址进行初始化</span></span><br><span class="line">		map-&gt;size = curSize;                    <span class="comment">//更新将size变为扩容的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO复用技术类dispatcher"><a href="#IO复用技术类dispatcher" class="headerlink" title="IO复用技术类dispatcher"></a>IO复用技术类dispatcher</h3><p>结构体成员都是函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>;    <span class="comment">//不管该结构体现在是否被定义出来，先告诉编译器有这种类型，下面就可以用这种类型去定义变量(Dispatcher和eventloop互包含了)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">	<span class="comment">// init --- 初始化epoll、poll或者select需要的数据块</span></span><br><span class="line">	<span class="type">void</span>* (*init)();                    <span class="comment">//返回值为什么是泛型void*，是为了兼容epoll、poll和select对应的不同的数据块</span></span><br><span class="line">	<span class="comment">// 添加</span></span><br><span class="line">	<span class="built_in">int</span> (*add)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	<span class="built_in">int</span> (*remove)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line">	<span class="comment">// 修改</span></span><br><span class="line">	<span class="built_in">int</span> (*modify)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line">	<span class="comment">// 事件检测</span></span><br><span class="line">	<span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout);</span><br><span class="line">	<span class="comment">// 清除数据(关闭fd或者释放内存)</span></span><br><span class="line">	<span class="built_in">int</span> (*clear)(<span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>epoll实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 520</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span> &#123;</span><br><span class="line">	<span class="type">int</span> epfd;                        <span class="comment">//epoll树根节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span>* events;      <span class="comment">//epoll_wait在工作时需要的传出参数，是一个结构体数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">epollInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体Dispatcher的变量EpollDispatcher</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> EpollDispatcher = &#123;     <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">	epollInit,</span><br><span class="line">	epollAdd,</span><br><span class="line">	epollRemove,</span><br><span class="line">	epollModify,</span><br><span class="line">	epollDispatch,</span><br><span class="line">	epollClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">epollInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EpollData));     <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line">	data-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (data-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开辟空间，参1是元素的个数；参2是每个元素占多大的内存</span></span><br><span class="line">	data-&gt;events = (<span class="keyword">struct</span> epoll_event*)<span class="built_in">calloc</span>(Max, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event));    <span class="comment">//calloc相较于malloc,会将开辟的空间初始化为0</span></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//epfd和events都存储在EventLoop里面的Dispatcherdata里面</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">	ev.data.fd = channel-&gt;fd;                <span class="comment">//要添加的文件描述符</span></span><br><span class="line">	<span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;          <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">		events |= EPOLLIN;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line">		events |= EPOLLOUT;                    <span class="comment">//保存写事件</span></span><br><span class="line">	&#125;</span><br><span class="line">	ev.events = events;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(data-&gt;epfd, op, channel-&gt;fd, &amp;ev);      <span class="comment">//参数：树的根节点；添加操作；对应的文件描述符；epoll_event结构体</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_ADD);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_DEL);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl delete&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过channel释放对应的TcpConnection资源</span></span><br><span class="line">	channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);       <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_MOD);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl modify&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">epoll_wait</span>(data-&gt;epfd, data-&gt;events, Max, timeout * <span class="number">1000</span>);    <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="type">int</span> events = data-&gt;events[i].events;</span><br><span class="line">		<span class="type">int</span> fd = data-&gt;events[i].data.fd;</span><br><span class="line">		<span class="comment">//对端断开连接后，就会产生EPOLLERR事件；对端断开连接后，还在发数据给对端就会产生EPOLLHUP事件</span></span><br><span class="line">		<span class="keyword">if</span> (events &amp; EPOLLERR || events &amp; EPOLLHUP) &#123;             <span class="comment">//如果对端断开连接</span></span><br><span class="line">			<span class="comment">//对方断开了连接，删除fd</span></span><br><span class="line">			<span class="comment">//epollRemove(Channel, evLoop);</span></span><br><span class="line">			<span class="keyword">continue</span>;             <span class="comment">//退出本轮循环</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (events &amp; EPOLLIN) &#123;                    <span class="comment">//如果读事件触发</span></span><br><span class="line">			<span class="comment">//epoll、poll、select只要触发了读写事件，调用的都是该函数</span></span><br><span class="line">			<span class="built_in">eventActivate</span>(evLoop, fd, ReadEvent);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (events &amp; EPOLLOUT) &#123;                   <span class="comment">//如果写事件触发</span></span><br><span class="line">			<span class="built_in">eventActivate</span>(evLoop, fd, WriteEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="built_in">free</span>(data-&gt;events);             <span class="comment">//释放</span></span><br><span class="line">	<span class="built_in">close</span>(data-&gt;epfd);              <span class="comment">//关闭树根节点</span></span><br><span class="line">	<span class="built_in">free</span>(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span> &#123;</span><br><span class="line">	fd_set readSet;</span><br><span class="line">	fd_set writeSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">selectInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">clearFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> SelectDispatcher = &#123;     <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">	selectInit,</span><br><span class="line">	selectAdd,</span><br><span class="line">	selectRemove,</span><br><span class="line">	selectModify,</span><br><span class="line">	selectDispatch,</span><br><span class="line">	selectClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">selectInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SelectData));     <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;data-&gt;readSet);               <span class="comment">//读集合清空</span></span><br><span class="line">	<span class="built_in">FD_ZERO</span>(&amp;data-&gt;writeSet);              <span class="comment">//写集合清空</span></span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;</span><br><span class="line">		<span class="built_in">FD_SET</span>(channel-&gt;fd, &amp;data-&gt;readSet);            <span class="comment">//将fd添加到读事件中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line">		<span class="built_in">FD_SET</span>(channel-&gt;fd, &amp;data-&gt;writeSet);           <span class="comment">//将fd添加到写事件中</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">clearFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;</span><br><span class="line">		<span class="built_in">FD_CLR</span>(channel-&gt;fd, &amp;data-&gt;readSet);     <span class="comment">//从读集合中移除fd，在读集合中对应的fd标志位被设为了0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line">		<span class="built_in">FD_CLR</span>(channel-&gt;fd, &amp;data-&gt;writeSet);           <span class="comment">//写集合中移除fd</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="keyword">if</span> (channel-&gt;fd &gt;= Max) &#123;              <span class="comment">//如果channel的fd是大于最大值的，就没有必须执行下面了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">setFdSet</span>(channel, data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="built_in">clearFdSet</span>(channel, data);</span><br><span class="line">	<span class="comment">//通过channel释放对应的TcpConnection资源</span></span><br><span class="line">	channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);       <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="comment">//睡先调用都可以</span></span><br><span class="line">	<span class="built_in">setFdSet</span>(channel, data);</span><br><span class="line">	<span class="built_in">clearFdSet</span>(channel, data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">timeval</span> val;</span><br><span class="line">	val.tv_sec = timeout;</span><br><span class="line">	val.tv_usec = <span class="number">0</span>;</span><br><span class="line">	fd_set rdtmp = data-&gt;readSet;</span><br><span class="line">	fd_set wrtmp = data-&gt;writeSet;</span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">select</span>(Max, &amp;rdtmp, &amp;wrtmp, <span class="literal">NULL</span>, &amp;val);    <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//变量读集合和写集合，看是哪个集合里面的文件描述符被激活了，如果被激活，在集合中对应标志位为1，否则为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;rdtmp)) &#123;           <span class="comment">//如果i在rdtmp里面，说明对应的文件描述符i的读数据就绪</span></span><br><span class="line">			<span class="built_in">eventActivate</span>(evLoop, i, ReadEvent);       <span class="comment">//调用对应的回调函数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;wrtmp)) &#123;            <span class="comment">//如果i在rdtmp里面，说明对应的文件描述符i的写数据就绪</span></span><br><span class="line">			<span class="built_in">eventActivate</span>(evLoop, i, WriteEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line">	<span class="built_in">free</span>(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poll实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 1024</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PollData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[Max];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">pollInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>; <span class="comment">// 单位: s</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> PollDispatcher = &#123;          <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">    pollInit,</span><br><span class="line">    pollAdd,</span><br><span class="line">    pollRemove,</span><br><span class="line">    pollModify,</span><br><span class="line">    pollDispatch,</span><br><span class="line">    pollClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">pollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> PollData));    <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line">    data-&gt;maxfd = <span class="number">0</span>;                               <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;fds[i].fd = <span class="number">-1</span>;                      <span class="comment">//指定为-1，为无效文件描述符</span></span><br><span class="line">        data-&gt;fds[i].events = <span class="number">0</span>;                    <span class="comment">//事件都指定为0</span></span><br><span class="line">        data-&gt;fds[i].revents = <span class="number">0</span>;                  <span class="comment">//事件都指定为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent)                  <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLOUT;                           <span class="comment">//保存写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找空位，将events写进去</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == <span class="number">-1</span>)                 <span class="comment">//找到空位了</span></span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = events;</span><br><span class="line">            data-&gt;fds[i].fd = channel-&gt;fd;</span><br><span class="line">            data-&gt;maxfd = i &gt; data-&gt;maxfd ? i : data-&gt;maxfd;              <span class="comment">//maxfd记录的是最大文件描述符</span></span><br><span class="line">            <span class="keyword">break</span>;                                 <span class="comment">//找到空位存储后，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                                <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == channel-&gt;fd)</span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = <span class="number">0</span>;</span><br><span class="line">            data-&gt;fds[i].revents = <span class="number">0</span>;</span><br><span class="line">            data-&gt;fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;                             <span class="comment">//找到要删除的fd后，进行重置(从检测集合中删除)，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 channel 释放对应的 TcpConnection 资源(给channel的回收资源回调函数指向销毁TcpConnection的函数即可)</span></span><br><span class="line">    channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);   <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                               <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//channel里面有要更改为什么样的事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent)             <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLOUT;                      <span class="comment">//保存写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == channel-&gt;fd)</span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = events;          <span class="comment">//得到更改好的events</span></span><br><span class="line">            <span class="keyword">break</span>;                                 <span class="comment">//找到空位存储后，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                             <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">poll</span>(data-&gt;fds, data-&gt;maxfd + <span class="number">1</span>, timeout * <span class="number">1000</span>);         <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= data-&gt;maxfd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == <span class="number">-1</span>)                          <span class="comment">//如果为-1，说明是没有用的一块空间,无效元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;                                       <span class="comment">//退出本轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是有效，判断它的revents是读事件还是写事件</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].revents &amp; POLLIN)                    <span class="comment">//如果读事件触发，调用对应的读回调</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过fd找到对应的channel</span></span><br><span class="line">            <span class="built_in">eventActivate</span>(evLoop, data-&gt;fds[i].fd, ReadEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].revents &amp; POLLOUT)                   <span class="comment">//如果写事件触发，调用对应的写回调</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">eventActivate</span>(evLoop, data-&gt;fds[i].fd, WriteEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件循环类EventLoop"><a href="#事件循环类EventLoop" class="headerlink" title="事件循环类EventLoop"></a>事件循环类EventLoop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> EpollDispatcher;           <span class="comment">//如果在某个文件中要使用其它文件里定义的全局变量时，需要添加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> PollDispatcher;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> SelectDispatcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理该节点中的channel的方式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Elemtype</span> &#123;ADD, DELETE, MODIFY&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务队列的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span> &#123;</span><br><span class="line">	<span class="type">int</span> type;                    <span class="comment">//如何处理该节点中的channel</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChanenlElenmet</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span>;  <span class="comment">//不管该结构体现在是否被定义出来，先告诉编译器有这种类型，下面就可以用这种类型去定义变量(Dispatcher和eventloop互包含了)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line">	<span class="type">bool</span> isQuit;                     <span class="comment">//EventLoop是否在工作</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Dispatcher</span>* dispatcher;        <span class="comment">//使用的io多路转接技术结构体，指向的是三个中其中一个</span></span><br><span class="line">	<span class="type">void</span>* dispatcherData;            <span class="comment">//dispatcher指向哪种io技术，这就指向对应的数据块</span></span><br><span class="line">	<span class="comment">// 任务队列</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* head;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* tail;</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap;</span><br><span class="line">	<span class="comment">//线程id，name，mutex</span></span><br><span class="line">	<span class="type">pthread_t</span> threadID;</span><br><span class="line">	<span class="type">char</span> threadName[<span class="number">32</span>];</span><br><span class="line">	<span class="type">pthread_mutex_t</span> mutex;           <span class="comment">//互斥锁，保护任务队列的</span></span><br><span class="line">	<span class="type">int</span> socketPair[<span class="number">2</span>];               <span class="comment">//存储本地通信的fd，通过socketpair初始化(用于激活阻塞的io复用)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInit</span>();                             <span class="comment">//如果eventloop是主线程，就使用这个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInitEx</span>(<span class="type">const</span> <span class="type">char</span>* threadName);     <span class="comment">//如果创建的eventloop属于子线程，就使用这个</span></span><br><span class="line"><span class="comment">//启动反应堆模型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRun</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;           <span class="comment">//参数为启动的实例</span></span><br><span class="line"><span class="comment">//处理被激活的文件fd(在evloop模型里面通过fd找到了对应的channel，然后就可以通过传进来的event来判断执行读回调或写回调)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventActivate</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> fd, <span class="type">int</span> event)</span></span>;   <span class="comment">//参数：evloop；要激活的fd；对应的事件</span></span><br><span class="line"><span class="comment">//添加任务到任务队列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAddTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel, <span class="type">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">//子线程处理任务队列中的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopProcessTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="comment">//处理dispatcher中的节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAdd</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRemove</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopModify</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="comment">//释放channel(断开连接，不需要用fd时调用)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">destroyChannel</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInit</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">eventLoopInitEx</span>(<span class="literal">NULL</span>);                   <span class="comment">//使用子线程的初始化函数即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据(这是主线程用来唤醒阻塞子线程的调用函数，在主线程执行eventLoopAddTask时会调用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskWakeup</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>;</span><br><span class="line">	<span class="built_in">write</span>(evLoop-&gt;socketPair[<span class="number">0</span>], msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读数据(主线程用来唤醒的读回调函数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readLocalMessage</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evloop = (<span class="keyword">struct</span> EventLoop*)arg;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="built_in">read</span>(evloop-&gt;socketPair[<span class="number">1</span>], buf, <span class="built_in">sizeof</span>(buf));       <span class="comment">//主要目的不是读数据处理，而是触发一次读回调，解除阻塞</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInitEx</span>(<span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = (<span class="keyword">struct</span> EventLoop*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EventLoop));          <span class="comment">//先创建出一个反应堆结构体</span></span><br><span class="line">	evLoop-&gt;isQuit = <span class="literal">false</span>;                    <span class="comment">//刚开始还没有运行，赋值为false</span></span><br><span class="line">	evLoop-&gt;threadID = <span class="built_in">pthread_self</span>();         <span class="comment">//哪个线程调用该函数，pthread_self()就会是该线程的id</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;evLoop-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(evLoop-&gt;threadName, threadName == <span class="literal">NULL</span> ? <span class="string">&quot;MainThread&quot;</span> : threadName);     <span class="comment">//如果是主线程，就固定名字，是子线程就设置为指定的名字</span></span><br><span class="line">	evLoop-&gt;dispatcher = &amp;EpollDispatcher;                        <span class="comment">//使用epoll模型</span></span><br><span class="line">	<span class="comment">//evLoop-&gt;dispatcher = &amp;PollDispatcher;                        //使用poll模型</span></span><br><span class="line">	<span class="comment">//evLoop-&gt;dispatcher = &amp;SelectDispatcher;                        //使用select模型</span></span><br><span class="line">	evLoop-&gt;dispatcherData = evLoop-&gt;dispatcher-&gt;<span class="built_in">init</span>();  <span class="comment">//通过函数指针init得到epoll模型需要的数据(根节点、检测集合)</span></span><br><span class="line">	<span class="comment">//链表</span></span><br><span class="line">	evLoop-&gt;head = evLoop-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	evLoop-&gt;channelMap = <span class="built_in">channelMapInit</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决子线程在epoll、poll或select中阻塞的情况</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, evLoop-&gt;socketPair);  <span class="comment">//调用成功后，evloop结构体里的socketPair数组里面就有2个可用的文件描述符，可进行本地的网络通信</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//指定规则：evLoop-&gt;socketPair[0]发送数据；evLoop-&gt;socketPair[1]接收数据</span></span><br><span class="line">	<span class="comment">// 1.当子线程发送阻塞时，通过socketPair[0]发送数据，socketPair[1]就会接收数据，读事件被激活</span></span><br><span class="line">	<span class="comment">// 2.底层epoll、poll或select阻塞时，它们检测对应的读集合里面没有处于激活状态的，然后在该读激活里面添加了socketPair[1]，当从socketPair[0]</span></span><br><span class="line">	<span class="comment">//   发送数据时，它们就可以检测到socketPair[1]被激活了，然后它们就解除阻塞了</span></span><br><span class="line">	<span class="comment">//初始化一个channel，当socketPair[0]发送数据后，socketPair[1]就会被激活，然后执行读回调readLocalMessage</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = <span class="built_in">channelInit</span>(evLoop-&gt;socketPair[<span class="number">1</span>], ReadEvent,</span><br><span class="line">		readLocalMessage, <span class="literal">NULL</span>, <span class="literal">NULL</span>, evLoop);  <span class="comment">//参数：通信描述符；事件；读回调；写回调；回调函数的参数</span></span><br><span class="line">	<span class="comment">//channel添加到任务队列</span></span><br><span class="line">	<span class="built_in">eventLoopAddTask</span>(evLoop, channel, ADD);           <span class="comment">//ADD添加到检测集合里面(但还没有开始进行监听)</span></span><br><span class="line">	<span class="keyword">return</span> evLoop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRun</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(evLoop != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">//取出事件分发和检测模型</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Dispatcher</span>* dispatcher = evLoop-&gt;dispatcher;</span><br><span class="line">	<span class="comment">//比较线程id是否正常</span></span><br><span class="line">	<span class="keyword">if</span> (evLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;                    <span class="comment">//异常情况就退出返回-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//循环进行事件处理</span></span><br><span class="line">	<span class="keyword">while</span> (!evLoop-&gt;isQuit) &#123;</span><br><span class="line">		<span class="comment">////超时时长2s,如果evLoop-&gt;dispatcher分别可以指向三张种io多路的其中一个，指向的不同，该行执行的也不同</span></span><br><span class="line">		dispatcher-&gt;<span class="built_in">dispatch</span>(evLoop, <span class="number">2</span>);    <span class="comment">//如果发生阻塞，就是阻塞在该行程序，里面执行的是就绪的读和写回调函数</span></span><br><span class="line">		<span class="comment">//dispatch函数里面只是监听fd，对有事件的fd调用对应的执行函数(所以每次执行完一系列fd的回调函数后，就查看处理一下任务队列eventLoopProcessTask)</span></span><br><span class="line">		<span class="built_in">eventLoopProcessTask</span>(evLoop);       <span class="comment">//子线程处理任务队列中的任务(dispatch没有对fd中的读和写事件进行修改的模块)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventActivate</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> fd, <span class="type">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span> || evLoop == <span class="literal">NULL</span>) &#123;             <span class="comment">//如果出现异常情况，直接退出</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//取出channel</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = evLoop-&gt;channelMap-&gt;list[fd];</span><br><span class="line">	<span class="built_in">assert</span>(channel-&gt;fd == fd);             <span class="comment">//理论上是相等的，因为list指向的数组下标与fd相等，且一一对应</span></span><br><span class="line">	<span class="comment">//初始化channel的时候，可能没有指定回调函数，所以当为空的时候，也不执行回调函数</span></span><br><span class="line">	<span class="keyword">if</span> (event &amp; ReadEvent &amp;&amp; channel-&gt;readCallback) &#123;</span><br><span class="line">		channel-&gt;<span class="built_in">readCallback</span>(channel-&gt;arg);            <span class="comment">//如果是读事件，就调用对应的读回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (event &amp; WriteEvent  &amp;&amp; channel-&gt;writeCallback) &#123;</span><br><span class="line">		channel-&gt;<span class="built_in">writeCallback</span>(channel-&gt;arg);           <span class="comment">//如果是写事件，就调用对应的写回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务到任务队列(主线程和子线程都可能执行该函数)</span></span><br><span class="line"><span class="comment">//2条路径：(1)子线程往任务队列里面添加任务，然后自己处理该任务；(2)主线程给任务队列添加入任务了，因为它是不能处理的，而它又不清楚子线程目前</span></span><br><span class="line"><span class="comment">// 是在工作还在阻塞，就默认是阻塞，因此主线程就调用一个唤醒函数，这样就能保证子线程是在工作了，即子线程都从run()函数的dispatch函数中解除阻塞</span></span><br><span class="line"><span class="comment">// 解除阻塞了，就可以执行任务队列中的任务了。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAddTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//添加链表节点的时候，有可能是主线程添加，也有可能是子线程添加，所以得加互斥锁</span></span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;evLoop-&gt;mutex);               <span class="comment">//加锁，保护共享资源</span></span><br><span class="line">	<span class="comment">//创建新节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* node = (<span class="keyword">struct</span> ChannelElement*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ChannelElement));</span><br><span class="line">	<span class="comment">//对节点的成员做初始化</span></span><br><span class="line">	node-&gt;channel = channel;</span><br><span class="line">	node-&gt;type = type;</span><br><span class="line">	node-&gt;next = <span class="literal">NULL</span>;              <span class="comment">//先让其指向空</span></span><br><span class="line">	<span class="comment">//插入链表</span></span><br><span class="line">	<span class="keyword">if</span> (evLoop-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		evLoop-&gt;head = evLoop-&gt;tail = node;         <span class="comment">//如果链表还为空，就将头指针和尾指针都指向node</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;            <span class="comment">//不为空，就后插法</span></span><br><span class="line">		evLoop-&gt;tail-&gt;next = node;              <span class="comment">//添加</span></span><br><span class="line">		evLoop-&gt;tail = node;                    <span class="comment">//后移</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;evLoop-&gt;mutex);             <span class="comment">//解锁，防止死锁</span></span><br><span class="line">	<span class="comment">//处理节点(主线程只负责监听有无客户端连接，子线程负责通信任务)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	细节：</span></span><br><span class="line"><span class="comment">		1.对于链表节点的添加：可能是当前线程也可能是其它线程(主线程)---&gt;前提条件是当前的eventloop反应堆属于子线程</span></span><br><span class="line"><span class="comment">			(1)修改fd事件，当前子线程发起，当前子线程处理</span></span><br><span class="line"><span class="comment">			(2)添加新的fd，添加任务节点的操作是由主线程发起的</span></span><br><span class="line"><span class="comment">		2.不能让主线程处理任务队列，需要由当前的子线程取消处理(因为每个线程都有一个eventloop反应堆，底层都有一个dispatcher,每个dispatcher都</span></span><br><span class="line"><span class="comment">		有epoll、poll或select，给它们提供服务的就是任务队列，都是一一对应的关系，对应错了，程序也就错了)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (evLoop-&gt;threadID == <span class="built_in">pthread_self</span>()) &#123;       <span class="comment">//如果evloop是主线程发反应堆模型，而目前执行该函数的线程也是主线程，就可以直接执行下面</span></span><br><span class="line">		<span class="comment">//当作为子线程，直接处理任务(遍历任务链表执行)</span></span><br><span class="line">		<span class="built_in">eventLoopProcessTask</span>(evLoop);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//当前为主线程 ---&gt;告诉子线程处理任务队列的任务</span></span><br><span class="line">		<span class="comment">// 情况：主线程监听到客户端连接后，执行它的读回调函数(取子反应堆与cfd，将channel添加到evloop的任务队列里)</span></span><br><span class="line">		<span class="comment">//子线程此时在：1.子线程在工作 </span></span><br><span class="line">		<span class="comment">// 2.子线程被阻塞了：select,poll,epoll(子线程被阻塞(没有激活事件)，如果主线程与客户端又来连接，主线程将任务添加到任务队列，子线程因为阻塞不会去执行)</span></span><br><span class="line">		<span class="built_in">taskWakeup</span>(evLoop);                  <span class="comment">//通过socketPair[0]向socketPair[1]写数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理任务队列中的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopProcessTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;evLoop-&gt;mutex);           <span class="comment">//加锁</span></span><br><span class="line">	<span class="comment">//取出头节点</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* head = evLoop-&gt;head;</span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = head-&gt;channel;</span><br><span class="line">		<span class="keyword">if</span> (head-&gt;type == ADD) &#123;</span><br><span class="line">			<span class="comment">//添加</span></span><br><span class="line">			<span class="built_in">eventLoopAdd</span>(evLoop, channel);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;type == DELETE) &#123;</span><br><span class="line">			<span class="comment">//删除(将channel里面的fd从evloop里面dispatch检测集合删除)</span></span><br><span class="line">			<span class="built_in">eventLoopRemove</span>(evLoop, channel);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;type == MODIFY) &#123;</span><br><span class="line">			<span class="comment">//修改</span></span><br><span class="line">			<span class="built_in">eventLoopModify</span>(evLoop, channel);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* tmp = head;</span><br><span class="line">		head = head-&gt;next;                      <span class="comment">//后移</span></span><br><span class="line">		<span class="built_in">free</span>(tmp);                              <span class="comment">//释放刚刚处理的任务节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	evLoop-&gt;head = evLoop-&gt;tail = <span class="literal">NULL</span>;         <span class="comment">//退出循环后，说明任务队列里面的任务已经处理完了，将头指针和尾指针都指向空</span></span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;evLoop-&gt;mutex);           <span class="comment">//解锁</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将channel添加到map集合中和dispatcher的检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAdd</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符(要添加的)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line">	<span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= channelMap-&gt;size) &#123;                 <span class="comment">//说明channelMap容量不够，没有位置来存储与channel(每个channel有一个fd)的关系</span></span><br><span class="line">		<span class="comment">//没有足够空间存储键值对 fd - channel ==》扩容</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">makeMapRoom</span>(channelMap, fd, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel*))) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;              <span class="comment">//如果没有成功就退出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找到fd对应的数组元素位置，并存储</span></span><br><span class="line">	<span class="keyword">if</span> (channelMap-&gt;list[fd] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		channelMap-&gt;list[fd] = channel;              <span class="comment">//存储fd与channel对应关系</span></span><br><span class="line">		<span class="comment">//把channel的文件描述符fd添加到对应的文件描述符检测集合中</span></span><br><span class="line">		evLoop-&gt;dispatcher-&gt;<span class="built_in">add</span>(channel, evLoop);    <span class="comment">//选择的dispatcher模型(epoll、poll、select)不一样，该指针指向的函数add处理动作也就不一样</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRemove</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符(要删除的)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line">	<span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= channelMap-&gt;size) &#123;                 <span class="comment">//说明要删除的文件描述符不在channelMap容器里存储，即要删除的描述符不在检测的集合里面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//不在就直接退出即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ret = evLoop-&gt;dispatcher-&gt;<span class="built_in">remove</span>(channel, evLoop);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopModify</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line">	<span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=channelMap-&gt;size || channelMap-&gt;list[fd] == <span class="literal">NULL</span>) &#123;         <span class="comment">//说明要修改的文件描述符不在channelMap容器里存储(相比视频多了一个判断，更严谨)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//不在就直接退出即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ret = evLoop-&gt;dispatcher-&gt;<span class="built_in">modify</span>(channel, evLoop);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">destroyChannel</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//删除 channel 和 fd 的对应关系</span></span><br><span class="line">	evLoop-&gt;channelMap-&gt;list[channel-&gt;fd] = <span class="literal">NULL</span>;    <span class="comment">//将该反应堆里面channelMap对应fd的位置置为null</span></span><br><span class="line">	<span class="comment">//关闭fd</span></span><br><span class="line">	<span class="built_in">close</span>(channel-&gt;fd);</span><br><span class="line">	<span class="comment">//释放</span></span><br><span class="line">	<span class="built_in">free</span>(channel);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-多线程"><a href="#5-2-多线程" class="headerlink" title="5.2 多线程"></a>5.2 多线程</h2><h3 id="线程池类ThreadPool"><a href="#线程池类ThreadPool" class="headerlink" title="线程池类ThreadPool"></a>线程池类ThreadPool</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">	<span class="comment">//主线程的反应堆模型</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* mainLoop;         <span class="comment">//主要做备份用，只负责与客户端建立连接(只有在线程池没有子线程的情况下，它才负责出来与客户端的连接通信)</span></span><br><span class="line">	<span class="type">bool</span> isStart;                       <span class="comment">//当前线程池是否启动</span></span><br><span class="line">	<span class="type">int</span> threadNum;                      <span class="comment">//线程池中子线程的数量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">WorkerThread</span>* workerThreads;      <span class="comment">//指向子线程数组的指针</span></span><br><span class="line">	<span class="type">int</span> index;                               <span class="comment">//编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* <span class="built_in">threadPoolInit</span>(<span class="keyword">struct</span> EventLoop* mainLoop, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* pool = (<span class="keyword">struct</span> ThreadPool*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ThreadPool));<span class="comment">//给线程池申请一块堆内存</span></span><br><span class="line">	pool-&gt;index = <span class="number">0</span>;                     <span class="comment">//下标先置为0</span></span><br><span class="line">	pool-&gt;isStart = <span class="literal">false</span>;               <span class="comment">//线程池默认情况下没有启动的，置为false</span></span><br><span class="line">	pool-&gt;mainLoop = mainLoop;           <span class="comment">//主线程的反应堆模型(当线程池没有子线程时，也就没有子反应堆，可以使用主反应堆模型)</span></span><br><span class="line">	pool-&gt;threadNum = count;             <span class="comment">//线程池中子线程的个数</span></span><br><span class="line">	pool-&gt;workerThreads = (<span class="keyword">struct</span> WorkerThread*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> WorkerThread) * count);    <span class="comment">//存储子线程实例的数组</span></span><br><span class="line">	<span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPoolRun</span><span class="params">(<span class="keyword">struct</span> ThreadPool* pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(pool &amp;&amp; !pool-&gt;isStart);        <span class="comment">//如果pool还为空(说明还没有创建线程池) 或线程池已经启动了都是有问题的</span></span><br><span class="line">	<span class="comment">//线程池里面存的是主线程反应堆，如果里面的线程号与当前的线程不一样，说明调用该函数的不是主线程，就退出</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;mainLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;            <span class="comment">//如果现在要启动线程池的不是主线程，就退出</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//以上都没有出错，就开始启动线程池</span></span><br><span class="line">	pool-&gt;isStart = <span class="literal">true</span>;                               <span class="comment">//是否启动置为true</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;threadNum) &#123;                              <span class="comment">//如果线程池里面的子线程大于0的。就初始化它们，再启动   </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;threadNum; i++) &#123;</span><br><span class="line">			<span class="built_in">workerThreadInit</span>(&amp;pool-&gt;workerThreads[i], i);       <span class="comment">//初始化。参数：子线程的地址，第i个</span></span><br><span class="line">			<span class="comment">//启动子线程(创建子反应堆--&gt;启动子反应堆--&gt;evloop的dispatcher开始一直检测)</span></span><br><span class="line">			<span class="built_in">workerThreadRun</span>(&amp;pool-&gt;workerThreads[i]);	        <span class="comment">//启动，参数：子线程实例化后的地址</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">takeWorkerEventLoop</span>(<span class="keyword">struct</span> ThreadPool* pool)    <span class="comment">//该函数的调用由主线程来完成</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">assert</span>(pool-&gt;isStart);                 <span class="comment">//此时如果线程池pool还没有运行，说明是错误的</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;mainLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;            <span class="comment">//如果调用该函数的线程的不是主线程，是错误的，退出</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//从线程池中找到一个子线程，然后取出里边的反应堆实例</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = pool-&gt;mainLoop;                  <span class="comment">//赋值主线程反应堆实例的地址</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;threadNum &gt; <span class="number">0</span>) &#123;                                  <span class="comment">//判断线程池里面的线程数量是否大于0</span></span><br><span class="line">		evLoop = pool-&gt;workerThreads[pool-&gt;index].evLoop;       <span class="comment">//取出子线程的反应堆模型</span></span><br><span class="line">		pool-&gt;index = ++pool-&gt;index % pool-&gt;threadNum;          <span class="comment">//使得每个子线程的反应堆模型都可以获取到</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> evLoop;         <span class="comment">//如果线程池里面的子线程&lt;=0，那么返回的就是主线程的反应堆模型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工作线程类WorkerThread"><a href="#工作线程类WorkerThread" class="headerlink" title="工作线程类WorkerThread"></a>工作线程类WorkerThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义子线程对应的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorkerThread</span> &#123;</span><br><span class="line">	<span class="type">pthread_t</span> threadID;              <span class="comment">//ID</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">24</span>];                   <span class="comment">//线程名</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span> mutex;           <span class="comment">//互斥锁</span></span><br><span class="line">	<span class="type">pthread_cond_t</span> cond;             <span class="comment">//条件变量</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop;        <span class="comment">//反应堆模型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">workerThreadInit</span><span class="params">(<span class="keyword">struct</span> WorkerThread* thread, <span class="type">int</span> index)</span>    <span class="comment">//参1是在外部创建好的一块结构体空间，然后传入的是指向该结构体的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	thread-&gt;evLoop = <span class="literal">NULL</span>;                           <span class="comment">//默认情况下，子线程的反应堆模型是没有的，所以指为空</span></span><br><span class="line">	thread-&gt;threadID = <span class="number">0</span>;                            <span class="comment">//线程还没有启动起来，id也指为0</span></span><br><span class="line">	<span class="built_in">sprintf</span>(thread-&gt;name, <span class="string">&quot;SubThread-%d&quot;</span>, index);    <span class="comment">//根据编号起名字</span></span><br><span class="line">	<span class="built_in">pthread_mutex_init</span>(&amp;thread-&gt;mutex, <span class="literal">NULL</span>);        <span class="comment">//初始化互斥锁</span></span><br><span class="line">	<span class="built_in">pthread_cond_init</span>(&amp;thread-&gt;cond, <span class="literal">NULL</span>);          <span class="comment">//初始化条件变量</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程的回调函数(创建子反应堆模型)</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">subThreadRunning</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">WorkerThread</span>* thread = (<span class="keyword">struct</span> WorkerThread*)arg;</span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;thread-&gt;mutex);                     <span class="comment">//加锁</span></span><br><span class="line">	thread-&gt;evLoop = <span class="built_in">eventLoopInitEx</span>(thread-&gt;name);         <span class="comment">//给当前的子线程实例化一个反应堆模型</span></span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;thread-&gt;mutex);                   <span class="comment">//解锁</span></span><br><span class="line">	<span class="built_in">pthread_cond_signal</span>(&amp;thread-&gt;cond);                     <span class="comment">//唤醒主线程，说明子线程创建反应堆成功</span></span><br><span class="line">	<span class="comment">//底层就是启动dispatcher，开始检测</span></span><br><span class="line">	<span class="built_in">eventLoopRun</span>(thread-&gt;evLoop);                           <span class="comment">//将该反应堆运行起来</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThreadRun</span><span class="params">(<span class="keyword">struct</span> WorkerThread* thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建子线程</span></span><br><span class="line">	<span class="built_in">pthread_create</span>(&amp;thread-&gt;threadID, <span class="literal">NULL</span>, subThreadRunning, thread);</span><br><span class="line">	<span class="comment">//阻塞主线程，让当前函数不会直接结束(如果主线程执行该函数结束了，而子线程的回调函数还没有结束，即反应堆还没有创建出来，那当我们使用该</span></span><br><span class="line">	<span class="comment">// 子线程的反应堆模型时，就会出现错误)</span></span><br><span class="line">	<span class="built_in">pthread_mutex_lock</span>(&amp;thread-&gt;mutex);        <span class="comment">//因为子线程的反应堆evLoop是共享资源(主线程和子线程都在访问，这里就是主线程访问)，所以需要加锁</span></span><br><span class="line">	<span class="keyword">while</span> (thread-&gt;evLoop == <span class="literal">NULL</span>) &#123;                     <span class="comment">//如果没有创建好，就阻塞在互斥锁上</span></span><br><span class="line">		<span class="built_in">pthread_cond_wait</span>(&amp;thread-&gt;cond, &amp;thread-&gt;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pthread_mutex_unlock</span>(&amp;thread-&gt;mutex);      <span class="comment">//退出循环，说明子线程执行完了，就解锁退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-IO模型"><a href="#5-3-IO模型" class="headerlink" title="5.3 IO模型"></a>5.3 IO模型</h2><h3 id="读写缓存区类Buffer"><a href="#读写缓存区类Buffer" class="headerlink" title="读写缓存区类Buffer"></a>读写缓存区类Buffer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">	<span class="type">char</span>* data;                 <span class="comment">//指向内存的指针</span></span><br><span class="line">	<span class="type">int</span> capacity;               <span class="comment">//buffer内存块的总大小</span></span><br><span class="line">	<span class="type">int</span> readPos;                <span class="comment">//读数据的位置</span></span><br><span class="line">	<span class="type">int</span> writePos;               <span class="comment">//写数据的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要使用memmem()函数不仅要有头文件&lt;strings.h&gt;，还需要定义宏_GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>* <span class="built_in">bufferInit</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Buffer</span>* buffer = (<span class="keyword">struct</span> Buffer*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Buffer));        <span class="comment">//申请出一块Buffer堆内存</span></span><br><span class="line">	<span class="keyword">if</span> (buffer != <span class="literal">NULL</span>) &#123;                              <span class="comment">//如果开辟成功</span></span><br><span class="line">		buffer-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);            <span class="comment">//让buffer里面的data指针指向char型的数组，长度为size</span></span><br><span class="line">		buffer-&gt;capacity = size;</span><br><span class="line">		buffer-&gt;writePos = buffer-&gt;readPos = <span class="number">0</span>;        <span class="comment">//初始情况下，读位置和写位置都为0</span></span><br><span class="line">		<span class="built_in">memset</span>(buffer-&gt;data, <span class="number">0</span>, size);                 <span class="comment">//将data指针指向的大小为size的内存块都置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferDestroy</span><span class="params">(<span class="keyword">struct</span> Buffer* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buf != <span class="literal">NULL</span>) &#123;                          <span class="comment">//首先判断buf是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;data != <span class="literal">NULL</span>) &#123;                <span class="comment">//再判断buf里面的data成员指向的内存是否为空</span></span><br><span class="line">			<span class="built_in">free</span>(buf-&gt;data);                    <span class="comment">//如果都不为空，说明它是指向了一块有效的堆内存，然后就释放该data堆内存</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(buf);                   <span class="comment">//释放buf堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferExtendRoom</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.内存够用 - 不需要扩容</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bufferWriteableSize</span>(buffer) &gt;= size) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.内存需要合并才够用 - 不需要扩容</span></span><br><span class="line">	<span class="comment">// 已读的内存 + 剩余的可写的内存 &gt;= size</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (buffer-&gt;readPos + <span class="built_in">bufferWriteableSize</span>(buffer) &gt;= size) &#123;</span><br><span class="line">		<span class="comment">//得到未读的内存大小</span></span><br><span class="line">		<span class="type">int</span> readable = <span class="built_in">bufferReadableSize</span>(buffer);</span><br><span class="line">		<span class="comment">//移动内存(将未读的数据移动到初始点)</span></span><br><span class="line">		<span class="built_in">memcpy</span>(buffer-&gt;data, buffer-&gt;data + buffer-&gt;readPos, readable);   <span class="comment">//将未读数据移动到初始点data,移动的长度为未读数据长度</span></span><br><span class="line">		<span class="comment">//更新位置</span></span><br><span class="line">		buffer-&gt;readPos = <span class="number">0</span>;                <span class="comment">//将读数据位置设为起点</span></span><br><span class="line">		buffer-&gt;writePos = readable;        <span class="comment">//将写数据位置设为未读数据的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3，内存不够用 - 扩容</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">void</span>* temp = <span class="built_in">realloc</span>(buffer-&gt;data, buffer-&gt;capacity + size);          <span class="comment">//参数：扩容内存块的起始地址；新的内存块需要多大</span></span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;                    <span class="comment">//失败了直接返回</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(temp + buffer-&gt;capacity, <span class="number">0</span>, size);                <span class="comment">//将新扩充的内存初始为0</span></span><br><span class="line">		<span class="comment">//更新数据</span></span><br><span class="line">		buffer-&gt;data = temp;                 <span class="comment">//更新起点</span></span><br><span class="line">		buffer-&gt;capacity += size;            <span class="comment">//更新容量大小</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferWriteableSize</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> buffer-&gt;capacity - buffer-&gt;writePos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferReadableSize</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> buffer-&gt;writePos - buffer-&gt;readPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferAppendData</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buffer == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || data &lt;= <span class="number">0</span>) &#123;               <span class="comment">//这三种情况任何一种发送都是异常的</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//扩容</span></span><br><span class="line">	<span class="built_in">bufferExtendRoom</span>(buffer, size);         <span class="comment">//这个函数里面不一定真的会扩容</span></span><br><span class="line">	<span class="comment">//数据拷贝</span></span><br><span class="line">	<span class="built_in">memcpy</span>(buffer-&gt;data + buffer-&gt;writePos, data, size);             <span class="comment">//从可写位置开始拷贝数据data，长度为size</span></span><br><span class="line">	buffer-&gt;writePos += size;                 <span class="comment">//更新写数据位置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当data数据的中间没有\0的时候，可以使用该函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferAppendString</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">const</span> <span class="type">char</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> size = <span class="built_in">strlen</span>(data);        <span class="comment">//strlen是遇到\0就结束统计</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">bufferAppendData</span>(buffer, data, size);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将客户端发来的信息存到readbuffer里面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferSocketRead</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// read/recv/readv都可以(readv接收数据时可以往多个数组里面放，第一个用完，就用第二个，以此类推)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];                            <span class="comment">//定义结构体数组，大小为2</span></span><br><span class="line">	<span class="comment">//初始化数组元素</span></span><br><span class="line">	<span class="type">int</span> writeable = <span class="built_in">bufferWriteableSize</span>(buffer);             <span class="comment">//接收buffer还有多长的能写区域</span></span><br><span class="line">	vec[<span class="number">0</span>].iov_base = buffer-&gt;data + buffer-&gt;writePos;       <span class="comment">//成员base指向buffer的写数据位置</span></span><br><span class="line">	vec[<span class="number">0</span>].iov_len = writeable;                              <span class="comment">//成员len赋值为能写区域的大小</span></span><br><span class="line">	<span class="type">char</span>* tmpbuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">40960</span>);                     <span class="comment">//重新申请一块空间，大小为4k</span></span><br><span class="line">	vec[<span class="number">1</span>].iov_base = tmpbuf;                                <span class="comment">//第2个结构体的base指向刚才申请的空间</span></span><br><span class="line">	vec[<span class="number">1</span>].iov_len = <span class="number">40960</span>;</span><br><span class="line">	<span class="type">int</span> result = <span class="built_in">readv</span>(fd, vec, <span class="number">2</span>);         <span class="comment">//接收数据，返回值是接收的字节数。参数：文件描述符；vec地址；vec里面元素的个数</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;                          <span class="comment">//出现错误，退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (result &lt;= writeable) &#123;         <span class="comment">//说明全部数据都写到了vec[0]这个结构体里面</span></span><br><span class="line">		buffer-&gt;writePos += result;         <span class="comment">//直接更新写数据位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;                                 <span class="comment">//这种情况就是vec[0]的内存不够写，写了一部分数据到刚申请的空间vec[1]结构体里面</span></span><br><span class="line">		buffer-&gt;writePos = buffer-&gt;capacity;           <span class="comment">//更新buffer里面的写数据位置(因为这张情况是写满了，所以就等于它的容量)</span></span><br><span class="line">		<span class="comment">//将vec[1]里面的数据拷贝到buffer的data里面(会进行扩容)</span></span><br><span class="line">		<span class="built_in">bufferAppendData</span>(buffer, tmpbuf, result - writeable);    <span class="comment">//参数：buffer；要写入的数据；写入的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(tmpbuf);             <span class="comment">//释放为vec[1]开辟的内存</span></span><br><span class="line">	<span class="keyword">return</span> result;            <span class="comment">//将接受到的字节返回出去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">bufferFindCRLF</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//strstr ---&gt;大字符串中匹配子字符串(遇到\0结束)</span></span><br><span class="line">	<span class="comment">//memmem ---&gt;大数据块中匹配子数据块(需要指定数据块大小)</span></span><br><span class="line">	<span class="type">char</span>* ptr = <span class="built_in">memmem</span>(buffer-&gt;data + buffer-&gt;readPos, <span class="built_in">bufferReadableSize</span>(buffer), <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>);  <span class="comment">//读数据起始位置；数据块大小；子数据块；子数据块大小</span></span><br><span class="line">	<span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferSendData</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断有无数据</span></span><br><span class="line">	<span class="type">int</span> readable = <span class="built_in">bufferReadableSize</span>(buffer);              <span class="comment">//buffer中还有多少待处理(未读)的数据 ---&gt;待发送的数据</span></span><br><span class="line">	<span class="keyword">if</span> (readable &gt; <span class="number">0</span>) &#123;                                     <span class="comment">//如果大于0的，就把数据发送出去</span></span><br><span class="line">		<span class="comment">//将未读的数据都发送出去(为了防止管道破裂，需要指定参4为非0)</span></span><br><span class="line">		<span class="type">int</span> count = <span class="built_in">send</span>(socket, buffer-&gt;data + buffer-&gt;readPos, readable, MSG_NOSIGNAL); <span class="comment">//参4指定为一个信号，表示忽略底层发来的该信号</span></span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;                   <span class="comment">//说明发送成功了</span></span><br><span class="line">			buffer-&gt;readPos += count;      <span class="comment">//移动buffer里面的读数据位置</span></span><br><span class="line">			<span class="built_in">usleep</span>(<span class="number">1</span>);                     <span class="comment">//睡眠一会，让接收端休息一下</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;             <span class="comment">//返回发送数据的长度</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Tcp通信类TcpConnection"><a href="#Tcp通信类TcpConnection" class="headerlink" title="Tcp通信类TcpConnection"></a>Tcp通信类TcpConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释该宏，就是边读边写模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SEND_AUTO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TcpConnection是运行在某个子线程里面的，其在哪个子线程，evloop就属于哪个子线程，即TcpConnection是属于evloop的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Buffer</span>* readBuf;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Buffer</span>* writeBuf;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">	<span class="comment">//协议</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* request;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子线程反应堆对应的读回调函数(处理读到的数据,即客户端给服务器发生的数据。将要发送的数据写到writebuf)</span></span><br><span class="line"><span class="comment">// 细节：</span></span><br><span class="line"><span class="comment">// 1.当使用的是一起发模式，读回调函数执行完后，所有要发送的数据都写到了wirtebuf,然后通过写回调函数进行一起发送</span></span><br><span class="line"><span class="comment">// 2.当使用的是边读边发模式，读回调函数执行完后，所有数据也都发送完了(因此在读回调函数末尾，就可以断开连接了)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processRead</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line">	<span class="comment">//接收数据，存到readBuffer里面</span></span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">bufferSocketRead</span>(conn-&gt;readBuf, conn-&gt;channel-&gt;fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Debug</span>(<span class="string">&quot;接收到的http请求数据：%s&quot;</span>, conn-&gt;readBuf-&gt;data + conn-&gt;readBuf-&gt;readPos);</span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;                              <span class="comment">//读到数据了</span></span><br><span class="line">		<span class="comment">//接收到了http请求，解析http请求</span></span><br><span class="line">		<span class="type">int</span> socket = conn-&gt;channel-&gt;fd;  <span class="comment">//初始化时，channel记录的只有检测文件描述符的读事件，而没有写事件(所以需要在检测集合对fd添加写事件)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSG_SEND_AUTO                          <span class="comment">//如果定义了该宏，就执行下面代码</span></span></span><br><span class="line">		<span class="comment">//由于写回调和读回调都是同一个线程来完成，所以执行完下来两行代码后，写事件不会立即生效，要等该读回调执行完后，线程继续执行下一轮的</span></span><br><span class="line">		<span class="comment">//dispatcher检测，这时就会检测到fd的写事件触发，就调用写回调函数，这时writebuf里面是肯定有数据的，因为写读调执行parseHttpRequest时，</span></span><br><span class="line">		<span class="comment">//就对http协议进行解析、处理、组织响应块，并存储到了writebuf里面。那么写回调函数就可以把writebuf里面的数据发送给客户端了，并断开连接</span></span><br><span class="line">		<span class="comment">//这种方法的弊端：只有将所有响应数据放到writebuf过后，才能把数据发送出去，如果要发送的数据很大，writebuf或许装不下(不能将所有发送的数据</span></span><br><span class="line">		<span class="comment">// 放到writebuf，就不能进行数据的发送)</span></span><br><span class="line">		<span class="comment">//解决方法：写一部分，发一部分</span></span><br><span class="line">		<span class="built_in">writeEventEnable</span>(conn-&gt;channel, <span class="literal">true</span>);   <span class="comment">//参数2为true，会往channel的检测添加写事件，这时channel记录的就是检测文件描述符的读写事件了</span></span><br><span class="line">		<span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, MODIFY);   <span class="comment">//在eventLoop里面修改节点，从原来的检测读事件变为了检测读写事件(只要能检测写事件，就会触发其写回调函数)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="comment">//接收到的数据在readbuf，通过readbuf处理响应体，将响应数据写到writebuf</span></span><br><span class="line">		<span class="type">bool</span> flag = <span class="built_in">parseHttpRequest</span>(conn-&gt;request, conn-&gt;readBuf, conn-&gt;response, conn-&gt;writeBuf, socket);</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;      <span class="comment">//如果为false就是解析失败，为true就是成功了，说明要发送的数据已经写到了writeBuf</span></span><br><span class="line">			<span class="comment">//解析失败，回复一个简单的html</span></span><br><span class="line">			<span class="type">char</span>* errMsg = <span class="string">&quot;Http/1.1 400 Bad Request\r\n\r\n&quot;</span>;</span><br><span class="line">			<span class="built_in">bufferAppendString</span>(conn-&gt;writeBuf, errMsg);          <span class="comment">//将errMsg写入到writeBuf</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSG_SEND_AUTO</span></span><br><span class="line">		<span class="comment">//断开连接，把用于通信的文件描述符conn对应的channel里面的fd从反应堆模型的dispatcher检测集合中删除</span></span><br><span class="line">		<span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE);       <span class="comment">//没有读到数据，断开连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO           <span class="comment">//如果没有定义了该宏，就执行下面代码(边读边发送模式)--&gt;读回调执行完，数据也就发完了，直接断开连接</span></span></span><br><span class="line">	<span class="comment">//断开连接，把用于通信的文件描述符conn对应的channel里面的fd从反应堆模型的dispatcher检测集合中删除</span></span><br><span class="line">	<span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE);      <span class="comment">//这里直接进行了统一断开连接，因为上面多种情况都会断开连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理写(写回调函数)---&gt;当没有注释宏MSG_SEND_AUTO时，下面的写回调函数是永远不会执行的(因为没有在检测集合里面对fd进行修改事件)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWrite</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Debug</span>(<span class="string">&quot;开始发送数据了(基于写回调发送).....&quot;</span>);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line">	<span class="comment">//发送数据</span></span><br><span class="line">	<span class="type">int</span> count = <span class="built_in">bufferSendData</span>(conn-&gt;writeBuf, conn-&gt;channel-&gt;fd);     <span class="comment">//返回发送数据长度</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//判断数据是否被全部发送出去了</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">bufferReadableSize</span>(conn-&gt;writeBuf) == <span class="number">0</span>) &#123;            <span class="comment">//满足条件(可读的长度为0)，说明数据发送完了</span></span><br><span class="line">			<span class="comment">//数据全部发送出去，就不检测写事件了(修改检测集合)--&gt;但由于B/S架构是 建立连接-请求-响应-断开 这一过程，所以发送完数据说明响应结束</span></span><br><span class="line">			<span class="comment">//1. 不再检测事件 -- 修改channel中保存的事件(可忽略)</span></span><br><span class="line">			<span class="built_in">writeEventEnable</span>(conn-&gt;channel, <span class="literal">false</span>);        <span class="comment">//参1是要修改的channel；参2未false，表示不检测写事件了</span></span><br><span class="line">			<span class="comment">//2. 修改dispatcher检测的集合 -- 添加任务节点(可忽略)</span></span><br><span class="line">			<span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, MODIFY);  <span class="comment">//上面对channel从检测读写事件，改为了检测读事件，这里才是真正修改节点数据</span></span><br><span class="line">			<span class="comment">//3. 删除这个节点(上面的1和2步都可以不要，只留下这一句即可)</span></span><br><span class="line">			<span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE); <span class="comment">//删除这个channel，客户端与服务端就断开连接了</span></span><br><span class="line">			<span class="comment">//数据发送完，断开连接：就将当前的文件描述符从eventLoop检测集合中删除就行，这样客户端与服务器的连接就断开了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* <span class="built_in">tcpConnectionInit</span>(<span class="type">int</span> fd, <span class="keyword">struct</span> EventLoop* evloop)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TcpConnection));  <span class="comment">//给TcpConnection申请一块堆内存</span></span><br><span class="line">	conn-&gt;evLoop = evloop;                        <span class="comment">//赋值为传进来的反应堆模型(子线程的反应堆)</span></span><br><span class="line">	conn-&gt;readBuf = <span class="built_in">bufferInit</span>(<span class="number">10240</span>);            <span class="comment">//初始化一块内存</span></span><br><span class="line">	conn-&gt;writeBuf = <span class="built_in">bufferInit</span>(<span class="number">10240</span>);           <span class="comment">//初始化一块内存</span></span><br><span class="line">	<span class="comment">//得到实例</span></span><br><span class="line">	conn-&gt;request = <span class="built_in">httpRequestInit</span>();</span><br><span class="line">	conn-&gt;response = <span class="built_in">httpResponseInit</span>();</span><br><span class="line">	<span class="built_in">sprintf</span>(conn-&gt;name, <span class="string">&quot;Connection-%d&quot;</span>, fd);     <span class="comment">//初始化名字</span></span><br><span class="line">	<span class="comment">//对通信描述符fd进行封装(参数：通信描述符；检测读事件；读回调函数；写回调函数；回调函数参数)</span></span><br><span class="line">	conn-&gt;channel = <span class="built_in">channelInit</span>(fd, ReadEvent, processRead, processWrite, tcpConnectionDestroy, conn);  <span class="comment">//初始只定义为检测读事件，当需要发的时候再改</span></span><br><span class="line">	<span class="built_in">eventLoopAddTask</span>(evloop, conn-&gt;channel, ADD);           <span class="comment">//将channel添加到事件循环的任务队列里面(子反应堆模型evloop的任务队列)</span></span><br><span class="line">	<span class="built_in">Debug</span>(<span class="string">&quot;和客户端建立连接，threadName: %s, threadID: %s, connName: %s&quot;</span>, evloop-&gt;threadName, evloop-&gt;threadID, conn-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存tcpConnection(在服务器和客户端断开连接过后调用，即在epoll、poll、select的remove函数中调用)---&gt;channel的销毁回调函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcpConnectionDestroy</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line">	<span class="keyword">if</span> (conn != <span class="literal">NULL</span>) &#123;                        <span class="comment">//conn不为空，就可以执行下面的销毁操作</span></span><br><span class="line">		<span class="comment">//如果readBuf和wirteBuf都指向有效内存，且在这两块内存里面没有可处理的数据了</span></span><br><span class="line">		<span class="keyword">if</span> (conn-&gt;readBuf &amp;&amp; <span class="built_in">bufferReadableSize</span>(conn-&gt;readBuf) == <span class="number">0</span> &amp;&amp; conn-&gt;writeBuf &amp;&amp; <span class="built_in">bufferReadableSize</span>(conn-&gt;writeBuf) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//就可以把TcpConnection里面保存的所有的资源释放掉</span></span><br><span class="line">			<span class="built_in">destroyChannel</span>(conn-&gt;evLoop, conn-&gt;channel);                 <span class="comment">//释放channel(把属于哪个反应堆模型evLoop的channel删除)</span></span><br><span class="line">			<span class="built_in">bufferDestroy</span>(conn-&gt;readBuf);                                <span class="comment">//释放readBuf</span></span><br><span class="line">			<span class="built_in">bufferDestroy</span>(conn-&gt;writeBuf);                               <span class="comment">//释放writeBuf</span></span><br><span class="line">			<span class="built_in">httpRequestDestroy</span>(conn-&gt;request);                           <span class="comment">//释放request</span></span><br><span class="line">			<span class="built_in">httpResponseDestroy</span>(conn-&gt;response);                         <span class="comment">//释放response</span></span><br><span class="line">			<span class="built_in">free</span>(conn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Debug</span>(<span class="string">&quot;连接断开，释放资源， gameover, connName: %s&quot;</span>, conn-&gt;name);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-服务器"><a href="#5-4-服务器" class="headerlink" title="5.4 服务器"></a>5.4 服务器</h2><h3 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">	<span class="type">int</span> lfd;                                 <span class="comment">//监听的描述符</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port;                     <span class="comment">//端口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span> &#123;</span><br><span class="line">	<span class="type">int</span> threadNum;                             <span class="comment">//线程池里面子线程的个数</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* mainLoop;                <span class="comment">//反应堆模型(主线程)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* threadPool;             <span class="comment">//线程池</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Listener</span>* listener;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对结构体TcpServer进行初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span>* <span class="built_in">tcpServerInit</span>(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpServer</span>* tcp = (<span class="keyword">struct</span> TcpServer*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TcpServer)); <span class="comment">//给tcpserver申请一块内存</span></span><br><span class="line">	tcp-&gt;listener = <span class="built_in">listenerInit</span>(port);       <span class="comment">//传入端口，得到通信fd，进行监听</span></span><br><span class="line">	tcp-&gt;mainLoop = <span class="built_in">eventLoopInit</span>();          <span class="comment">//初始化主线程的反应堆模型</span></span><br><span class="line">	tcp-&gt;threadNum = threadNum;               <span class="comment">//子线程的个数</span></span><br><span class="line">	<span class="comment">//实例化线程池</span></span><br><span class="line">	tcp-&gt;threadPool = <span class="built_in">threadPoolInit</span>(tcp-&gt;mainLoop, threadNum);     <span class="comment">//参数：主线程的反应堆实例；线程池里面子线程的个数</span></span><br><span class="line">	<span class="keyword">return</span> tcp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过端口，创建监听fd</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span>* <span class="built_in">listenerInit</span>(<span class="type">unsigned</span> <span class="type">short</span> port)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Listener</span>* listener = (<span class="keyword">struct</span> Listener*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Listener));       <span class="comment">//创建一块Listener结构体</span></span><br><span class="line">	<span class="comment">//1.创建监听的fd(基于tcp的套接字) ---&gt;参三写0即可，因为这里是用流式协议，写0就代表使用的式流式协议的tcp;如果使用的是报文协议，写0就代表使用的是报文协议的udp</span></span><br><span class="line">	<span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);    <span class="comment">//参数：指定使用的ip协议是ipv4还是ipv6；指定使用的套接字是基于流式协议还是报文协议</span></span><br><span class="line">	<span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.设置端口复用</span></span><br><span class="line">	<span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span> opt);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3.绑定</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">	addr.sin_family = AF_INET;</span><br><span class="line">	addr.sin_port = <span class="built_in">htons</span>(port);               <span class="comment">//将转进来的端口转为网络字节序再进行存储</span></span><br><span class="line">	<span class="comment">//该0地址就表示这里绑定本地任意一个ip地址，假如本地计算机有多个网卡，0地址就可以监听所有网卡上面指定的port端口(INADDR_ANY没有大小端之分，所以直接使用即可)</span></span><br><span class="line">	addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">//如果有客户端将连接请求发给了网卡a或网卡b对应的port端口，在本地都可以接收到该请求</span></span><br><span class="line">	ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.设置监听</span></span><br><span class="line">	ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);             <span class="comment">//一次性最多接收128个请求</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回fd</span></span><br><span class="line">	listener-&gt;lfd = lfd;</span><br><span class="line">	listener-&gt;port = port;</span><br><span class="line">	<span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程反应堆模型中监听描述符的读回调函数(与客户端连接)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">acceptConnection</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TcpServer</span>* server = (<span class="keyword">struct</span> TcpServer*)arg;</span><br><span class="line">	<span class="comment">//和客户端建立连接</span></span><br><span class="line">	<span class="type">int</span> cfd = <span class="built_in">accept</span>(server-&gt;listener-&gt;lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);     <span class="comment">//参数：监听描述符；存储对端信息结构体；参2的大小</span></span><br><span class="line">	<span class="comment">//从线程池中取出一个子线程的反应堆实例。去处理这个cfd通信</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = <span class="built_in">takeWorkerEventLoop</span>(server-&gt;threadPool);     <span class="comment">//从线程池中取出一个子子线程，得到该子线程的反应堆模型</span></span><br><span class="line">	<span class="comment">//将cfd放到TcpConnection中处理</span></span><br><span class="line">	<span class="built_in">tcpConnectionInit</span>(cfd, evLoop);            <span class="comment">//对fd进行封装，封装好后放到子线程的反应堆模型里面</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tcpServerRun</span><span class="params">(<span class="keyword">struct</span> TcpServer* server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Debug</span>(<span class="string">&quot;服务器程序已经启动了..........&quot;</span>);</span><br><span class="line">	<span class="comment">//启动线程池</span></span><br><span class="line">	<span class="built_in">threadPoolRun</span>(server-&gt;threadPool);</span><br><span class="line">	<span class="comment">//给主线程的反应堆模型添加检测的任务(监听连接)</span></span><br><span class="line">	<span class="comment">//初始化一个channel实例。参数：监听的文件描述符；检测什么事件；事件触发处理的动作(读回调)；写回调；前面回调函数的参数</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = <span class="built_in">channelInit</span>(server-&gt;listener-&gt;lfd,</span><br><span class="line">		ReadEvent, acceptConnection, <span class="literal">NULL</span>, <span class="literal">NULL</span>, server);       <span class="comment">//因为是监听描述符，所以不需要写回调，同时运行期间不应该释放lfd,所以销毁回调也会为空</span></span><br><span class="line">	<span class="comment">//下面先将任务添加到任务队列进行处理，最后添加到对应检测集合中，再启动反应堆模型</span></span><br><span class="line">	<span class="built_in">eventLoopAddTask</span>(server-&gt;mainLoop, channel, ADD);      <span class="comment">//参数：主线程的反应堆模型；channel(里面封装了文件描述符)；</span></span><br><span class="line">	<span class="comment">//启动主线程的反应堆模型</span></span><br><span class="line">	<span class="built_in">eventLoopRun</span>(server-&gt;mainLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-Http"><a href="#5-5-Http" class="headerlink" title="5.5 Http"></a>5.5 Http</h2><h3 id="接收请求类HttpRequest"><a href="#接收请求类HttpRequest" class="headerlink" title="接收请求类HttpRequest"></a>接收请求类HttpRequest</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求头键值对</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestHeader</span> &#123;</span><br><span class="line">	<span class="type">char</span>* key;</span><br><span class="line">	<span class="type">char</span>* value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前的解析状态(用来记录)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpRequestState</span> &#123;</span><br><span class="line">	ParseReqLine,                      <span class="comment">//请求行</span></span><br><span class="line">	ParseReqHeaders,                   <span class="comment">//请求头</span></span><br><span class="line">	ParseReqBody,                      <span class="comment">//请求的数据块(get请求没有该状态)</span></span><br><span class="line">	ParseReqDone                       <span class="comment">//表示当前的请求协议已经解析完了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义http请求结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line">	<span class="comment">//请求行</span></span><br><span class="line">	<span class="type">char</span>* method;                          <span class="comment">//请求方式</span></span><br><span class="line">	<span class="type">char</span>* url;                             <span class="comment">//请求资源</span></span><br><span class="line">	<span class="type">char</span>* version;                         <span class="comment">//使用的版本</span></span><br><span class="line">	<span class="comment">//请求头(有若干个键值对组成)</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">RequestHeader</span>* reqHeaders;     <span class="comment">//比如说01234下的键值对已经添加，reqHeadersNum就为5，下次继续添加键值对时，直接从5下标开始</span></span><br><span class="line">	<span class="type">int</span> reqHeadersNum;                   <span class="comment">//键值对的个数</span></span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">HttpRequestState</span> curState;             <span class="comment">//记录当前的解析状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* <span class="built_in">httpRequestInit</span>();</span><br><span class="line"><span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestReset</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestResetEx</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestDestroy</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;       <span class="comment">//内存释放函数</span></span><br><span class="line"><span class="comment">//获取处理状态</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> HttpRequestState <span class="title">httpRequestState</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request)</span></span>;</span><br><span class="line"><span class="comment">//添加请求头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line"><span class="comment">//根据key得到请求头的value</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">httpRequestGetHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key)</span></span>;</span><br><span class="line"><span class="comment">//解析请求行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestLine</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析请求头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span>;</span><br><span class="line"><span class="comment">//解析http请求协议(readbuf里面存了有待解析的数据)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理http请求协议(处理前需要先解析http请求)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">processHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> HttpResponse* response)</span></span>;</span><br><span class="line"><span class="comment">//解码字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decodeMsg</span><span class="params">(<span class="type">char</span>* to, <span class="type">char</span>* from)</span></span>;</span><br><span class="line"><span class="comment">//响应数据类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getFileType</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">//发送目录</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span>;</span><br><span class="line"><span class="comment">//发送文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HeaderSize 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* <span class="built_in">httpRequestInit</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* request = (<span class="keyword">struct</span> HttpRequest*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HttpRequest));     <span class="comment">//为HttpRequest结构体申请一块空间</span></span><br><span class="line">	<span class="built_in">httpRequestReset</span>(request);</span><br><span class="line">	request-&gt;reqHeaders = (<span class="keyword">struct</span> RequestHeader*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> RequestHeader) * HeaderSize);   <span class="comment">//给请求头开辟一块空间</span></span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数主要是用来数据重置的(每发完一次，回到初始设置)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestReset</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	req-&gt;curState = ParseReqLine;                        <span class="comment">//刚开始默认状态是处理请求行</span></span><br><span class="line">	req-&gt;method = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;url = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;version = <span class="literal">NULL</span>;</span><br><span class="line">	req-&gt;reqHeadersNum = <span class="number">0</span>;            <span class="comment">//放数据时从该下标开始放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestResetEx</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(req-&gt;url);</span><br><span class="line">	<span class="built_in">free</span>(req-&gt;method);</span><br><span class="line">	<span class="built_in">free</span>(req-&gt;version);</span><br><span class="line">	<span class="keyword">if</span> (req-&gt;reqHeaders != <span class="literal">NULL</span>) &#123;                            <span class="comment">//先判断指向结构体数值的指针是否为空</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; req-&gt;reqHeadersNum; i++) &#123;         <span class="comment">//遍历数组释放元素</span></span><br><span class="line">			<span class="built_in">free</span>(req-&gt;reqHeaders[i].key);</span><br><span class="line">			<span class="built_in">free</span>(req-&gt;reqHeaders[i].value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(req-&gt;reqHeaders);                                <span class="comment">//释放完元素，就释放组数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">httpRequestReset</span>(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestDestroy</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (req != <span class="literal">NULL</span>) &#123;                                            <span class="comment">//先判断req是否为空</span></span><br><span class="line">		<span class="built_in">httpRequestResetEx</span>(req);</span><br><span class="line">		<span class="built_in">free</span>(req);                              <span class="comment">//释放结构体地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">enum</span> HttpRequestState <span class="title">httpRequestState</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> request-&gt;curState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//外面是创建好的一块key和value的结构体，这里面直接赋值即可，不需要申请内存</span></span><br><span class="line">	request-&gt;reqHeaders[request-&gt;reqHeadersNum].key = (<span class="type">char</span>*)key;</span><br><span class="line">	request-&gt;reqHeaders[request-&gt;reqHeadersNum].value = (<span class="type">char</span>*)value;</span><br><span class="line">	request-&gt;reqHeadersNum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">httpRequestGetHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (request != <span class="literal">NULL</span>) &#123;               <span class="comment">//如果request不指向空</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; request-&gt;reqHeadersNum; i++) &#123;                     <span class="comment">//遍历键值对</span></span><br><span class="line">			<span class="comment">//strncasecmp是指比较n个不区分大小写的字符串</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(request-&gt;reqHeaders[i].key, key, <span class="built_in">strlen</span>(key)) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> request-&gt;reqHeaders[i].value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;                    <span class="comment">//为空或没有找到对应的键值对，就直接返回空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分请求行(解决下面函数parseHttpRequestLine的冗余问题) 参数：起始位置；结束位置；子数据块</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">splitRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* start, <span class="type">const</span> <span class="type">char</span>* end, <span class="type">const</span> <span class="type">char</span>* sub, <span class="type">char</span>** ptr)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span>* space = end;</span><br><span class="line">	<span class="keyword">if</span> (sub != <span class="literal">NULL</span>) &#123;                              <span class="comment">//第一个和第二个需要用到，获取版本时传入sub==NULL即可</span></span><br><span class="line">		space = <span class="built_in">memmem</span>(start, end - start, sub, <span class="built_in">strlen</span>(sub));</span><br><span class="line">		<span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                       <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> length = space - start;           <span class="comment">//没有进if()，space就是end</span></span><br><span class="line">	<span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length + <span class="number">1</span>);     <span class="comment">//开辟一块空间</span></span><br><span class="line">	<span class="built_in">strncpy</span>(tmp, start, length);</span><br><span class="line">	tmp[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	*ptr = tmp;</span><br><span class="line">	<span class="keyword">return</span> space + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析请求行(将发来的http请求信息(在readbuf里面)解析后存到requeset结构体里面)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestLine</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//保存字符串结束地址\r\n的位置(该函数并没有对buffer进行读取操作，即readpos的位置没有变)</span></span><br><span class="line">	<span class="type">char</span>* end = <span class="built_in">bufferFindCRLF</span>(readBuf);</span><br><span class="line">	<span class="comment">//保存字符串起始地址</span></span><br><span class="line">	<span class="type">char</span>* start = readBuf-&gt;data + readBuf-&gt;readPos;</span><br><span class="line">	<span class="comment">//请求行总长度</span></span><br><span class="line">	<span class="type">int</span> lineSize = end - start;</span><br><span class="line">	<span class="keyword">if</span> (lineSize) &#123;                       <span class="comment">//如果请求行总长度大于0</span></span><br><span class="line">		start = <span class="built_in">splitRequestLine</span>(start, end, <span class="string">&quot; &quot;</span>, &amp;request-&gt;method);    <span class="comment">//调用辅助函数，完成method的截取</span></span><br><span class="line">		start = <span class="built_in">splitRequestLine</span>(start, end, <span class="string">&quot; &quot;</span>, &amp;request-&gt;url);       <span class="comment">//静态资源的截取</span></span><br><span class="line">		<span class="built_in">splitRequestLine</span>(start, end, <span class="literal">NULL</span>, &amp;request-&gt;version);          <span class="comment">//版本号的截取</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">		<span class="comment">// get /xxx/xxx.txt http/1.1\r\n       ---&gt;end指向的是\r</span></span><br><span class="line">		<span class="comment">//请求方式</span></span><br><span class="line">		<span class="type">char</span>* space = <span class="built_in">memmem</span>(start, lineSize, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);      <span class="comment">//大数据块起始位置；大数据块长度；子数据块；子数据块长度</span></span><br><span class="line">		<span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                              <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line">		<span class="type">int</span> methodSize = space - start;                     <span class="comment">//获取method长度</span></span><br><span class="line">		request-&gt;method = (<span class="type">char</span>*)<span class="built_in">malloc</span>(methodSize + <span class="number">1</span>);    <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line">		<span class="built_in">strncpy</span>(request-&gt;method, start, methodSize);        <span class="comment">//从起始位置读methodSize长度(get)放到request-&gt;method里面</span></span><br><span class="line">		request-&gt;method[methodSize] = <span class="string">&quot;\0&quot;</span>;                 <span class="comment">//在get后面加\0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//请求的静态资源</span></span><br><span class="line">		start = space + <span class="number">1</span>;                                  <span class="comment">//重新设置起始位置，原来是get后面的空格+1即可</span></span><br><span class="line">		<span class="type">char</span>* space = <span class="built_in">memmem</span>(start, end-start, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);     <span class="comment">//大数据块起始位置；大数据块长度；子数据块；子数据块长度</span></span><br><span class="line">		<span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                              <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line">		<span class="type">int</span> urlSize = space - start;                        <span class="comment">//获取静态资源长度</span></span><br><span class="line">		request-&gt;url = (<span class="type">char</span>*)<span class="built_in">malloc</span>(urlSize + <span class="number">1</span>);          <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line">		<span class="built_in">strncpy</span>(request-&gt;url, start, urlSize);              <span class="comment">//从起始位置读urlSize长度(静态资源)放到request-&gt;url里面</span></span><br><span class="line">		request-&gt;url[urlSize] = <span class="string">&quot;\0&quot;</span>;                       <span class="comment">//在静态资源后面加\0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//http版本</span></span><br><span class="line">		start = space + <span class="number">1</span>;                                  <span class="comment">//重新设置起始位置，原来是静态资源后面的空格+1即可</span></span><br><span class="line">		request-&gt;version = (<span class="type">char</span>*)<span class="built_in">malloc</span>(end - start + <span class="number">1</span>);  <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line">		<span class="built_in">strncpy</span>(request-&gt;version, start, end - start);      <span class="comment">//从起始位置读相应长度(静态资源)放到request-&gt;version里面</span></span><br><span class="line">		request-&gt;version[end - start] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//为解析请求头做准备</span></span><br><span class="line">		readBuf-&gt;readPos += lineSize;              <span class="comment">//令读数据位置为请求行的\r</span></span><br><span class="line">		readBuf-&gt;readPos += <span class="number">2</span>;                     <span class="comment">//再加2个位置(\r\n)，读数据位置就为请求头行了</span></span><br><span class="line">		<span class="comment">//修改状态</span></span><br><span class="line">		request-&gt;curState = ParseReqHeaders;        <span class="comment">//当前状态为请求头状态</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数处理请求头中的一行(如果要处理请求头中的多行，需要循环调用)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span>    <span class="comment">//传进来的readBuf已经处理完请求头，读数据位置在请求头行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* end = <span class="built_in">bufferFindCRLF</span>(readBuf);         <span class="comment">//正常情况下end指向\r</span></span><br><span class="line">	<span class="keyword">if</span> (end != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">char</span>* start = readBuf-&gt;data + readBuf-&gt;readPos;           <span class="comment">//请求头的起始位置</span></span><br><span class="line">		<span class="type">int</span> lineSize = end - start;              <span class="comment">//获取长度</span></span><br><span class="line">		<span class="comment">//基于: 搜索字符串</span></span><br><span class="line">		<span class="type">char</span>* middle = <span class="built_in">memmem</span>(start, lineSize, <span class="string">&quot;: &quot;</span>, <span class="number">2</span>);       <span class="comment">//在请求头的某一行搜索子数据块&quot;: &quot;，标准的http请求key和value之间是&quot;: &quot;</span></span><br><span class="line">		<span class="keyword">if</span> (middle != <span class="literal">NULL</span>) &#123;                                  <span class="comment">//如果不等于NULL，说明middle指向了:</span></span><br><span class="line">			<span class="type">char</span>* key = <span class="built_in">malloc</span>(middle - start + <span class="number">1</span>);            <span class="comment">//为key开辟一块空间，加1是为了最后存\0</span></span><br><span class="line">			<span class="built_in">strncpy</span>(key, start, middle - start);</span><br><span class="line">			key[middle - start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="comment">//middle+2的位置就是value值的初始位置</span></span><br><span class="line">			<span class="type">char</span>* value = <span class="built_in">malloc</span>(end - middle - <span class="number">2</span> + <span class="number">1</span>);            <span class="comment">//为value开辟一块空间</span></span><br><span class="line">			<span class="built_in">strncpy</span>(value, middle+<span class="number">2</span>, end - middle - <span class="number">2</span>);</span><br><span class="line">			key[end - middle - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="comment">//httpRequestAddHeader函数里面是没有对key和value申请内存的，所以在本函数为它们开辟有效内存</span></span><br><span class="line">			<span class="built_in">httpRequestAddHeader</span>(request, key, value);          <span class="comment">//将得到key和value存放到结构体数组中</span></span><br><span class="line">			<span class="comment">//移动读数据的位置</span></span><br><span class="line">			readBuf-&gt;readPos += lineSize;</span><br><span class="line">			readBuf-&gt;readPos += <span class="number">2</span>;                              <span class="comment">//readBuf里面的读数据位置移动到下一行</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;            <span class="comment">//否则说明请求头已经的内容已经获取完了(请求头的下面是空行\r\n，里面是没有&quot;: &quot;的)</span></span><br><span class="line">			<span class="comment">//请求头被解析完了，跳过空行</span></span><br><span class="line">			readBuf-&gt;readPos += <span class="number">2</span>;</span><br><span class="line">			<span class="comment">//修改解析状态</span></span><br><span class="line">			<span class="comment">//忽略post请求(空行下面是有数据的)，按照get请求处理(空行下面是没有数据的)</span></span><br><span class="line">			request-&gt;curState = ParseReqDone;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http协议(先解析请求行，再解析请求头)，调用辅助函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf, <span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (request-&gt;curState != ParseReqDone) &#123;                    <span class="comment">//当前状态不是结束状态就循环</span></span><br><span class="line">		<span class="keyword">switch</span> (request-&gt;curState) &#123;</span><br><span class="line">		<span class="keyword">case</span> ParseReqLine:</span><br><span class="line">			flag = <span class="built_in">parseHttpRequestLine</span>(request, readBuf);        <span class="comment">//解析请求行存到request，将状态改为解析请求头</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ParseReqHeaders:</span><br><span class="line">			flag = <span class="built_in">parseHttpRequestHeader</span>(request, readBuf);       <span class="comment">//解析请求头存到request，将状态改为解析完毕ParseReqDone</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ParseReqBody:               <span class="comment">//只有post请求才会用到这种状态</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;                     <span class="comment">//当解析请求行或请求头出现问题时，会使flag为false，这种情况就直接退出</span></span><br><span class="line">			<span class="keyword">return</span> flag;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断是否解析完毕了，如果完毕了，需要准备回复的数据</span></span><br><span class="line">		<span class="keyword">if</span> (request-&gt;curState == ParseReqDone) &#123;</span><br><span class="line">			<span class="comment">// 1. 根据解析出的原始数据，对客户端的请求做出处理(主要完成http协议响应的格式)</span></span><br><span class="line">			<span class="built_in">processHttpRequest</span>(request,response);      <span class="comment">//该函数调用后，response指针指向的结构体地址被写入了要发送的数据</span></span><br><span class="line">			<span class="comment">// 2. 组织相应数据写到sendBuf，并发送给客户端</span></span><br><span class="line">			<span class="built_in">httpResponsePrepareMsg</span>(response, sendBuf, socket); <span class="comment">//根据response里面写入的结构体数据，组织了一个发送给客户端的响应数据块存到sendBuf</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	request-&gt;curState = ParseReqLine;       <span class="comment">//还原状态，保证还能继续处理第二条以及以后的请求(从客户端读来的数据都存到buffer里面的)</span></span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理http请求(http协议的响应格式发送)---&gt;没有发送，只是进行了存储，存储在了response结构体中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">processHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> HttpResponse* response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(request-&gt;method, <span class="string">&quot;get&quot;</span>) != <span class="number">0</span>) &#123;        <span class="comment">//若干客户端的请求不是get请求，就不处理，直接返回-1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">decodeMsg</span>(request-&gt;url, request-&gt;url);            <span class="comment">//将参2url解码后又存到参1url(中文的utf-8形式转纯中文)</span></span><br><span class="line">	<span class="comment">//处理客户端请求的静态资源</span></span><br><span class="line">	<span class="type">char</span>* file = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(request-&gt;url, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>) &#123;              <span class="comment">//若干客户端的请求路径是/</span></span><br><span class="line">		file = <span class="string">&quot;./&quot;</span>;                    <span class="comment">//将目录改为资源文件的根目录(因为有操作会将当前目录切换为资源目录，所以才是./)</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		file = request-&gt;url + <span class="number">1</span>;         <span class="comment">//若不是，就移动位置，取客户端想要的文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取文件的属性</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">stat</span>(file, &amp;st);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;               <span class="comment">//出错</span></span><br><span class="line">		<span class="comment">//文件不存在--回复404</span></span><br><span class="line">		<span class="built_in">strcpy</span>(response-&gt;fileName, <span class="string">&quot;404.html&quot;</span>);             <span class="comment">//文件名</span></span><br><span class="line">		response-&gt;statusCode = NotFound;                    <span class="comment">//状态码</span></span><br><span class="line">		<span class="built_in">strcpy</span>(response-&gt;statusMsg, <span class="string">&quot;Not Found&quot;</span>);           <span class="comment">//状态描述</span></span><br><span class="line">		<span class="comment">//响应头(有许多键值对的，这里只发一个键值对)</span></span><br><span class="line">		<span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(<span class="string">&quot;.html&quot;</span>));</span><br><span class="line">		response-&gt;sendDataFunc = sendFile;            <span class="comment">//发送数据的函数指针指向发送文件数据函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">//出错了退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(response-&gt;fileName, file);</span><br><span class="line">	response-&gt;statusCode = OK;</span><br><span class="line">	<span class="built_in">strcpy</span>(response-&gt;statusMsg, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">	<span class="comment">//判断文件类型(看是目录还是文件)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;          <span class="comment">//如果是目录</span></span><br><span class="line">		<span class="comment">//响应头(有许多键值对的，这里只法一个键值对)</span></span><br><span class="line">		<span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(<span class="string">&quot;.html&quot;</span>));    <span class="comment">//因为是目录，它也是通过html文件显示的</span></span><br><span class="line">		response-&gt;sendDataFunc = sendDir;            <span class="comment">//发送数据的函数指针指向发送目录数据函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//响应头</span></span><br><span class="line">		<span class="type">char</span> tmp[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">sprintf</span>(tmp,<span class="string">&quot;%ld&quot;</span>, st.st_size);</span><br><span class="line">		<span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(file));     <span class="comment">//文件类型</span></span><br><span class="line">		<span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-length&quot;</span>, tmp);                 <span class="comment">//文件内容长度</span></span><br><span class="line">		response-&gt;sendDataFunc = sendFile;            <span class="comment">//发送数据的函数指针指向发送数据函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符转换为整形数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexToDec</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="comment">// to 存储解码之后的数据, 传出参数, from被解码的数据, 传入参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decodeMsg</span><span class="params">(<span class="type">char</span>* to, <span class="type">char</span>* from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; *from != <span class="string">&#x27;\0&#x27;</span>; ++to, ++from)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// isxdigit -&gt; 判断字符是不是16进制格式, 取值在 0-f</span></span><br><span class="line">		<span class="comment">// Linux%E5%86%85%E6%A0%B8.jpg</span></span><br><span class="line">		<span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将16进制的数 -&gt; 十进制 将这个数值赋值给了字符 int -&gt; char</span></span><br><span class="line">			<span class="comment">// B2 == 178</span></span><br><span class="line">			<span class="comment">// 将3个字符, 变成了一个字符, 这个字符就是原始数据</span></span><br><span class="line">			*to = <span class="built_in">hexToDec</span>(from[<span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">hexToDec</span>(from[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 跳过 from[1] 和 from[2] 因此在当前循环中已经处理过了</span></span><br><span class="line">			from += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 字符拷贝, 赋值</span></span><br><span class="line">			*to = *from;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	*to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应数据类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getFileType</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// a.jpg a.mp4 a.html</span></span><br><span class="line">	<span class="comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);                        <span class="comment">//从右往左找，找到点，就停止，读后面内容也就是后缀了</span></span><br><span class="line">	<span class="keyword">if</span> (dot == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;	<span class="comment">// 纯文本</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wav&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;           <span class="comment">//如果没有找到对应的文件格式，就返回纯文本，符号编码是utf-8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拼好的html数据块添加到readbuf里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;</span>, dirName);</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dirent</span>** namelist;</span><br><span class="line">	<span class="comment">//遍历目录，返回值是该目录下文件的数量</span></span><br><span class="line">	<span class="comment">//scandir 函数会动态分配内存，将每个目录项的指针存储到一个指针数组namelist中。这个数组中的每个元素都是指向struct dirent结构体的指针，这些结构体包含了文件名等目录项信息。</span></span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">scandir</span>(dirName, &amp;namelist, <span class="literal">NULL</span>, alphasort);   <span class="comment">//参1：要遍历的目录的名字；参2：传出参数；参3：回调函数(遍历的规则)；参4：排序的方式</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="comment">//取出文件名。namelist指向的是一个指针数组 struct dirent* tmp[] -----&gt;数组tmp里面的元素都是struct dirent*类型的指针</span></span><br><span class="line">		<span class="type">char</span>* name = namelist[i]-&gt;d_name;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">		<span class="type">char</span> subPath[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">sprintf</span>(subPath, <span class="string">&quot;%s/%s&quot;</span>, dirName, name);          <span class="comment">//拼接成绝对路径</span></span><br><span class="line">		<span class="built_in">stat</span>(subPath, &amp;st);                                <span class="comment">//判断该绝对路径是目录还是文件</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;</span><br><span class="line">			<span class="comment">//注意：如果是%s/有斜线，就代表要跳转到某个目录里面去，如果没有斜线，就代表是访问某个文件</span></span><br><span class="line">			<span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, name, name, st.st_size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, name, name, st.st_size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">bufferAppendString</span>(sendBuf, buf);               <span class="comment">//将buf里面的数据写到sendBuf</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO          <span class="comment">//如果定义了该宏(说明使用一起发模式，即将所有数据写到sendbuf里面，最后在写回调函数一起发)，下面代码就无效</span></span></span><br><span class="line">		<span class="built_in">bufferSendData</span>(sendBuf, cfd);                       <span class="comment">//sendbuf又有数据了，发送数据(边读边发的模式)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));                    <span class="comment">//然后将容器buf清0</span></span><br><span class="line">		<span class="built_in">free</span>(namelist[i]);       <span class="comment">//用完了释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);             <span class="comment">//拼接结束标签</span></span><br><span class="line">	<span class="built_in">bufferAppendString</span>(sendBuf, buf);                   <span class="comment">//将buf里面的数据写到sendBuf</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO                                  <span class="comment">//如果定义了该宏，下面代码就无效</span></span></span><br><span class="line">	<span class="built_in">bufferSendData</span>(sendBuf, cfd);                       <span class="comment">//发送数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">free</span>(namelist);             <span class="comment">//释放二级指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要发送的数据写到readbuf</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span>              <span class="comment">//发送文件函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1.打开文件</span></span><br><span class="line">	<span class="type">int</span> fd = <span class="built_in">open</span>(filename, O_RDONLY);                   <span class="comment">//以只读的方式打开文件filename</span></span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//assert(fd &gt; 0);                                      //设置断言(如果fd&lt;=0，就会报错)</span></span><br><span class="line">	<span class="comment">//发送文件的两种方式(没有改，这里只能用第一种方法)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span> buf);             <span class="comment">//从文件中读出数据存到buf</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;                                   <span class="comment">//每次循环后，如果数据还没有读完，len就会大于0</span></span><br><span class="line">			<span class="built_in">bufferAppendData</span>(sendBuf, buf, len);         <span class="comment">//将数据buf长度为len的数据写入到sendBuf(buf结尾不是\0，所以得用该函数)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO             <span class="comment">//如果定义了该宏(说明使用一起发模式，即将所有数据写到sendbuf里面，最后在写回调函数一起发)，下面代码就无效</span></span></span><br><span class="line">			<span class="built_in">bufferSendData</span>(sendBuf, cfd);                <span class="comment">//sendBuf又有数据了，发送数据(边读边发的模式)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">//usleep(10);   //重要,但已经在bufferSendData()函数里面睡眠了(无论是 一起发模式 还是 边写边发模式 都会调用该函数)</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;                             <span class="comment">//文件读完了，直接退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                                           <span class="comment">//其它情况就是出现问题了，打印错误信息</span></span><br><span class="line">			<span class="built_in">close</span>(fd);                                   <span class="comment">//关闭fd</span></span><br><span class="line">			<span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//该方法只适用于发送文件的场景</span></span><br><span class="line">	<span class="comment">//这种方式是把文件打开，把文件描述符传给sendfile函数，函数内部就会将数据发给客户端(效率更高)---&gt;但如果发送的是目录，该方法还是不行</span></span><br><span class="line">	<span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);     <span class="comment">//获取文件的大小(指针被移动到尾部了)</span></span><br><span class="line">	<span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);                <span class="comment">//将指针移回头部</span></span><br><span class="line">	<span class="keyword">while</span> (offset &lt; size) &#123;         <span class="comment">//当偏移量到达要发送文件大小后(说明发送完了)，就直接退出循环</span></span><br><span class="line">		<span class="type">int</span> ret = <span class="built_in">sendfile</span>(cfd, fd, &amp;offset, size - offset);        <span class="comment">//参1是通信描述符；参2的文件描述符；参3是参2的偏移量；参4是open打开文件的大小</span></span><br><span class="line">		<span class="comment">//sendfile的第3个参数offset：</span></span><br><span class="line">		<span class="comment">// 1.发送数据之前，根据该偏移量开始读文件数据</span></span><br><span class="line">		<span class="comment">// 2.发送数据之后，更新该偏移量(不需要我们手动设置，系统自动更新偏移量)</span></span><br><span class="line">		<span class="comment">//printf(&quot;ret value: %d\n&quot;, ret);</span></span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;没有数据.....\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组织响应体类HttpResponse"><a href="#组织响应体类HttpResponse" class="headerlink" title="组织响应体类HttpResponse"></a>组织响应体类HttpResponse</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义状态码枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpStatusCode</span> &#123;</span><br><span class="line">	Unknown,</span><br><span class="line">	OK = <span class="number">200</span>,</span><br><span class="line">	MovedPermanently = <span class="number">301</span>,</span><br><span class="line">	MovedTemporarily = <span class="number">302</span>,</span><br><span class="line">	BadRequest = <span class="number">400</span>,</span><br><span class="line">	NotFound = <span class="number">404</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义响应的结构体(一个结构体对应一个key-value)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ResponseHeader</span> &#123;</span><br><span class="line">	<span class="type">char</span> key[<span class="number">32</span>];</span><br><span class="line">	<span class="type">char</span> value[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数指针，用来组织要回复给客户端的数据块</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*responseBody)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fileName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line">	<span class="comment">//状态行：状态码，状态描述</span></span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">HttpStatusCode</span> statusCode;     <span class="comment">//状态码</span></span><br><span class="line">	<span class="type">char</span> statusMsg[<span class="number">128</span>];                <span class="comment">//状态描述</span></span><br><span class="line">	<span class="type">char</span> fileName[<span class="number">128</span>];             <span class="comment">//文件名</span></span><br><span class="line">	<span class="comment">//响应头：键值对</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ResponseHeader</span>* headers;       <span class="comment">//通过malloc多开辟几个该结构体空间，即形成一个数组，headers指向数组头</span></span><br><span class="line">	<span class="type">int</span> headerNum;                  <span class="comment">//响应头里面有效的元素个数</span></span><br><span class="line">	responseBody sendDataFunc;      <span class="comment">//回复给客户端的数据块(函数指针类型),也可以理解为回调函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能实现文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* <span class="built_in">httpResponseInit</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* response = (<span class="keyword">struct</span> HttpResponse*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HttpResponse));</span><br><span class="line">	response-&gt;headerNum = <span class="number">0</span>;                 <span class="comment">//初始化响应头的个数为0</span></span><br><span class="line">	<span class="type">int</span> size = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ResponseHeader) * ResHeaderSize;</span><br><span class="line">	response-&gt;headers = (<span class="keyword">struct</span> ResponseHeader*)<span class="built_in">malloc</span>(size);     <span class="comment">//开辟存放响应头的空间</span></span><br><span class="line">	response-&gt;statusCode = Unknown;          <span class="comment">//初始化状态码为未知</span></span><br><span class="line">	<span class="comment">//初始化数组</span></span><br><span class="line">	<span class="built_in">bzero</span>(response-&gt;headers, size);</span><br><span class="line">	<span class="built_in">bzero</span>(response-&gt;statusMsg, <span class="built_in">sizeof</span>(response-&gt;statusMsg));     <span class="comment">//状态描述</span></span><br><span class="line">	<span class="built_in">bzero</span>(response-&gt;fileName, <span class="built_in">sizeof</span>(response-&gt;fileName));       <span class="comment">//文件名</span></span><br><span class="line">	<span class="comment">//函数指针</span></span><br><span class="line">	response-&gt;sendDataFunc = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponseDestroy</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (response != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(response-&gt;headers);      <span class="comment">//释放响应头数组</span></span><br><span class="line">		<span class="built_in">free</span>(response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponseAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (response == <span class="literal">NULL</span> || key == <span class="literal">NULL</span> || value == <span class="literal">NULL</span>) &#123;      <span class="comment">//当着三个1其中一个出现空时，都是错误的</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(response-&gt;headers[response-&gt;headerNum].key, key);          <span class="comment">//c语言不能直接赋值，需要进行拷贝</span></span><br><span class="line">	<span class="built_in">strcpy</span>(response-&gt;headers[response-&gt;headerNum].value, value);      <span class="comment">//拷贝value</span></span><br><span class="line">	response-&gt;headerNum++;                                            <span class="comment">//元素个数++</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组织http响应数据(将之前添加到response里面的数据写入到sendBuf里面)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponsePrepareMsg</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//状态行</span></span><br><span class="line">	<span class="type">char</span> tmp[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">sprintf</span>(tmp, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, response-&gt;statusCode, response-&gt;statusMsg);      <span class="comment">//拼接状态行到tmp</span></span><br><span class="line">	<span class="built_in">bufferAppendString</span>(sendBuf, tmp);                                                   <span class="comment">//将数据tmp写到sendBuf</span></span><br><span class="line">	<span class="comment">//响应头</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; response-&gt;headerNum; i++) &#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s: %s\r\n&quot;</span>, response-&gt;headers[i].key, response-&gt;headers[i].value);</span><br><span class="line">		<span class="built_in">bufferAppendString</span>(sendBuf, tmp);               <span class="comment">//将拼接的响应头中的每一行都依次存入到sendBuf</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空行</span></span><br><span class="line">	<span class="built_in">bufferAppendString</span>(sendBuf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	<span class="comment">//目前，http响应体(状态行、状态头、空行)已经组织好放在了sendbuf(如果采用边发边发送的模式，就可以先发送了)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO                                  <span class="comment">//如果定义了该宏(说明使用一起发的模式)，下面代码就无效</span></span></span><br><span class="line">	<span class="built_in">bufferSendData</span>(sendBuf, socket);                   <span class="comment">//发送数据(先将sendbuf里面的数据先发送)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//回复的数据(该函数指针指向的是两个目录，一个是发送目录，一个是发送文件)，在processHttpRequest函数里面就让该函数指针指向对应的函数地址</span></span><br><span class="line">	response-&gt;<span class="built_in">sendDataFunc</span>(response-&gt;fileName, sendBuf, socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程：</p>
<p>从main()函数开始，先通过函数tcpServerInit()创建一个服务器的实例，并设置了主线程启动后，它线程池里面的子线程个数为4，这样就得到了一个服务器的实例对象server，随后就可以调用它的一个Run方法了。</p>
<p>在启动服务器的时候，就是把线程池启动起来，并且把用于监听的套接字用于封装，然后把它放到了当前主线程对应的反应堆模型里面，之后主线程的反应堆模型就运行起来了，那么它底层的pool、epool或select也就运行起来了。它就可以检测监听描述符lfd里面的事件，这里是指读事件。如果有新的客户端连接，读事件就触发了，然后读回调函数acceptConnection就被调用了。</p>
<p>在读回调函数acceptConnection里，它第一件事就是和客户端建立连接得到了一个通信的文件描述符，然后从主线程里面取出了一个子线程，并且把子线程的反应堆模型evLoop取出来，然后把用于通信的文件描述符放到了evLoop里面。在tcpConnectionInit()函数里面，其实就是把cfd进行了封装，最终得到了一个新的channel，然后把这个channel放到了evLoop子线程的反应堆模型里面。</p>
<p>总的来说，就是当主线程建立连接之后，它并不会去处理与客户端的通信，和客户端的通信全都是在子线程里面处理的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://lxxl9313.online">lxx9339-T</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lxxl9313.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/">http://lxxl9313.online/2024/08/20/Http高并发服务器项目/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lxxl9313.online" target="_blank">-lxxl-</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/Http/">Http</a></div><div class="post_share"><div class="social-share" data-image="/img/22.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/21/%E5%85%AB%E8%82%A1%E6%96%871/" title="八股文1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/one.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">八股文1</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/" title="Qt斗地主项目(下)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/23.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Qt斗地主项目(下)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/03/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="Linux基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-03</div><div class="title">Linux基础知识</div></div></a></div><div><a href="/2024/07/24/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9C%A8%E7%BA%BF%E8%AF%8D%E5%85%B8/" title="linux网络编程小项目-在线词典"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/15.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">linux网络编程小项目-在线词典</div></div></a></div><div><a href="/2024/07/06/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/" title="shell脚本编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/7.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-06</div><div class="title">shell脚本编程</div></div></a></div><div><a href="/2024/07/26/%E7%BB%93%E5%90%88epoll%E5%92%8Chttp%E5%AE%9E%E7%8E%B0BS%E6%A8%A1%E5%BC%8F/" title="结合epoll和http实现B&#x2F;S模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-26</div><div class="title">结合epoll和http实现B&#x2F;S模式</div></div></a></div><div><a href="/2024/07/06/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/" title="静态库与动态库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-06</div><div class="title">静态库与动态库</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lxx9339-T</div><div class="author-info__description">即使身处阴沟,也能仰望星空。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">53</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2235221711@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2235221711&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8D%95%E5%8F%8D%E5%BA%94%E5%A0%86%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. 单反应堆的服务器模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%A4%9A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">3. 多反应堆的服务器模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Http%E5%8D%8F%E8%AE%AE"><span class="toc-text">4. Http协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-http%E8%AF%B7%E6%B1%82"><span class="toc-text">4.1 http请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-get%E8%AF%B7%E6%B1%82"><span class="toc-text">4.2 get请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-post%E8%AF%B7%E6%B1%82"><span class="toc-text">4.3 post请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-http%E5%93%8D%E5%BA%94"><span class="toc-text">4.4 http响应</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%A4%9A%E5%8F%8D%E5%BA%94%E5%A0%86-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5. 多反应堆+线程池高并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.1反应堆模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B0%81%E8%A3%85%E7%B1%BBchannel"><span class="toc-text">文件描述符封装类channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85channel%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BBChannelMap"><span class="toc-text">封装channel的容器类ChannelMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E7%B1%BBdispatcher"><span class="toc-text">IO复用技术类dispatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%B1%BBEventLoop"><span class="toc-text">事件循环类EventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">5.2 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BBThreadPool"><span class="toc-text">线程池类ThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%B1%BBWorkerThread"><span class="toc-text">工作线程类WorkerThread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">5.3 IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%BC%93%E5%AD%98%E5%8C%BA%E7%B1%BBBuffer"><span class="toc-text">读写缓存区类Buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tcp%E9%80%9A%E4%BF%A1%E7%B1%BBTcpConnection"><span class="toc-text">Tcp通信类TcpConnection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">5.4 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TcpServer%E7%B1%BB"><span class="toc-text">TcpServer类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Http"><span class="toc-text">5.5 Http</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E7%B1%BBHttpRequest"><span class="toc-text">接收请求类HttpRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E7%BB%87%E5%93%8D%E5%BA%94%E4%BD%93%E7%B1%BBHttpResponse"><span class="toc-text">组织响应体类HttpResponse</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/CMake%E5%9F%BA%E7%A1%80/" title="CMake基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/34.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake基础"/></a><div class="content"><a class="title" href="/2025/03/31/CMake%E5%9F%BA%E7%A1%80/" title="CMake基础">CMake基础</a><time datetime="2025-03-31T14:41:39.000Z" title="发表于 2025-03-31 22:41:39">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/git%E5%AD%A6%E4%B9%A0/" title="git学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/36.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git学习"/></a><div class="content"><a class="title" href="/2025/03/26/git%E5%AD%A6%E4%B9%A0/" title="git学习">git学习</a><time datetime="2025-03-26T13:25:44.000Z" title="发表于 2025-03-26 21:25:44">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/Qt%E6%93%8D%E4%BD%9C/" title="Qt操作"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/35.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt操作"/></a><div class="content"><a class="title" href="/2025/03/26/Qt%E6%93%8D%E4%BD%9C/" title="Qt操作">Qt操作</a><time datetime="2025-03-26T04:21:04.000Z" title="发表于 2025-03-26 12:21:04">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/04/protobuf/" title="protobuf"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/33.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="protobuf"/></a><div class="content"><a class="title" href="/2025/03/04/protobuf/" title="protobuf">protobuf</a><time datetime="2025-03-04T05:48:23.000Z" title="发表于 2025-03-04 13:48:23">2025-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/" title="数据库mysql"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/32.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库mysql"/></a><div class="content"><a class="title" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/" title="数据库mysql">数据库mysql</a><time datetime="2025-01-10T06:46:50.000Z" title="发表于 2025-01-10 14:46:50">2025-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> lxx9339-T</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.lxx93.online/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))

    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.31/dist/twikoo.all.min.js').then(init)
  }

  if ('Twikoo' === 'Twikoo' || !true       //软加载打开，可以提高网址性能) {
    if (true       //软加载打开，可以提高网址性能) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="12221117397" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script> - <script data-pjax defer src="https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'a24c62babc5b484d932b02c4747b0f56';
  var gaud_map_key = '9bcdd4b88228b310aa9787a1153666fd';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '103.719156,36.104195';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>