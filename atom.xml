<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>-lxxl-</title>
  
  <subtitle>我们一起去偷月亮吧</subtitle>
  <link href="https://lxx93.online/atom.xml" rel="self"/>
  
  <link href="https://lxx93.online/"/>
  <updated>2025-05-11T14:32:49.728Z</updated>
  <id>https://lxx93.online/</id>
  
  <author>
    <name>lxx9339-T</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMake基础</title>
    <link href="https://lxx93.online/2025/03/31/CMake%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2025/03/31/CMake%E5%9F%BA%E7%A1%80/</id>
    <published>2025-03-31T14:41:39.000Z</published>
    <updated>2025-05-11T14:32:49.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CMake概述"><a href="#1-CMake概述" class="headerlink" title="1.CMake概述"></a>1.CMake概述</h1><p>​         CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们所熟知的还有Makefile(通过 make 命令进行项目的构建)，大多数IDE软件都集成了make，比如：VS 的 nmake、linux 下的 GNU make、Qt 的 qmake等，如果自己动手写 makefile，会发现，makefile 通常依赖于当前的编译平台，而且编写 makefile 的工作量比较大，解决依赖关系时也容易出错。</p><p>​        而CMake恰好能解决上述问题， 其允许开发者指定整个工程的编译流程，在根据编译平台，自动生成本地化的Makefile和工程文件，最后用户只需make编译即可，所以可以把CMake看成一款自动生成 Makefile的工具，其编译流程如下图：</p><p><img src="/.online//图床数据\必备技能skills\7.png"></p><ul><li>蓝色虚线表示使用<code>makefile</code>构建项目的过程</li><li>红色实线表示使用<code>cmake</code>构建项目的过程</li></ul><p>优点：</p><ul><li>跨平台</li><li>能够管理大型项目</li><li>简化编译构建过程和编译过程</li><li>可扩展：可以为cmake编写特定功能的模块，扩充cmake功能</li><li>支持生成几乎所有主流IDE的项目</li></ul><p>缺点：</p><ul><li>cmake新版本与老版本变化有点大，API不稳定(cmake还在成长)</li></ul><p><strong>CMake没有阻碍C++的发展，相反CMake拯救了C++</strong></p><ul><li>相比其它语言的构建工具，CMake自然要复杂很多，但这不是CMake的问题。相比其它的编程语言，C&#x2F;C++更关注底层和构建其它的编程语言，即往往用于原始创新的项目，因此C&#x2F;C++面临的问题(环境)与其它编程语言不是很一样，也就导致CMake比较困难</li><li>正因为CMake的出现，C++才终于完成了项目跨平台(以前很难跨平台)</li></ul><p>CMake与Makefile、Make的关系</p><ul><li><p>Makefile并不跨平台，Cmake会根据编译器的类型来决定是否生成Makefile，大多数情况下CMake会生产Makefile</p></li><li><p>大型项目不推荐手动编写Makefile</p></li><li><p>Make工具(类似批处理工具)是通过调用makefile文件中的命令实现编译和链接的，最好不要在cmake中使用make命令</p></li><li><p>make是一个自动化构建工具，用于根据规则生成目标文件(如可执行文件、库文件等)。它通过读取一个名为Makefile或makefile的配置文件来确定如何构建项目</p></li><li><p>makefile是make工具的配置文件，它定义了如何构建项目</p></li></ul><p>CMake命令行执行流程：</p><p>1.编写CMakeLists.txt文件，下面是最基本的配置</p><ul><li>cmake_minimum_required(VERSION 3.20)     #指定最小版本3.20</li><li>project(Hello)       #指定项目名称</li><li>add_executable(Hello hello.cpp)   #由源文件(.cpp)生成一个可执行的程序(二进制文件)</li></ul><p>2.cmake -B build</p><ul><li>创建一个build(名字任取)，并在此目录下生成makefile或其它文件</li></ul><p>3.cmake –build build(步骤2生成的文件夹名)</p><ul><li>生成项目</li></ul><h1 id="2-Windows下用CMake构建项目"><a href="#2-Windows下用CMake构建项目" class="headerlink" title="2.Windows下用CMake构建项目"></a>2.Windows下用CMake构建项目</h1><h2 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h2><p>官网下载：<a href="https://cmake.org/download/">(https://cmake.org/download/)</a></p><p><img src="/.online//图床数据\必备技能skills\8.png"></p><p>Windows下的build system generator</p><ul><li>cmake默认的编译器是MSVC  (vs2022与vs2019)</li><li>可用安装MinGW  (gcc与clang)</li><li>cmake参数：<code>cmake -G &lt;generator-name&gt; -T &lt;toolset-spec&gt; -A &lt;platform-name&gt; &lt;path-to-source&gt;</code> </li><li>通过指定-G “MinGW Makefile” 来指定cmake使用gcc</li></ul><p>补充：</p><ul><li><code>MSVC</code>：是微软为 Windows 平台提供的 C++ 编译器及工具链，深度集成在 Visual Studio 开发环境中。它专注于 Windows 开发，提供了丰富的调试工具和性能优化</li><li><code>MinGW</code>：是基于 GNU 工具链(GCC)的 Windows 实现，旨在为 Windows 提供一个轻量级的开发环境</li></ul><p><strong>MSVC 和 MinGW 都是 Windows 系统上用于编译 C++ 代码的编译器工具链，开发者可以根据自己的需求选择其中一种来编译项目</strong></p><h2 id="cmake下通过MSVC构建项目"><a href="#cmake下通过MSVC构建项目" class="headerlink" title="cmake下通过MSVC构建项目"></a>cmake下通过MSVC构建项目</h2><p>1.创建一个文件夹<code>CMake_study</code>，在该文件夹下：</p><ul><li><p>编写源文件<code>hello.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建CMakeLists.txt配置文件，进行编写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(Hello)</span><br><span class="line"><span class="keyword">add_executable</span>(Hello hello.cpp)</span><br></pre></td></tr></table></figure></li></ul><p>2.vscode中将终端切换为git bash，执行<code>cmake -B build_MSVC</code>，创建一个<code>build_MSVC</code>文件夹，并在此文件夹下生成makefile或其它文件(关于cmake的项目)</p><p>3.执行<code>cmake --build build_MSVC</code>，在<code>build_MSVC\Debug</code>下生成可执行文件</p><h2 id="cmake下通过MinGW构建项目"><a href="#cmake下通过MinGW构建项目" class="headerlink" title="cmake下通过MinGW构建项目"></a>cmake下通过MinGW构建项目</h2><p>1.与上面第一个步骤一样，在<code>CMake_study</code>下编写hello.cpp源文件和CMakeLists.txt配置文件</p><p>2.git bash终端执行<code>cmake -B build_MinWG -G &quot;MinGW Makefiles&quot;</code>，创建一个<code>build_MinWG</code>文件夹，里面的文件通过gcc</p><p>来编译生成的(通过指定了编译器名称MinGW Makefiles)</p><p>3.执行<code>cmake --build build_MinGw</code>，在build_MSVC下生成可执行文件</p><h1 id="CMake语法"><a href="#CMake语法" class="headerlink" title="CMake语法"></a>CMake语法</h1><p>下面主要通过在.cmake文件里面编写语法来执行，创建一个first.cmake文件进行编写内容</p><p>运行.cmake文件：</p><ul><li><code>cmake -P .cmake文件名</code></li></ul><p>1.输入输出message()</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(hello)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;abc</span></span><br><span class="line"><span class="string">def&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>([[xyz</span><br><span class="line">aaa]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取CMAKE中的信息，通过$&#123;&#125;</span></span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;CMAKE_VERSION&#125;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/.online//图床数据\必备技能skills\9.png"></p><p>2.变量操作set、list</p><ul><li>CMake中的变量分为两种，即CMake提供和自定义的</li><li>CMake变量的命名区分大小写</li><li>CMake中的变量在存储时都是字符串</li><li>CMake获取变量方式：${变量名}</li><li>变量的基础操作是set()与unset()，但也可以用list或是string操作变量</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-CMake概述&quot;&gt;&lt;a href=&quot;#1-CMake概述&quot; class=&quot;headerlink&quot; title=&quot;1.CMake概述&quot;&gt;&lt;/a&gt;1.CMake概述&lt;/h1&gt;&lt;p&gt;​         CMake 是一个项目构建工具，并且是跨平台的。关于项目构建我们</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="https://lxx93.online/2025/03/26/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lxx93.online/2025/03/26/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-26T13:25:44.000Z</published>
    <updated>2025-07-27T02:51:41.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1.Git概述"></a>1.Git概述</h1><p>Git是一个免费的、开源的<code>分布式版本控制系统</code>，可以快速高效地处理从小型到大型的各种项目。Git易于学习，占地面积小，性能极快。它具有廉价的本地库、方便的暂存区域和多个工作流分支等特性，其性能优于Subversion、CVS、Perforce和ClearCase等版本工具。</p><p><code>版本控制</code>：是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。其最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><code>集中式版本控制</code>：诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或者提交更新。</p><ul><li>优点：每个人都可以在一定程度上看到项目中的其它人正在做些什么，而管理员也可以轻松掌握每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>缺点：中央服务器的单点故障问题，如果服务器死机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</li></ul><p><code>分布式版本控制</code>：诸如Git、Mercurial等，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)，这样任何一处协同工作用的文件发送故障，事后都可以用其它客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式版本控制系统解决了集中式版本控制系统的缺陷：</p><ul><li>服务器断网的情况下也可以进行开发(因为版本控制是在本地进行的)</li><li>每个客户端保存的也都是整个完整的项目(包含历史记录，更加安全)</li></ul><p>Git工作机制：</p><p><img src="/.online//图床数据\git\1.png"></p><p>代码托管中心：是基于网络服务器的远程代码仓库，一般简单称为<code>远程库</code></p><ul><li>局域网：GitLab</li><li>互联网：GitHub(外网)、Gitee码云(国内网站)</li></ul><h1 id="2-Git操作"><a href="#2-Git操作" class="headerlink" title="2.Git操作"></a>2.Git操作</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name 用户名</td><td align="center">设置用户签名</td></tr><tr><td align="center">git config –global user.email 邮箱</td><td align="center">设置用户签名</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息”文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看历史记录</td></tr><tr><td align="center">git reset –hard 版本号</td><td align="center">版本穿梭</td></tr></tbody></table><h2 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h2><p>基本语法：</p><ul><li><code>git config --global user.name lxx</code>93</li><li><code>git config --global user.email 2235221711@qq.com</code></li></ul><p>查看：在<code>C:\Users\PC</code>目录下的文件<code>.gitconfig</code>里面查看</p><p>作用：区分不同操作者身份，用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的(Git首次安装必须设置一下用户签名，否则无法提交代码)。</p><p>注意：这里设置的用户签名和将来登录Github(或其它代码托管中心)的账号没有任何关系。</p><h2 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h2><p>1.初始化本地库</p><p>首先需要选择一个仓库目录，这里使用目录<code>C:\study\git_study\git_demo</code>作为<code>工作区</code>，在该目录下打开git bash。</p><p>基本语法：</p><ul><li><code>git init</code></li></ul><p>结果：在该目录下会生成一个.git文件夹</p><p>2.查看本地库状态</p><p>基本语法：</p><ul><li><code>git status</code></li></ul><p><img src="/.online//图床数据\git\2.png"></p><p>解释：</p><ul><li><code>On branch master</code>：当前本地库在master分支里面</li><li><code>No commits yet</code>：当前没有提交过内容(还是空的git库)</li><li><code>nothing to commit</code>：当前没有什么可以提交(因为当前还没有要提交的文件)</li></ul><p>此时在该git_demo文件夹下添加hello.txt文件：</p><p><img src="/.online//图床数据\git\3.png"></p><p>解释：</p><ul><li><code>Untracked files</code>：表示未被追踪的文件(还没有将文件添加到暂存区)</li><li><code>红色</code>标记：表示文件还没有添加到暂存区</li></ul><p>3.将本地文件添加到<code>暂存区</code>(git追踪文件)</p><p>基本语法：</p><ul><li><code>git add 文件名</code></li></ul><p><img src="/.online//图床数据\git\4.png"></p><p>解释：</p><ul><li>当前git已经追踪到了文件hello.txt，此时该文件只是存在于暂存区(还可以删除，无历史版本)</li><li><code>绿色</code>标识：表示文件已经被添加到暂存区</li></ul><p>补充：将暂存区的文件删除，但该文件在工作区(git_demo目录下)还是存在的</p><ul><li><code>git rm --cached 文件名</code></li></ul><p>4.将暂存区的文件提交到本地库(可以形成一个历史版本)</p><p>基本语法：</p><ul><li><code>git commit -m “日志信息”文件名</code></li></ul><p><img src="/.online//图床数据\git\5.png"></p><p>5.查看历史版本</p><p>基本语法(两种方式)：</p><ul><li><code>git reflog</code></li><li><code>git log</code></li></ul><p><img src="/.online//图床数据\git\6.png" alt="6"></p><p>解释：git reflog查看到的是版本号的前7位，git log查看到的是完整的版本号、谁提交的该版本和提交时间</p><p>6.修改文件</p><p>操作1：修改文件hello.txt后再次查看本地库状态：</p><p><img src="/.online//图床数据\git\7.png"></p><p>解释：会提示文件被修改了，此时是红色标记，说明修改的文件还没有添加到暂存区</p><p>操作2：将修改的hello.txt上传到暂存区，查看状态，并提交到本地库</p><p><img src="/.online//图床数据\git\8.png"></p><p>操作3：查看历史版本</p><p><img src="/.online//图床数据\git\9.png"></p><p>解释：工作区里面永远只会显示一个文件(版本)，git底层是通过指针来控制各个版本的</p><p>7.版本穿梭</p><p>基本语法：</p><ul><li><code>git reset --hard 版本号</code></li></ul><p><img src="/.online//图床数据\git\10.png" alt="10"></p><p>解释：原来有三个版本，且指针是指向第三个版本的(工作区显示)，现在通过第二个版本的版本号，将版本穿梭回了第二个版本，此时工作区显示的就是第二个版本的文件内容了。</p><p>补充：<code>头指针(工作区能看到的内容)指向master分支，master分支指向当前版本号</code></p><ul><li><p>在.git目录下面的HEAD文件里面的内容是：</p><ul><li><code>ref: refs/heads/master</code>：表示指针指向的是master，当前是在master这个分支上</li></ul></li><li><p>在.git\refs\heads目录下的master文件里面的内容是当前master指向的版本号(完整)</p></li></ul><h1 id="3-分支"><a href="#3-分支" class="headerlink" title="3.分支"></a>3.分支</h1><p>在版本控制过程中，同时推进多个任务，为每个任务，可以创建每个任务的单独分支，使用分支意为着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。即当你文件里有内容时，如果这时你创建了一个副分支，那么在副分支下，你主分支里每个文件的内容，在副分支下都存在(相当于拷贝)，但分支底层其实也就是指针的引用。</p><p>优点：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可。</li></ul><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">把指定的分支合并到当前分支上</td></tr><tr><td align="center">git branch -d 分支名</td><td align="center">删除分支</td></tr></tbody></table><p>1.查看分支</p><p><img src="/.online//图床数据\git\11.png"></p><p>2.创建分支hot-fix</p><p><img src="/.online//图床数据\git\12.png"></p><p>3.切换分支</p><p><img src="/.online//图床数据\git\13.png"></p><p>4.合并操作</p><ul><li>正常合并：master分支没有修改文件，而hot-fix分支对文件进行修改了，所以将hot-fix分支合并到master分支后，文件的内容是hot-fix分支文件的内容(修改的)。</li></ul><p><img src="/.online//图床数据\git\14.png"></p><ul><li>冲突合并：当在主分支对某个文件hello.txt进行修改(如第一行)时，如果提交到了本地库，在副分支下是不会显示f1修改的内容(因为副分支之前已经创建过，相当于另一条分支了，如果是新创建一个分支，则该分支下会显示f1修改的内容)，如果这时你在副分支下，对f1第一行也进行了修改，并且提交到了本地库，当回到主分支进行合并副分支时，就会出现合并冲突，此时只能手动改。</li></ul><p>操作1：主分支和副分支分别修改同一个文件hello.txt，并且修改位置(修改的行)是一样的，又分别提交到本地库，在主分支上将副分支合并</p><p><img src="/.online//图床数据\git\15.png"></p><p>操作2：手动打开hello.txt文件进行修改(不需要哪些内容，删除即可)，修改完后进行保存</p><p><img src="/.online//图床数据\git\16.png"></p><p>操作3：将hello.txt提交到本地库(<code>使用git commit命令时不能带文件名了</code>)</p><p><img src="/.online//图床数据\git\17.png"></p><p>注意：此时master分支下hello.txt文件是手动修改后的内容，而hot-fix副分支下的hello.txt文件还是之前的内容。因为合并只会修改主分支的内容，即只会修改合并的那个分支，被合并的分支不会被修改。</p><p>5.总结</p><p><img src="/.online//图床数据\git\18.png"></p><p>master、hot-fix其实都是指向具体版本记录的指针，当前所在的分支是由HEAD决定的，所以<code>创建分支</code>的本质就是多创建一个指针。</p><ul><li>HEAD如果指向master，那么此时就在master分支上</li><li>HEAD如果指向hot-fix，那么此时就在hot-fix分支上</li><li>所以<code>切换分支</code>的本质就是移动HEAD指针</li></ul><h1 id="4-Git团队协作机制"><a href="#4-Git团队协作机制" class="headerlink" title="4.Git团队协作机制"></a>4.Git团队协作机制</h1><p>1.团队内协作</p><ul><li>电脑A初始化了一个本地库，通过<code>push</code>命令可以将自己本地库下面的代码推送到<code>代码托管中心</code>，即产生一个远程库A</li><li>电脑B可以通过<code>clone</code>命令将远程库A里面的代码克隆到自己的本地库</li><li>电脑B在本地库对克隆的代码进行修改后，通过<code>push</code>命令又推送到远程库A(前提：电脑A将电脑B拉进该项目的团队里面)</li><li>电脑A就可以通过<code>pull</code>命令来拉取远程库A里面电脑B修改的代码，更新到自己的本地库(电脑B、远程库、电脑A的数据同步了)</li></ul><p>2.跨团队协作</p><ul><li>在代码托管中心，远程库B通过<code>fork</code>命令得到远程库A里面的代码</li><li>电脑B通过<code>clone</code>命令将远程库B里面的代码克隆到自己的本地库</li><li>电脑B在本地库对克隆的代码进行修改后，通过<code>push</code>命令推送到远程库B</li><li>远程库B发一个拉取请求<code>Pull request</code>给远程库A</li><li>远程库A收到请求，进行审核</li><li>审核成功，远程库A就通过命令<code>merge</code>命令将远程库B的代码合并过来</li><li>电脑A就可以通过<code>pull</code>命令来拉取合并后的远程库A的代码，更新到自己的本地库</li></ul><h1 id="5-远程库"><a href="#5-远程库" class="headerlink" title="5.远程库"></a>5.远程库</h1><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td align="center">查看当前所有远程地址别名</td></tr><tr><td align="center">git remote add 别名 远程库地址</td><td align="center">给远程库起别名</td></tr><tr><td align="center">git push 别名 分支</td><td align="center">推送本地分支上的内容到远程库</td></tr><tr><td align="center">git clone 远程地址</td><td align="center">将远程库的内容克隆到本地</td></tr><tr><td align="center">git pull 远程库地址别名 远程分支名</td><td align="center">将远程库对于分支最新的内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h2 id="创建远程库-创建别名"><a href="#创建远程库-创建别名" class="headerlink" title="创建远程库&amp;创建别名"></a>创建远程库&amp;创建别名</h2><p>1.登录github账号，点击右上角的<code>+</code>，点击<code>New repository</code></p><p><img src="/.online//图床数据\git\19.png"></p><p>2.在新建远程库页面设置库名git-demo(在自己账号下不能重名)，选择公开</p><p><img src="/.online//图床数据\git\20.png"></p><p>3.进入远程库git-demo，复制远程库链接</p><p><img src="/.online//图床数据\git\21.png"></p><p>4.创建别名</p><ul><li><code>git remote -v</code>：查看当前所有远程地址别名</li><li><code>git remote add 别名 远程地址</code>：为远程库创建别名，下面通过<code>git-demo</code>为别名</li></ul><p><img src="/.online//图床数据\git\22.png"></p><p>解释：当创建好别名后，再查看当前所有远程库别名就会出现两个git-demo，因为该别名即可用拉取<code>fetch</code>，也可用用来推送<code>push</code>。</p><p>5.推送本地库</p><ul><li><code>git push 别名 分支(test1)</code>：<ul><li>如果没有给远程库设置别名，也可以使用链接</li><li>代码含义：将本地库的test1分支推送到远程库的test1分支</li></ul></li></ul><p><img src="/.online//图床数据\git\23.png"></p><p><img src="/.online//图床数据\git\24.png"></p><p>6.拉取远程库到本地库(本地库本身有相关文件，拉取只是对本地进行一个更新)</p><ul><li><code>git pull 远程库地址别名 远程分支名</code></li></ul><p>如果自己本地库推送到远程库后，远程库对文件进行了更新，现在将其拉取到本地库。</p><p><img src="/.online//图床数据\git\25.png"></p><p>解释：拉取下来后，查看本地库状态是干净的，说明拉取动作(拉取到本地库的文件)会自动提交到本地库。最后结果就是本地库的代码和远程库的代码已经同步了。</p><p>7.克隆远程库到本地(本地库本身没有相关文件)</p><ul><li><code>git clone 远程库链接</code></li></ul><p>首先需要先新建一个文件夹(新本地库)git-clone，如果这个本地库还是在自己电脑上，需要在凭据管理器先删除之前本地库的凭据(windows同时只能记住一个账号)。其次是需要获取远程库的链接</p><p><img src="/.online//图床数据\git\26.png"></p><p>然后在git-clone本地库执行<code>git clone 远程库链接</code>，即可完成克隆操作</p><p>注意：执行clone命令后，会默认完成工作：(1)拉取代码、(2)初始化本地库、(3)创建别名</p><h1 id="6-团队内协作"><a href="#6-团队内协作" class="headerlink" title="6.团队内协作"></a>6.团队内协作</h1><p>1.公司将自己的代码推送到了github的远程库，员工a通过<code>clone</code>命令将远程库的代码克隆到自己电脑的本地库，并修改了该代码，现在准备将修改的代码推送到公司github账号下的远程库上(员工推送需要使用到自己的github账号)。</p><p>2.如果只通过命令<code>git push 公司远程库链接 分支</code>将会报错，提示没有权限。需要在公司github账号中，将员工a的账号添加到该库的成员</p><p><img src="/.online//图床数据\git\27.png"></p><p>3.添加成功后，公司的github账号会出现对应的邀请函链接，公司将该链接发给员工a</p><p>4.员工a得到该邀请函链接后在自己电脑上打开该链接，点击同意加入，员工a的github账号中就有公司对应的远程库了</p><p>5.员工通过<code>git push 公司远程库链接 分支</code>命令即可完成推送，公司远程库下的代码也就完成了修改</p><h1 id="7-github的SSH免密登录"><a href="#7-github的SSH免密登录" class="headerlink" title="7.github的SSH免密登录"></a>7.github的SSH免密登录</h1><p>本地库与远程库的拉取和推送不仅可以用https协议链接来完成，也可用通过ssh协议链接来完成，但需要先完成ssh免密登录(在本地库电脑上生成公钥与私钥，绑定固定github账号用于免密登录)。</p><p>1.在<code>C:\Users\PC</code>目录下打开git bash，通过命令<code>ssh-keygen -t rsa -C github绑定的邮箱</code>即可在目录下生成员工<code>.ssh</code>文件夹，文件夹下有生成的公钥与私钥。</p><p><img src="/.online//图床数据\git\28.png"></p><p>2.打开<code>.ssh</code>文件夹下的文件id_rsa.pub，复制里面的公钥设置到远程库所在的github账号里面</p><p><img src="/.online//图床数据\git\29.png"></p><p>设置公钥：</p><p><img src="/.online//图床数据\git\30.png"></p><p>完成后弹出界面：</p><p><img src="/.online//图床数据\git\31.png"></p><p>3.可用通过如下命令对远程库进行推送和拉取</p><ul><li>从远程库通过ssh链接拉取到本地库：<code>git pull 远程库ssh链接 master</code></li><li>从本地库通过ssh链接推送到远程库：<code>git push 远程库ssh链接 master</code></li></ul><h1 id="补：上传分支到远程库"><a href="#补：上传分支到远程库" class="headerlink" title="补：上传分支到远程库"></a>补：上传分支到远程库</h1><p>本地只保留一个开发分支master，每次修改代码后都提交到本地库，创建一个分支，将该分支上传到远程库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常提交到 main 分支</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;day1day2&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建临时分支（不切换过去）</span></span><br><span class="line">git branch 1_2day</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送本地 1day 分支到远程（作为快照）</span></span><br><span class="line">git push origin 1_2day</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Git概述&quot;&gt;&lt;a href=&quot;#1-Git概述&quot; class=&quot;headerlink&quot; title=&quot;1.Git概述&quot;&gt;&lt;/a&gt;1.Git概述&lt;/h1&gt;&lt;p&gt;Git是一个免费的、开源的&lt;code&gt;分布式版本控制系统&lt;/code&gt;，可以快速高效地处理从小型到大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt操作</title>
    <link href="https://lxx93.online/2025/03/26/Qt%E6%93%8D%E4%BD%9C/"/>
    <id>https://lxx93.online/2025/03/26/Qt%E6%93%8D%E4%BD%9C/</id>
    <published>2025-03-26T04:21:04.000Z</published>
    <updated>2025-05-29T15:53:29.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Qt中多线程的使用"><a href="#一、Qt中多线程的使用" class="headerlink" title="一、Qt中多线程的使用"></a>一、Qt中多线程的使用</h1><p>在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。</p><p>1.在qt中使用了多线程，有些事项是需要额外注意的：</p><ul><li>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</li><li>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</li><li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制(即如果子线程需要对窗口的数据进行修改，只能先通过connect发送给主线程，由主线程对窗口进行修改，而子线程不能直接对窗口进行修改)。</li></ul><h2 id="使用方式1"><a href="#使用方式1" class="headerlink" title="使用方式1"></a>使用方式1</h2><ul><li>创建一个线程类的子类，让其继承QT中的线程类 QThread</li><li>重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程</li><li>在主线程中创建子线程对象，new 一个就可以了</li><li>启动子线程, 调用 start() 方法</li></ul><p>案例：创建一个子线程文件，里面定义三个子线程类，使其继承QThread，分别重写虚函数run，子线程需要执行的任务都写在该函数里面。而在主线程中，先创建该类的一个对象，调用start函数，则表示启动子线程(run()函数)。</p><p>下面创建了一个MyThread.h文件，在该文件里面创建了三个子线程类，分别是</p><ul><li>Generate类：生成随机数</li><li>BubbleSort类：对生成的随机数进行冒泡排序</li><li>QuickSort类：对生成的随机数进行快速排序</li></ul><p>子线程头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvNum</span><span class="params">(<span class="type">int</span> num)</span></span>;            <span class="comment">//槽函数，复制要生成的随机数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子线程的执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::recvNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;m_num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_list[j]&gt;m_list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j+<span class="number">1</span>];</span><br><span class="line">                m_list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(m_list,<span class="number">0</span>,m_list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程的执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::recvNum); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        gen-&gt;<span class="built_in">start</span>();     <span class="comment">//启动子线程，即执行子线程的run方法(生成随机数)</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::recvArray);     <span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::recvArray);       <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;        <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       bubble-&gt;<span class="built_in">start</span>();        <span class="comment">//启动冒牌排序子线程</span></span><br><span class="line">       quick-&gt;<span class="built_in">start</span>();         <span class="comment">//启动快速排序子线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/.online//图床数据\Qt\8_6.png"></p><h2 id="使用方式2"><a href="#使用方式2" class="headerlink" title="使用方式2"></a>使用方式2</h2><p>Qt提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些。</p><ul><li>创建一个新的类(如MyWork)，让这个类从QObject派生</li><li>在这个类中添加一个公共的成员函数，如working()，函数体就是我们要子线程中执行的业务逻辑</li><li>在主线程中创建一个QThread对象, 这就是子线程的对象</li><li>在主线程中创建工作的类对象(千万不要指定给创建的对象指定父对象)</li><li>将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的moveToThread()方法</li><li>启动子线程，调用 start(), 这时候线程启动了, 但是移动到线程中的对象(任务)并没有工作</li><li>调用MyWork类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><p>主窗口的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数执行函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    QThread* t1=<span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* t2=<span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* t3=<span class="keyword">new</span> QThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建任务类对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将任务对象移动到某个子线程中</span></span><br><span class="line">    gen-&gt;<span class="built_in">moveToThread</span>(t1);</span><br><span class="line">    bubble-&gt;<span class="built_in">moveToThread</span>(t2);</span><br><span class="line">    quick-&gt;<span class="built_in">moveToThread</span>(t3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::working); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        t1-&gt;<span class="built_in">start</span>();  <span class="comment">//启动子线程，即执行子线程的working()方法(生成随机数)，没有start，是不会执行working函数的</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::working);  <span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::working);   <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       t2-&gt;<span class="built_in">start</span>();        <span class="comment">//启动冒牌排序子线程</span></span><br><span class="line">       t3-&gt;<span class="built_in">start</span>();         <span class="comment">//启动快速排序子线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的执行函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::working</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j]&gt;list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = list[j];</span><br><span class="line">                list[j] = list[j+<span class="number">1</span>];</span><br><span class="line">                list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(list,<span class="number">0</span>,list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h1><p>​        在Qt中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个QRunnable类型，因此在程序中需要创建子类继承QRunnable这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p><p>主线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvNum</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主线程执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建任务对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::recvNum); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(gen);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::recvArray);<span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::recvArray); <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(bubble);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">       QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(quick);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置当前类的对象放到线程池中后，工作完毕能自动析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::recvNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;m_num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_list[j]&gt;m_list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j+<span class="number">1</span>];</span><br><span class="line">                m_list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(m_list,<span class="number">0</span>,m_list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、基于TCP的Qt网络通信"><a href="#三、基于TCP的Qt网络通信" class="headerlink" title="三、基于TCP的Qt网络通信"></a>三、基于TCP的Qt网络通信</h1><p>使用Qt提供的类进行基于TCP的套接字通信需要用到两个类：</p><ul><li>QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。</li><li>QTcpSocket：通信的套接字类，客户端、服务器端都需要使用。</li></ul><p>这两个套接字通信类都属于网络模块<code>network</code>。</p><blockquote><p>在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由Qt框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。</p></blockquote><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>通信流程：</p><ul><li>创建套接字服务器QTcpServer对象</li><li>通过QTcpServer对象设置监听，即：QTcpServer::listen()</li><li>基于QTcpServer::newConnection()信号检测是否有新的客户端连接</li><li>如果有新的客户端连接调用QTcpSocket *QTcpServer::nextPendingConnection()得到通信的套接字对象</li><li>使用通信的套接字对象QTcpSocket和客户端进行通信</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li>创建通信的套接字类QTcpSocket对象</li><li>使用服务器端绑定的IP和端口连接服务器QAbstractSocket::connectToHost()</li><li>使用QTcpSocket对象和服务器进行通信</li></ul><p>案例1：通过服务端&#x2F;客户端实现数据发送</p><p>服务端头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_setListen_clicked</span><span class="params">()</span></span>;      <span class="comment">//点击 启动监听服务 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendMsg_clicked</span><span class="params">()</span></span>;        <span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpServer* m_s;        <span class="comment">//监听的服务器对象(监听描述符)</span></span><br><span class="line">    QTcpSocket* m_tcp;      <span class="comment">//通信的套接字对象(通信描述符)</span></span><br><span class="line">    QLabel* m_status;       <span class="comment">//状态栏里面的label对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务端执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);     <span class="comment">//端口号默认设置为8899</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;服务器&quot;</span>);       <span class="comment">//给窗口添加标题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监听的服务器对象</span></span><br><span class="line">    m_s = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);       <span class="comment">//指定父对象，窗口关闭自动析构服务器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端监听的时候，当有客户端连接到达时，就会发出信号newConnection</span></span><br><span class="line">    <span class="built_in">connect</span>(m_s, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_tcp = m_s-&gt;<span class="built_in">nextPendingConnection</span>();     <span class="comment">//得到一个用于通信的套接字对象(实例化)</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/connect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//改为连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">        <span class="comment">//检测客户点是否发来数据(当接收到readyRead信号的时候，就可以接收数据了)</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();           <span class="comment">//接收所有数据</span></span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say：&quot;</span> + data);    <span class="comment">//将接收的数据显示在record框</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//当客户端断开连接，m_tcp会发出信号disconnected</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            m_tcp-&gt;<span class="built_in">close</span>();              <span class="comment">//关闭通信描述符</span></span><br><span class="line">            m_tcp-&gt;<span class="built_in">deleteLater</span>();        <span class="comment">//进行析构</span></span><br><span class="line">            m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));    <span class="comment">//状态栏的连接状态重新设置为为未连接状态</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;       <span class="comment">//创建一个label</span></span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//默认情况下是未连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加label</span></span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态：&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击窗口的 启动监听服务 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_setListen_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();    <span class="comment">//获取端口号(字符串类型)，转为无符号短整型</span></span><br><span class="line">    m_s-&gt;<span class="built_in">listen</span>(QHostAddress::Any, port);       <span class="comment">//进行监听(绑定了本地的任意一个ip地址，指定端口)</span></span><br><span class="line">    ui-&gt;setListen-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);           <span class="comment">//将该按钮设置为不可用状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMsg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();        <span class="comment">//以纯文本的方式读取要发送的信息</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());        <span class="comment">//将string类型转换为QByteArray类型进行写入发送</span></span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器say：&quot;</span> + msg);       <span class="comment">//将要发送的msg写入到record框</span></span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();           <span class="comment">//发送完毕后，清空输入框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendMsg_clicked</span><span class="params">()</span></span>;       <span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_connect_clicked</span><span class="params">()</span></span>;       <span class="comment">//点击 连接服务器 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_disconnect_clicked</span><span class="params">()</span></span>;    <span class="comment">//点击 断开连接 按钮触发的槽函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line">    QTcpSocket* m_tcp;      <span class="comment">//通信的套接字对象(通信描述符)</span></span><br><span class="line">    QLabel* m_status;       <span class="comment">//状态栏里面的label对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);     <span class="comment">//端口号默认设置为8899</span></span><br><span class="line">    ui-&gt;ip-&gt;<span class="built_in">setText</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;客户端&quot;</span>);       <span class="comment">//给窗口添加标题</span></span><br><span class="line">    ui-&gt;disconnect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);        <span class="comment">//刚开始时，断开连接 按钮不能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建通信的服务器对象</span></span><br><span class="line">    m_tcp = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);       <span class="comment">//实例化通信套接字对象，如果指定父对象this，窗口关闭自动析构服务器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测客户点是否发来数据(当接收到readyRead信号的时候，就可以接收数据了)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();           <span class="comment">//接收所有数据</span></span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务端say：&quot;</span> + data);    <span class="comment">//将接收的数据显示在record框</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当客户端断开连接，m_tcp会发出信号disconnected</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//m_tcp-&gt;deleteLater();  //进行析构(m_tcp创建时没有指定父对象，就在这里手动析构)--&gt;这里如果手动析构，断开后再连接就闪退</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));<span class="comment">//状态栏的连接状态重新设置为为未连接状态</span></span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务端与客户端断开了连接.....&quot;</span>);</span><br><span class="line">        ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);        <span class="comment">//断开连接后，连接按钮能使用</span></span><br><span class="line">        ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);      <span class="comment">//断开按钮不可以使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当客户端连接成功，就发出connected信号</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">       m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/connect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">       ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;已经成功连接到服务端.....&quot;</span>);</span><br><span class="line">       ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);        <span class="comment">//成功连接到服务端后，连接按钮不能使用</span></span><br><span class="line">       ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);      <span class="comment">//断开按钮可以使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;       <span class="comment">//创建一个label</span></span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//默认情况下是未连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加label</span></span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态：&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMsg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();        <span class="comment">//以纯文本的方式读取要发送的信息</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());        <span class="comment">//将string类型转换为QByteArray类型进行写入发送</span></span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say：&quot;</span> + msg);       <span class="comment">//将要发送的msg写入到record框</span></span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();           <span class="comment">//发送完毕后，清空输入框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 连接服务器 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_connect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString ip = ui-&gt;ip-&gt;<span class="built_in">text</span>();                       <span class="comment">//获取ip</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>(); <span class="comment">//获取端口</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip),port);      <span class="comment">//通过ip和端口进行连接服务端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 断开连接按钮，触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_disconnect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">close</span>();                         <span class="comment">//关闭通信套接字连接，后续会发出信号disconnected</span></span><br><span class="line">    ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);        <span class="comment">//断开连接后，连接按钮能使用</span></span><br><span class="line">    ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);      <span class="comment">//断开按钮不可以使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：通过服务端&#x2F;客户端实现文件发送(C:\Qt\study\socket_Qt)</p><h1 id="四、Json在Qt中使用"><a href="#四、Json在Qt中使用" class="headerlink" title="四、Json在Qt中使用"></a>四、Json在Qt中使用</h1><p>JSON(JavaScrip Object Notation)是一种轻量级的数据交换格式，它基于ECMAScript(欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON成为理想的数据交换语言，易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>可以理解为Json是一种数据格式，和语言无关，在什么语言中都可以使用Json，基于这种通用的数据格式，一般处理两方面任务：</p><ul><li>组织数据(数据序列化)，用于数据的网络传输</li><li>组数数据(数据序列化)，写磁盘文件实现数据的持久化存储(一般以<code>.json</code>作为文件后缀)</li></ul><p>Json中主要有两种数据格式：Json数组和Json对象，并且这两种格式可以交叉嵌套使用。</p><p>注意：在一个json文件中只能有一个Json数组或Json对象的根节点，不允许同时存储多个并列的根节点。</p><h2 id="Json数组"><a href="#Json数组" class="headerlink" title="Json数组"></a>Json数组</h2><p>Json数组使用[]表示，[]里面是元素，元素和元素之间使用逗号间隔，最后一个因素后边没有逗号，一个Json数组中支持同时存在多种不同类型的成员，包括：<code>整型</code>、<code>浮点</code>、<code>字符串</code>、<code>布尔类型</code>、<code>json数组</code>、<code>json对象</code>、<code>空值(null)</code>。可见Json数组比起c&#x2F;c++数组要灵活很多</p><h2 id="Json对象"><a href="#Json对象" class="headerlink" title="Json对象"></a>Json对象</h2><p>Json对象使用{}来描述，每个Json对象中可以存储若干个元素，每一个元素对应一个键值对(key：value结构)，元素和元素之间使用逗号间隔，最后一个元素后边没有逗号，对于每个元素中的键值对有以下需要注意：</p><ul><li>键值(key)必须是字符串，位于同一层级的键值不要重复(因为是通过键值取出对应的value值)</li><li>value值的类型是可选的，，可根据实际需求指定，可用类型包括：<code>整型</code>、<code>浮点</code>、<code>字符串</code>、<code>布尔类型</code>、<code>json数组</code>、<code>json对象</code>、<code>空值(null)</code></li></ul><p>从Qt 5.0开始提供了对Json的支持，我们可以直接使用Qt提供的Json类进行数据的组织和解析。相关的类常用的主要有四个，具体如下：</p><table><thead><tr><th align="center">Json类</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">QJsonDocument</td><td align="center">它封装了一个完整的JSON文档，并且可以从UTF-8编码的基于文本的表示以及Qt自己的二进制格式读取和写入该文档。</td></tr><tr><td align="center">QJsonArray</td><td align="center">JSON数组是一个值列表。可以通过从数组中插入和删除QJsonValue来操作该列表。</td></tr><tr><td align="center">QJsonObject</td><td align="center">JSON对象是键值对的列表，其中键是唯一的字符串，值由QJsonValue表示。</td></tr><tr><td align="center">QJsonValue</td><td align="center">该类封装了JSON支持的数据类型。</td></tr></tbody></table><h2 id="QJsonValue"><a href="#QJsonValue" class="headerlink" title="QJsonValue"></a>QJsonValue</h2><p>在Qt中QJsonValue可以封装的基础数据类型有六种(和Json支持的类型一致)，分别为：</p><ul><li>布尔类型：QJsonValue::Bool</li><li>浮点类型(包括整形)： QJsonValue::Double</li><li>字符串类型： QJsonValue::String</li><li>Json数组类型： QJsonValue::Array</li><li>Json对象类型：QJsonValue::Object</li><li>空值类型： QJsonValue::Null</li></ul><p>这些类型可以通过QJsonValue的构造函数被封装为一个类对象:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Json对象</span></span><br><span class="line">QJsonValue(const QJsonObject &amp;o);</span><br><span class="line"><span class="comment">// Json数组</span></span><br><span class="line">QJsonValue(const QJsonArray &amp;a);</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">QJsonValue(const char *s);</span><br><span class="line">QJsonValue(QLatin1String s);</span><br><span class="line">QJsonValue(const QString &amp;s);</span><br><span class="line"><span class="comment">// 整形 and 浮点型</span></span><br><span class="line">QJsonValue(qint64 v);</span><br><span class="line">QJsonValue(int v);</span><br><span class="line">QJsonValue(double v);</span><br><span class="line"><span class="comment">// 布尔类型</span></span><br><span class="line">QJsonValue(bool b);</span><br><span class="line"><span class="comment">// 空值类型</span></span><br><span class="line">QJsonValue(QJsonValue<span class="punctuation">:</span><span class="punctuation">:</span>Type type = Null);</span><br></pre></td></tr></table></figure><p>通过<code>QJsonValue</code>对象，判断内部封装的到底是什么类型的数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否是Json数组</span></span><br><span class="line">bool isArray() const;</span><br><span class="line"><span class="comment">// 是否是Json对象</span></span><br><span class="line">bool isObject() const;</span><br><span class="line"><span class="comment">// 是否是布尔类型</span></span><br><span class="line">bool isBool() const;</span><br><span class="line"><span class="comment">// 是否是浮点类型(整形也是通过该函数判断)</span></span><br><span class="line">bool isDouble() const;</span><br><span class="line"><span class="comment">// 是否是空值类型</span></span><br><span class="line">bool isNull() const;</span><br><span class="line"><span class="comment">// 是否是字符串类型</span></span><br><span class="line">bool isString() const;</span><br><span class="line"><span class="comment">// 是否是未定义类型(无法识别的类型)</span></span><br><span class="line">bool isUndefined() const;</span><br></pre></td></tr></table></figure><p>通过判断函数得到对象内部数据的实际类型之后，如果有需求就可以再次将其转换为对应的基础数据类型，对应的API函数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换为Json数组</span></span><br><span class="line">QJsonArray toArray(const QJsonArray &amp;defaultValue) const;</span><br><span class="line">QJsonArray toArray() const;</span><br><span class="line"><span class="comment">// 转换为布尔类型</span></span><br><span class="line">bool toBool(bool defaultValue = <span class="literal"><span class="keyword">false</span></span>) const;</span><br><span class="line"><span class="comment">// 转换为浮点类型</span></span><br><span class="line">double toDouble(double defaultValue = <span class="number">0</span>) const;</span><br><span class="line"><span class="comment">// 转换为整形</span></span><br><span class="line">int toInt(int defaultValue = <span class="number">0</span>) const;</span><br><span class="line"><span class="comment">// 转换为Json对象</span></span><br><span class="line">QJsonObject toObject(const QJsonObject &amp;defaultValue) const;</span><br><span class="line">QJsonObject toObject() const;</span><br><span class="line"><span class="comment">// 转换为字符串类型</span></span><br><span class="line">QString toString() const;</span><br><span class="line">QString toString(const QString &amp;defaultValue) const;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Qt中多线程的使用&quot;&gt;&lt;a href=&quot;#一、Qt中多线程的使用&quot; class=&quot;headerlink&quot; title=&quot;一、Qt中多线程的使用&quot;&gt;&lt;/a&gt;一、Qt中多线程的使用&lt;/h1&gt;&lt;p&gt;在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://lxx93.online/2025/03/04/protobuf/"/>
    <id>https://lxx93.online/2025/03/04/protobuf/</id>
    <published>2025-03-04T05:48:23.000Z</published>
    <updated>2025-05-09T14:07:30.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ProtoBuf概述"><a href="#1-ProtoBuf概述" class="headerlink" title="1.ProtoBuf概述"></a>1.ProtoBuf概述</h1><p>protobuf也叫protocol buffer，是google的一种数据交换的格式，它独立于语言，独立于平台。google提供了多种语言的实现，如java、c#、c++、go和python等，每一种实现都包含了相应语言的编译器以及库文件。</p><p>1.作用：</p><ul><li><p>数据的持久化存储</p><ul><li>序列化：将数据从内存存储到磁盘</li><li>反序列化：将数据从磁盘加载到内存</li></ul></li><li><p>数据的网络传输：客户端与服务端之间的数据传输</p><ul><li>序列化：对象到字节序列</li><li>反序列化：字节序列到对象</li></ul></li></ul><p>2.特点</p><ul><li>语言无关、平台无关：ProtoBuf支持java、c++、python等多种语言、支持多个平台</li><li>高效：比XML更小、更快、更为简单</li><li>扩展性、兼容性好：可以更新数据结构，而不影响和破坏原有的旧程序</li></ul><p>3.使用特点(c++)：ProtoBuf是需要依赖通过编译生成的头文件和源文件来使用的。</p><p>比如说对于常规发送消息，首先是需要定义一个Class类，在该类里面有：(1)一些列属性字段(要发送的)、(2)处理字段的方法、(3)处理类的方法(序列化、反序列化)。可以发现(2)和(3)是非常耗时，且对于开发者来说比较伤脑筋的，则通过protobuf就可以避免这些问题。</p><h1 id="2-ProtoBuf在window下的使用"><a href="#2-ProtoBuf在window下的使用" class="headerlink" title="2.ProtoBuf在window下的使用"></a>2.ProtoBuf在window下的使用</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>1.下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases"><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers&#x2F;protobuf</a></a></p><p>2.下载对应的压缩包，解压后在bin文件夹下有一个protoc.exe</p><p>3.在该文件夹下打开终端，执行protoc –version，打印对应版本即安装成功</p><p>4.为方便使用，将protoc.exe的目录添加到环境变量中</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>1.定义消息字段</p><p>在message中我们可以定义其属性字段，字段定义格式为：字段类型 字段名&#x3D;字段唯一编号；</p><ul><li>字段名称命名规范：全小写字母，多个字母之间用下划线_连接</li><li>字段类型分为：<strong>标量数据类型</strong> 和 <strong>特殊类型</strong>(包括枚举、其他消息类型等)</li><li>字段唯一编号：用来标识字段，一旦开始使用就不能够再改变</li></ul><p>该表格展示了定义消息体中的<strong>标量数据类型</strong>，以及编译.proto文件之后自动生成的类中与之对应的字段类型。再这里展示了与c++语言对应的类型。</p><table><thead><tr><th align="center">.proto type</th><th align="center">Notes</th><th align="center">c++ Type</th></tr></thead><tbody><tr><td align="center">double</td><td align="center"></td><td align="center">double</td></tr><tr><td align="center">float</td><td align="center"></td><td align="center">float</td></tr><tr><td align="center">int32</td><td align="center">使用变长编码，负数的编码效率较低，若字段可能为负值，应使用sint32代替</td><td align="center">int32</td></tr><tr><td align="center">int64</td><td align="center">使用变长编码，负数的编码效率较低，若字段可能为负值，应使用sint64代替</td><td align="center">int64</td></tr><tr><td align="center">uint32</td><td align="center">使用变长编码</td><td align="center">uint32</td></tr><tr><td align="center">uint64</td><td align="center">使用变长编码</td><td align="center">uint64</td></tr><tr><td align="center">sint32</td><td align="center">使用变长编码，符号整型，负值的编码效率高于常规的int32类型</td><td align="center">int32</td></tr><tr><td align="center">sint64</td><td align="center">使用变长编码，符号整型，负值的编码效率高于常规的int64类型</td><td align="center">int64</td></tr><tr><td align="center">fixed32</td><td align="center">定长4字节，若值常大于2^28，则会比uint32更高效</td><td align="center">uint32</td></tr><tr><td align="center">fixed64</td><td align="center">定长8字节，若值常大于2^56，则会比uint64更高效</td><td align="center">uint64</td></tr><tr><td align="center">sfixed32</td><td align="center">定长4字节</td><td align="center">int32</td></tr><tr><td align="center">sfixed64</td><td align="center">定长8字节</td><td align="center">int64</td></tr><tr><td align="center">bool</td><td align="center"></td><td align="center">bool</td></tr><tr><td align="center">string</td><td align="center">包含UTF-8和ASCII编码的字符串，长度不能超过2^32</td><td align="center">string</td></tr><tr><td align="center">bytes</td><td align="center">可包含任意的字节序列，但长度不能超过2^32</td><td align="center">string</td></tr></tbody></table><p>注意：变长编码是指经过protobuf编码后，原本4字节或8字节的数可能会被变为其他字节数。</p><p>2.字段唯一编号的范围：1-536870911(2^29-1)，其中19000-19999不可用</p><p>19000-19999不可用的原因：在protobuf协议的实现中，对这些数进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警</p><blockquote><p>值得一提的是，范围为1-15的字段编号需要一个字节进行保存编码(只是指编号占的空间，不是指一整条字段)，16-2047内的数字需要两个字节进行保存编码。所以1-15要用来标记出现非常频繁的字段，要为将来有可能添加的、频繁出现的字段预留一些出来。</p></blockquote><p>3.实践</p><p>1.创建一个文件contacts.proto，在该文件内编写以下内容</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首行：语法指定行</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span> &#123;</span><br><span class="line">Red = <span class="number">0</span>;</span><br><span class="line">Green = <span class="number">5</span>;</span><br><span class="line">Yelloc = <span class="number">6</span>;</span><br><span class="line">Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Address</span>&#123;</span><br><span class="line">    <span class="type">string</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int32</span> sum = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义联系人message</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PeopleInfo</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;       <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int32</span> age = <span class="number">2</span>;         <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> addr = <span class="number">3</span>;       <span class="comment">//数组</span></span><br><span class="line">    Color color = <span class="number">4</span>;               <span class="comment">//使用枚举</span></span><br><span class="line">    Address addr = <span class="number">5</span>;              <span class="comment">//复合类型嵌套使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：message Address也可以定义在Address.proto里面，但如果contacts.proto文件要用到Address，就想要通过import &quot;Address.proto&quot;来导入</span></span><br></pre></td></tr></table></figure><p>2.在该文件的目录下打开终端执行：<code>protoc --cpp_out=. contacts.proto</code></p><p>注意：编译contacts.proto文件后会发生什么？</p><p>编译contacts.proro文件后，会发生所选择语言的代码，如果选择的是c++，那么编译后生成两个文件：contacts.pb.h、contacts.pb.cc。</p><p>对于编译生成的c++代码，包含了以下内容：</p><ul><li>对于每个meaaage，都会生成一个对应的消息类</li><li>在消息类中，编译器为每个字段提供了获取和设置方法，以及一些其它能够操作字段的方法</li><li>编译器会针对于每个.proto文件生成.h和.cc文件，分别用来存放类的声明与类的实现</li></ul><blockquote><p>特别的，对于处理类的方法(序列化、反序列化)并不在PeopleInfo里面，而是在它的父类里面定义的。</p></blockquote><p>序列化的结果为二进制字节序列，而非文本格式(json)。</p><p>3.编写main.cc文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contacts.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string people_str;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对一个联系人的信息使用PB进行序列化，并将结果打印出来</span></span><br><span class="line">        contacts::PeopleInfo people;               <span class="comment">//通过bao(命名空间)定义一个对象</span></span><br><span class="line">        people.<span class="built_in">set_name</span>(<span class="string">&quot;lxx&quot;</span>);</span><br><span class="line">        people.<span class="built_in">set_age</span>(<span class="string">&quot;25&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!people.<span class="built_in">SerializeToString</span>(&amp;people_str))&#123;         <span class="comment">//序列化</span></span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;序列化联系人失败！&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;序列化成功，结果：&quot;</span>&lt;&lt;people_str&lt;&lt;std::endl;         <span class="comment">//打印出的是乱码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对序列化后的内容使用PB进行反序列化，解析出联系人信息并打印出来</span></span><br><span class="line">        contacts::PeopleInfo people;</span><br><span class="line">        <span class="keyword">if</span>(!people.<span class="built_in">ParseFromString</span>(people_str))&#123;           <span class="comment">//反序列化</span></span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;反序列化联系人失败！&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;反序列化成功，结果：&quot;</span>&lt;&lt;people_str&lt;&lt;std::endl</span><br><span class="line">                 &lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;people.<span class="built_in">name</span>()&lt;&lt;std::endl</span><br><span class="line">                 &lt;&lt;<span class="string">&quot;年龄：&quot;</span>&lt;&lt;people.<span class="built_in">age</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端输入：<code>g++ -o TestPb main.cc contacts.pb.cc -std=c++11 -lprotobuf</code></p><ul><li>生成TestPb可执行文件</li><li>-lprotobuf：加入要使用的库，不加会有链接错误</li><li>s-std&#x3D;c++11：要使用c++11的语法</li></ul><p>总结：相对于XML和JSON来说，因为被编码成二进制，破解成本增大，Protobuf编码是相对安全的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-ProtoBuf概述&quot;&gt;&lt;a href=&quot;#1-ProtoBuf概述&quot; class=&quot;headerlink&quot; title=&quot;1.ProtoBuf概述&quot;&gt;&lt;/a&gt;1.ProtoBuf概述&lt;/h1&gt;&lt;p&gt;protobuf也叫protocol buffer，是goo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库mysql</title>
    <link href="https://lxx93.online/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/"/>
    <id>https://lxx93.online/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/</id>
    <published>2025-01-10T06:46:50.000Z</published>
    <updated>2025-06-02T06:10:10.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本常识"><a href="#1-基本常识" class="headerlink" title="1. 基本常识"></a>1. 基本常识</h1><p>1.查询该linux系统安装的数据库mysql包：<code>rpm -aq | grep mysql </code></p><p>2.启动mysql服务：<code>systemctl start mysqld</code></p><p>3.查看mysql的服务进程是否启动：<code>ps -ef | grep mysqld</code></p><p>4.Oracle数据库和mysql数据库的区别</p><p><img src="/.online//Users\PC\Desktop\数据库\1.png"></p><ul><li>Oracle只有有一个数据库(安装的时候指定的实例)，数据库名就叫<code>orcl</code>，该数据库下有多个用户，如scott、hr等，每个用户下又有很多表。</li><li>Mysql只有一个用户，用户名就叫root，该用户下有很多数据库，每个库下又有很多表。</li></ul><h1 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h1><h2 id="1-mysql服务"><a href="#1-mysql服务" class="headerlink" title="1. mysql服务"></a>1. mysql服务</h2><ul><li>重启Mysql服务：<code>systemctl restart mysqld</code></li><li>查看Mysql服务状态：<code>systemctl status mysqld</code></li><li>停止Mysql服务：<code>systemctl stop mysqld</code></li><li>启动Mysql服务：<code>systemctl start mysqld</code></li></ul><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h2><p>1、进入mysql</p><ul><li>启动Mysql服务进程：<code>systemctl start mysqld</code></li><li>进入mysql：<code>mysql -uroot -pLxxwly@93</code></li></ul><p>2、查看有哪些数据库</p><ul><li>查看：<code>show databases;</code></li></ul><p>3、创建删除一个数据库firstdb</p><ul><li><p>创建：<code>create database firstdb;</code></p></li><li><p>删除：<code>drop database blog;</code></p></li></ul><p>4、操作数据库firstdb</p><p>(1)进入数据库firstdb：<code>use firstdb;</code></p><p>(2)查看有多少张表：<code>show tables;</code></p><p>(3)创建一张表：<code>create table t1(表名) (id varchar(20),name varchar(50));</code></p><p>(4)展示创建的表：<code>show create table t1;</code></p><p>(5)查看表的字段：<code>desc t1;</code></p><p>(6)向表中插入数据：<code>insert into t1 values (‘0001’,’lxx’);</code></p><p>(7)查看这张表中的所有数据：<code>select * from t1;</code></p><p>(8)按条件查：<code>select * from t1 where id=’0002’</code> </p><ul><li>还有条件的话，可以加and继续</li></ul><p>(9)按条件查，满足包含l字母的：<code>select * from t1 where name like “%l%”</code> </p><ul><li>默认打印出全部，如果后面加limit 1，表示只打印一行</li></ul><p>(10)机器localhost可以通过用户名first、密码为123进入数据库firstdb，对器所有的表进行操作：<code>grant all on firstdb.* to first@’localhost’ identified by “123”;</code></p><p>(11)在客户端(服务器)192.168.88.93上面可以通过用户名first、密码为123进入数据库firstdb，对器所有的表进行操作：<code>grant all on firstdb.* to first@’192.168.88.93’ identified by “123”;</code></p><p><strong>注意：10和11在mysql8.0版本以上就不可以了，需要先创建用户</strong></p><p>(12)先创建用户，在赋予权限：</p><ul><li><p>create user first@’lxx’ identified by ‘Lxxwly@93’;</p></li><li><p>grant all on firstdb.* to first@’lxx’;  ——&gt;all改为select就表示只赋予查找的权限</p></li><li><p>mysql -hlxx -ufirst -pLxxwly@93 -P3306  ——–退出后，从linux终端进入</p></li></ul><p>注意：flush privileges;    —–&gt;刷新权限，每次更改后，需要刷新权限</p><p>(13)删除数据库：<code>drop database test_db;</code></p><p>(14)删除表：<code>drop table test01;</code></p><p>(15)清空表内容：<code>delete from test01;</code></p><p>(16)查看数据库字符集：<code>show variables like &#39;%char%&#39;;</code></p><p>(17)修改密码：<code>mysqladmin -uroot -p password</code></p><h2 id="3-综合案例"><a href="#3-综合案例" class="headerlink" title="3. 综合案例"></a>3. 综合案例</h2><p>1.创建一个学生表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table student(id int, name varchar(20), chinese int, english int, math int);</span><br></pre></td></tr></table></figure><p>2.插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name,chinese,english,math) values(1,&#x27;路飞&#x27;,80,85,90);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(2,&#x27;索隆&#x27;,90,95,95);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(3,&#x27;山治&#x27;,80,96,96);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(4,&#x27;娜美&#x27;,81,97,85);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(5,&#x27;乌索普&#x27;,85,84,90);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(6,&#x27;罗宾&#x27;,92,85,87);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(7,&#x27;乔巴&#x27;,75,81,80);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(8,&#x27;甚平&#x27;,77,80,79);</span><br></pre></td></tr></table></figure><p>3.基础SQL</p><ul><li>查询表中所有学生的信息：<code>select * from student;</code></li><li>查询表中所有学生的姓名和对应的英语成绩：<code>select name,english from student;</code></li><li>过滤表中英语成绩重复的数据：<code>select distinct english from student;</code></li><li>计算每个人三科的总成绩，并使用别名：<code>select english+chinese+math as 总分 from student;</code></li><li>在所有学生英语分数上加10分：<code>select name,english+10 from student;</code></li><li>查询姓名为索隆的学生成绩：<code>select * from student where name = &#39;索隆&#39;;</code></li><li>查询英语成绩大于90分的同学：<code>select * from student where english &gt; 90;</code></li><li>查询总分大于250分的所有同学：<code>select * from student where english+chinese+math&gt; 250;</code></li><li>查询英语分数在85-95之间的同学：<ul><li><code>select * from student where english&gt;=85 and english&lt;=95;</code></li><li><code>select * from student where english between 85 and 95;</code></li></ul></li><li>查询数学分数为84，90，91的同学：<ul><li><code>select * from student where math=84 or math=90 or math=91;</code></li><li><code>select * from student where math in(84,90,91);</code></li></ul></li><li>查询所有姓索的学生成绩：<code>select * from student where name like &#39;索%&#39;;</code></li><li>对数学成绩排序后输出(升序)：<code>select * from student order by math;</code></li><li>对总分进行排序输出(降序)：<code>select * from student order by math+chinese+english desc;</code></li><li>对姓索的同学按总成绩排序输出(降序)：<code>select * from student where name like &#39;索%&#39; order by math+chinese+english desc;</code></li><li>统计一个班级共有多少学生：<code>select count(*) from student;</code></li><li>统计数学成绩大于90分的学生个数：<code>select count(*) from student where math&gt;90;</code></li><li>统计一个班级数学总成绩：<code>select sum(math) from student;</code></li><li>统计一个班级语文、英语、数学各科的总成绩：<code>select sum(math),sum(chinese),sum(english) from student;</code></li><li>统计一个班级语文、英语、数学的成绩总和：<ul><li><code>select sum(math+chinese+english) from student;</code></li><li><code>select sum(math)+sum(chinese)+sum(english) from student;</code></li></ul></li><li>一个班级的数学平均分：<code>select avg(math) from student;</code></li><li>班级的最高分的最低分：<code>select max(math+chinese+english),min(math+chinese+english) from student;</code></li></ul><h2 id="4-日期时间函数"><a href="#4-日期时间函数" class="headerlink" title="4. 日期时间函数"></a>4. 日期时间函数</h2><p>mysql里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)</p><ul><li><p>查看当前时间、当前年、当前月、当前日和当前天：<code>select now(), year(now()), month(now()), day(now()), date(now());</code></p><p><img src="/.online//Users\PC\Desktop\数据库\2.png"></p></li><li><p>查看当前天，当前时间，当前时间戳：<code>select current_date(), current_time(), current_timestamp() from dual;</code></p></li></ul><h2 id="5-相关函数"><a href="#5-相关函数" class="headerlink" title="5. 相关函数"></a>5. 相关函数</h2><ul><li><p>对多个字符串进行拼接：<code>select concat(&#39;aaa&#39;,&#39;bbb&#39;, &#39;ccc&#39;) from dual;</code></p></li><li><p>将字符串转换为大写：<code>select ucase(&#39;abc&#39;) from dual;</code></p></li><li><p>将字符串转换为小写：<code>select lcase(&#39;ABC&#39;) from dual;</code></p></li><li><p>返回第二个参数字符串在第一个参数字符串中出现的位置：<code>select instr(&#39;abc&#39;,&#39;bc&#39;) from dual;</code></p></li><li><p>从字符串abc中的左边起取2个字符：<code>select left(&#39;abc&#39;,2) from dual;</code></p></li><li><p>返回字符串的长度：<code>select length(&#39;abc&#39;) from dual;</code></p></li><li><p>将字符串abcdefg中的abc转换为lxx：<code>select replace(&#39;abcdefg&#39;,&#39;abc&#39;,&#39;lxx&#39;) from dual;</code></p></li><li><p>按字符比较两个字符串的大小：<code>select strcmp(&#39;abcdefg&#39;,&#39;abc&#39;) from dual;</code></p></li><li><p>日期转换为字符串显示：<code>select date_format(now(), &#39;%Y-%m-%d %h:%i:%s&#39;) from dual;</code></p></li></ul><p>1.数字相关函数</p><table><thead><tr><th align="center">函数</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">abs(number)</td><td align="center">绝对值</td></tr><tr><td align="center">bin(number)</td><td align="center">十进制转二进制</td></tr><tr><td align="center">ceiling(number)</td><td align="center">向上取整</td></tr><tr><td align="center">conv(number,from,to)</td><td align="center">进制转换</td></tr><tr><td align="center">floor(number)</td><td align="center">向下取整</td></tr><tr><td align="center">format(number,decimal_places)</td><td align="center">保留小数位数</td></tr><tr><td align="center">hex(number)</td><td align="center">转十六进制</td></tr><tr><td align="center">least(number1,number2,…..)</td><td align="center">求最小值</td></tr><tr><td align="center">mod(numerator,denominator)</td><td align="center">求余</td></tr></tbody></table><h2 id="6-Linux-操作系统里要使用-MySQL"><a href="#6-Linux-操作系统里要使用-MySQL" class="headerlink" title="6. Linux 操作系统里要使用 MySQL"></a>6. Linux 操作系统里要使用 MySQL</h2><h3 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h3><ul><li>连接 MySQL 服务器：<code>mysql -u$user -p</code><ul><li>连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的</li><li>完成 TCP 连接的建立后，连接器就要开始验证用户名和密码</li><li>如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断</li></ul></li></ul><p>注意：如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置</p><ul><li><p>如何查看 MySQL 服务被多少个客户端连接了：<code>show processlist;</code></p><ul><li>如果Command 列的状态为 Sleep ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接</li><li><strong>空闲连接会一直占用着吗</strong>：不会，MySQL 定义了空闲连接的最大空闲时长，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时(28880秒)，如果空闲连接超过了这个时间，连接器就会自动将它断开<ul><li>查看最大空闲时长：<code>show variables like &#39;wait_timeout&#39;;</code></li><li>手动断开连接：<code>kill connection +id;</code></li><li>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到报错</li></ul></li></ul></li><li><p>MySQL 的连接数有限制吗：有</p><ul><li>MySQL 服务支持的最大连接数由 max_connections 参数控制，默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示<ul><li>查看：<code>show variables like &#39;max_connections&#39;;</code></li></ul></li></ul></li></ul><p>注意：MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 短连接</span><br><span class="line">连接 mysql 服务(TCP 三次握手)</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务(TCP 四次挥手)</span><br><span class="line"></span><br><span class="line">// 长连接</span><br><span class="line">连接 mysql 服务(TCP 三次握手)</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务(TCP 四次挥手)</span><br></pre></td></tr></table></figure><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为连接过程中产生的临时数据(如缓存、会话变量、临时表等)没有得到及时释放，那么这些数据将会持续占用内存直到连接断开。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象</p><ul><li>怎么解决长连接占用内存的问题？<ul><li>定期断开长连接</li><li>客户端主动重置连接：MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态</li></ul></li></ul><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><ul><li>连接器完成工作后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句</li><li>如果 SQL 是查询语句(select 语句)，MySQL 就会先去查询缓存里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果</li><li>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中</li></ul><p>缺点：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于白白花费时间去缓存</p><p>所有在mysql的高版本中直接将查询缓存删掉了(执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了)。低版本中想要关闭查询缓存，可以将参数 query_cache_type 设置成 DEMAND</p><p>注意：高版本移除的是 server 层的查询缓存，并不是 Innodb 存储引擎中的 buffer pool</p><h3 id="3-执行一条-SQL-查询语句，期间发生了什么"><a href="#3-执行一条-SQL-查询语句，期间发生了什么" class="headerlink" title="3. 执行一条 SQL 查询语句，期间发生了什么"></a>3. 执行一条 SQL 查询语句，期间发生了什么</h3><ul><li>连接器：建立连接，管理连接、校验用户身份</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析(表或字段不存在时，不会报错)；然后构建语法树，方便后续模块读取表名、字段、语句类型</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端</li></ul></li></ul><p><img src="/.online//Users\PC\Desktop\数据库\3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基本常识&quot;&gt;&lt;a href=&quot;#1-基本常识&quot; class=&quot;headerlink&quot; title=&quot;1. 基本常识&quot;&gt;&lt;/a&gt;1. 基本常识&lt;/h1&gt;&lt;p&gt;1.查询该linux系统安装的数据库mysql包：&lt;code&gt;rpm -aq | grep mysql </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="https://lxx93.online/2024/11/18/redis%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/11/18/redis%E5%9F%BA%E7%A1%80/</id>
    <published>2024-11-18T01:48:53.000Z</published>
    <updated>2025-06-03T14:27:50.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis 也称为远程字典服务，是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库，提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等等。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布&#x2F;订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案。</p><p>1.主流功能与应用</p><ul><li>分布式缓存，挡在mysql数据库之前的带刀护卫<ul><li>所有查询先去找redis，查得到就直接返回，找不到就去访问MySQL，mysql返回数据以后，就把该数据写到redis，下次客户端在查询该数据，就可用直接在redis上查到了。</li></ul></li><li>内存存储和持久化(RDB+AOF)，redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<ul><li>redis活着的时候，所有数据都是在内存(memory)的，但断电后，redis里面的数据就会丢失，那又要把mysql的数据重新加载进redis？这样的工作会比较烦躁，所以redis自己也带有数据持久化功能，当redis关机了，在内存中的redis数据可以写进硬盘，那么当redis恢复使用后，就可以把硬盘上的东西重新读回到redis，依旧不麻烦mysql。</li></ul></li><li>高可用架构搭配<ul><li>单机、主场、哨兵、集群</li></ul></li><li>缓存穿透、击穿、雪崩<ul><li>避免一台redis挂了，所有查询都找mysql</li></ul></li><li>分布式锁</li><li>队列</li></ul><p>2.redis与传统数据库(mysql)的关系</p><ul><li>Redis是Key-Value数据库(NoSQL一种)，mysql是关系数据库</li><li>Redis数据操作主要在内存，而mysql主要存储在磁盘</li><li>Redis在某一些场景使用中要明显优于mysql，比如计数器、排行榜等方面</li><li>Redis通常用于一些特定场景，需要与Mysql一起配合使用</li><li>两者并不是相互替换和竞争关系，而是共用和配合使用</li></ul><p>3.redis优势</p><ul><li>性能极高，Redis能读的速度是110000次&#x2F;秒，写的速度是81000次&#x2F;秒</li><li>Redis数据类型丰富，不仅仅支持简单的Key-Value类型的数据，同时还提供list、set、zset、hash等数据结构的存储</li><li>Redis支持数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ul><p>4.总结图</p><p><img src="/.online//图床数据\必备技能skills\3.png"></p><p>5.官网地址</p><p>英文：<a href="https://redis.io/">https://redis.io</a></p><p>中文：</p><ul><li><a href="https://redis.cn/">http://redis.cn</a></li><li><a href="https://www.redis.com.cn/documentation.html">https://www.redis.com.cn/documentation.html</a></li></ul><p>6.Redis源码地址：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><p>7.Redis在线测试：<a href="https://try.redis.io/">https://try.redis.io</a></p><p>8.Redis命令参考：<a href="http://doc.redisfans.com/">http://doc.redisfans.com</a></p><h1 id="2-安装使用"><a href="#2-安装使用" class="headerlink" title="2. 安装使用"></a>2. 安装使用</h1><p>1.下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a>。</p><p>2.下载完后，解压文件，在该文件目录下<code>redis.windows.conf</code>文件中可以修改端口和密码。</p><p>3.启动服务器：在该目录下的终端执行<code>redis-server.exe redis.windows.conf</code>。</p><h2 id="2-1-Redis客户端"><a href="#2-1-Redis客户端" class="headerlink" title="2.1 Redis客户端"></a>2.1 Redis客户端</h2><p>安装完成Redis，我们就可以操作Reids，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编辑客户端</li></ul><p>1.命令行客户端</p><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [option] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的ip地址，默认是127.0.0.1</li><li><code>-p 6279</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123456</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回pong</li></ul><p>不指定commond时，会进入redis-cli的交互控制台。</p><p>注意：如果在文件目录下的控制台直接输入<code>redis-cli.exe -h 127.0.0.1 -p 6380 -a 123456</code>会出现提醒，提醒这样输入密码会有风险，所以可以通过如下命令完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6380</span><br><span class="line">AUTH 123456</span><br></pre></td></tr></table></figure><h1 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3. 常见命令"></a>3. 常见命令</h1><h2 id="3-1-Redis数据结构介绍"><a href="#3-1-Redis数据结构介绍" class="headerlink" title="3.1 Redis数据结构介绍"></a>3.1 Redis数据结构介绍</h2><p>Redis是一个Key-Value的数据库，Key一般是String类型，不过value的类型多种多样：</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">hello world</td></tr><tr><td align="center">Hash</td><td align="center">{name: “jack”, age: 21}</td></tr><tr><td align="center">List</td><td align="center">[A -&gt; B -&gt; C -&gt; C]</td></tr><tr><td align="center">Set</td><td align="center">{A, B, C}</td></tr><tr><td align="center">SortedSet</td><td align="center">{A: 1, B: 2, C: 3}</td></tr><tr><td align="center">GEO</td><td align="center">{A: (120.3, 30.5)}</td></tr><tr><td align="center">BitMap</td><td align="center">0110110101110101011</td></tr><tr><td align="center">HyperLog</td><td align="center">0110110101110101011</td></tr></tbody></table><p>其中，前面5种是基本类型，后面3种是特殊类型。</p><p>Redis为了方便我们学习，将操作不同的数据类型的命令也做了分组，在官网<a href="https://redis.io/commands">https://redis.io/commands</a>可以查看到不同的命令。</p><h2 id="3-2-Redis通用命令"><a href="#3-2-Redis通用命令" class="headerlink" title="3.2 Redis通用命令"></a>3.2 Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><p>help：查看一个命令的具体用法，例如：help keys</p></li><li><p>keys：查看符合模板的所有Key，不建议在生产环境设备上使用(底层是模糊查询的机制，当数据量过大时，会给cpu很大的负担，会搜索很长的时间，而redis是单线程的，那么搜索这段时间就不会执行其它程序)</p><ul><li>查询所有匹配的keys：<code>keys *</code></li><li>查询以a开头的所有的keys：<code>keys a*</code></li></ul></li><li><p>del：删除一个指定的key</p><ul><li>删除name这个key：<code>del name</code></li></ul></li><li><p>exists：判断key是否存在，存在返回1，不存在就返回0</p><ul><li>判断name这个key是否存在：<code>exists name</code></li></ul></li><li><p>expire：给一个key设置有效期，有效期到期时，该key会被自动删除</p><ul><li>给age这个key设置20秒的有效期：<code>expire age 20</code></li></ul></li><li><p>ttl：查看一个key的剩余有效期，当返回-2时，说明该key已经不存在了</p><ul><li>查看age这个key的剩余有效期：<code>ttl age</code></li><li>当创建的key没有指定有效期时，通过ttl查询会返回-1，表示该key会永久有效。</li></ul></li></ul><h2 id="3-3-String类型"><a href="#3-3-String类型" class="headerlink" title="3.3 String类型"></a>3.3 String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">msg</td><td align="center">hello world</td></tr><tr><td align="center">num</td><td align="center">10</td></tr><tr><td align="center">score</td><td align="center">92.5</td></tr></tbody></table><p>1.String类型的常见命令：</p><ul><li>set：添加或者修改已经存在的一个String类型的键值对</li><li>get：根据key获取String类型的value</li><li>mset：批量添加多个String类型的键值对</li><li>mget：根据多个key获取多个String类型的value</li><li>incr：让一个整型的key自增1</li><li>incrby：让一个整型的key自增并指定步长，例如：incrby num 2 让num的值自增2</li><li>incrbyfloat：让一个浮点类型的数字自增(必须指定步长)</li><li>setnx：添加一个String类型的键值对，前提是这个key不存在，否则不执行(修改不成功)</li><li>setex：添加一个String类型的键值对，并且指定有效期<ul><li>添加一个key为name，value为jack，有效期为10s的数据：<code>setex name 10 jack</code></li></ul></li></ul><p>Redis没有类似Mysql中Table的概念，那该如何区分不同类型的key？</p><p>2.key的结构</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><p><code>项目名：业务名：类型：id</code></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条</p><p>例如项目名称叫heima，有user和product两种不同类型的数据，可以这样定义key：</p><ul><li>user相关的key：heima:user:1</li><li>product相关的key：heima:product:1</li></ul><p>如果value是一个java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">heima:user:1</td><td align="center">{“id”: 1, “name”: “jack”, “age”: 21 }</td></tr><tr><td align="center">heima:product:1</td><td align="center">{“id”: 1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>例子：</p><p><img src="/.online//图床数据\必备技能skills\4.png"></p><h2 id="3-4-Hash类型"><a href="#3-4-Hash类型" class="headerlink" title="3.4 Hash类型"></a>3.4 Hash类型</h2><p>Hash类型，也叫散列，其中value是一个无序字典，类似于java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/.online//图床数据\必备技能skills\5.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/.online//图床数据\必备技能skills\6.png"></p><p>1.Hash类型的常见命令：</p><ul><li><p>hset key field value：添加或者修改hash类型key的field的值</p><ul><li>向heima:user:3里面的name添加值lucy：<code>hset heima:user:3 name lucy</code></li><li>向heima:user:3里面的age添加值21：<code>hset heima:user:3 age 21</code></li></ul></li><li><p>hget key field：获取一个hash类型key的field的值</p></li><li><p>hmset：批量添加多个hash类型key的field的值</p><ul><li>使用：<code>hmset heima:user:4 name lilei age 20 sex man</code></li></ul></li><li><p>hmget：批量获取多个hash类型key的field的值</p><ul><li>使用：<code>hmget heima:user:4 name age sex</code></li></ul></li><li><p>hgetall：获取一个hash类型的key中的所有的field和value</p></li><li><p>hkeys：获取一个hash类型的key中的所有的field</p></li><li><p>hvals：获取一个hash类型的key中的所有的value</p></li><li><p>hincrby：让一个hash类型key的字段值自增并指定步长</p><p>使用(自增2)：<code>hincrby heima:user:3 age 2</code></p></li><li><p>hsetnx：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行(修改不成功)</p></li></ul><h2 id="3-4-List类型"><a href="#3-4-List类型" class="headerlink" title="3.4 List类型"></a>3.4 List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，如朋友圈点赞列表、评论列表等。</p><p>List类型的常见命令</p><ul><li>lpush key element … ：向列表左侧插入一个或多个元素<ul><li>向users的列表左侧依次插入1、2、3：<code>Lpush users 1 2 3</code></li></ul></li><li>lpop key ：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>rpush key element … ：向列表右侧插入一个或多个元素</li><li>rpop key ：移除并返回列表右侧的第一个元素，没有则返回nil</li><li>lrange key start end ：返回一段角标范围内的所有元素<ul><li>向users的列表左侧依次取出下标1到3的元素（）：<code>lrange users 1 3</code></li></ul></li><li>blpop和brpop ：与lpop和rpop类似，只不过在没有元素时等待指定时间，而不是直接返回nil<ul><li>向users2中从左边移除元素，且等待时间为39秒：<code>blpop users2 39</code></li></ul></li></ul><h2 id="3-5-Set类型"><a href="#3-5-Set类型" class="headerlink" title="3.5 Set类型"></a>3.5 Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个Hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p>Set类型的常见命令</p><ul><li>sadd key member … ：向set中添加一个或多个元素</li><li>srem key member … ：移除set中的指定元素</li><li>scard key ：返回set中元素的个数</li><li>sismember key member ：判断一个元素是否存在于set中</li><li>smembers：获取set中的所有元素</li><li>sinter key1 key2 … ：求key1和key2的交集</li><li>sdiff key1 key2 … ：求key1和key2的差集(key1中有，而key2中没有的元素)</li><li>sunion key1 key2 … ：求key1和key2的并集</li></ul><h2 id="3-6-SortedSet类型"><a href="#3-6-SortedSet类型" class="headerlink" title="3.6 SortedSet类型"></a>3.6 SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别较大，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因此SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet类型的常见命令</p><ul><li>zadd key score member：添加一个或多个元素到sortedset，如果已经存在则更新其score值<ul><li>使用：<code>zadd students 85 jack 83 kucy 95 tom</code></li></ul></li><li>zrem key member：删除sortedset中的一个指定元素<ul><li>使用：<code>zrem students tom</code></li></ul></li><li>zscore key member：获取sortedset中的指定元素的score值</li><li>zrank key member：获取sortedset中的指定元素的排名<ul><li>使用：<code>zrank students rose</code></li></ul></li><li>zcard key：获取sortedset中的元素个数<ul><li>使用：<code>zcard students</code></li></ul></li><li>zcount key min max：统计score值在给定范围内的所有元素的个数<ul><li>使用：<code>zcount students 0 80</code></li></ul></li><li>zincrby key increment member：让sortedset中的指定元素自增，步长为指定的increment值<ul><li>使用：<code>zincrby students 2 rose</code></li></ul></li><li>zrange key min max：按照score排序后，获取指定排名范围内的元素<ul><li>如果是前三名：<code>zrevrange students 0 2</code></li></ul></li><li>zrangebyscore key min max：按照score排序后，获取指定score范围内的元素</li><li>zdiff、zinter、zunion：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序的，如果要降序则在命令的Z后面添加rev即可</p><p>Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><h2 id="4-redis基本知识"><a href="#4-redis基本知识" class="headerlink" title="4. redis基本知识"></a>4. redis基本知识</h2><p>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis 也称为远程字典服务，是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++基础</title>
    <link href="https://lxx93.online/2024/11/03/c++%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/11/03/c++%E5%9F%BA%E7%A1%80/</id>
    <published>2024-11-03T06:15:26.000Z</published>
    <updated>2025-01-04T05:46:34.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-c-简介"><a href="#1-c-简介" class="headerlink" title="1. c++简介"></a>1. c++简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<em><strong>中级</strong></em>语言，它综合了高级语言和低级语言的特点。</p><p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</li><li>继承：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</li><li>多态：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</li><li>抽象：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</li></ul><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h1><h2 id="1-变量和数据类型"><a href="#1-变量和数据类型" class="headerlink" title="1. 变量和数据类型"></a>1. 变量和数据类型</h2><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p><p>c++中七种基本的 C++ 数据类型及其扩展：</p><table><thead><tr><th align="center">类型</th><th align="center">位</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">-128到127 或者 0到255</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">0到255</td></tr><tr><td align="center">signed char</td><td align="center">1</td><td align="center">-128到127</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">-2147483648 到 2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">4</td><td align="center">0 到 4294967295</td></tr><tr><td align="center">signed int</td><td align="center">4</td><td align="center">-2147483648 到 2147483647</td></tr><tr><td align="center">short int</td><td align="center">2</td><td align="center">-32768 到 32767</td></tr><tr><td align="center">unsigned short int</td><td align="center">2</td><td align="center">0 到 65,535</td></tr><tr><td align="center">signed short int</td><td align="center">2</td><td align="center">-32768 到 32767</td></tr><tr><td align="center">long int</td><td align="center">8</td><td align="center">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">signed long int</td><td align="center">8</td><td align="center">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">unsigned long</td><td align="center">8</td><td align="center">0 到 18,446,744,073,709,551,615</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">单精度型浮点型</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">双精度型浮点型</td></tr><tr><td align="center">long long</td><td align="center">8</td><td align="center"></td></tr><tr><td align="center">long double</td><td align="center">16</td><td align="center"></td></tr><tr><td align="center">wchar_t</td><td align="center">2或4</td><td align="center">1个宽字符</td></tr></tbody></table><p>类型转换</p><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p><ul><li><p>静态转换</p><ul><li><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p></li><li><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p></li><li><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;                    <span class="comment">//其他类型指针-&gt;void*指针-&gt;其他类型指针</span></span><br><span class="line"><span class="type">double</span>* pp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(ptr);     <span class="comment">//将指针类型转换的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> b = a;                           <span class="comment">//安全，可以隐式转换，不会出现警告</span></span><br><span class="line"><span class="type">double</span> c = <span class="number">1.23</span>;</span><br><span class="line"><span class="type">long</span> d = (<span class="type">long</span>)c;                     <span class="comment">//C风格：显式转换</span></span><br><span class="line"><span class="type">long</span> d1 = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(c);      <span class="comment">//c++风格：显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//double* pd1 = &amp;a;                    //错误，不能隐式转换</span></span><br><span class="line"><span class="type">double</span>* pd2 = (<span class="type">double</span>*)&amp;a;             <span class="comment">//c风格，强制类型转换</span></span><br><span class="line"><span class="comment">//double* pd3 = static_cast&lt;double*&gt;(&amp;a);     //错误，static_cast不支持不同类型指针的转换，但可以通过void*指针中转</span></span><br><span class="line"><span class="type">void</span>* pv = &amp;a;                         <span class="comment">//任何类型的指针都可以隐式的转换为void*(无符号型指针)</span></span><br><span class="line"><span class="type">double</span>* pd3 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(pv);      <span class="comment">//然后通过static_cast将void*转换为其他类型的指针</span></span><br><span class="line">cout &lt;&lt; pd3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态转换</p><ul><li><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>常量转换</p><ul><li><p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</p></li><li><p>常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 常量转换，将const int转换为int</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>重新解释转换</p><ul><li><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p></li><li><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p></li><li><pre><code class="c++">int i = 10;float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;    //使用std这个命名空间</span><br><span class="line">int number;   //全局变量可以不用赋值，默认为0</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int number = 1;    //局部变量</span><br><span class="line">cout &lt;&lt; &quot;number=&quot; &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;::number=&quot; &lt;&lt; ::number &lt;&lt; endl;     //访问全局变量前要加::</span><br><span class="line"></span><br><span class="line">//定义常量</span><br><span class="line">const float Pi = 3.14;</span><br><span class="line">cout &lt;&lt; &quot;Pi=&quot; &lt;&lt; Pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//特殊字符</span><br><span class="line">cout &lt;&lt; &quot;hello world\t\&quot;hello world\&quot;\n \?&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>c++中有两种类型的表达式：</p><ul><li>左值：指向内存位置的表达式被称为左值表达式。左值可以出现在赋值号的左边或右边。</li><li>右值：术语右值指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul><p>c++中的变量作用域：</p><ul><li>局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</li><li>全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</li><li>块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</li><li>类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</li></ul><h2 id="2-修饰符类型"><a href="#2-修饰符类型" class="headerlink" title="2. 修饰符类型"></a>2. 修饰符类型</h2><p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p><table><thead><tr><th align="center">限定符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">const</td><td align="center">const定义常量，表示该变量的值不能被修改</td></tr><tr><td align="center">volatile</td><td align="center">修饰符volatile告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程</td></tr><tr><td align="center">restrict</td><td align="center">由restrict修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict</td></tr><tr><td align="center">mutable</td><td align="center">表示类中的成员变量可以在 const 成员函数中被修改</td></tr><tr><td align="center">static</td><td align="center">用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问</td></tr><tr><td align="center">register</td><td align="center">用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// 定义常量 NUM，其值不可修改</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// 定义变量 num，其值可能会在未知的时间被改变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_; <span class="comment">// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// register 关键字建议编译器将变量 num 存储在寄存器中</span></span><br><span class="line">    <span class="comment">// 以提高程序执行速度</span></span><br><span class="line">    <span class="comment">// 但是实际上是否会存储在寄存器中由编译器决定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//短路求值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> || ++i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位运算符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0xb5</span>;    <span class="comment">// 1011 0101</span></span><br><span class="line">cout &lt;&lt; hex;      <span class="comment">//十六进制表示(设置cout的输出格式为十六进制表示)</span></span><br><span class="line"><span class="comment">//算术操作符会导致 整型提升(bits原来是8位，经过移动操作后，c++会将其提升为int类型32位)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bits左移2位：&quot;</span> &lt;&lt; (bits &lt;&lt; <span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 0000 0000 0000 0000 0000 0010 1101 0100</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bits右移2位：&quot;</span> &lt;&lt; (bits &gt;&gt; <span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 0000 0000 0000 0000 0000 0000 0010 1101</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dec;     <span class="comment">//十进制表示</span></span><br><span class="line">cout &lt;&lt; (<span class="number">200</span> &lt;&lt; <span class="number">3</span>) &lt;&lt; endl;        <span class="comment">//扩大8倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//位逻辑运算符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc1 = <span class="number">5</span>;      <span class="comment">// 0000 0101</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc2 = <span class="number">12</span>;     <span class="comment">// 0000 1100</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~uc1) &lt;&lt; endl;   <span class="comment">//按位取反    1111 1010  最高位是1，是负数(负数是以补码形式表示的)，原码：0000 0110</span></span><br><span class="line">cout &lt;&lt; (uc1 &amp; uc2) &lt;&lt; endl;     <span class="comment">//按位取与    0000 0100</span></span><br><span class="line">cout &lt;&lt; (uc1 | uc2) &lt;&lt; endl;     <span class="comment">//按位取或    0000 1101</span></span><br><span class="line">cout &lt;&lt; (uc1 ^ uc2) &lt;&lt; endl;     <span class="comment">//按位异或    0000 1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：从一组数里找出只出现一次的那个数</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">5</span>, i2 = <span class="number">12</span>, i3 = <span class="number">12</span>, i4 = <span class="number">9</span>, i5 = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;只出现一次的那个数：&quot;</span> &lt;&lt; (i1 ^ i2 ^ i3 ^ i4 ^ i5) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="type">int</span> total = <span class="number">20</span>, num = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span> avg = total / num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; avg &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; (<span class="type">double</span>)total / num &lt;&lt; endl;   <span class="comment">//c语言风格</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; <span class="built_in">double</span>(total) / num &lt;&lt; endl;   <span class="comment">//c++函数调用风格</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total) / num &lt;&lt; endl;   <span class="comment">//c++强制类型转换运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">bits左移<span class="number">2</span>位：<span class="number">2</span>d4</span><br><span class="line">bits右移<span class="number">2</span>位：<span class="number">2</span>d</span><br><span class="line"><span class="number">1600</span></span><br><span class="line"><span class="literal">-6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">只出现一次的那个数：<span class="number">9</span></span><br><span class="line">avg=<span class="number">3</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br></pre></td></tr></table></figure><h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h2><p>1.范围for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;现在的数字是：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.99乘法表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i * j &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.绘制爱心曲线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//爱心曲线方程：(x^2+y^2-a)^3-x^2 * y^3 = 0</span></span><br><span class="line"><span class="type">double</span> a = <span class="number">0.8</span>;</span><br><span class="line"><span class="type">double</span> bound = <span class="number">1.3</span> * <span class="built_in">sqrt</span>(a);</span><br><span class="line"><span class="comment">//x,y坐标变换步长</span></span><br><span class="line"><span class="type">double</span> step = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//二维码扫描所有点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> y = bound; y &gt;= -bound; y -= step) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> x = -bound; x &lt;= bound; x += <span class="number">0.5</span>*step) &#123;</span><br><span class="line"><span class="comment">//代入曲线方程，计算每个点是否在曲线内</span></span><br><span class="line"><span class="type">double</span> result = <span class="built_in">pow</span>((<span class="built_in">pow</span>(x,<span class="number">2</span>) + <span class="built_in">pow</span>(y, <span class="number">2</span>) - a), <span class="number">3</span>) - <span class="built_in">pow</span>(x, <span class="number">2</span>) * <span class="built_in">pow</span>(y, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-指针与常量"><a href="#5-指针与常量" class="headerlink" title="5. 指针与常量"></a>5. 指针与常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="type">int</span>* p1;</span><br><span class="line"><span class="type">long</span>* p2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>* p3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p3) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的使用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="type">long</span> c = <span class="number">93</span>;</span><br><span class="line">p1 = &amp;a;</span><br><span class="line">p2 = &amp;c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的地址为：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;          <span class="comment">//0000007A6770FB94</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b的地址为：&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;          <span class="comment">//0000007A6770FBB4</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c的地址为：&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;          <span class="comment">//0000007A6770FBD4</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1 &lt;&lt; endl;                <span class="comment">//0000007A6770FB94</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; endl;                <span class="comment">//0000007A6770FBD4</span></span><br><span class="line"></span><br><span class="line">*p1 = <span class="number">12</span>;     <span class="comment">//修改p1指针指向的变量值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//12</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//将p1指向的变量改为b的地址</span></span><br><span class="line">*p1 = <span class="number">25</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//12</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;                 <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1 = <span class="number">10</span>, c2 = <span class="number">25</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pc = &amp;c1;     <span class="comment">//pc指向int类型常量的指针，   int* pc = &amp;c1;会报错</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pc=&quot;</span> &lt;&lt; *pc &lt;&lt; endl;            <span class="comment">//10</span></span><br><span class="line">pc = &amp;c2;       <span class="comment">//指向的常量不能修改，但可以修改指针的指向</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pc=&quot;</span> &lt;&lt; *pc &lt;&lt; endl;            <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指针常量(const指针)：指针的指向不能改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> cp = &amp;a;     <span class="comment">//只能指向int型变量，不能是常量</span></span><br><span class="line">*cp = <span class="number">93</span>;    <span class="comment">//指向的地址不能变，但里面的值可以变</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//93</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指针数组和数组指针</span></span><br><span class="line"><span class="type">int</span>* pa[<span class="number">5</span>];       <span class="comment">//指针数组：数组里面存的是指针</span></span><br><span class="line"><span class="built_in">int</span>(*ap)[<span class="number">5</span>];      <span class="comment">//数组指针：指向数组的指针</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pa在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(pa) &lt;&lt; endl;      <span class="comment">//5*8 = 40</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ap) &lt;&lt; endl;      <span class="comment">//是一个指针，所以长度是8</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, &#125;;</span><br><span class="line">ap = &amp;arr;        <span class="comment">//ap指向的是整个arr数组，不能是ap=arr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-引用与常量"><a href="#6-引用与常量" class="headerlink" title="6. 引用与常量"></a>6. 引用与常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//引用：地址是同一个地址，而且引用一个变量过后，不能再绑定其他变量，地址就定了，但里面的值可以改</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;     <span class="comment">//   int&amp; ref =90;  将会报错</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;             <span class="comment">//10</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的地址为：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;        <span class="comment">//0000001CE5EFF964</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref的地址为：&quot;</span> &lt;&lt; &amp;ref &lt;&lt; endl;    <span class="comment">//0000001CE5EFF964</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对常量的引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref = zero;</span><br><span class="line"><span class="comment">//cref = 10;   cref是zero的一个常量引用了，因此不能修改所引用的值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref2 = i;     <span class="comment">//可以用一个变量做初始值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref3 = <span class="number">10</span>;   <span class="comment">//可以用字面值常量做初始化值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针常量</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span>&amp; ref6 = t;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;t;</span><br><span class="line">ref6 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; endl;        <span class="comment">//20</span></span><br><span class="line">*p = <span class="number">15</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; endl;        <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定指针的引用</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;</span><br><span class="line"><span class="type">int</span>*&amp; prep = ptr;</span><br><span class="line"><span class="comment">//没有指向引用的指针，因为引用不是一种数据类型，它也是绑定其他数据类型的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量引用</strong>：通过使用 <code>const int&amp;</code>，你可以创建一个引用，该引用可以引用常量(const int)、变量(int)或字面值(10)，但你不能通过这个引用修改其引用的值。</p><p><strong>引用与指针常量的区别</strong></p><p>引用：</p><ul><li>绑定后不可变，始终指向同一个变量</li><li>可以通过引用来修改其所绑定变量的值</li></ul><p>指针常量：</p><ul><li>绑定后不可变，指向的对象不能改变</li><li>可以通过指针来修改其所指向变量的值</li></ul><p>结论：引用和指针常量在绑定后都是不能再绑定到其他变量，但它们的用法和语义上有明显的区别。引用更像是一个别名，而指针常量则是一个变量，其值是一个内存地址。</p><h2 id="7-对象特性"><a href="#7-对象特性" class="headerlink" title="7. 对象特性"></a>7. 对象特性</h2><p>1.构造函数和析构函数</p><p>构造函数和析构函数都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</p><ul><li><p>构造函数</p><ul><li>没有返回值，不用写void</li><li>函数名与类名相同</li><li>构造函数可以有参数，可以发生重载</li><li>创建对象的时候，构造函数会自动调用，而且只调用一次</li></ul></li><li><p>析构函数(进行清理的操作)</p><ul><li>没有返回值，不写void</li><li>函数名和类名相同，在名称前加~</li><li>析构函数不可以有参数的，不可以发生重载</li><li>对象在销毁前，会自动调用析构函数，而且只调用一次</li></ul></li></ul><p>2.成员变量和成员函数分开存储</p><p>空对象占用内存空间为1，c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置。</p><p>下面这个程序中，当Person类中有<code>int num</code>的时候，程序输出为4，当没有<code>int num</code>的时候，输出的结果为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> num;               <span class="comment">//非静态成员变量，属于类的对象上</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sum;        <span class="comment">//静态成员变量，不属于类对象上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;         <span class="comment">//非静态成员函数，不属于类对象上</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">//静态成员函数，不属于类对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类的大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.this指针和指针常量</p><p>this指针的本质是指针常量，指针的指向是不可以修改的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//在成员函数后面加const，修饰的是this指向，让指针指向的值也不能修改，相当于const Person * const this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;           <span class="comment">//常函数</span></span><br><span class="line"><span class="comment">//this-&gt;a = 100;    </span></span><br><span class="line"><span class="keyword">this</span>-&gt;b = <span class="number">100</span>;    <span class="comment">//不会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> b;   <span class="comment">//特殊变量，即使在常函数中，也可以修改这个值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"><span class="type">const</span> Person p1;  <span class="comment">//在对象前面加const，变为常对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-运算符重载"><a href="#8-运算符重载" class="headerlink" title="8. 运算符重载"></a>8. 运算符重载</h2><p>1.赋值运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在普通赋值运算符情况下，当有些属性创建在堆区，此时就会出现浅拷贝的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line"><span class="comment">//编译器提供的是浅拷贝</span></span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line">cout &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.关系运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 ==  号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 !=  号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;lxx&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;lxx&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.加号运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1、成员函数来重载+运算符</span></span><br><span class="line"><span class="comment">//下面调用的本质：Person p3 =p1.operator+(p2);</span></span><br><span class="line"><span class="comment">/*Person operator+(Person&amp; p) &#123;</span></span><br><span class="line"><span class="comment">Person temp;</span></span><br><span class="line"><span class="comment">temp.ma = this-&gt;ma + p.ma;</span></span><br><span class="line"><span class="comment">temp.mb = this-&gt;mb + p.mb;</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数重载</span></span><br><span class="line"><span class="comment">//下面调用的本质：Person p3 = operator+(p1, p2);</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.ma = p1.ma + p2.ma;</span><br><span class="line">temp.mb = p1.mb + p2.mb;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、运算符重载也可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, <span class="type">int</span> num) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.ma = p1.ma + num;</span><br><span class="line">temp.mb = p1.mb + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p1.ma = <span class="number">10</span>;</span><br><span class="line">p1.mb = <span class="number">10</span>;</span><br><span class="line">Person p2;</span><br><span class="line">p2.ma = <span class="number">10</span>;</span><br><span class="line">p2.mb = <span class="number">10</span>;</span><br><span class="line">Person p3 = p1 + p2;</span><br><span class="line"><span class="comment">// Person p3 = p1.operator+(p2);      //第一种重载也可以使用这种方式来使用</span></span><br><span class="line">Person p4 = p1 + <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; p3.ma &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p3.mb &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.ma &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p4.mb &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.左移运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//利用成员函数重载 左移运算符 p.operator&lt;&lt;(cout)  简化版本是p&lt;&lt;cout</span></span><br><span class="line"><span class="comment">//不能利用成员函数进行重载&lt;&lt;运算符，因为无法实现 cout在左侧</span></span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;p) &#123;      <span class="comment">//operator&lt;&lt;(cout,p)的本质是cout&lt;&lt;p</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ma=&quot;</span> &lt;&lt; p.ma &lt;&lt; <span class="string">&quot; mb=&quot;</span> &lt;&lt; p.mb;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">Person p;</span><br><span class="line">p.ma = <span class="number">10</span>; p.mb = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9. 继承"></a>9. 继承</h2><p>1.以public方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中依然是公共权限</li><li>父类中的保护权限成员 到 子类中依然是保护权限</li><li>父类中的私有权限成员 在 子类中访问不到</li></ul><p>2.以protected方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中是保护权限</li><li>父类中的保护权限成员 到 子类中是保护权限</li><li>父类中的私有权限成员 在 子类访问不到</li></ul><p>3.以private方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中是私有权限</li><li>父类中的保护权限成员 到 子类中是私有权限</li><li>父类中的私有权限成员 在 子类访问不到</li></ul><p>注意：继承中的构造函数和析构函数的顺序：先构造父类，再构造子类，析构函数顺序与构造函数顺序相反</p><p>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数。如果想访问到父类中被隐藏的同名成员函数，需要加作用域</p><p>菱形继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承，解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前，加上关键字virtual变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yyy</span> :<span class="keyword">public</span> sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">yyy s;</span><br><span class="line">s.sheep::ma = <span class="number">18</span>;</span><br><span class="line">s.Tuo::ma = <span class="number">24</span>;</span><br><span class="line"><span class="comment">//加上虚继承后，访问的就是同一个地址下的值了，解决了资源浪费的问题</span></span><br><span class="line">cout &lt;&lt; s.sheep::ma &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Tuo::ma &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.ma &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-多态"><a href="#10-多态" class="headerlink" title="10. 多态"></a>10. 多态</h2><p>1.多态满足的条件</p><ul><li>有继承关系</li><li>子类重写父类的虚函数(重写：函数返回值类型、函数名、参数列表 完成相同)</li></ul><p>多态使用：父类的指针或者引用 指向子类对象</p><p>2.纯虚函数：只要有一个纯虚函数，这个类就是抽象类<br>抽象类的特定：</p><ul><li>无法实例化</li><li>抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子类中func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Base b;     //无法实例化抽象类</span></span><br><span class="line">Base* p = <span class="keyword">new</span> son;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.虚析构函数和纯虚析构函数共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>区别：如果是纯虚析构函数，该类是抽象类，无法实例化对象。</p><p>虚析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;            <span class="comment">// 虚析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;                <span class="comment">// 派生类的析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();      <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;                     <span class="comment">// 删除时调用派生类和基类的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>纯虚析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;  <span class="comment">// 纯虚析构函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>() &#123;  <span class="comment">// 纯虚析构函数的定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;  <span class="comment">// 派生类的析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;  <span class="comment">// 删除时调用派生类和基类的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-模板"><a href="#11-模板" class="headerlink" title="11. 模板"></a>11. 模板</h2><p>1.函数模板的应用：建立一个通用函数，其函数反回值类型和形参可以不具体制定，用一个虚拟的类型来表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//声明一个模板，告诉编译器后面代码种紧跟这的T不要报错，T是一个通用数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line"><span class="comment">//1、自动类型推到</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line"><span class="comment">//mySwap(a, c);   //错误，T推到不出一致的类型，一个是int，一个是char</span></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="comment">//mySwap&lt;int&gt;(a, b);</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="comment">//func();      //报错，模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.调用规则</p><ul><li>如果函数模板和普通函数都可以调用，优先调用普通函数</li><li>可以通过空模板参数列表 强制调用 函数模板</li><li>函数模板可以发生函数重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;普通函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;模板函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;模板函数重载调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myprint</span>(a,b); <span class="comment">//调用的是普通函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过空模板参数列表，强制调用函数模板</span></span><br><span class="line">myprint&lt;&gt;(a, b);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板也可以重载</span></span><br><span class="line"><span class="built_in">myprint</span>(a, b, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数模板可以产生更好的匹配，优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myprint</span>(c1, c2);    <span class="comment">//虽然普通函数可以隐式的转换类型，但调用的是模板函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数模板的全特化</p><p>模板的调用不是万能的，当对自定义类型数据等进行比较时，会有问题。利用全特化的模板，可以解决自定义类型的通用性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;      <span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;    <span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ma = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;mb = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用具体化person的版本实现代码，具体化优先调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">bool</span> <span class="title">mycompare</span><span class="params">(person&amp; p1, person&amp; p2)</span> </span>&#123;    <span class="comment">//template&lt;&gt;是模板全特化</span></span><br><span class="line"><span class="keyword">if</span> (p1.ma == p2.ma &amp;&amp; p1.mb == p2.mb) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> ref = <span class="built_in">mycompare</span>(a, b);     <span class="comment">//是int类型，调用原始模板即可</span></span><br><span class="line"><span class="keyword">if</span> (ref) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">bool</span> ref1 = <span class="built_in">mycompare</span>(p1, p2);      <span class="comment">//是person类型，调用自己写的全特化的模板</span></span><br><span class="line"><span class="keyword">if</span> (ref1) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板全特化 :</p><ul><li><code>template&lt;&gt;</code> 表示这是一个模板的完全特化版本。也就是说，这个 <code>mycompare</code> 函数专门用于 <code>person</code> 类型的对象比较。</li><li>全特化意味着 <code>mycompare</code> 函数模板的原型存在，但这里的版本仅适用于 <code>person</code> 类型。</li></ul><p>4.类模板</p><p>类模板与函数模板的区别</p><ul><li>类模板没有自动类型推导的使用方法</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mname = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mage = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mname &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; mage &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">NameType mname;</span><br><span class="line">AgeType mage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">39</span>)</span></span>;</span><br><span class="line">p1.<span class="built_in">showperson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板中的成员函数并不是一开始就创建的，在调用时才去创建的。</p><h1 id="2-STL教程"><a href="#2-STL教程" class="headerlink" title="2. STL教程"></a>2. STL教程</h1><p>C++ 标准模板库是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p><p>STL 分为多个组件，包括容器、迭代器、算法、函数对象和适配器等。</p><h2 id="1-array容器"><a href="#1-array容器" class="headerlink" title="1. array容器"></a>1. array容器</h2><p><code>std::array</code> 是 C++ 标准库中的一个模板类，它定义在 <code>&lt;array&gt;</code> 头文件中。<code>std::array</code> 模板类提供了一个固定大小的数组，其大小在编译时确定，并且不允许动态改变。与 C 语言中的数组相比，具有更好的类型安全和内存管理特性。</p><p>1.std::array的基本语法：</p><p><code>std::array&lt;T, N&gt; array_name;</code></p><ul><li><code>T</code> 是数组中元素的类型。</li><li><code>N</code> 是数组的大小，必须是一个非负整数。</li></ul><p>声明与初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个定长为5的int数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.特点</p><ul><li><strong>类型安全</strong>：<code>std::array</code> 强制类型检查，避免了 C 语言数组的类型不安全问题。</li><li><strong>固定大小</strong>：数组的大小在编译时确定，不能在运行时改变。</li><li><strong>内存连续</strong>：<code>std::array</code> 的元素在内存中是连续存储的，这使得它可以高效地访问元素。</li><li><strong>标准容器</strong>：<code>std::array</code> 提供了与 <code>std::vector</code> 类似的接口，如 <code>size()</code>, <code>at()</code>, <code>front()</code>, <code>back()</code> 等。</li></ul><p>3.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>at(size_t pos)</code></td><td align="left">返回指定位置的元素，带边界检查</td></tr><tr><td align="left"><code>operator[]</code></td><td align="left">返回指定位置的元素，不带边界检查</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回数组的第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回数组的最后一个元素</td></tr><tr><td align="left"><code>data()</code></td><td align="left">返回指向数组数据的指针</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回数组大小（固定不变）</td></tr><tr><td align="left"><code>fill(const T&amp; value)</code></td><td align="left">将数组所有元素设置为指定值</td></tr><tr><td align="left"><code>swap(array&amp; other)</code></td><td align="left">交换两个数组的内容</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回数组的起始&#x2F;结束迭代器</td></tr></tbody></table><p>4.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::array</code></th></tr></thead><tbody><tr><td align="center"><strong>大小</strong></td><td align="center">编译时固定</td></tr><tr><td align="center"><strong>边界检查</strong></td><td align="center"><code>at()</code> 提供边界检查</td></tr><tr><td align="center"><strong>内存管理</strong></td><td align="center">栈上分配</td></tr><tr><td align="center"><strong>性能</strong></td><td align="center">高效</td></tr><tr><td align="center"><strong>接口</strong></td><td align="center">支持 STL 标准接口</td></tr></tbody></table><h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2. vector容器"></a>2. vector容器</h2><p><code>vector</code>是 STL 中的一个容器类，用于存储动态大小的数组。<code>vector</code>是一个序列容器，它允许用户在容器的末尾快速地添加或删除元素。与数组相比，<code>&lt;vector&gt;</code> 提供了更多的功能，如自动调整大小、随机访问等。</p><p>1.声明与初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1;                  <span class="comment">// 空的vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 长度为5的vector，元素默认初始化</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 长度为5的vector，元素值为10</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>push_back(const T&amp; val)</code></td><td align="left">在末尾添加元素</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">删除末尾元素</td></tr><tr><td align="left"><code>at(size_t pos)</code></td><td align="left">返回指定位置的元素，带边界检查</td></tr><tr><td align="left"><code>operator[]</code></td><td align="left">返回指定位置的元素，不带边界检查</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回最后一个元素</td></tr><tr><td align="left"><code>data()</code></td><td align="left">返回指向底层数组的指针</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回当前元素数量</td></tr><tr><td align="left"><code>capacity()</code></td><td align="left">返回当前分配的容量</td></tr><tr><td align="left"><code>reserve(size_t n)</code></td><td align="left">预留至少 <code>n</code> 个元素的存储空间</td></tr><tr><td align="left"><code>resize(size_t n)</code></td><td align="left">将元素数量调整为 <code>n</code></td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清空所有元素</td></tr><tr><td align="left"><code>insert(iterator pos, val)</code></td><td align="left">在指定位置插入元素</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">删除指定位置的元素</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回起始&#x2F;结束迭代器</td></tr></tbody></table><p>3.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::vector</code></th></tr></thead><tbody><tr><td align="center"><strong>大小</strong></td><td align="center">动态可变</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">连续内存</td></tr><tr><td align="center"><strong>访问性能</strong></td><td align="center">随机访问快速</td></tr><tr><td align="center"><strong>插入和删除性能</strong></td><td align="center">末尾操作性能高，其他位置较慢</td></tr><tr><td align="center"><strong>内存增长方式</strong></td><td align="center">容量不足时成倍增长</td></tr></tbody></table><h2 id="3-list容器"><a href="#3-list容器" class="headerlink" title="3. list容器"></a>3. list容器</h2><p><code>&lt;list&gt;</code> 是 C++ 标准模板库中的一个序列容器，它允许在容器的任意位置快速插入和删除元素。与数组或向量<code>&lt;vector&gt;</code>不同，<code>list</code> 不需要在创建时指定大小，并且可以在任何位置添加或删除元素，而不需要重新分配内存。</p><p>1.声明和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst1;                  <span class="comment">// 空的list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 包含5个默认初始化元素的list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 包含5个元素，每个元素为10</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.特点</p><ul><li><strong>双向迭代</strong>：<code>&lt;list&gt;</code> 提供了双向迭代器，可以向前和向后遍历元素。</li><li><strong>动态大小</strong>：与数组不同，<code>&lt;list&gt;</code> 的大小可以动态变化，不需要预先分配固定大小的内存。</li><li><strong>快速插入和删除</strong>：可以在列表的任何位置快速插入或删除元素，而不需要像向量那样移动大量元素。</li></ul><p>3.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>push_back(const T&amp; val)</code></td><td align="left">在链表末尾添加元素</td></tr><tr><td align="left"><code>push_front(const T&amp; val)</code></td><td align="left">在链表头部添加元素</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">删除链表末尾的元素</td></tr><tr><td align="left"><code>pop_front()</code></td><td align="left">删除链表头部的元素</td></tr><tr><td align="left"><code>insert(iterator pos, val)</code></td><td align="left">在指定位置插入元素</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">删除指定位置的元素</td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清空所有元素</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回链表中的元素数量</td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查链表是否为空</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回链表第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回链表最后一个元素</td></tr><tr><td align="left"><code>remove(const T&amp; val)</code></td><td align="left">删除所有等于指定值的元素</td></tr><tr><td align="left"><code>sort()</code></td><td align="left">对链表中的元素进行排序</td></tr><tr><td align="left"><code>merge(list&amp; other)</code></td><td align="left">合并另一个已排序的链表</td></tr><tr><td align="left"><code>reverse()</code></td><td align="left">反转链表</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回链表的起始&#x2F;结束迭代器</td></tr></tbody></table><p>4.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::list</code></th></tr></thead><tbody><tr><td align="center"><strong>内存结构</strong></td><td align="center">非连续内存，双向链表</td></tr><tr><td align="center"><strong>访问性能</strong></td><td align="center">顺序访问较快，随机访问慢</td></tr><tr><td align="center"><strong>插入&#x2F;删除性能</strong></td><td align="center">任意位置插入、删除快</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">频繁在中间插入&#x2F;删除</td></tr><tr><td align="center"><strong>迭代器稳定性</strong></td><td align="center">稳定，元素插入或删除不会失效</td></tr></tbody></table><p>5.注意事项</p><ul><li><code>&lt;list&gt;</code> 的元素是按插入顺序存储的，而不是按元素值排序。</li><li>由于 <code>&lt;list&gt;</code> 的元素存储在不同的内存位置，所以它不适合需要随机访问的场景。</li><li>与向量相比，<code>&lt;list&gt;</code> 的内存使用效率较低，因为每个元素都需要额外的空间来存储指向前后元素的指针。</li></ul><h2 id="4-deque容器"><a href="#4-deque容器" class="headerlink" title="4. deque容器"></a>4. deque容器</h2><p><code>&lt;deque&gt;</code> 提供了双端队列的实现，它在C++中以模板类的形式存在，允许存储任意类型的数据。</p><p><code>&lt;deque&gt;</code> 是一个动态数组，它提供了快速的随机访问能力，同时允许在两端进行高效的插入和删除操作。这使得 <code>&lt;deque&gt;</code> 成为处理需要频繁插入和删除元素的场景的理想选择。</p><p>1.声明和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d;                  <span class="comment">// 空的deque</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 包含5个默认初始化元素的d</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 包含5个元素，每个元素为10</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常用的一些函数</p><table><thead><tr><th align="left">函数名称</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left"><code>operator=</code></td><td align="left">赋值操作符，赋值给 <code>deque</code> 容器。</td></tr><tr><td align="left"><code>assign()</code></td><td align="left">用新值替换 <code>deque</code> 容器中的所有元素。</td></tr><tr><td align="left"><code>at(size_type pos)</code></td><td align="left">返回 <code>pos</code> 位置的元素，并进行范围检查。</td></tr><tr><td align="left"><code>operator[](size_type pos)</code></td><td align="left">返回 <code>pos</code> 位置的元素，不进行范围检查。</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回第一个元素的引用。</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回最后一个元素的引用。</td></tr><tr><td align="left"><code>begin()</code></td><td align="left">返回指向第一个元素的迭代器。</td></tr><tr><td align="left"><code>end()</code></td><td align="left">返回指向末尾元素后一位置的迭代器。</td></tr><tr><td align="left"><code>rbegin()</code></td><td align="left">返回指向最后一个元素的逆向迭代器。</td></tr><tr><td align="left"><code>rend()</code></td><td align="left">返回指向第一个元素之前位置的逆向迭代器。</td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查容器是否为空。</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回容器中的元素个数。</td></tr><tr><td align="left"><code>max_size()</code></td><td align="left">返回容器可容纳的最大元素个数。</td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清除容器中的所有元素。</td></tr><tr><td align="left"><code>insert(iterator pos, const T&amp; value)</code></td><td align="left">在 <code>pos</code> 位置插入 <code>value</code> 元素。</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">移除 <code>pos</code> 位置的元素。</td></tr><tr><td align="left"><code>push_back(const T&amp; value)</code></td><td align="left">在容器末尾添加 <code>value</code> 元素。</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">移除容器末尾的元素。</td></tr><tr><td align="left"><code>push_front(const T&amp; value)</code></td><td align="left">在容器前端添加 <code>value</code> 元素。</td></tr><tr><td align="left"><code>pop_front()</code></td><td align="left">移除容器前端的元素。</td></tr><tr><td align="left"><code>resize(size_type count)</code></td><td align="left">调整容器大小为 <code>count</code>，多出部分用默认值填充。</td></tr><tr><td align="left"><code>swap(deque&amp; other)</code></td><td align="left">交换两个 <code>deque</code> 容器的内容。</td></tr><tr><td align="left"><code>get_allocator()</code></td><td align="left">返回一个用于构造双端队列的分配器对象的副本。</td></tr></tbody></table><p><strong>注意：</strong>在使用 front() 或 back() 之前，确保双端队列不为空，否则会引发未定义的行为。如果需要检查双端队列是否为空，可以使用 empty() 成员函数。</p><h2 id="5-stack容器"><a href="#5-stack容器" class="headerlink" title="5. stack容器"></a>5. stack容器</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准模板库的一部分，它实现了一个后进先出的数据结构。这种数据结构非常适合于需要”最后添加的元素最先被移除”的场景。</p><p><code>&lt;stack&gt;</code> 容器适配器提供了一个栈的接口，它基于其他容器(如 <code>deque</code> 或 <code>vector</code>)来实现。栈的元素是线性排列的，但只允许在一端(栈顶)进行添加和移除操作。</p><p>1.常用的操作</p><ul><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 移除栈顶元素。</li><li><code>top()</code>: 返回栈顶元素的引用，但不移除它。</li><li><code>empty()</code>: 检查栈是否为空。</li><li><code>size()</code>: 返回栈中元素的数量。</li></ul><p>2.注意事项</p><ul><li><code>&lt;stack&gt;</code> 不提供直接访问栈中元素的方法，只能通过 <code>top()</code> 访问栈顶元素。</li><li>尝试在空栈上调用 <code>top()</code> 或 <code>pop()</code> 将导致未定义行为。</li><li><code>&lt;stack&gt;</code> 的底层容器可以是任何支持随机访问迭代器的序列容器，如 <code>vector</code> 或 <code>deque</code>。</li></ul><h2 id="6-queue容器"><a href="#6-queue容器" class="headerlink" title="6. queue容器"></a>6. queue容器</h2><p>C++ 标准库中的 <code>&lt;queue&gt;</code> 头文件提供了队列数据结构的实现。队列是一种先进先出的数据结构，它允许在一端添加元素(称为队尾)，并在另一端移除元素(称为队首)。</p><p>1.常用的操作</p><ul><li><code>empty()</code>: 检查队列是否为空。</li><li><code>size()</code>: 返回队列中的元素数量。</li><li><code>front()</code>: 返回队首元素的引用。</li><li><code>back()</code>: 返回队尾元素的引用。</li><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 移除队首元素。</li></ul><p>2.注意事项</p><ul><li>队列不允许随机访问元素，即不能直接通过索引访问队列中的元素。</li><li>队列的实现通常使用链表或动态数组，这取决于具体的实现。</li></ul><h2 id="7-priority-queue容器"><a href="#7-priority-queue容器" class="headerlink" title="7. priority_queue容器"></a>7. priority_queue容器</h2><p>在 C++ 中，<code>&lt;priority_queue&gt;</code> 是标准模板库的一部分，用于实现优先队列。优先队列是一种特殊的队列，它允许我们快速访问队列中具有最高(或最低)优先级的元素。</p><p>在 C++ 中，<code>priority_queue</code> 默认是一个大顶堆，这意味着队列的顶部元素总是具有最大的值。</p><p><code>priority_queue</code> 是一个容器适配器，它提供了对底层容器的堆操作。它不提供迭代器，也不支持随机访问。</p><p>1.常用的操作</p><ul><li><code>empty()</code>: 检查队列是否为空。</li><li><code>size()</code>: 返回队列中的元素数量。</li><li><code>top()</code>: 返回队列顶部的元素(不删除它)。</li><li><code>push()</code>: 向队列添加一个元素。</li><li><code>pop()</code>: 移除队列顶部的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类型，使用优先队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person1</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="comment">//bool operator&lt;(const person1&amp; p) const &#123;</span></span><br><span class="line"><span class="comment">//return this-&gt;a &gt; p.a;       //小于符号是大顶堆，大于符号是小顶堆</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> person1&amp; p1, <span class="type">const</span> person1&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.b &lt; p2.b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置que为小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; que;   <span class="comment">//参3为less&lt;int&gt;，则是大顶堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义类型的优先队列</span></span><br><span class="line">    <span class="comment">//priority_queue&lt;person1&gt;q;    //方法1的调用</span></span><br><span class="line">    priority_queue&lt;person1, vector&lt;person1&gt;, cmp&gt;q;    <span class="comment">//方法2的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-set容器"><a href="#8-set容器" class="headerlink" title="8. set容器"></a>8. set容器</h2><p>C++ 标准库中的 <code>&lt;set&gt;</code> 是一个关联容器，它存储了一组唯一的元素，并按照一定的顺序进行排序。</p><p><code>&lt;set&gt;</code> 提供了高效的元素查找、插入和删除操作。它是基于红黑树实现的，因此具有对数时间复杂度的查找、插入和删除性能。</p><p><code>&lt;set&gt;</code> 容器中存储的元素类型必须满足以下条件：</p><ul><li>元素类型必须可以比较大小。</li><li>元素类型必须可以被复制和赋值。</li></ul><p>1.常用的操作</p><ul><li><code>insert(元素)</code>: 插入一个元素。</li><li><code>erase(元素)</code>: 删除一个元素。</li><li><code>find(元素)</code>: 查找一个元素。</li><li><code>size()</code>: 返回容器中元素的数量。</li><li><code>empty()</code>: 检查容器是否为空。</li></ul><p>2.set容器的特点：</p><ul><li>所有元素插入时会自动排序</li><li>set容器不存在重复的值</li></ul><p>3.unordered_set容器</p><p>提供了一种基于哈希表的容器，用于存储唯一的元素集合。与 <code>set</code> 不同，<code>unordered_set</code> 不保证元素的自动排序，但通常提供更快的查找、插入和删除操作。常用的操作和set容器大致一样。</p><h2 id="9-map容器"><a href="#9-map容器" class="headerlink" title="9.map容器"></a>9.map容器</h2><p><code>&lt;map&gt;</code> 是标准模板库的一部分，它提供了一种关联容器，用于存储键值对。</p><p><code>map</code> 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景。</p><p>1.定义和特性</p><ul><li><strong>键值对</strong>：<code>map</code> 存储的是键值对，其中每个键都是唯一的。</li><li><strong>排序</strong>：<code>map</code> 中的元素按照键的顺序自动排序，通常是升序。</li><li><strong>唯一性</strong>：每个键在 <code>map</code> 中只能出现一次。</li><li><strong>双向迭代器</strong>：<code>map</code> 提供了双向迭代器，可以向前和向后遍历元素。</li></ul><p>2.常用的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种(不建议，但可以用来访问)</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());  <span class="comment">//删除第一个元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">//按照key删除一个元素</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过key设置排序方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;     <span class="comment">//小于是升序，大于的降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, mycompare&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, mycompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-algorithm算法库"><a href="#3-algorithm算法库" class="headerlink" title="3.  algorithm算法库"></a>3.  algorithm算法库</h1><p>C++ 标准库中的 <code>&lt;algorithm&gt;</code> 头文件提供了一组用于操作容器(如数组、向量、列表等)的算法。这些算法包括排序、搜索、复制、比较等，它们是编写高效、可重用代码的重要工具。</p><p><code>&lt;algorithm&gt;</code> 头文件定义了一组模板函数，这些函数可以应用于任何类型的容器，只要容器支持迭代器。这些算法通常接受两个或更多的迭代器作为参数，表示操作的起始和结束位置。 </p><h2 id="1-排序算法sort"><a href="#1-排序算法sort" class="headerlink" title="1. 排序算法sort"></a>1. 排序算法sort</h2><p>定义：对容器中的元素进行排序。</p><p>语法：<code>sort(container.begin(), container.end(), compare_function);</code></p><p>其中 compare_function 是一个可选的比较函数，用于自定义排序方式。</p><p>其它算法：</p><ul><li><strong>std::partial_sort</strong>: 对部分区间排序</li><li><strong>std::stable_sort</strong>: 稳定排序，保留相等元素的相对顺序。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());         <span class="comment">//普通排序(默认升序)</span></span><br><span class="line">    std::<span class="built_in">partial_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">3</span>, numbers.<span class="built_in">end</span>()); <span class="comment">//前3个是有序，后续的无序(获取最小的3个数)  </span></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());  <span class="comment">//普通排序(相等元素的相对位置不变)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-搜索算法find"><a href="#2-搜索算法find" class="headerlink" title="2. 搜索算法find"></a>2. 搜索算法find</h2><p>定义：在容器中查找与给定值匹配的第一个元素。</p><p>语法：<code>auto it = find(container.begin(), container.end(), value);</code></p><p>如果找到，it 将指向匹配的元素；如果没有找到，it 将等于 container.end()。</p><p>其它算法：</p><ul><li><strong>std::binary_search</strong>: 对有序区间进行二分查找。</li><li><strong>std::find_if</strong>: 查找第一个满足特定条件的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());  <span class="comment">// 先排序</span></span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">4</span>);      <span class="comment">//找4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复制算法copy"><a href="#3-复制算法copy" class="headerlink" title="3. 复制算法copy"></a>3. 复制算法copy</h2><p>定义：将一个范围内的元素复制到另一个容器或数组。</p><p>语法：<code>copy(source_begin, source_end, destination_begin);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> destination[<span class="number">5</span>];</span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), destination);   <span class="comment">//将source中的元素复制到数组destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-比较算法equal"><a href="#4-比较算法equal" class="headerlink" title="4. 比较算法equal"></a>4. 比较算法equal</h2><p>定义：比较两个容器或两个范围内的元素是否相等。</p><p>语法：<code>bool result = equal(first1, last1, first2, compare_function);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> are_equal = std::<span class="built_in">equal</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-修改算法"><a href="#5-修改算法" class="headerlink" title="5. 修改算法"></a>5. 修改算法</h2><p>常用的语法：</p><ul><li><strong>std::reverse</strong>: 反转区间内的元素顺序。<ul><li><code>std::reverse(vec.begin(), vec.end());</code></li></ul></li><li><strong>std::fill</strong>: 将指定区间内的所有元素赋值为某个值。<ul><li><code>std::fill(vec.begin(), vec.end(), 0);  // 所有元素设为 0</code></li></ul></li><li><strong>std::replace</strong>: 将区间内的某个值替换为另一个值。<ul><li><code>std::replace(vec.begin(), vec.end(), 1, 99);  // 将所有 1 替换为 99</code></li></ul></li><li><strong>std::copy</strong>: 将区间内的元素复制到另一个区间。<ul><li><code>std::copy(vec.begin(), vec.end(), vec2.begin());</code></li></ul></li></ul><h2 id="6-归并算法merge"><a href="#6-归并算法merge" class="headerlink" title="6. 归并算法merge"></a>6. 归并算法merge</h2><p>定义：将两个有序区间合并到一个有序区间。</p><p>语法：<code>std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></p><p>其它算法：</p><ul><li><strong>std::inplace_merge</strong>: 在单个区间中合并两个有序子区间。<ul><li><code>std::inplace_merge(vec.begin(), middle, vec.end());</code></li></ul></li></ul><h2 id="7-集合算法"><a href="#7-集合算法" class="headerlink" title="7.  集合算法"></a>7.  集合算法</h2><p>常用的语法：</p><ul><li><p><strong>std::set_union</strong>: 计算两个有序集合的并集。</p><ul><li><code>auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li><li>其中返回的it是result中得到的并集元素中最后一个的下一个位置</li></ul></li><li><p><strong>std::set_intersection</strong>: 计算两个有序集合的交集。</p><ul><li><code>auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li></ul></li><li><p><strong>std::set_difference</strong>: 计算集合的差集。</p><ul><li><code>auto it = std::set_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li></ul></li></ul><h2 id="8-其它有用算法"><a href="#8-其它有用算法" class="headerlink" title="8. 其它有用算法"></a>8. 其它有用算法</h2><p>常用的语法：</p><ul><li><p><strong>std::accumulate（需要 <numeric> 库）</numeric></strong>：计算范围内元素的累计和。</p><ul><li><code>int sum = std::accumulate(vec.begin(), vec.end(), 0);</code></li></ul></li><li><p><strong>std::for_each</strong>: 对区间内的每个元素执行相应操作。</p><ul><li><code>std::for_each(vec.begin(), vec.end(), [](int&amp; x) &#123; x += 1; &#125;);</code></li></ul></li><li><p><strong>std::min_element</strong> 和 <strong>std::max_element</strong>: 查找区间内的最小值和最大值。</p><ul><li><code>auto min_it = std::min_element(vec.begin(), vec.end());</code></li><li><code>auto max_it = std::max_element(vec.begin(), vec.end());</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-c-简介&quot;&gt;&lt;a href=&quot;#1-c-简介&quot; class=&quot;headerlink&quot; title=&quot;1. c++简介&quot;&gt;&lt;/a&gt;1. c++简介&lt;/h1&gt;&lt;p&gt;C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://lxx93.online/2024/09/26/docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/09/26/docker%E5%9F%BA%E7%A1%80/</id>
    <published>2024-09-26T01:04:01.000Z</published>
    <updated>2024-10-07T15:46:26.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-docker概述"><a href="#1-docker概述" class="headerlink" title="1. docker概述"></a>1. docker概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<code>一次镜像，处处运行</code>。</p><p>Linux容器技术的出现就解决了这样一个问题，而Docker就是再它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>docker理念：解决了<code>运行环境和配置问题</code>的<code>软件容器</code>，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>1.传统虚拟机(virtual machine)：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统(如VirtualBox、VMware等)，创建虚拟机(虚拟出各种硬件)，在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢。</p><p>2.Linux容器(Linux Container，简称LXC)：</p><p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><p>3.两者对比</p><table><thead><tr><th align="center">特性</th><th align="center">Docker容器</th><th align="center">虚拟机(VM)</th></tr></thead><tbody><tr><td align="center">操作系统</td><td align="center">与宿主机共享OS</td><td align="center">宿主机OS上运行虚拟机OS</td></tr><tr><td align="center">存储大小</td><td align="center">镜像小，便于存储与传输</td><td align="center">镜像庞大(vmdk、vdi等)</td></tr><tr><td align="center">运行性能</td><td align="center">几乎无额外性能损失</td><td align="center">操作系统额外的CPU、内存消耗</td></tr><tr><td align="center">移植性</td><td align="center">轻便、灵活，适用于Linux</td><td align="center">笨重，与虚拟化技术耦合度高</td></tr><tr><td align="center">硬件亲和性</td><td align="center">面向软件开发者</td><td align="center">面向硬件运维者</td></tr><tr><td align="center">部署速度</td><td align="center">快速，秒级</td><td align="center">较慢，10s以上</td></tr></tbody></table><h2 id="1-3-Docker运行速度快的原因"><a href="#1-3-Docker运行速度快的原因" class="headerlink" title="1.3 Docker运行速度快的原因"></a>1.3 Docker运行速度快的原因</h2><ul><li><p>Docker有比虚拟机更少的抽象层：</p><ul><li>由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。</li></ul></li><li><p>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：</p><ul><li>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</li></ul></li><li><p>Docker容器的本质就是一个进程。</p></li></ul><h2 id="1-4-Docker软件"><a href="#1-4-Docker软件" class="headerlink" title="1.4 Docker软件"></a>1.4 Docker软件</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。在Windows上安装Docker时需要依赖WLS，即Windows下的Linux子系统。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分(三要素)：</p><ul><li><p>镜像(image)：就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p></li><li><p>容器(container)：Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。</p></li><li><p>仓库(repository)：是集中存放镜像文件的场所。</p></li></ul><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S(Client-Server) 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/1.png"></p><p>Docker运行的基本流程为：</p><ul><li><p>用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p></li><li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p></li><li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p></li><li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p></li><li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p></li><li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p></li><li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/2.png"></p><h1 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2. 安装docker"></a>2. 安装docker</h1><h2 id="2-1-linux系统"><a href="#2-1-linux系统" class="headerlink" title="2.1 linux系统"></a>2.1 linux系统</h2><p>1.安装gcc：<code>yum -y install gcc</code></p><p>2.安装g++：<code>yum -y install gcc-c++</code></p><p>3.# yum-util提供yum-config-manager功能：<code>yum install -y yum-utils</code></p><p>4.配置docker的资源库(阿里云镜像地址)：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>5.更新yum软件包索引(可选)：<code>yum makecache fast</code></p><p>6.安装Docker引擎：<code>yum install docker-ce docker-ce-cli containerd.io</code></p><p>7.启动docker：<code>systemctl start docker</code></p><ul><li><p>通过<code>ps -ef | grep docker</code>查看启动的docker</p></li><li><p>此时查看docker版本，可以看到Server: Docker Engine(Docker引擎)版本号：<code>docker version</code></p></li></ul><p>8.测试：<code>docker run hello-world</code></p><p>其它命令：</p><p>使用yum删除docker引擎 ：<code>yum remove docker-ce docker-ce-cli containerd.io</code></p><p>删除镜像、容器、卷、自定义配置等文件 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="2-2-配置加速器"><a href="#2-2-配置加速器" class="headerlink" title="2.2 配置加速器"></a>2.2 配置加速器</h2><p>往<code>daemon.json</code>中写入内容，终端执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://u7fgx15j.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后刷新配置、重启docker即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>注意：但是发现这样配置加速器后，当执行<code>docker run hello-world</code>时，依然会拉取不成功，出现以下问题：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/3.png"></p><p>解决方案1(推荐)：</p><p>1.在<code>/etc/docker/daemon.json</code>文件中改写为以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://do.nark.eu.org&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dc.j8.work&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后刷新配置、重启docker</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon<span class="literal">-reload</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>3.检查registry mirror刚刚配置的加速地址是否成功，执行<code>docker info</code></p><p>当最下面能看到如下内容，表示配置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/4.png"></p><p>4.执行<code>docker run hello-world</code>就可以发现成功了</p><blockquote><p>run的作用：开始时，Docker在本机中寻找该镜像，如果本机有该镜像，就以该镜像为模板生产容器实例运行；如果本机没有该镜像，就去Docker Hub上查找该镜像，Hub如果能找到，就下载该镜像到本地，以该镜像为模板生产容器实例运行；如果Hub不能找到，就返回失败错误，查不到该镜像。</p></blockquote><p>解决方案2：由于目前国内的许多镜像都被停用了，所以想要拉取镜像，得用一些不常规的方法，如下所示：</p><p>先在<code>/etc/docker/daemon.json</code>里面添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://register.liberx.info&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker后，如果想要<code>docker search</code>，在终端执行是不管用的，得在网址<a href="https://register.liberx.info/">https://register.liberx.info/</a>提供的页面里输入相应的镜像查看，该页面所提供的镜像版本都可以在linux终端通过<code>docker pull</code>；来拉取获得。</p><h1 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3 .Docker常用命令"></a>3 .Docker常用命令</h1><h2 id="3-1-帮助启动类命令"><a href="#3-1-帮助启动类命令" class="headerlink" title="3.1 帮助启动类命令"></a>3.1 帮助启动类命令</h2><p>1.启动docker：<code>systemctl start docker</code></p><p>2.停止docker：<code>systemctl stop docker</code></p><p>3.重启docker：<code>systemctl restart docker</code></p><p>4.查看docker状态：<code>systemctl status docker</code></p><p>5.开机自启动：<code>systemctl enable docker</code></p><p>6.查看docker概要信息：<code>docker info</code></p><p>7.查看docker总体帮助文档：<code>docker --help</code></p><p>8.查看docker命令帮助文档：<code>docker 具体命令 --help</code></p><h2 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h2><p>1.列出本地主机上的镜像：<code>docker images</code></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/5.png"></p><p>REPOSITORY：表示镜像的仓库源</p><p>TAG：镜像的标签版本号</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像创建时间</p><p>SIZE：镜像大小</p><blockquote><p>同一仓库源可以有多个TAG版本，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果不指定一个镜像的版本标签。例如只使用ubuntu，docker将默认使用ubuntu:latest镜像</p></blockquote><p>OPTIONS说明：</p><ul><li>-a：列出本地所有的镜像(含历史映像层)</li><li>-q：只显示镜像ID</li></ul><p>2.查镜像：<code>docker search 某个xxx镜像名字</code></p><p>含义：通过相应的镜像加速器去Hub(远程仓库)上面去查找有无需要的镜像</p><p>属性解释：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">镜像名称</td></tr><tr><td align="center">DESCRIPTION</td><td align="center">镜像说明</td></tr><tr><td align="center">STARS</td><td align="center">点赞数量</td></tr><tr><td align="center">OFFICIAL</td><td align="center">是否是官方的</td></tr><tr><td align="center">AUTOMATED</td><td align="center">是否是自动构建的</td></tr></tbody></table><p>OPTIONS说明：</p><ul><li>–limit：只列出N个镜像，默认是25个</li><li>docker search –limit 5 redis：表示只列出5个redis镜像</li></ul><p>3.拉取镜像：<code>docker pull 某个xxx镜像名字</code></p><ul><li>pull镜像名字的时候，如果没有加对应的版本号，就默认下载最新的版本:latest，如<code>docker pull redis:6.0.8</code>是下载redis的6.0.8版本</li></ul><p>4.查看镜像&#x2F;容器&#x2F;数据卷所占的空间：<code>docker system df</code></p><p>5.删除镜像：<code>docker rmi 某个xxx镜像名字ID</code></p><ul><li><p>有些情况下，因为某种原因，不能直接删除对应的镜像，这时就需要通过<code>docker rmi -f 镜像名字ID</code>强制删除</p></li><li><p>如果需要删除多个镜像，后面进行追加即可，如果需要删除全部镜像，可以通过<code>docker rmi -f $(docker images -qa)</code>实现</p></li></ul><blockquote><p>面试题：谈谈docker虚悬镜像是什么？</p><p>仓库名、标签都是<none>的镜像，就俗称虚悬镜像dangling image。这种镜像建议删除，没什么用，有时候docker构建的时候，会出现一些问题。</none></p></blockquote><h2 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h2><p>有镜像才能创建容器，这是根本前提。镜像是模板，容器是实例</p><p>1.新建+启动容器 ——-&gt;启动交互式容器(前台命令行)</p><p>指令：docker run [OPTIONS] image [COMMAND] [ARG…] </p><p>OPTIONS说明(常用)：有些是一个减号，有些是两个减号</p><ul><li><p>–name&#x3D;”容器新名字”：为容器指定一个名称(没有取的话，系统会随机取一个名字)；</p></li><li><p>-d：后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p></li><li><p>-i：以交互模式运行容器，通常与-t同时使用；</p></li><li><p>-t：为容器重新分配一个伪输入终端，通过与-i同时使用。也即启动交互式容器(前台有伪终端，等待交互)</p></li><li><p>-P：随机端口映射，大写P</p></li><li><p>-p：指定端口映射，小写p</p></li></ul><p>如：<code>docker run -it ubuntu /bin/bash</code></p><ul><li>ubuntu：ubuntu镜像</li><li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里希望有个交互式Shell，因此用的是&#x2F;bin&#x2F;bash</li><li>退出终端，直接输入exit</li></ul><p>2.列出当前所有正在运行的容器</p><p>指令：docker ps [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器</li><li>-n 数字：显示最近(数字)个创建的容器</li><li>-q：静默模式，只显示容器编号</li></ul><p>例子：再通过ubuntu镜像创建一个容器实例，然后查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=myu1 ubuntu bash</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/6.png"></p><p>3.退出容器</p><ul><li>exit：run进行容器，exit退出，容器停止</li><li>ctrl+p+q：run进去容器，ctrl+p+q退出，容器不停止</li></ul><p>4.启动已停止运行的容器：docker start 容器ID或者容器名</p><p>5.重启容器：docker restart 容器ID或者容器名</p><p>6.停止容器：docker stop 容器ID或者容器名</p><p>7.强制停止容器：docker kill 容器ID或者容器名</p><p>8.删除已停止的容器：docker rm 容器ID</p><ul><li><p>加-f可以强制删除活着的容器</p></li><li><p>一次性删除多个容器实例：</p><ul><li>docker rm -f $(docker ps -a -q)</li><li>docker ps -a -q | xargs docker rm</li></ul></li></ul><p>9.启动守护式容器(后台服务器)</p><p>在大部分的场景下，我们希望docker的服务是在后台运行的，这样就可以通过-d指定容器的后台运行模式。</p><p>问题：使用镜像ubuntu:latest以后台模式启动一个容器，终端执行docker run -d ubuntu后，用docker ps -a进行查看，会发现容器已经退出。所以非常重要的一点是，docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令(比如运行top、tail)，就是会自动退出的。所以有些镜像-d是不可以的，doekcr机制必须要用-it。</p><p>对应像mysql和redis等应用，使用前台交互式启动<code>docker run -it redis:6.0.8</code>是不怎么合理的，因为不小心关掉窗口或ctrl+c都容易导致服务停止，容易误伤。所以以后台守护式启动更加合理。</p><p>10.查看容器的日志：<code>docker logs 容器ID</code></p><p>11.查看容器内运行的进程：<code>docker top 容器ID</code></p><p>12.查看容器内部细节：docker inspect 容器ID</p><p>13.进入正在运行的容器并以命令行交互</p><ul><li>docker exec -it 容器ID bin&#x2F;bash</li><li>docker attach 容器ID</li></ul><p>应用：当是通过ctrl+p+q退出的容器，但其容器还在运行，或者像进入一些通过后台守护式启动的容器，可以通过上面两种方法重新进入容器。</p><p>两者之间的区别：</p><ul><li>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出后，会导致容器停止</li><li>exec是在容器中打开新的终端，并且可以启动新的进程，用exec退出后，不会导致容器停止(建议使用)</li></ul><p>14.从容器内拷贝文件到主机上：<code>docker cp 容器ID:容器内路径 目的主机路径</code></p><p>例子：将容器ID为ddb1ae909a66容器里面目录文件&#x2F;tmp&#x2F;a.txt拷贝到主机的&#x2F;test目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ddb1ae909a66:/tmp/a.txt /test</span><br></pre></td></tr></table></figure><p>15.导入和导出容器</p><ul><li>export导出容器的内容留作为一个tar归档文件<ul><li>指令：docker export 容器ID &gt; 文件名.tar</li></ul></li><li>import从tar包中的内容创建一个新的文件系统再导入为镜像<ul><li>指令：cat 文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本号</li></ul></li></ul><h1 id="4-Docker镜像"><a href="#4-Docker镜像" class="headerlink" title="4. Docker镜像"></a>4. Docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>只有通过这个镜像文件才能生成Docker容器实例。</p><h2 id="4-1-联合文件系统"><a href="#4-1-联合文件系统" class="headerlink" title="4.1 联合文件系统"></a>4.1 联合文件系统</h2><p>联合文件系统(UnionFS)：Union文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像可以制作具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="4-2-Docker镜像加载原理"><a href="#4-2-Docker镜像加载原理" class="headerlink" title="4.2 Docker镜像加载原理"></a>4.2 Docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就叫联合文件系统。</p><p>bootfs(boot file system)主要包含 bootloader 和 kernel，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统。在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs（root file system，在bootfs之上，包含的就是典型Linux系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code>等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu、CentOS等。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/7.png"></p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。</p><blockquote><p>Docker镜像要采用这种分层结构的原因：镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p></blockquote><h2 id="4-3-容器层"><a href="#4-3-容器层" class="headerlink" title="4.3 容器层"></a>4.3 容器层</h2><p>Docker镜像层都是只读的，容器层是可写的</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动，即添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/8.png"></p><h2 id="4-4-Docker镜像commit操作"><a href="#4-4-Docker镜像commit操作" class="headerlink" title="4.4 Docker镜像commit操作"></a>4.4 Docker镜像commit操作</h2><p>docker commit提交容器副本使之成为一个新的镜像</p><ul><li>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]</li></ul><p>案例：演示ubuntu安装vim</p><ol><li><p>从Hub上下载ubuntu镜像到本地并成功运行，原始的默认ubuntu镜像是不带着vim命令的</p><ul><li>下载镜像：<code>docker pull ubuntu</code></li><li>运行：<code>docker run -it ubuntu /bin/bash</code></li></ul></li><li><p>外网连通的情况下，安装vim</p><ul><li>先更新包管理工具：<code>apt-get update</code></li><li>然后安装需要的vim：<code>apt-get install vim</code></li></ul></li><li><p>安装完成后，commit一个新镜像(与之前镜像不一样的)</p><ul><li><p><code>docker commit -m=&quot;vim cmd add ok&quot; -a=&quot;lxx&quot; 734e289931b0 lxxmake/myubuntu:1.0</code></p></li><li><p>查看本地镜像：<code>docker images</code></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/9.png"></p></li></ul></li><li><p>启动新镜像后，可以使用vim编辑</p><ul><li><code>docker run -it lxxmake/myubuntu:1.0 /bin/bash</code></li></ul></li></ol><p>总结：Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/10.png"></p><h2 id="4-5-本地镜像发布到阿里云"><a href="#4-5-本地镜像发布到阿里云" class="headerlink" title="4.5 本地镜像发布到阿里云"></a>4.5 本地镜像发布到阿里云</h2><p>1.进入阿里云官网，先点击左上角的列表，点击容器里面的容器镜像服务。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/11.png"></p><p>2.在弹出的如下页面，先完成个人实例的创建</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/12.png"></p><p>3.点击创建命名空间，随便取一个名字即可</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/13.png"></p><p>4.为刚刚创建的命名空间创建一个镜像仓库</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/14.png"></p><p>5.填写完相关信息，进入下一步，选择本地仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/15.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/16.png"></p><p>6.完成以上操作后，就会有该界面了，点击管理进入仓库管理</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/17.png"></p><p>7.点击管理后，就会进入该页面，这里有从我们本地将镜像推送到阿里云的步骤，也有从阿里云拉取镜像会本地的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/18.png"></p><p>下面是我在linux系统上操作的情况：首先是将本地自己写的镜像拉取到阿里云(操作1、操作2、操作3)，然后删除本地的这个镜像(操作4)，在确保本地没有该镜像后，再从阿里云上拉取回刚刚推送的镜像(操作5)。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/19.png"></p><h2 id="4-6-本地镜像发布到私有库"><a href="#4-6-本地镜像发布到私有库" class="headerlink" title="4.6 本地镜像发布到私有库"></a>4.6 本地镜像发布到私有库</h2><p>官方Docker Hub地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p><p>操作步骤：省略</p><h1 id="5-容器卷"><a href="#5-容器卷" class="headerlink" title="5. 容器卷"></a>5. 容器卷</h1><p>容器卷有点类似于Redis里面的rdb和aof文件，将docker容器内的数据保存进宿主机的磁盘中，以达到数据的持久化和敏感重要数据的备份(通过映射目录实现)。</p><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><blockquote><p>作用：众所周知，将运用与运行的环境打包镜像，run后形成容器实例运行，但是我们是希望数据能够持久化的。Docker容器产生的数据，如果不进行备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能够保存数据在docker中，所以就需要使用卷了。</p></blockquote><p>特点：</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p>1.运行一个带有容器卷存储功能的容器实例：<code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</code></p><p>案例1：宿主和容器之间映射添加容器卷</p><p>首先是通过带有容器卷存储功能的方式进入容器，这里指明了本地的映射目录是&#x2F;docker&#x2F;host_data，容器里面对应的映射目录是&#x2F;docker&#x2F;docker_data。</p><p>下面是完成映射绑定之后，对应的容器端，在这容器里面的映射目录下创建的文件，会同步到本地映射目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/20.png"></p><p>下面是本地映射目录端，在这里面创建的文件，也会同步映射到容器对应的映射目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/21.png"></p><p>注意：当把容器停掉之后，在本地映射目录下继续添加、修改文件等操作，都还是会同步到容器对应的映射目录下。</p><p>2.读写规则映射添加说明</p><p>上面的操作是默认支持读写规则的，但有些情况下，只是像将本地的内容映射到容器，而不想容器能进行修改，即容器自己只能读取不能写，就需要通过ro来进行指明。</p><p>指令：<code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p><p>3.卷的继承和共享</p><p>指令：通过<code>--volumes-from 父类名</code>来完成</p><p>案例2：以ubuntu镜像为例，实现继承操作</p><p>容器1先完成和宿主机的映射：docker run -it –privileged&#x3D;true -v &#x2F;tmp&#x2F;host_data:&#x2F;tmp&#x2F;docker_data –name&#x3D;u1 ubuntu</p><p>容器2继承容器1的卷规则：docker run -it –privileged&#x3D;true –volumes-from u1 –name&#x3D;u2 ubuntu</p><blockquote><p>需要了解的是，在完成上面两个指令后，之前容器u1和宿主机映射目录的文件，在容器u2中也具备了，u2在继承下来的映射目录下进行添加或修改文件等操作也会同步到u1和宿主机中。</p></blockquote><h1 id="6-docker常规软件安装"><a href="#6-docker常规软件安装" class="headerlink" title="6. docker常规软件安装"></a>6. docker常规软件安装</h1><p>总体步骤：</p><ol><li><p>搜索镜像</p></li><li><p>拉取镜像</p></li><li><p>查看镜像</p></li><li><p>启动镜像(服务端口映射)</p></li><li><p>停止容器</p></li><li><p>移除容器</p></li></ol><h2 id="6-1-tomcat安装"><a href="#6-1-tomcat安装" class="headerlink" title="6.1 tomcat安装"></a>6.1 tomcat安装</h2><p>1.在docker hub官网<a href="https://hub.docker.com/">https://hub.docker.com/</a>上面查找tomcat镜像，如果有对应的镜像，才能拉取下载到本地。</p><p>2.从docker hub上拉取tomcat镜像到本地：<code>docker pull tomcat</code></p><p>3.查看是否有拉取到的tomcat：<code>docker images</code></p><p>4.使用tomcat镜像创建容器实例(运行镜像)</p><ul><li>指令：<code>docker run -it -p 8080:8080 tomcat</code><ul><li>-p：小写，主机端口:docker容器端口</li><li>-P：大写，随机分配端口</li><li>-i：交互</li><li>-t：终端</li><li>-d：后台</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/22.png"></p><p>5.访问猫主页</p><ul><li>问题：当进入tomcat后，在虚拟机的火狐上通过<code>localhost:8080</code>访问时，不会弹出一只猫的页面，这是不正常的。</li><li>原因：这是因为在新版的tomcat中做了改变，在通过<code>docker exec -it 9aada4d3af80 /bin/bash</code>进入tomcat后，它的<code>webapps</code>目录下的内容为空。真正有内容的已经被改为了webapps.dist文件夹</li><li>解决方法：<ul><li>通过<code>rm -r webapps</code>删除该文件夹</li><li>通过<code>mv webapps.dist webapps</code>将文件夹webapps.dist重新命名为webapps</li><li>这样就完成了，在虚拟机上搜索localhost:8080就可以看到了一只猫的页面了</li></ul></li></ul><p>补充：所有的docker容器实例其本质而言均是一个迷你版的、精简版的内核版的linux</p><p>6.免费改版说明</p><p>可以通过下载非最新版来避免上面一系列的繁琐操作，运行后直接通过<code>localhost:8080</code>访问得到一只猫的页面了</p><ul><li>下载镜像：<code>docker pull billygoo/tomcat8-jdk8</code></li><li>后台运行：<code>docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8</code></li></ul><h2 id="6-2-安装mysql"><a href="#6-2-安装mysql" class="headerlink" title="6.2 安装mysql"></a>6.2 安装mysql</h2><p>1.在docker hub上面查找mysql镜像</p><p>2.从docker hub上拉取mysql镜像到本地标签为5.7(这里以5.7版本为例)</p><ul><li>下载拉取：<code>docker pull mysql:5.7</code></li></ul><p>3.使用mysql15.7镜像创建容器(运行镜像)</p><ul><li>指令：<code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code><ul><li>注意：当linux服务器上本身装了mysql，且是启动的，所以在使用docker之前，端口3306就已经被占用了，所以在执行该命令之前，需要先将linux系统本身的mysql停掉</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/23.png"></p><p>4.进入容器中的mysql</p><ul><li>进入装有mysql容器：<code>docker exec -it 555d7763267c /bin/bash</code></li><li>进入mysql：<code>mysql -uroot -p</code></li><li>输入密码123456，进入后所有操作和在linux上操作mysql一模一样</li><li>查看使用的字符集：<code>SHOW VARIABLES LIKE &#39;character%&#39;;</code> —–&gt;发现使用的基本上都不是utf-8</li></ul><p>5.完善</p><ul><li><p>问题：1.插入中文数据会出现报错乱码；2删除容器后，里面的mysql数据全没了</p></li><li><p>解决方法：对容器里面mysql的日志、数据和配置进行挂载，即挂载3个容器卷。</p><ul><li><p>执行指令：docker run -d -p 3306:3306 –privileged&#x3D;true -v &#x2F;database&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;database&#x2F;mysql&#x2F;ldata:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;database&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name mysql1 mysql:5.7</p></li><li><p>在主机的&#x2F;database&#x2F;mysql&#x2F;conf&#x2F;文件夹下新建my.cnf，添加内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure></li><li><p>重新启动mysql容器实例，再重新进入：<code>docker restart mysql1</code>  —–&gt;注意：mysql1是之前创建时取的容器名字</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-docker概述&quot;&gt;&lt;a href=&quot;#1-docker概述&quot; class=&quot;headerlink&quot; title=&quot;1. docker概述&quot;&gt;&lt;/a&gt;1. docker概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="https://lxx93.online/2024/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB/"/>
    <id>https://lxx93.online/2024/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB/</id>
    <published>2024-09-15T01:35:50.000Z</published>
    <updated>2024-09-16T15:48:39.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MongoDB是一个基于分布式文件存储的数据库，操作语法与JavaScript类似，容易上手。它与mysql不一样，mysql操作的是表格，即结构化数据，而mongodb操作的是json非结构化数据。下载地址<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>数据库是按照数据结构来组织、存储和管理数据的<code>应用程序</code>，主要作用就是<code>管理数据</code>，对数据进行增删改查。</p><p>Mongodb数据库在使用前，需要在终端执行<code>mongod</code>来打开数据库服务端，在终端执行<code>mongo</code>打开客户端，通过相关命令来完成数据库的增删改查。当然也可以下载<code>Mongoose</code>包来通过代码完成对<code>Mongodb</code>数据库的增删改查。</p><p>相比纯文件管理数据，数据库管理数据有如下特点：</p><ul><li>速度更快</li><li>扩展性更高</li><li>安全性更高</li></ul><p>Mongodb中有三个重要概念：</p><ul><li><p>数据库(database)：是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合</p></li><li><p>集合(collection)：集合类似于 JS 中的数组，在集合中可以存放很多文档</p></li><li><p>文档(document)：档是数据库中的最小单位，类似于 JS 中的对象</p></li></ul><p>理解：</p><ul><li>一个JSON文件好比是一个<code>数据库</code>，一个Mongodb服务下可以有N个数据库</li><li>JSON文件中的一级属性的数组值好比是<code>集合</code></li><li>数组中的对象好比是<code>文档</code></li><li>对象中的属性也可以称为<code>字段</code></li></ul><blockquote><p>一般情况下：</p><ul><li><p>一个项目使用一个数据库</p></li><li><p>一个集合会存储同一种类型的数据</p></li></ul></blockquote><h1 id="2-操作命令"><a href="#2-操作命令" class="headerlink" title="2. 操作命令"></a>2. 操作命令</h1><p>1.显示所有的数据块：<code>show dbs</code></p><p>2.切换到指定的数据库，如果数据库不存在会自动创建数据库：<code>use 数据库名</code></p><p>3.显示当前数据库：<code>db</code></p><p>4.删除当前数据库：先<code>use 库名</code>，再<code>db.dropDatabase()</code></p><p>5.创建集合：db.createCollection(‘集合名称’)</p><p>6.显示当前数据库中的所有集合：show collections</p><p>7.删除某个集合：db.集合名.drop()</p><p>8.重命名集合：db.集合名.renameCollection(‘newName’)</p><p>9.插入文档：db.集合名.insert(文档对象)</p><p>10.查询文档：db.集合名.find(查询条件)</p><ul><li>_id是mongodb自动生成的唯一编号，用来唯一标识文档</li></ul><p>11.更新文档：</p><ul><li>db.集合名.update(查询条件,新的文档)</li><li>db.集合名.update({name:’张三’},{$set:{age:19}})</li></ul><p>12.删除文档：db.集合名.remove(查询条件)</p><h1 id="3-Mongoose"><a href="#3-Mongoose" class="headerlink" title="3. Mongoose"></a>3. Mongoose</h1><p><code>Mongoose</code>是一个对象文档模型库，主要作用就是方便使用代码操作<code>mongodb</code>数据库。</p><p>因为它有事一个工具包，所以在通过<code>npm init</code>创建一个包后，就可以在该文件夹下使用<code>npm i mongoose</code>来下载该包。</p><h2 id="3-1-通过mongoose连接上Mongodb数据库"><a href="#3-1-通过mongoose连接上Mongodb数据库" class="headerlink" title="3.1 通过mongoose连接上Mongodb数据库"></a>3.1 通过mongoose连接上Mongodb数据库</h2><p>在下载Mongoose工具包后，在该文件夹下创建一个js文件，添加以下程序即可完成连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接mongodb服务</span></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://127.0.0.1:27017/bilibili&#x27;</span>);      <span class="comment">//协议-ip-端口-路径(要操作数据库的名称，不存在会自动创建)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123; <span class="comment">//设置连接成功的回调，这里on和once都可以，区别在于once只会连接1次(当服务端关了又开了后，once不会去连接了)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">()=&gt;</span>&#123;           <span class="comment">//设置连接错误的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接失败&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">()=&gt;</span>&#123;           <span class="comment">//设置连接关闭的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接关闭&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭mongodb的连接</span></span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">&#125;, <span class="number">2000</span>);          <span class="comment">//2s钟后关闭</span></span><br></pre></td></tr></table></figure><h2 id="3-2-Mongoose插入文档"><a href="#3-2-Mongoose插入文档" class="headerlink" title="3.2 Mongoose插入文档"></a>3.2 Mongoose插入文档</h2><p>对于文档的插入操作，是在连接成功的回调函数中执行。在下面程序中，需要注意的是：在旧版本中 <code>Model.create()</code> 的<code>第二个参数是一个回调函数</code>用来捕获成功或异常。但是最新版本中，<code>Model.create()</code> 中<code>就没有第二个参数了</code>，而是返回了一个 <code>Promise</code> 对象，我们将采用 <code>then</code> 方法 和 <code>catch</code> 方法来捕获状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123; <span class="comment">//设置连接成功的回调，这里on和once都可以，区别在于once只会连接1次(当服务端关了又开了后，once不会去连接了)</span></span><br><span class="line">    <span class="comment">//创建文档的结构对象</span></span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    <span class="comment">//新增(下面这种方式在高版本是不支持的，会报错)</span></span><br><span class="line">    <span class="comment">// BookModel.create(&#123;</span></span><br><span class="line">    <span class="comment">//     name: &#x27;西游记&#x27;,</span></span><br><span class="line">    <span class="comment">//     author: &#x27;吴承恩&#x27;,</span></span><br><span class="line">    <span class="comment">//     price: 19.9</span></span><br><span class="line">    <span class="comment">// &#125;, (err, data) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     //如果出现错误</span></span><br><span class="line">    <span class="comment">//     if(err)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(err);</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //如果没有出错，则输出插入后的文档对象</span></span><br><span class="line">    <span class="comment">//     console.log(data);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//较高的版本使用这种方式插入</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">19.9</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//关闭数据块连接</span></span><br><span class="line">    mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-3-字段类型"><a href="#3-3-字段类型" class="headerlink" title="3.3 字段类型"></a>3.3 字段类型</h2><p>文档结构可选的常用字段类型列表：</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">字符串</td></tr><tr><td align="center">Number</td><td align="center">数字</td></tr><tr><td align="center">Boolean</td><td align="center">布尔值</td></tr><tr><td align="center">Array</td><td align="center">数组，也可以使用[]来标识</td></tr><tr><td align="center">Date</td><td align="center">日期</td></tr><tr><td align="center">Buffer</td><td align="center">Buffer对象</td></tr><tr><td align="center">Mixed</td><td align="center">任意类型，需要使用mongoose.Schema.Types.Mixed指定</td></tr><tr><td align="center">Objectld</td><td align="center">对象ID，需要使用mongoose.Schema.Types.ObjectId指定</td></tr><tr><td align="center">Decimal128</td><td align="center">高精度数字，需要使用mongoose.Schema.Types.Decimal128指定</td></tr></tbody></table><p>测试程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//创建文档的结构对象</span></span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">tags</span>: <span class="title class_">Array</span>,</span><br><span class="line">        <span class="attr">pub_time</span>: <span class="title class_">Date</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">19.9</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">tags</span>: [<span class="string">&#x27;鬼怪&#x27;</span>, <span class="string">&#x27;励志&#x27;</span>, <span class="string">&#x27;社会&#x27;</span>],</span><br><span class="line">        <span class="attr">pub_time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()              <span class="comment">//当前时间为发布时间</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();         <span class="comment">//关闭数据库</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();         <span class="comment">//关闭数据库</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-字段值验证"><a href="#3-4-字段值验证" class="headerlink" title="3.4 字段值验证"></a>3.4 字段值验证</h2><p>Mongoose有一些内建验证器，可以对字段值进行验证</p><p>1.必填项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>         <span class="comment">//表明该属性必须不为空</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">author</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">default</span>: <span class="string">&#x27;匿名&#x27;</span>        <span class="comment">//设置默认值，如果没有选择这一属性，会默认为`匿名`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3.枚举值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gender</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">enum</span>: [<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>]         <span class="comment">//设置的值必须是数组中的</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>4.唯一值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">unique</span>: <span class="literal">true</span>            <span class="comment">//设置这个属性为唯一性，不能有重复的该字段名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>unique 需要 重建集合 才能有效果</p></li><li><p>永远不要相信用户的输入，需要检查后再插入数据库</p></li></ul><p>测试程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,         <span class="comment">//表明该属性必须不为空</span></span><br><span class="line">            <span class="attr">unique</span>: <span class="literal">true</span>            <span class="comment">//设置为独一无二的，不能重复的属性名</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">author</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;匿名&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">enum</span>: [<span class="string">&#x27;言情&#x27;</span>, <span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;志怪&#x27;</span>, <span class="string">&#x27;恐怖&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,           <span class="comment">//为空了会报错</span></span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,         <span class="comment">//没有这一项，会默认作者是&#x27;匿名&#x27;</span></span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;言情&#x27;</span>             <span class="comment">//类型只能选择上面定义好的枚举类里面的内容</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-5-Mongoose删除和更新文档"><a href="#3-5-Mongoose删除和更新文档" class="headerlink" title="3.5 Mongoose删除和更新文档"></a>3.5 Mongoose删除和更新文档</h2><p>下面程序需要注意的是，由于版本的问题，现在高版本已经不支持<code>BookModel.deleteMany(&#123;&#125;, (err, data) =&gt; &#123;&#125;);</code>这种回调的写法了。</p><p>1.通过以下方式来完成删除操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除1条，因为版本问题，不同通过回调函数的形式来写了</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">deleteOne</span>(&#123;<span class="attr">_id</span>: <span class="string">&#x27;66e65604f92fdec9fa0a7f53&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//批量删除，删除is_hot为false的文档</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">deleteMany</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">false</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.通过以下方式来完成更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新数据1条(参数：条件；更新的情况)</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">updateOne</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">13.9</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//批量更新</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">updateMany</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">true</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">19.9</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-6-读取文档"><a href="#3-6-读取文档" class="headerlink" title="3.6 读取文档"></a>3.6 读取文档</h2><p>1.普通读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    <span class="comment">//1.读取单条</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//2.通过id获取</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">findById</span>(<span class="string">&#x27;66e65688565eb1640b878f88&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//3.批量获取(如果find里面没有写任何内容，就是获取全部)</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">true</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.运算符</p><p>在mongodb不能直接使用<code>&gt;、&lt;、&gt;=、&lt;=、!==</code>等运算符，需要使用替代符号：</p><ul><li><code>&gt;</code>使用<code>$gt</code></li><li><code>&lt;</code>使用<code>$lt</code></li><li><code>&gt;=</code>使用<code>$gte</code></li><li><code>&lt;=</code>使用<code>$lte</code></li><li><code>!==</code>使用<code>$ne</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找价格小于30的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">price</span>: &#123;<span class="attr">$lt</span>: <span class="number">30</span>&#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>3.逻辑运算</p><ul><li><code>$or</code>表示逻辑或</li><li><code>$and</code>表示逻辑与</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找名字为名侦探柯南或海贼王的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">$or</span>: [&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">&#x27;海贼王&#x27;</span>&#125;]</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//价格大于15，下于30的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">$and</span>: [&#123;<span class="attr">price</span>: &#123;<span class="attr">$gt</span>: <span class="number">15</span>&#125;&#125;, &#123;<span class="attr">price</span>: &#123;<span class="attr">$lt</span>:<span class="number">30</span>&#125;&#125;]</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>4.正则匹配</p><p>条件中可以直接使用JS的正则语法，通过正则可以进行模糊查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找名字带柯的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="regexp">/柯/</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>5.个性化读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取全部数据，但每条数据只显示name和author</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>        <span class="comment">//如果不添加_id: 0，默认会有id的</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//对数据的价格进行升序排序</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    .<span class="title function_">sort</span>(&#123;<span class="attr">price</span>: <span class="number">1</span>&#125;)                  <span class="comment">//1是升序；-1是倒序</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//按照价格降序排序，又跳过了3个，所以选择查看第4和第5贵的书籍信息</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>&#125;)</span><br><span class="line">      .<span class="title function_">sort</span>(&#123;<span class="attr">price</span>: -<span class="number">1</span>&#125;)            <span class="comment">//降序</span></span><br><span class="line">      .<span class="title function_">skip</span>(<span class="number">3</span>)                      <span class="comment">//跳过前面3个</span></span><br><span class="line">      .<span class="title function_">limit</span>(<span class="number">2</span>)                     <span class="comment">//限定，选择前2个</span></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>最后如果想要操作更加的简单，可以使用Mongodb的图形化工具，比如说Navicat等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;MongoDB是一个基于分布式文件存储的数据库，操作语法与JavaScript类似，容易上手。它与mysql不一样，my</summary>
      
    
    
    
    <category term="数据库" scheme="https://lxx93.online/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>nodejs基础</title>
    <link href="https://lxx93.online/2024/09/10/nodejs%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/09/10/nodejs%E5%9F%BA%E7%A1%80/</id>
    <published>2024-09-10T13:22:55.000Z</published>
    <updated>2024-10-07T15:09:27.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Node.js是一个开源的，跨平台的JavaScript运行环境。通俗来讲，node.js就是一款应用程序，是一款软件，它可以运行JavaScript。</p><h2 id="1-1-Node-js的作用"><a href="#1-1-Node-js的作用" class="headerlink" title="1.1 Node.js的作用"></a>1.1 Node.js的作用</h2><p>1.开发服务器应用</p><p>众所周知，网页的构建是通过HTML、CSS、JavaScript来完成的，其中HTML负责控制结构、CSS负责控制样式、JS负责控制交互和效果。当在本机双击HTML文件后，页面就能够打开，但是这个网页只能在本机看到。如果想要该网页能够让每个人都能够访问，就需要使用服务器了。因为服务器能够保存我们写好的HTML、CSS、JavaScript，其他用户能够在自己的电脑上通过url来向我们的服务器发送请求，发送请求后，服务器能够将这些资源返回给用户的浏览器，然后浏览器就可以对这些资源做解析，页面就能够呈现了(所有的用户都能够通过url来访问服务器)。在这个过程中，node.js就运行在服务器端，它会对用户的请求做处理，并且把这些资源返回给浏览器。</p><p>2.开发工具类应用</p><p>目前前端开发中非常重要的三款工具Webpack、vite、Babel，它们可以提高前端项目的开发效率和质量，但都是借助于Node.js开发能力而实现的。所以可以借助node.js来创建一些属于自己的工具，来提高开发效率。</p><p>3.开发桌面端应用</p><p>对于代码编辑工具VSCode、设计工具Figma、接口测试工具Postman这三款软件都是借助electron框架，而这个框架又是借助node.js开发出来的，所以在学习了node.js后还可以去开发一些桌面端应用程序。</p><h2 id="1-2-node-js编码注意事项"><a href="#1-2-node-js编码注意事项" class="headerlink" title="1.2 node.js编码注意事项"></a>1.2 node.js编码注意事项</h2><p>1.Node.js中不能使用BOM和DOM的API，可以使用console和定时器API。</p><ul><li><p>BOM(Browser Object Model，浏览器对象模型)是与浏览器窗口进行互动的对象结构。它提供了一组可以操作浏览器窗口、历史记录、定时器等浏览器相关信息的API</p></li><li><p>DOM(Document Object Model，文档对象模型)则是一个与平台和语言无关的接口，它将网页的结构化文档表示为一个树形结构，允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p></li></ul><p>简而言之，BOM API 允许开发者与浏览器窗口和浏览器本身进行交互，而 DOM API 则允许开发者访问和操作网页的内容和结构。两者都是 JavaScript 编程中的重要组成部分，使得开发者能够创建动态和交互式的网页应用。</p><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许 JavaScript 运行在服务器端。由于 Node.js 运行在服务器端，而不是在浏览器环境中，因此它不提供浏览器特有的 API，比如 BOM 和部分 DOM API。</p><p>2.Node.js中的顶级对象为global，也可以用globalThis访问顶级对象。</p><ul><li><p>在 Node.js 环境中，全局对象被称为 <code>global</code>。这意味着在 Node.js 中定义的全局变量和函数会自动成为 <code>global</code> 对象的属性和方法。例如，如果你在 Node.js 脚本中定义了一个全局变量 <code>var myGlobalVar = &#39;Hello, world!&#39;;</code>，那么你可以通过 <code>global.myGlobalVar</code> 来访问这个变量。</p></li><li><p><code>globalThis</code> 是一个相对较新的全局属性，它在所有环境中(包括浏览器和 Node.js)都指向全局对象。这意味着无论在哪个环境中，你都可以使用 <code>globalThis</code> 来访问全局作用域下的变量和函数。在 Node.js 中，<code>globalThis</code> 指向的就是 <code>global</code> 对象。</p></li></ul><h1 id="2-Buffer-缓冲器"><a href="#2-Buffer-缓冲器" class="headerlink" title="2. Buffer(缓冲器)"></a>2. Buffer(缓冲器)</h1><p>Buffer中文译为缓冲区，是一个类似于Array的对象，用于表示固定长度的字节序列。换句话说，Buffer就是一段固定长度的内存空间，用于处理二进制数据。</p><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>1.概念：Buffer是一个类似于数值的<code>对象</code>，用于表示固定长度的字节序列。Buffer本质是一段内存空间，专门用来处理<code>二进制数据</code>。</p><p>2.特点</p><ul><li>Buffer大小固定且无法调整</li><li>Buffer性能较好，可以直接对计算机内存进行操作</li><li>每个元素的大小为1字节(byte)</li></ul><h2 id="2-2Buffer的使用"><a href="#2-2Buffer的使用" class="headerlink" title="2.2Buffer的使用"></a>2.2Buffer的使用</h2><p>1.buffer的创建有三种方法，分别是alloc、allocUnsafe和from。如下程序所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. alloc</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);   <span class="comment">//创建一个10字节的buffey，Buffer是nodejs的内置模块，在启动时已经被加载进来，不需要手动导入就可以使用，它可以理解为全局变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);             <span class="comment">//用alloc创建的方法，每个二进制位都会归0(清0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.allocUnsafe</span></span><br><span class="line"><span class="keyword">let</span> buf_2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">1000</span>);     <span class="comment">//这种方法创建的buffer，可能包含旧的内存数据(之前用完但没有清0的)，但速度比alloc方法快</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.from</span></span><br><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);        <span class="comment">//这种方法可以将一个字符串或数组转为buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_4);</span><br></pre></td></tr></table></figure><p>2.Buffer与字符串的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buffer与字符串的转换</span></span><br><span class="line"><span class="keyword">let</span> buf_1 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">121</span>,<span class="number">111</span>,<span class="number">117</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_1.<span class="title function_">toString</span>());         <span class="comment">//默认采用的是utf-8的方式进行转换</span></span><br></pre></td></tr></table></figure><p>3.Buffer的读写：可以直接通过[]的方式对数据进行处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf[<span class="number">0</span>]);                   <span class="comment">//将h通过utf-8进行转换为十进制数  结果：104</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf[<span class="number">0</span>].<span class="title function_">toString</span>(<span class="number">2</span>));       <span class="comment">//将h转换为2进制数              结果：1101000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);                      <span class="comment">//先打印buf内容                结果&lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">95</span>;                           <span class="comment">//对第一位h进行修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="title function_">toString</span>());           <span class="comment">//打印修改的结果(转换成字符串了)  结果：_ello</span></span><br></pre></td></tr></table></figure><p>4.注意事项</p><p>如果数值超过255，则超过8位，数据会被舍弃：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">361</span>;          <span class="comment">//舍弃高位数字(超过8位的，大于255的) 361=000101101001 =&gt; 0110 1001，即69</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);      <span class="comment">//打印结果为 &lt;Buffer 69 65 6c 6c 6f&gt;</span></span><br></pre></td></tr></table></figure><p>中文是utf-8的中文，一个中文一般占3个字节：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;你好&#x27;</span>);     <span class="comment">//是6个字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);       <span class="comment">//结果：&lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-计算机基础"><a href="#3-计算机基础" class="headerlink" title="3. 计算机基础"></a>3. 计算机基础</h1><h2 id="3-1-计算机基本组成"><a href="#3-1-计算机基本组成" class="headerlink" title="3.1 计算机基本组成"></a>3.1 计算机基本组成</h2><p>1.CPU：中央处理器，是整个计算机运算和控制的中心</p><p>2.内存：是存储数据的一个介质，可以在里面存放大量的0和1这样的数据</p><ul><li>特点：读写速度较快，断电丢失数据。程序在运行时都会载入到内存当中，让CPU高速的对这个数据进行执行和处理</li></ul><p>3.硬盘：也可以存储很多0和1这样的数据，</p><ul><li>特点：读写速度较慢，断电不丢失数据。平时下载的程序，如英雄联盟、浏览器、QQ等这些程序下载安装完后都是放到了硬盘里面。</li></ul><p>4.显卡：负责处理视频信号的，当有信息需要呈现，需要在显示器中显示时，就会将信号传递给显卡，显卡处理完毕后，再将信号传递给显示器，然后显示器最终显示。</p><p>5.主板：是一块大的集成电路板，上面有很多插槽，很多元器件就是插在插槽里面，通过主板联系在一起的。</p><p>除了上面器件，再通过一些外设，如显示器、键盘、鼠标和音响等，整个电脑就算组装完毕了。</p><h2 id="3-2-程序运行的基本流程"><a href="#3-2-程序运行的基本流程" class="headerlink" title="3.2 程序运行的基本流程"></a>3.2 程序运行的基本流程</h2><p>当所有器件都组装完毕之后，计算机也不能正常去运行。因为还缺少一个操作系统，常见的操作系统有Windows、Linux和MacOS。操作系统也是一种应用程序(010101..)，用来管理和调度硬件资源。可以理解为，操作系统能够让cpu去执行哪个程序。</p><p>装系统：就是将操作系统这个程序安装在硬盘的这样一个过程。当把这个操作系统程序装到硬盘之后，电脑就可以开机运行了。</p><p>运行流程：首先会先将Windows相关的一些程序文件载入到内存里面，载入内存之后，CPU就可以运行了。CPU执行的时候，如果发现有视频信号需要在显示器上去呈现，就会交给显卡去处理，显卡处理完之后，再交由显示器去呈现。再处理过程当中，如果遇到了声音信号，这时候会交给声卡，声卡再将信号传递给外部的播放设备(如耳机、音响等)。它们一结合，就会呈现出视频和声音一起播放的效果</p><blockquote><p>程序一般保存在硬盘中(还有一些是存在软盘这样一些介质里面的)，软件安装的过程就是将程序写入硬盘的过程。程序在运行时会加载进入内存，然后由CPU读取并执行程序。</p></blockquote><h1 id="4-fs模块"><a href="#4-fs模块" class="headerlink" title="4. fs模块"></a>4. fs模块</h1><p>fs模块可以实现与硬盘的交互。例如文件的创建、删除、重命名、移动，还有文件内容的写入、读取，以及文件夹的相关操作。</p><p>文件写入的应用场景：当需要持久化保存数据的时候，应该想到文件写入。</p><ul><li>下载文件</li><li>安装软件</li><li>保存程序日志，如Git</li><li>编辑器保存文件</li><li>视频录制</li></ul><p>文件读取应用场景</p><ul><li>电脑开机</li><li>程序运行</li><li>编辑器打开文件</li><li>查看图片</li><li>播放视频</li><li>播放音乐</li><li>Git查看日志</li><li>上传文件</li><li>查看聊天记录</li></ul><h2 id="4-1-读写操作"><a href="#4-1-读写操作" class="headerlink" title="4.1 读写操作"></a>4.1 读写操作</h2><p>1.writeFile异步写入</p><p>语法：<code>fs.writeFile(file, data[, options], callback)</code></p><p>参数说明：</p><ul><li>file：文件名(不存在会自动创建)</li><li>data：待写入的数据</li><li>options：选项设置(可选)</li><li>callback：写入回调(当写入完成之后，会自动调用该回调函数)</li></ul><p>测试程序：在下面程序中，代码先自上而下运行，当运行到writeFile时，会进行磁盘的写入，它会将这个磁盘写入交给另一个线程(IO线程)去完成，而主线程会继续向下执行。当IO线程写入完毕之后，会将回调函数压入到队列当中，等js的主线程给初始化的代码执行完毕之后，就会从任务队列中将这个回调函数取出来执行。如下面程序的结果是先打印12，再打印写入成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：新建一个文件夹，座右铭.txt，写入的内容：三人行，必有我师焉</span></span><br><span class="line"><span class="comment">//1. 导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 写入文件</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;三人行，必有我师焉&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;  <span class="comment">//当写入完成之后，会自动调用该回调函数,并将错误传递给这个函数</span></span><br><span class="line">    <span class="comment">//err写入失败：错误对象；写入成功：null</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>+<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>2.writeFileSync同步写入</p><p>语法：<code>fs.writeFileSync(file, data)</code></p><p>参数说明：</p><ul><li>file：文件名(不存在会自动创建)</li><li>data：待写入的数据</li></ul><p>测试程序：创建了一个data.txt文件，向里面写入了test</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">`test`</span>);</span><br></pre></td></tr></table></figure><p>3.appendFile异步追加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;择其善者而从之，择其不善者而改之&#x27;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.appendFileSync同步追加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;\r\n温故而知新，可以为师矣&#x27;</span>);      <span class="comment">// \r\n表示换行</span></span><br></pre></td></tr></table></figure><p>5.writeFile实现追加写入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;love love love&#x27;</span>,&#123;<span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//a是追加；w是写入(覆盖)；r是读；默认是w</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6.createWriteStream流式写入</p><p>createWriteStream会根据传入的参数路径，与它建立一个通道，啥时候想写，就通过write往通道里面传入内容即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);     <span class="comment">//引入写入流对象(接收一个文件路径的参数)</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方糖一签开\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;有源头活水来\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">close</span>();                 <span class="comment">//关闭通道</span></span><br></pre></td></tr></table></figure><blockquote><p>特点：程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p>流式写入方式适用于<code>大文件写入或者频繁写入的场景</code>，writeFile适用于<code>写入频率较低的场景</code>。</p></blockquote><p>7.readFile异步读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//err接收错误的信息；data用来接收读取的文件内容</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        cconsole.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>8.readFileSync同步读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><p>9.createReadStream流式读取</p><p>在绑定事件中，当从文件当中读取出来一块数据之后，就会执行一次回调，并把读取到的内容传递给形参chunk。这种方法相比其他读取方法，效率会更高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./video.mp4&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定data事件(参数：事件的名字；带参数chunk的回调函数)</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="property">length</span>);       <span class="comment">//65536字节 =&gt; 64KB(每次读取的大小)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//当文件读取完毕之后，会触发该事件(可选事件)</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>10.文件移动和重命名</p><p>可以使用<code>rename</code>或<code>renameSync</code>来移动或重命名文件或文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行重命名，将座右铭.txt改为论语.txt</span></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;./论语.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行移动</span></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">&#x27;../资料/data.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>11.删除文件</p><p><code>unlink</code>方法对应的同步方法是<code>unlinkSync</code>；<code>rm</code>方法对应的同步方法是<code>reSync</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./论语.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功~&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-2-文件夹操作"><a href="#4-2-文件夹操作" class="headerlink" title="4.2 文件夹操作"></a>4.2 文件夹操作</h2><p>通过node,js可以对文件夹进行创建、读取、删除等操作</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mkdir&#x2F;mkdirSync</td><td align="center">创建文件夹</td></tr><tr><td align="center">readdir&#x2F;readdirSync</td><td align="center">读取文件夹</td></tr><tr><td align="center">rmdir&#x2F;rmdirSync</td><td align="center">删除文件夹</td></tr></tbody></table><p>1.创建文件夹mkdir</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建单个文件夹html</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归创建多层文件夹</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a/b/c&#x27;</span>,&#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.读取文件夹readdir</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.删除文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单层文件夹</span></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除多层文件夹</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./a&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;      <span class="comment">//如果用rmdir也可以，但有警告</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.查看资源的状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;./video.mp4&#x27;</span>, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);                  <span class="comment">//打印出指定文件的状态数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isFile</span>());         <span class="comment">//是否是文件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isDirectory</span>());    <span class="comment">//是否是文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5.’全局变量’__dirname</p><p>相对路径参照物是命令行的工作目录，所以有时候在代码中写相对路径时，会因为命令行的工作目录而导致编写出错。</p><p><code>__dirname</code>：保存的是所在文件的所有目录的绝对路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFileSync</span>(__dirname + <span class="string">&#x27;/index.txt&#x27;</span>, <span class="string">&#x27;love&#x27;</span>);      <span class="comment">//在当前文件下的index.txt文件中写入love</span></span><br></pre></td></tr></table></figure><h1 id="5-path模块"><a href="#5-path模块" class="headerlink" title="5. path模块"></a>5. path模块</h1><p>path模块提供了操作路径的功能，下面是几个常用的API：</p><table><thead><tr><th align="center">API</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">path.resolve</td><td align="center">拼接规范的绝对路径</td></tr><tr><td align="center">path.sep</td><td align="center">获取操作系统的路径分隔符</td></tr><tr><td align="center">path.parse</td><td align="center">解析路径并返回对象</td></tr><tr><td align="center">path.basename</td><td align="center">获取路径的基础名称</td></tr><tr><td align="center">path.dirname</td><td align="center">获取路径的目录名</td></tr><tr><td align="center">path.extname</td><td align="center">获取路径的扩展名</td></tr></tbody></table><h1 id="6-http模块"><a href="#6-http模块" class="headerlink" title="6. http模块"></a>6. http模块</h1><p>1.想要获取请求的数据，需要通过request对象</p><table><thead><tr><th align="center">含义</th><th align="center">语法</th></tr></thead><tbody><tr><td align="center">请求方法</td><td align="center">request.method</td></tr><tr><td align="center">请求版本</td><td align="center">request.httpVersion</td></tr><tr><td align="center">请求路径</td><td align="center">request.url</td></tr><tr><td align="center">URL路径</td><td align="center">require(‘url’).parse(request.url).pathname</td></tr><tr><td align="center">URL查询字符串</td><td align="center">require(‘url’).parse(request.url,true).query</td></tr><tr><td align="center">请求头</td><td align="center">request.headers</td></tr><tr><td align="center">请求体</td><td align="center">request.on(‘data’,function(chunk{}))</td></tr></tbody></table><h2 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h2><p>1.用nodejs创建了一个HTTP服务端，在浏览器输入<a href="http://127.0.0.1:9000](http://127.0.0.1:9000/)后，回车，网页上会显示`Hello">http://127.0.0.1:9000](http://127.0.0.1:9000/)后，回车，网页上会显示`Hello</a> HTTP Server&#96;。如果监听的端口为80的话，浏览器输入127.0.0.1即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建服务对象(当收到请求，就会调用回调函数)</span></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server  =http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="comment">//console.log(request.method);</span></span><br><span class="line">    <span class="comment">//获取请求的url</span></span><br><span class="line">    <span class="comment">//console.log(request.url);       //只包含url中的路径与查询字符串(不包含协议、ip和端口)</span></span><br><span class="line">    <span class="comment">//获取请求头</span></span><br><span class="line">    <span class="comment">//console.log(request.headers);</span></span><br><span class="line">    <span class="comment">//response.end(&#x27;Hello HTTP Server&#x27;);                     //设置响应体，并结束响应</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;你好，世界&#x27;</span>);        <span class="comment">//设置响应体(是中文的话会出现乱码，需要设置响应的字符集)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>HTTP协议默认端口是80，HTTPS协议的默认端口是443，HTTP服务开发常用端口有3000、8080、8090和9000等</p><blockquote><p>如果端口被其他程序占用，可以使用<code>资源监视器</code>找到占用端口的程序，然后使用<code>任务管理器</code>关闭对应的程序。</p></blockquote><p>2.获取请求体的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//1.声明一个变量(接收响应体的结果)</span></span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">//2.给request绑定事件data</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">chunk</span> =&gt;</span> &#123;      <span class="comment">//参数：给request绑定的一个data事件，回调函数</span></span><br><span class="line">        body += chunk;       <span class="comment">//将取出的数据放到body中</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3.绑定end事件(把可读流里面的数据都读完了，会触发end事件)</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(body);             <span class="comment">//打印请求体的内容</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;Hello HTTP&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.获取请求路径与查询字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);     <span class="comment">//导入url模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//解析request.url</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>);              <span class="comment">//这是包含了路径和查询字符串</span></span><br><span class="line">    <span class="comment">//通过url的parse解析request.url的结果</span></span><br><span class="line">    <span class="keyword">let</span> res = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>);   <span class="comment">//参数2为true,可以使得结构体中的query属性(存放字符串的)变为一个对象,方便获得value值</span></span><br><span class="line">    <span class="comment">//console.log(res);                      //可以得到请求的一个结构体(key：value)</span></span><br><span class="line">    <span class="keyword">let</span> pathname = res.<span class="property">pathname</span>;           <span class="comment">//获取路径</span></span><br><span class="line">    <span class="comment">//console.log(pathname);</span></span><br><span class="line">    <span class="keyword">let</span> keyword = res.<span class="property">query</span>.<span class="property">keyword</span>;      <span class="comment">//获得keyword对应的value值(因为解析时，参2为true，所以可以这样调用)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(keyword);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例：实现一个http的服务端，当url的路径是login时，访问的是登录界面；当url的路径是reg时，访问的是注册界面；当路径是其他时，访问的是Not Found界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//获取请求方法</span></span><br><span class="line">    <span class="keyword">let</span> &#123;method&#125; = request;</span><br><span class="line">    <span class="comment">//获取请求的url路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>,<span class="string">&#x27;http://127.0.0.1&#x27;</span>);           <span class="comment">//参1：路径和key-value值</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span>(method === <span class="string">&#x27;GET&#x27;</span> &amp;&amp; pathname === <span class="string">&#x27;/login&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//登录的情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;登录界面&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method === <span class="string">&#x27;GET&#x27;</span> &amp;&amp; pathname === <span class="string">&#x27;/reg&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//注册的情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;注册界面&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//情况情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;Not Found&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.设置响应报文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//1.设置响应状态码</span></span><br><span class="line">    response.<span class="property">statusCode</span> = <span class="number">203</span>;</span><br><span class="line">    <span class="comment">//2.设置状态描述</span></span><br><span class="line">    response.<span class="property">statusMessage</span> = <span class="string">&#x27;lxxl&#x27;</span>;</span><br><span class="line">    <span class="comment">//3.响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);          <span class="comment">//响应内容的类型和编码字符</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Server&#x27;</span>, <span class="string">&#x27;Node.js&#x27;</span>);                   <span class="comment">//标识服务端的名字的</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;myheader&#x27;</span>, <span class="string">&#x27;test test test&#x27;</span>);          <span class="comment">//也可以设置自己想加的</span></span><br><span class="line">    <span class="comment">//4.响应头设置</span></span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;lxxl&#x27;</span>);            <span class="comment">//设置响应体，可以有多个write</span></span><br><span class="line">    response.<span class="title function_">end</span>();                    <span class="comment">//一般使用了write，就不用end写(为空即可)，end只能有一个</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例：创建一个HTTP服务端，返回给浏览器一个注册界面(用html写好的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js部分的程序</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//读取文件内容</span></span><br><span class="line">    <span class="keyword">let</span> html = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/reg.html&#x27;</span>);        <span class="comment">//拼接文件名，并读取</span></span><br><span class="line">    response.<span class="title function_">end</span>(html);                <span class="comment">//设置响应体</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html部分的程序 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin: 0 auto; border: 1px solid #ccc; padding: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1998<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1999<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>7<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>8<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>9<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>10<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第三行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;中国上海&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>未婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;three&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第五行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第六行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢的类型：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 妩媚的 </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 可爱的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 性感的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 开朗的</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第七行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第八行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第九行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span> 我同意注册条款和会员加入标准</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我是会员，立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚的寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/skills/1.png"></p><p>补充：HTTP服务在哪个文件夹中寻找静态资源，哪个文件夹就是<code>静态资源目录</code>，也称为<code>网站根目录</code>。</p><p>5.设置资源类型(mime类型)</p><p>媒体类型是一种标准，用来表示文档、文件或字节流的性质和格式。</p><p>HTTP服务可以设置响应头Content-Type来表示响应体的MIME类型，浏览器会根据该类型决定如何处理资源。下面是常见文件对应的mime类型：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">html: &#x27;text/html&#x27;</span></span><br><span class="line"><span class="section">css: &#x27;text/css&#x27;</span></span><br><span class="line"><span class="section">js: &#x27;text/javascript&#x27;</span></span><br><span class="line"><span class="section">png: &#x27;image/png&#x27;</span></span><br><span class="line"><span class="section">jpg: &#x27;image/jpeg&#x27;</span></span><br><span class="line"><span class="section">gif: &#x27;image/gif&#x27;</span></span><br><span class="line"><span class="section">mp4: &#x27;video/mp4&#x27;</span></span><br><span class="line"><span class="section">mp3: &#x27;audio/mpeg&#x27;</span></span><br><span class="line"><span class="section">json: &#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于未知的资源类型，可以选择<code>application/octet-stream</code>类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是常见的<code>下载</code>效果。</p></blockquote><p>下面程序是设置响应体的MIME类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个变量</span></span><br><span class="line"><span class="keyword">let</span> mimes = &#123;</span><br><span class="line">    <span class="attr">html</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">    <span class="attr">css</span>: <span class="string">&#x27;text/css&#x27;</span>,</span><br><span class="line">    <span class="attr">js</span>: <span class="string">&#x27;text/javascript&#x27;</span>,</span><br><span class="line">    <span class="attr">png</span>: <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line">    <span class="attr">jpg</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">    <span class="attr">gif</span>: <span class="string">&#x27;image/gif&#x27;</span>,</span><br><span class="line">    <span class="attr">mp4</span>: <span class="string">&#x27;video/mp4&#x27;</span>,</span><br><span class="line">    <span class="attr">mp3</span>: <span class="string">&#x27;audio/mpeg&#x27;</span>,</span><br><span class="line">    <span class="attr">json</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//读取请求url的路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>, <span class="string">&#x27;http://127.0.0.1&#x27;</span>);       <span class="comment">//获得路径</span></span><br><span class="line">    <span class="comment">//声明一个变量</span></span><br><span class="line">    <span class="keyword">let</span> root = __dirname + <span class="string">&#x27;/page&#x27;</span>;             <span class="comment">//这是拼接资源目录</span></span><br><span class="line">    <span class="comment">//拼接文件路径</span></span><br><span class="line">    <span class="keyword">let</span> filePath = root + pathname;            <span class="comment">//得到对应资源目录下，对端要得到的文件的路径</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">            response.<span class="property">statusCode</span> = <span class="number">500</span>;</span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;文件读取失败&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取文件的后缀名</span></span><br><span class="line">        <span class="comment">//let ext = path.extname(filePath);             //如果url输入的路径是3.png，这里得到的就是.png</span></span><br><span class="line">        <span class="keyword">let</span> ext = path.<span class="title function_">extname</span>(filePath).<span class="title function_">slice</span>(<span class="number">1</span>);      <span class="comment">//从下标1开始截取，这里得到的是png</span></span><br><span class="line">        <span class="comment">//获取对应的类型</span></span><br><span class="line">        <span class="keyword">let</span> type = mimes[ext];</span><br><span class="line">        <span class="keyword">if</span>(type)&#123;</span><br><span class="line">            <span class="comment">//匹配到了</span></span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, type);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/octet-stream&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        response.<span class="title function_">end</span>(data);                <span class="comment">//设置响应体</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-GET和POST请求"><a href="#6-2-GET和POST请求" class="headerlink" title="6.2 GET和POST请求"></a>6.2 GET和POST请求</h2><p>1.使用情况</p><ul><li>GET请求的情况：<ul><li>在地址栏直接输入url访问</li><li>点击a链接</li><li>link标签引入css</li><li>script标签引入css</li><li>video与audio引入多媒体</li><li>img标签引入图片</li><li>form标签中的method为get(不区分大小写)</li><li>ajax中的get请求</li></ul></li><li>POST请求的情况：<ul><li>form标签中的method为post(不区分大小写)</li><li>ajax的post请求</li></ul></li></ul><p>2.GET和POST请求的区别</p><ul><li>作用：GET主要用来获取数据，POST主要用来提交数据</li><li>参数位置：GET带参数请求一般是将参数缀到URL之后，POST带参数请求一般是将参数放到请求体中</li><li>安全性：POST请求相对GET安全一些，因为在浏览器中参数会暴露在地址栏</li><li>GET请求大小有限制，一般为2K，而POST请求则没有大小限制</li></ul><h1 id="7-Node-js模块化"><a href="#7-Node-js模块化" class="headerlink" title="7. Node.js模块化"></a>7. Node.js模块化</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>模块化的概念：将一个复杂的程序文件依据一定规则(规范)拆分成多个文件的过程称之为<code>模块化</code>。</p><p>模块的概念：对拆分出的每个文件就是一个模块，模块的内部数据是私有的，不过模块可以暴露内部数据以便其它模块使用。</p><p>模块化的好处：</p><ul><li>防止命名冲突</li><li>高复用性</li><li>高维护性</li></ul><h2 id="7-2-操作"><a href="#7-2-操作" class="headerlink" title="7.2 操作"></a>7.2 操作</h2><p>模块暴露数据的方式有两种：</p><ul><li>module.exports &#x3D; value</li><li>exports.name &#x3D; value</li></ul><blockquote><p>注意：</p><ul><li>module.exports可以暴露<code>任意</code>数据</li><li>不能使用<code>exports = value</code>的形式暴露数据，模块内部module与exports的隐式关系是<code>exports = module.exports = &#123;&#125;</code></li></ul></blockquote><p>1.创建一个需要暴露的程序me.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tiemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;贴膜.....&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//捏脚</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">niejiao</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捏脚.....&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露数据1</span></span><br><span class="line"><span class="comment">//module.exports = tiemo;               //这里是只暴露了iemo函数</span></span><br><span class="line"><span class="comment">// module.exports = &#123;</span></span><br><span class="line"><span class="comment">//     tiemo,</span></span><br><span class="line"><span class="comment">//     niejiao</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露数据2</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">niejiao</span> = niejiao;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">tiemo</span> = tiemo;</span><br></pre></td></tr></table></figure><p>引用的程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="built_in">require</span>(<span class="string">&#x27;./me.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">me.<span class="title function_">tiemo</span>();</span><br><span class="line">me.<span class="title function_">niejiao</span>();</span><br></pre></td></tr></table></figure><p>2.导入模块</p><p>在模块中使用require传入文件路径即可引入文件：<code>const test = require(&#39;./me.js&#39;);</code></p><p>require使用的一些注意事项：</p><ul><li>对于自己创建的模块，导入时路径建议写<code>相对路径</code>，且不能省略<code>./</code>和<code>../</code></li><li>js和json文件导入时可以不用写后缀，c&#x2F;c++编写的node扩展文件也可以不用写后缀，但是一般用不到</li><li>如果导入其它类型的文件，会以js文件进行处理</li><li>如果导入的路径是个文件夹，则会首先检测该文件夹下package.json文件中的main属性对应的文件，如果存在则导入，反之如果文件不存在会报错。如果main属性不存在，或者package.json不存在，则会尝试导入文件夹下的index.js和index.json，如果还是没有找到，就会报错。</li><li>导入node.js内置模块时，直接require模块的名字即可，无需加<code>./</code>和<code>../</code>。</li></ul><h1 id="8-包管理工具"><a href="#8-包管理工具" class="headerlink" title="8. 包管理工具"></a>8. 包管理工具</h1><h2 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h2><p>包英文单词是package，代表了一组特定功能的源码集合</p><p>包管理工具：是管理包的应用软件，可以对包进行下载安装、更新、删除和上传等操作。借助包管理工具，可以快速开发项目，提升开发效率。包管理工具是一个通用的概念，很多编程语言都有包管理工具。</p><p>常用的包管理工具有：npm、yarm、cnpm</p><h2 id="8-2-npm"><a href="#8-2-npm" class="headerlink" title="8.2 npm"></a>8.2 npm</h2><p>npm是node.js官方内置的包管理工具，是必须要掌握的工具</p><p>初始化：创建一个空目录，然后以此目录作为工作目录启动命令行工具，执行<code>npm init</code>。</p><p><code>npm init</code>命令的作用是将文件夹初始化为一个包，交互式创建<code>package.json</code>文件，它是包的配置文件，每个包都必须要有<code>package.json</code>。</p><p>1.属性解释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm&quot;</span><span class="punctuation">,</span>                <span class="comment">//包的名字</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span>           <span class="comment">//包的版本</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span>           <span class="comment">//包的入口文件</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                  <span class="comment">//脚本配置</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                 <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span>             <span class="comment">//开源证书</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span>             <span class="comment">//包的描述</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化过程中注意事项：</p><ul><li><code>package name</code>不能使用中文、大写，默认值是文件夹的名称，所以文件夹名称也不能使用中文和大写</li><li><code>version</code>要求<code>x.x.x</code>的形式定义，x必须是数字，默认值是<code>1.0.0</code></li><li><code>package.json</code>开源手动创建与修改</li><li>使用<code>npm init -y</code>或者<code>npm init --yes</code>极速创建<code>package.json</code></li></ul></blockquote><p>2.生产环境与开发环境</p><p>开发环境是程序员专门用来写代码的环境，一般是指程序员的电脑，开发环境的项目一般<code>只能程序员自己自己访问</code></p><p>生产环境是项目代码正式运行的环境，一般是指正式的服务器电脑，生产环境的项目一般<code>每个客户都可以访问</code></p><p>3.生产依赖与开发依赖</p><p>可以在安装时设置选项来区分<code>依赖的类型</code>，如：</p><table><thead><tr><th align="center">类型</th><th align="center">命令</th><th align="center">补充</th></tr></thead><tbody><tr><td align="center">生产依赖</td><td align="center">npm i -S uniq</td><td align="center">-S等效于–save，-S是默认选项</td></tr><tr><td align="center">开发依赖</td><td align="center">npm i -D less</td><td align="center">-D等效于–save-dev</td></tr></tbody></table><p>其中生产依赖的包信息保存在package.json中<code>dependencies</code>属性，开发依赖保存的包信息保存在package.json中的<code>devDependencies</code>属性</p><p>生产依赖是指这个依赖即在开发阶段使用，也在最终的运行当中使用</p><p>开发依赖是指这个依赖只在开发阶段使用，过了开发阶段就没有用了</p><p>4.全局安装</p><p>上面介绍的是局部安装，即只能在打开终端的那个文件夹下使用。可以执行安装选项<code>-g</code>进行全局安装，如<code>npm i -g nodemon</code>，全局安装完成之后就可以在命令行的任何位置运行nodemon命令了。这个命令的作用是<code>自动重启node应用程序</code></p><p>说明：</p><ul><li>可以通过<code>npm root -g</code>查看全局安装包的位置</li><li>不是所有的包都适合全局安装，只有全局类的工具才适合，可以通过查看包的官方文档来确定安装方式。</li></ul><p>5.安装包依赖</p><p>在项目协作中有一个常用的命令就是<code>npm i</code>，通过该命令可以依据<code>package.json</code>和<code>package-lock.json</code>的依赖声明安装项目依赖</p><blockquote><p><code>node_modules</code>文件夹大多数情况都不会存入版本库，因为当一个项目很大时，会用到很多的依赖包，而项目的依赖包都存在<code>node_modules</code>文件夹中，如果将该项目上传到Git，其他人下载时就会很麻烦。所以就可以下载除了<code>node_modules</code>文件夹的其它所有文件，然后通过<code>npm i</code>来下载项目所需要的依赖。</p></blockquote><p>6.安装指定的包和删除依赖</p><p>如果当前包的版本不匹配，或要安装指定版本的包，可以通过<code>npm i &lt;包名@版本号&gt;</code>，如<code>npm i jquery@1.11.2</code></p><p>删除依赖包可以使用：</p><ul><li>局部删除：npm remove 包名或者npm r 包名</li><li>全局删除：npm remove -g 包名</li></ul><p>7.配置命名别名</p><p>通过配置命名别名可以更简单的执行命令，如在package.json中的scripts属性中有如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node server.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">.....</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置完之后，可以使用别名执行命令，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run server           <span class="comment">//执行的是node server.js</span></span><br><span class="line">npm run start            <span class="comment">//执行的是node index.js</span></span><br></pre></td></tr></table></figure><p>不过<code>start</code>别名比较特别，使用时可以省略，如<code>npm start</code></p><h2 id="8-3-npm配置淘宝镜像"><a href="#8-3-npm配置淘宝镜像" class="headerlink" title="8.3 npm配置淘宝镜像"></a>8.3 npm配置淘宝镜像</h2><p>用npm也可以使用淘宝镜像，配置的方式有两种</p><ul><li>直接配置</li><li>工具配置</li></ul><p>1.直接配置</p><p>执行如下命令即可完成配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p>2.工具配置(建议使用)</p><p>使用nrm配置npm的镜像地址<code>npm registry manager</code></p><ul><li>安装nrm：<code>npm i -g nrm</code></li><li>修改镜像：<code>nrm use taobao</code></li><li>检查是否配置成功(可选)，如果是<code>https://registry.npmmirror.com/</code>，则表名成功：<code>npm config list</code></li></ul><p>补充：查看支持的镜像地址：<code>nrm ls</code></p><p>然后就可以通过<code>nrm use 要使用的镜像</code>来切换镜像地址了，如切换为官方地址<code>nrm use npm</code></p><p>注意：淘宝镜像是只读的，只能下载，不能上传。比如说写好一个工具包，想要上传到npm去给其他人用，就需要切换为npm的官方地址才可以上传。</p><h2 id="8-4-管理发布包"><a href="#8-4-管理发布包" class="headerlink" title="8.4 管理发布包"></a>8.4 管理发布包</h2><p>1.创建与发布</p><p>可以将自己开发的工具包发布到npm服务上，方便自己和其他开发者使用，操作步骤如下：</p><ul><li>创建文件夹，并创建文件index.js，在文件中声明函数，使用module.exports暴露</li><li>npm初始化工具包，package.json填写包的信息(包的名字是唯一的)</li><li>注册账号<a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></li><li>激活账号(必须)—–&gt;填写验证码</li><li>修改为官方的官方镜像(命令行中运行nrm use npm)</li><li>命令行<code>npm login</code>填写相关用户信息</li><li>命令行下<code>npm publish</code>提交包</li></ul><p>2.更新包</p><p>后续可以对自己发布的包进行更新，操作如下：</p><ul><li>更新包中的代码</li><li>测试代码是否可用</li><li>修改package.json中的版本号(在原来基础上做++操作，相当于自己修改一次，也修改一次版本号)</li><li>发布更新<code>npm publish</code></li></ul><p>3.删除包</p><p>执行命令<code>npm unpublish --force</code>即可</p><blockquote><p>删除包需要满足的条件：</p><ul><li>要是包的作者</li><li>发布小于24小时</li><li>大于24小时后，没有其他包依赖，并且每周小于300下载量，并且只有一个维护者</li></ul></blockquote><p>4.nvm使用</p><p>下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases">Releases · coreybutler&#x2F;nvm-windows (github.com)</a>，选择<code>nvm-setup.exe</code>下载即可</p><p>常用的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nvm list available</td><td>显示所有可以下载的Node.js版本</td></tr><tr><td>nvm list</td><td>显示已安装的版本</td></tr><tr><td>nvm install 18.12.1</td><td>安装18.12.1版本的Node.js</td></tr><tr><td>nvm install latest</td><td>安装最新版本的Node.js</td></tr><tr><td>nvm uninstall 18.12.1</td><td>删除某个版本的Node.js</td></tr><tr><td>nvm use 18.12.1</td><td>切换18.12.1版本的Node.js</td></tr></tbody></table><h1 id="9-express框架"><a href="#9-express框架" class="headerlink" title="9. express框架"></a>9. express框架</h1><p>express是一个基于Node.js平台的极简、灵活的WEB应用开发框架，官方网址：<a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></p><p>简单来说，express是一个封装好的工具包，本身是一个npm包，所以可以通过npm安装。express封装了很多功能，便于开发WEB应用(HTTP服务)。</p><h2 id="9-1-操作"><a href="#9-1-操作" class="headerlink" title="9.1 操作"></a>9.1 操作</h2><p>首先是先创建一个文件夹，在该文件夹下的终端执行&#96;npm init’，先生成一个包，然后执行npm i express，在该目录下下载express工具包，这样在该目录下就可以使用该工具包了。如下是程序程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//当浏览器把请求发送过来之后，如果请求的方法是get，并且请求url的路径是/home，就会执行后面的回调函数，用它来对浏览器响应结果</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1.express路由</p><p>路由确定了应用程序如何响应客户端对特定端点的请求。</p><p>一个路由的组成有<code>请求方法</code>、<code>路径</code>和<code>回调函数</code>组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.get方法，路径为/home</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;网址首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//2.post方法，路径为/login</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;注册页面&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3.匹配所有方法,路径为/test</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;test test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//4.404响应(当没有匹配成功路由时，执行该路由)</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;404 not Found&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.获取请求报文参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//原生操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">method</span>);               <span class="comment">//获取请求方式</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">url</span>);                  <span class="comment">//获取请求路径和key-value</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">httpVersion</span>);          <span class="comment">//获取http版本</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>);              <span class="comment">//获取请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//express操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">path</span>);            <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);           <span class="comment">//获取key和value值，是用&#123;&#125;封装的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">ip</span>);              <span class="comment">//获取ip</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="title function_">get</span>(<span class="string">&#x27;host&#x27;</span>));     <span class="comment">//获取ip和端口</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时，为了更加的灵活运用，也可以通过占位符的方式来作为路径。在如下程序中，浏览器的路径只要是<code>任意字符.html</code>都可以匹配成功路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/:id.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;    <span class="comment">//通过:id占位符来完成，浏览器只要是</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>.<span class="property">id</span>);         <span class="comment">//获取路径(这里的id要与上面的占位符名字一样)</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.响应设置</p><p>express框架封装了一些API来方便给客户端响应数据，并且兼容原生HTTP模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/singer/:id.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//原生响应</span></span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">404</span>;                <span class="comment">//状态码</span></span><br><span class="line">    res.<span class="property">statusMessage</span> = <span class="string">&#x27;love&#x27;</span>;          <span class="comment">//状态描述</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;yyy&#x27;</span>);         <span class="comment">//响应头</span></span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&#x27;hello express &#x27;</span>);         <span class="comment">//响应体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//express响应</span></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>);                     <span class="comment">//状态码</span></span><br><span class="line">    res.<span class="title function_">set</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);               <span class="comment">//响应头</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;您好 express&#x27;</span>);             <span class="comment">//响应体</span></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">set</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>).<span class="title function_">send</span>(<span class="string">&#x27;这都是OK的&#x27;</span>);    <span class="comment">//也可以直接这样操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//express其他的响应方法</span></span><br><span class="line">    <span class="comment">//跳转响应</span></span><br><span class="line">    res.<span class="title function_">redirect</span>(<span class="string">&#x27;http://atguigu.com&#x27;</span>);          <span class="comment">//页面会跳转到http://atguigu.com网址去</span></span><br><span class="line">    <span class="comment">//下载响应</span></span><br><span class="line">    res.<span class="title function_">download</span>(__dirname + <span class="string">&#x27;/package.json&#x27;</span>);   <span class="comment">//会下载指定目录下的文件</span></span><br><span class="line">    <span class="comment">//JSON响应</span></span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;lxx&#x27;</span>,</span><br><span class="line">        <span class="attr">slogon</span>: <span class="string">&#x27;让天下没有难学的技术&#x27;</span></span><br><span class="line">    &#125;);       <span class="comment">//显示json内容</span></span><br><span class="line">    <span class="comment">//响应文件内容</span></span><br><span class="line">    res.<span class="title function_">sendFile</span>(__dirname + <span class="string">&#x27;/test.html&#x27;</span>);      <span class="comment">//会显示test.html的这个页面</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-2-express中间件"><a href="#9-2-express中间件" class="headerlink" title="9.2 express中间件"></a>9.2 express中间件</h2><p>中间件本质是一个回调函数，中间件函数可以像路由回调一样访问请求对象(request)，响应对象(response)。</p><p>中间件的作用：就是使用函数封装公共操作，简化代码</p><p>中间件的类型：</p><ul><li>全局中间件：就是指一个请求发过来后，这个全局中间件就会执行，执行完毕后才去执行路由回调。(每一个请求过来，全局中间件一定会执行)</li><li>路由中间件：就是指一个请求发过来后，路由中间件是和路由放在一起的，只有满足了某一个路由规则，它所对应的中间件才会去执行。</li></ul><p>1.全局中间件实现：当客户端通过浏览器访问该服务器时，会对应的记录它的url和ip，然后保保存到一个文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明一个中间件函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recoremiddleware</span>(<span class="params">req, res, next</span>)&#123; <span class="comment">//参数：请求报文对象；响应报文对象；内部函数，执行之后会指向后续的路由回调或者是中间件函数回调</span></span><br><span class="line">    <span class="comment">//获取url和ip</span></span><br><span class="line">    <span class="keyword">let</span> &#123;url, ip&#125; = req;</span><br><span class="line">    <span class="comment">//将信息保存再文件中access.log(通过追加的方式写入)</span></span><br><span class="line">    fs.<span class="title function_">appendFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./access.log&#x27;</span>), <span class="string">`<span class="subst">$&#123;url&#125;</span> <span class="subst">$&#123;ip&#125;</span>\r\n`</span>);  <span class="comment">//文件的路径；写入的内容。注意$要与反引号结合使用</span></span><br><span class="line">    <span class="comment">//调用next，它会去执行后续的回调函数，如路由回调</span></span><br><span class="line">    <span class="title function_">next</span>();              <span class="comment">//如果不执行这行，那么就只记录了，没有回应给客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用中间件函数</span></span><br><span class="line">app.<span class="title function_">use</span>(recoremiddleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;后台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.路由中间件实现：当客户端通过浏览器发送请求后，先通过url来匹配执行哪个路由，当匹配完后，要执行中间件里面的代码，即判断有无携带<code>code=520</code>，如果有，就执行对应的路由回调；如果没有携带，就回应一个暗号错误。(防盗链可以用类似的方法实现)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3声明一个中间件函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recoremiddleware</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">   <span class="comment">//判断URL中是否code参数等于520</span></span><br><span class="line">   <span class="keyword">if</span>(req.<span class="property">query</span>.<span class="property">code</span> === <span class="string">&#x27;520&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;暗号错误&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>,recoremiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;       <span class="comment">//对该路由设置了中间件</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin&#x27;</span>,recoremiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//对该路由设置了中间件</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;后台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-3-处理静态资源的中间件"><a href="#9-3-处理静态资源的中间件" class="headerlink" title="9.3 处理静态资源的中间件"></a>9.3 处理静态资源的中间件</h2><blockquote><p>使用注意事项：</p><ul><li>index.html文件为默认打开的资源</li><li>如果静态资源与路由规则同时都匹配，谁先匹配，谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ul></blockquote><p>当添加了静态资源中间件设置，再浏览器发送请求时，如果路径声明没有写(即&#x2F;)，服务端这边会先找index.html页面，即到public这个静态目录里面去找，找到了就读取内容，响应给浏览器。但如果路由规则也设置了&#x2F;，那么谁先匹配上，就执行谁(执行顺序从上到下)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源中间件设置，将当前文件夹下的public目录作为网站的根目录</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">&#x27;/public&#x27;</span>));        <span class="comment">//当前这个目录中都是一些静态资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比如说对应的public下有一个index.html文件，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ADD8E6</span>; <span class="comment">/* 浅蓝色 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin: 0 auto; border: 1px solid #ccc; padding: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1998<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1999<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>7<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>8<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>9<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>10<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第三行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;中国上海&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>未婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;three&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第五行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第六行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢的类型：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 妩媚的 </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 可爱的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 性感的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 开朗的</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第七行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第八行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第九行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span> 我同意注册条款和会员加入标准</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我是会员，立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚的寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/skills/2.png"></p><h2 id="9-4-EJS模板引擎"><a href="#9-4-EJS模板引擎" class="headerlink" title="9.4 EJS模板引擎"></a>9.4 EJS模板引擎</h2><p>模板引擎是分离<code>用户界面和业务数据</code>的一种技术，是一个高效的Javascript的模板引擎。</p><p>1.ejs普通渲染</p><p>创建一个文件夹，在文件夹的终端下执行<code>npm i ejs</code>，这样在该目录下就可以使用ejs工具包了。</p><p>先创建一个2-lxx.html文件，这里只是简单写了一行代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我爱你 &lt;%= china %&gt;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再创建一个js文件，来完成跨文件渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> china = <span class="string">&#x27;中国&#x27;</span>;</span><br><span class="line"><span class="comment">//声明变量(读取其它文件的内容)</span></span><br><span class="line"><span class="keyword">let</span> str = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./2-lxx.html&#x27;</span>).<span class="title function_">toString</span>(); <span class="comment">//读取2-lxx.html文件里面的内容,想要toString，不然是buffer类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ejs渲染</span></span><br><span class="line"><span class="keyword">let</span> result = ejs.<span class="title function_">render</span>(str, &#123;<span class="attr">china</span>:china&#125;);    <span class="comment">//对str进行一个解析，找到&lt;%=这些标识，然后把里面的内容替换为参2里面对应属性的value值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);            <span class="comment">//输出的是&lt;h2&gt;我爱你 中国&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure><p>2.ejs条件渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isLogin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ejs渲染(这里也可以放到其它文件里，再调用)</span></span><br><span class="line"><span class="keyword">let</span> result = ejs.<span class="title function_">render</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;% if(isLogin)&#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;欢迎回来&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125;else&#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;登录&lt;/button&gt; &lt;button&gt;登录&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">    `</span>, &#123;<span class="attr">isLogin</span>: isLogin&#125;);      <span class="comment">//对str进行一个解析，找到&lt;%=这些标识，然后把里面的内容替换为参2里面对应属性的value值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);            <span class="comment">//输出的是&lt;h2&gt;我爱你 中国&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-5-Express应用程序生成器"><a href="#9-5-Express应用程序生成器" class="headerlink" title="9.5 Express应用程序生成器"></a>9.5 Express应用程序生成器</h2><p>通过应用生成器工具express-generator可以快速创建一个应用的骨架。可以通过npx命令来运行Express应用程序生成器。</p><p>全局安装这个包：<code>npm install -g express-generator</code>。</p><p>创建骨架：<code>express -e generator</code>，-e表示添加ejs模板引擎的支持，generator表示文件夹的名称(将代码装到哪个文件夹下)。</p><p>在生成骨架的文件夹下，安装依赖：<code>npm i</code></p><p>启动服务端：<code>npm start</code></p><h2 id="9-6-案例实践-记账本"><a href="#9-6-案例实践-记账本" class="headerlink" title="9.6 案例实践-记账本"></a>9.6 案例实践-记账本</h2><p>首先是创建一个文件夹，在该文件夹下创建一个应用裤架：<code>express -e accounts</code></p><p>在accounts文件夹下安装依赖：<code>npm i</code></p><p>需要用到一个小型的数据库lowdb：<code>npm i lowdb@1.0.0</code></p><p>对每一个订单进行编号id，安装shortid：<code>npm i shortid</code></p><h1 id="10-API接口"><a href="#10-API接口" class="headerlink" title="10. API接口"></a>10. API接口</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>接口是前后端通信的桥梁，可以理解为一个接口就是服务中的一个路由规则，根据请求响应结果。这里所指的接口是<code>数据接口</code>，与编程语言(java、go等)中的接口语法不同。</p><p>接口的作用：实现前后端通信</p><p>接口的组成：请求方法、接口地址(URL)、请求参数、响应结果</p><h2 id="10-2-RESTful-API接口"><a href="#10-2-RESTful-API接口" class="headerlink" title="10.2 RESTful API接口"></a>10.2 RESTful API接口</h2><p><code>RESTful API</code>是一种特殊风格的接口，主要特点有如下几个：</p><ul><li><p>URL 中的路径表示 资源 ，路径中不能有动词 ，例如<code>create</code> , <code>delete</code> , <code>update</code>等这些都不能有</p></li><li><p>操作资源要与 <code>HTTP请求方法</code> 对应</p></li><li><p>操作结果要与<code>HTTP响应状态码</code>对应</p></li></ul><table><thead><tr><th align="center">操作</th><th align="center">请求类型</th><th align="center">URL</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">新增歌曲</td><td align="center">POST</td><td align="center">&#x2F;song</td><td align="center">返回新生成的歌曲信息</td></tr><tr><td align="center">删除歌曲</td><td align="center">DELETE</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回一个空文档</td></tr><tr><td align="center">修改歌曲</td><td align="center">PUT</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回更新后的歌曲信息</td></tr><tr><td align="center">修改歌曲</td><td align="center">PATCH</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回更新后的歌曲信息</td></tr><tr><td align="center">获取所有歌曲</td><td align="center">GET</td><td align="center">&#x2F;song</td><td align="center">返回歌曲列表数组</td></tr><tr><td align="center">获取单个歌曲</td><td align="center">GET</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回单个歌曲信息</td></tr></tbody></table><h2 id="10-3-json-server"><a href="#10-3-json-server" class="headerlink" title="10.3 json-server"></a>10.3 json-server</h2><p>json-server本身是一个JS编写的工具包，可以快速搭建RESTful API服务</p><p>搭建临时的接口服务操作步骤：</p><p>1.全局安装<code>json-server</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="literal">-g</span> json<span class="literal">-server</span></span><br></pre></td></tr></table></figure><p>2.创建JSON文件(db.json)，编写基本结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;活着&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;余华&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;西游记&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;吴承恩&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;平凡的世界&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;路遥&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;songs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;知足&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;五月天&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;不能说的秘密&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;周杰伦&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.以<code>JSON</code>文件所在文件夹作为工作目录，执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json<span class="literal">-server</span> <span class="literal">--watch</span> db.json</span><br></pre></td></tr></table></figure><p>完成过后，客户端(浏览器)就可以通过<code>http://127.0.0.1:3000/</code>后面加上路径来访问对应的数据了。</p><h1 id="11-会话控制"><a href="#11-会话控制" class="headerlink" title="11. 会话控制"></a>11. 会话控制</h1><h2 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h2><p>所谓会话控制就是对会话进行控制。HTTP是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端，无法区分用户，所以可以通过<code>会话控制</code>来解决该问题。</p><p>常见的会话控制技术有三种：</p><ul><li>cookie</li><li>session</li><li>token</li></ul><h2 id="11-2-cookie"><a href="#11-2-cookie" class="headerlink" title="11.2 cookie"></a>11.2 cookie</h2><p>cookie是HTTP服务器发送到用户浏览器并保存在本地的一小块数据，简单来说：</p><ul><li>cookie是保存在浏览器端的一小块数据</li><li>cookie是按照域名划分保存的</li></ul><p>示例：</p><table><thead><tr><th align="center">域名</th><th align="center">cookie</th></tr></thead><tbody><tr><td align="center"><a href="http://www.baidu.com/">www.baidu.com</a></td><td align="center">a&#x3D;100;b&#x3D;200</td></tr><tr><td align="center"><a href="http://www.bilibili.com/">www.bilibili.com</a></td><td align="center">xid&#x3D;1020abce121;hm&#x3D;112411213</td></tr><tr><td align="center">jd.com</td><td align="center">x&#x3D;100;ocw&#x3D;12414cce</td></tr></tbody></table><p>1.特点</p><p>浏览器向服务器发送请求时，会自动将<code>当前域名</code>下可用的cookie设置在请求头中，然后传递给服务器。这个请求头的名字也叫cookie，所以将cookie理解为一个HTTP的请求头也是可以的。</p><p>2.cookie运行流程</p><ul><li><p>浏览器这边会先把我们的账号密码等信息传递给服务器，服务器就会返回一个属于我们的cookie。注意的是，服务器是通过响应报文里面响应头为set-cookie传递给我们的。</p></li><li><p>当服务器返回一个我们的cookie后，浏览器就会将set-cookie后面的内容进行一个存储，于是就将cookie信息保存在我们当前这个域名的cookie下面。</p></li><li><p>当保存完毕之后，浏览器下次再向该服务器发送请求时，就会自动携带这个域名下面的cookie，然后传递给服务器。此时服务器就可以通过对这个信息的解析来得知请求的一个发送者，所以在返回结果时，就可以通过对应的发送者来响应对应的内容，这样就实现了用户的识别，实现了会话控制。</p></li></ul><h2 id="11-3-express框架使用cookie"><a href="#11-3-express框架使用cookie" class="headerlink" title="11.3 express框架使用cookie"></a>11.3 express框架使用cookie</h2><p>在一个文件夹下的终端通过<code>npm init</code>创建一个包的配置文件，再在该目录下通过<code>npm i express</code>安装express工具包。</p><p>1.设置和删除cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/set-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//res.cookie(&#x27;name&#x27;, &#x27;zhangsan&#x27;);            //会在浏览器关闭的时候销毁</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span>*<span class="number">1000</span>&#125;);     <span class="comment">//参3是设置生命周期，这里设置了存活1分钟(期间关闭浏览器也可以的)</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);                   <span class="comment">//这里又设置一个cookie</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/remove-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">clearCookie</span>(<span class="string">&#x27;name&#x27;</span>);                       <span class="comment">//删除cookie name</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;删除成功~~~&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>2.获取cookie</p><p>如果要在express框架中获取cookie，还需要通过<code>npm i cookie-parser</code>来下载工具包cookie-parser。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/set-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span>*<span class="number">1000</span>&#125;);        <span class="comment">//参3是设置生命周期，这里设置了存活1分钟(期间关闭浏览器也可以的)</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);                   <span class="comment">//这里又设置一个cookie</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/get-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">cookies</span>);                      <span class="comment">//获取cookie name</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`欢迎您 <span class="subst">$&#123;req.cookies.name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="11-4-session"><a href="#11-4-session" class="headerlink" title="11.4 session"></a>11.4 session</h2><p>session是保存在<code>服务器端的一块数据</code>，保存当前访问用户的相关消息。它的作用是实现会话控制，可以识别用户的身份，快速获取当前用户的相关消息。</p><p>1.session的运行流程</p><ul><li>用户提供自己的账号和密码传递给服务器，服务器接收到后会对其进行校验，检查填写的内容是否正确、与数据库里面的填写的内容是否匹配。如果填写没有问题，服务器会为当前的访问者创建一个对象，可以理解为是session对象。在这个对象里面会保存当前用户的一些基本信息，如用户名、用户id、用户邮箱等。除此之外，服务器端还会在这个对象当中生成一个独一无二的id标识，即session_id。</li><li>有了这个session对象之后，一方面服务器会将该对象存到session对象池里面(每个用户有了session对象之后都会被存到服务器那边的session对象池里面)，一方面会将这个id以响应cookie的形式返回给浏览器，浏览器接收到后就会将这个cookie信息保存起来。</li><li>有了cookie之后，以后再向服务器发送请求时，它就会带着cookie向服务器发送请求。服务器接收到该请求后，服务器就会从cookie里面把这个session_id取出来，取出来后就可以到session对象池里面去匹配寻找，即在存放session对象的容器里面去找，如果找到了跟这个session_id匹配的数据，就知道当前的用户是谁了。</li></ul><h2 id="11-5-express框架使用session"><a href="#11-5-express框架使用session" class="headerlink" title="11.5 express框架使用session"></a>11.5 express框架使用session</h2><p>在一个文件夹下的终端通过<code>npm init</code>创建一个包的配置文件，再在该目录下通过<code>npm i express</code>安装express工具包。</p><p>然后还需要安装两个工具包，终端执行命令：<code>npm i express-session connect-mongo</code>。</p><p>下面程序是session在express框架下的使用，同时结合了mongodb数据库来辅助观察存储的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//引入模块 express-session connect-mongo</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 session 的中间件</span></span><br><span class="line"><span class="comment">//解释：app.use是设置中间件的，session是一个函数，接收一个对象类型的参数，返回一个函数</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sid&#x27;</span>,       <span class="comment">//设置cookie的name，默认值是：connect.sid</span></span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;atguigu&#x27;</span>, <span class="comment">//参与加密的字符串（又称签名）</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">false</span>, <span class="comment">//是否为每次请求都设置一个cookie用来存储session的id</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">true</span>, <span class="comment">//是否在每次请求时重新保存session</span></span><br><span class="line">    <span class="attr">store</span>: <span class="title class_">MongoStore</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">mongoUrl</span>: <span class="string">&#x27;mongodb://127.0.0.1:27017/bilibili&#x27;</span> <span class="comment">//数据库的连接配置，将当前信息存储在mongodb里面的bilibili下面</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">cookie</span>: &#123;</span><br><span class="line">        <span class="attr">httpOnly</span>: <span class="literal">true</span>,      <span class="comment">// 开启后前端无法通过 JS 操作来访问cookie</span></span><br><span class="line">        <span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">60</span> <span class="comment">// 是控制后端sessionID和发送给浏览器的cookie的过期时间的，这里设置了1分钟</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//首页，打开后即可完成在mongodb数据库中的bilibili下创建一个session数据库</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie，在url输入username=admin&amp;password=admin即可完成得到session_id，它会存储在数据库中</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//username=admin&amp;password=admin</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">query</span>.<span class="property">username</span> === <span class="string">&#x27;admin&#x27;</span> &amp;&amp; req.<span class="property">query</span>.<span class="property">password</span> === <span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//设置session信息</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="property">username</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">        req.<span class="property">session</span>.<span class="property">uid</span> = <span class="string">&#x27;258aefccc&#x27;</span>;</span><br><span class="line">        <span class="comment">//成功响应</span></span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;登录失败~~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//session读取</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/cart&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//检测session是否存在用户数据</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">username</span>)&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">`购物车页面，欢迎您 <span class="subst">$&#123;req.session.username&#125;</span>`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;您还没有登录~~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//session销毁,从数据库中也销毁了该信息</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;退出成功~~~&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="11-6-session和cookie的区别"><a href="#11-6-session和cookie的区别" class="headerlink" title="11.6 session和cookie的区别"></a>11.6 session和cookie的区别</h2><p>cookie和session的区别主要在于如下几点：</p><ol><li><p>所在的位置</p><ul><li>cookie：浏览器端</li><li>session：服务端</li></ul></li><li><p>安全性</p><ul><li>cookie是以明文的方式存放在客户端的，安全性相对较低</li><li>session存放于服务器中，所以安全性<code>相对</code>较好</li></ul></li><li><p>网络传输量</p><ul><li>cookie设置的内容过多会增大报文体积，会影响传输效率</li><li>session数据存储在服务器，只是通过cookie传递id，所以不影响传输效率</li></ul></li><li><p>存储限制</p><ul><li>浏览器限制单个cookie保存的数据不能超过4k，且单个域名下的存储数量也有限制</li><li>session数据存储在服务器中，所以没有这些限制</li></ul></li></ol><h2 id="11-7-token"><a href="#11-7-token" class="headerlink" title="11.7 token"></a>11.7 token</h2><p><code>token</code>是服务端生成并返回给HTTP客户端的一串加密字符串，<code>token</code>中保存着用户信息。它的作用是实现会话控制，可以识别用户的身份，主要用于移动端APP。</p><p>1.token的工作流程</p><ul><li>客户端将账号和密码通过请求发送给服务器，服务端检测了所提交的信息之后，如果没有问题，就会创建出token。创建好后，就会将该信息返回给客户端。</li><li>客户端收到服务器返回的token信息后，下次再发送请求时，客户端就会带着token传递给服务器，服务器就会对传来的token做校验，并且从token里面提取出用户的信息，继而识别用户的身份。</li></ul><blockquote><p>可以发现，token和cookie很像，cookie也是服务端校验用户的信息以后，将cookie返回给客户端，下次客户端发送请求时，再带着cookie给服务器。但它们之间也还是有一些区别的，cookie是自动携带的，而token是手动携带，比如说客户端给服务器发请求了，它得自己将token放在请求报文里面，然后再向服务器发请求。但cookie不是，当客户端要发送请求给服务器时，浏览器就会自动的将信息放在请求报文里面传递给服务器。</p></blockquote><p>2.token的特点</p><ul><li><p>服务端压力更小</p><ul><li>数据存储在客户端</li></ul></li><li><p>相对更安全</p><ul><li>数据加密</li><li>可以避免CSRF(跨站请求伪造)</li></ul></li><li><p>扩展性更强</p><ul><li>服务间可以共享</li><li>增加服务节点更简单</li></ul></li></ul><p>3.JWT</p><p>JWT是目前最流行的跨域认证解决方案，可用于基于token的身份验证。JWT是token的生成于校验更规范。</p><p>使用：在文件夹的终端通过<code>npm init</code>创建一个包的配置文件，再通过<code>npm i jsonwebtoken</code>下载jsonwebtoken工具包。</p><p>创建出一个token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生成token -----&gt; let token = jwt.sign(用户数据，加密字符串，配置对象)</span></span><br><span class="line"><span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;lixx&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;atguigu&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">60</span>,          <span class="comment">//token的声明周期，单位是秒</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(token);</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpeHgiLCJpYXQiOjE3MjY0NzMzNzcsImV4cCI6MTcyNjQ3MzQzN30.mrmErdIPfWz7lLEdZRXSQdV7F9HrtYJVEuEwFSzmad0</span><br></pre></td></tr></table></figure><p>验证token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="string">&#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpeHgiLCJpYXQiOjE3MjY0NzMzNzcsImV4cCI6MTcyNjQ3MzQzN30.mrmErdIPfWz7lLEdZRXSQdV7F9HrtYJVEuEwFSzmad0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证生成的token</span></span><br><span class="line">jwt.<span class="title function_">verify</span>(t, <span class="string">&#x27;atguigu&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;校验失败~~~&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果在指定的token生命周期里面执行上面的验证代码，都会出现如下信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; username: <span class="string">&#x27;lixx&#x27;</span>, iat: <span class="number">1726473377</span>, exp: <span class="number">1726473437</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Node.js是一个开源的，跨平台的JavaScript运行环境。通俗来讲，node.js就是一款应用程序，是一款软件，</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>c++全栈聊天项目</title>
    <link href="https://lxx93.online/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"/>
    <id>https://lxx93.online/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-09-03T07:34:24.000Z</published>
    <updated>2025-08-10T13:42:06.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本项目为c++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nodejs搭建验证服务，各服务间用grpc通信，server和client用asio通信等，也包括用户信息的录入等，实现跨平台设计，先设计windows的server，之后再考虑移植到linux中，较为全面的展示c++在实际项目中的应用。</p><p><img src="/.online//Users\PC\Desktop\聊天项目\0.jpg"></p><h1 id="2-创建主界面"><a href="#2-创建主界面" class="headerlink" title="2. 创建主界面"></a>2. 创建主界面</h1><h3 id="2-1-创建方式"><a href="#2-1-创建方式" class="headerlink" title="2.1 创建方式"></a>2.1 创建方式</h3><p>新建—&gt;Application—&gt;Qt Widgets Application—&gt;项目名称为lxxlchat—&gt;类名为MainWindow—&gt;基类为QMainWindow</p><h3 id="2-2-修改主窗口MainWindow的ui"><a href="#2-2-修改主窗口MainWindow的ui" class="headerlink" title="2.2 修改主窗口MainWindow的ui"></a>2.2 修改主窗口MainWindow的ui</h3><p>1.固定大小(宽300，高500)和修改窗口标题</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\1.png"></p><p>2.修改图标icon</p><p>将图标图片放到项目的根目录下</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\2.png"></p><p>在lxxlchat.pro文件里面添加代码</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\3.png"></p><h3 id="2-3-主窗口的作用"><a href="#2-3-主窗口的作用" class="headerlink" title="2.3 主窗口的作用"></a>2.3 主窗口的作用</h3><p>该项目是让主窗口类MainWindows处于一个顶层，来衔接两个对话框，即登录对话框和注册对话框。主要作用就是让主窗口类里面的类对象之间有交互时，可以在主窗口类中处理，可以减少耦合。</p><h3 id="2-4-对话框嵌入到主窗口方式"><a href="#2-4-对话框嵌入到主窗口方式" class="headerlink" title="2.4 对话框嵌入到主窗口方式"></a>2.4 对话框嵌入到主窗口方式</h3><p>1.在创建<code>登录对话框</code>和<code>注册对话框</code>时，没有指定父对象，直接在主窗口的构造函数中通过<code>setCentralWidget(对话框对象)</code>即可完成嵌入操作</p><ul><li>需要手动析构登录对话框和注册对话框，即在主窗口类的析构函数中进行处理</li><li>当点击关闭主窗口时，可能会出现程序异常退出这种情况</li></ul><p>2.在创建<code>登录对话框</code>和<code>注册对话框</code>时，指定父对象this。这样就不需要再主窗口类的析构函数中进行手动删除对话框了，但需要完成以下操作，才能实现将对话框嵌入到主窗口。</p><ul><li>将对话框的固定大小设置为主窗口的固定大小</li><li>不仅需要添加<code>setCentralWidget(_login_dlg)</code>，还需要去除对话框的边框和标题栏<ul><li><code>_login_dlg-&gt;setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint);</code></li></ul></li></ul><h1 id="3-创建登录的对话框"><a href="#3-创建登录的对话框" class="headerlink" title="3. 创建登录的对话框"></a>3. 创建登录的对话框</h1><h3 id="3-1-创建方式"><a href="#3-1-创建方式" class="headerlink" title="3.1 创建方式"></a>3.1 创建方式</h3><p>新建—&gt;Qt—&gt;Qt设计师界面类—&gt;选择界面模板：Dialog without Buttons—&gt;类名为：LoginDialog</p><h3 id="3-2-登录对话框加载到主界面上"><a href="#3-2-登录对话框加载到主界面上" class="headerlink" title="3.2 登录对话框加载到主界面上"></a>3.2 登录对话框加载到主界面上</h3><p>将登录对话框的类对象定义在主窗口类的成员里面，在主界面的构造函数中加入如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_login_dlg = <span class="keyword">new</span> <span class="built_in">LoginDialog</span>();            <span class="comment">//创建登录界面</span></span><br><span class="line"><span class="built_in">setCentralWidget</span>(_login_dlg);              <span class="comment">//将登录界面设置到setCentralWidget(主界面就会加载登录界面)</span></span><br><span class="line">_login_dlg-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><h1 id="4-创建资源文件："><a href="#4-创建资源文件：" class="headerlink" title="4. 创建资源文件："></a>4. 创建资源文件：</h1><h3 id="4-1-创建方式"><a href="#4-1-创建方式" class="headerlink" title="4.1 创建方式"></a>4.1 创建方式</h3><p>新建—&gt;Qt—&gt;Qt Resource File—&gt;名称为rc</p><h3 id="4-2-在qt中使用资源文件"><a href="#4-2-在qt中使用资源文件" class="headerlink" title="4.2 在qt中使用资源文件"></a>4.2 在qt中使用资源文件</h3><p>1.将资源图片文件res放到根目录下</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\4.png"></p><p>2.在Qt中引入资源文件res</p><p>操作1：在qt的资源文件中添加现有文件</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\5.png"></p><p>操作2：在弹出的对话框中，将要加入的资源文件全部选上，然后点击打开</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\6.png"></p><p>操作3：选择Yes to All</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\7.png"></p><h3 id="4-3-给登录界面添加位图"><a href="#4-3-给登录界面添加位图" class="headerlink" title="4.3 给登录界面添加位图"></a>4.3 给登录界面添加位图</h3><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\8.png"></p><h1 id="5-创建注册的对话框"><a href="#5-创建注册的对话框" class="headerlink" title="5. 创建注册的对话框"></a>5. 创建注册的对话框</h1><h3 id="5-1-创建方式"><a href="#5-1-创建方式" class="headerlink" title="5.1 创建方式"></a>5.1 创建方式</h3><p>新建—&gt;Qt—&gt;Qt设计师界面类—&gt;选择界面模板：Dialog without Buttons—&gt;类名为：RegisterDialog</p><h1 id="6-Qt中使用qss"><a href="#6-Qt中使用qss" class="headerlink" title="6. Qt中使用qss"></a>6. Qt中使用qss</h1><p>1.在根目录下加入style文件夹，在该文件夹下面添加qss文件</p><p><img src="/.online//Users\PC\Desktop\lxxlchat项目\9.png"></p><p>2.将qss文件加载到Qt的资源文件中，和之前在Qt资源文件中引入资源图片是一样的操作</p><p>3.将qss样式应用到Qt界面上，需要在main()函数下添加如下程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载一个QSS样式表文件，并将其应用到整个Qt应用程序的界面上</span></span><br><span class="line"><span class="function">QFile <span class="title">qss</span><span class="params">(<span class="string">&quot;:/style/stylesheet.qss&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(qss.<span class="built_in">open</span>(QFile::ReadOnly))&#123;                       <span class="comment">//以只读打开文件</span></span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;open success&quot;</span>);</span><br><span class="line">    QString style = <span class="built_in">QLatin1String</span>(qss.<span class="built_in">readAll</span>()); <span class="comment">//读取文件的全部内容(QByteArray类型)，将字节数组转换为字符串</span></span><br><span class="line">    a.<span class="built_in">setStyleSheet</span>(style);               <span class="comment">//将读取到的样式字符串设置为应用程序的全局样式</span></span><br><span class="line">    qss.<span class="built_in">close</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Open failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-创建全局的文件"><a href="#7-创建全局的文件" class="headerlink" title="7. 创建全局的文件"></a>7. 创建全局的文件</h1><p>新建—&gt;c++—&gt;c++ Header File—&gt;名称为global.h</p><p>新建—&gt;c++—&gt;c++ Source File—&gt;名称为global.cpp</p><h1 id="8-单例类的创建"><a href="#8-单例类的创建" class="headerlink" title="8. 单例类的创建"></a>8. 单例类的创建</h1><p>新建—&gt;c++—&gt;c++ Header File—&gt;名称为singleton.h</p><h1 id="9-创建Qt的Http发送的管理者类"><a href="#9-创建Qt的Http发送的管理者类" class="headerlink" title="9. 创建Qt的Http发送的管理者类"></a>9. 创建Qt的Http发送的管理者类</h1><p>新建—&gt;c++—&gt;c++class—&gt;类名为HttpMgr</p><p>注意：该类涉及到网络的使用，所以需要在pro文件里面添加<code>network</code>模块</p><p>CRTP：可以让还未声明的类，继承以自己为模板实例的类(继承以自己为模板的单例类)</p><h1 id="10-vs中配置boost与jsoncpp"><a href="#10-vs中配置boost与jsoncpp" class="headerlink" title="10. vs中配置boost与jsoncpp"></a>10. vs中配置boost与jsoncpp</h1><p>8.定时按钮类</p><p>新建—&gt;c++,c++clase—&gt;类名为TimerBtn，基类为Custom</p><p>创建好后，令其继承QPushButton按钮类</p><p>将注册界面的获取按钮提升为TimerBtn，当点击该按钮后，就会触发TimerBtn重写的一些功能。</p><p>9.创建可点击的标签类ClickedLabel，用于密码和确认密码的隐藏和显示</p><p>新建—&gt;c++，c++clase—&gt;类名为ClickedLabel，基类为Custom(创建好后，继承基类QLabel)</p><p>将注册页面的两个label标签提升为ClickedLabel类</p><p>将登录界面的忘记密码按钮提升为ClickedLabel类</p><p>将ChatPage界面里面的emo_lb和file_lb两个label提升为可点击的ClickedLabel类</p><p>10.创建应该TCP管理者类</p><p>新建—&gt;c++，c++clase—&gt;类名为TcpMgr，基类为Custom(先不写，默认的)</p><p>11.创建聊天对话框</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为Dialog without Buttons—&gt;类名为ChatDialog</p><p>12.创建可点击的按钮类</p><p>新建—&gt;c++，c++clase—&gt;类名为ClickedBtn，基类为Custom(创建好后，继承基类QPushButton)</p><p>将聊天界面里面的add_btn按钮提升为ClickedBtn类</p><p>将ChatPage界面的receive_btn和send_btn提升为ClickedBtn类</p><p>13.创建自定义的输入框类</p><p>新建—&gt;c++，c++clase—&gt;类名为CustomizeEdit，基类为Custom(创建好后，继承基类QLineEdit)</p><p>将聊天界面里面的search_edit输入框提升为CustomizeEdit类</p><p>14.创建自定义的listwidget类</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatUserList，基类为Custom(创建好后，继承基类QListWidget)</p><p>将聊天界面里面的char_user_list框提升为ChatUserList类</p><p>15.创建用户窗口</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为widget—&gt;类名为ChatUserWid</p><p>创建好好继承ListItemBase类(自己写的)</p><p>16.创建控制item的基类ListItemBase</p><p>新建—&gt;c++，c++clase—&gt;类名为ListItemBase，基类为Custom(创建好后，继承基类QWidget)</p><p>17.创建加载内容的对话框</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为Dialog without Buttons—&gt;类名为LoadingDlg</p><p>18.创建聊天页类ChatPage</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为widget—&gt;类名为ChatPage</p><p>将聊天界面中QstackedWidget模块里面的chat_page提升为ChatPage类</p><p>19.创建聊天界面（主）</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatView，基类为Custom(创建好后，继承基类QWidget)</p><p>将聊天界面中的chat_data_list提升为ChatView</p><p>20.创建聊天界面框架(副)</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatItemBase，基类为Custom(创建好后，继承基类QWidget)</p><p>21.创建聊天界面的气泡</p><p>新建—&gt;c++，c++clase—&gt;类名为BubbleFrame，基类为Custom(创建好后，继承基类QFrame)</p><p>22.创建气泡里面的文本</p><p>新建—&gt;c++，c++clase—&gt;类名为TextBubble，基类为Custom(创建好后，继承基类BubbleFrame)</p><p>23.常见气泡里面的图片</p><p>新建—&gt;c++，c++clase—&gt;类名为PictureBubble，基类为Custom(创建好后，继承基类BubbleFrame)</p><ol start="24"><li></li></ol><p>新建—&gt;c++，c++clase—&gt;类名为MessageTextEdit，基类为Custom(创建好后，继承基类QTextEdit)</p><p>将chatpage.ui里面的chatEdit提升为MessageTextEdit</p><p>25.创建StateWidget类</p><p>新建—&gt;c++，c++clase—&gt;类名为StateWidget，基类为Custom</p><hr><h1 id="2-网关服务器GateServer"><a href="#2-网关服务器GateServer" class="headerlink" title="2. 网关服务器GateServer"></a>2. 网关服务器GateServer</h1><p>网关服务器主要应答客户端基本的连接请求，包括根据服务器负载情况选择合适服务器给客户端登录、注册、获取验证服务等，接收http请求并应答。</p><p>1.绑定和监听连接(服务端)</p><p>利用visual studio创建一个空项目，项目名字为GateServer，然后按照之前的方法配置boost库和jsoncpp配置好后，我们添加一个新的类，名字叫CServer。添加成功后生成的CServer.h和CServer.cpp也会自动加入到项目中。</p><p>在<code>GateServer</code>项目中的逻辑：先是CServer启动，其启动后，就会监听连接。当对端有连接请求来之后，就交给<code>HttpConnection</code>类去管理，在这个类里面，它会先监听读事件，当对端有数据发来之后会触发读回调函数，在这个函数里面会处理读的请求<code>HandleReq()</code>，并且启动超时检测<code>CheckDeadline()</code>(检测发送是否超时)。其中在处理读请求<code>HandleReq()</code>函数中，会调用底层的<code>LogicSystem</code>逻辑层去处理请求，同时这里会把请求的<code>url</code>和<code>HttpConnection</code>对象的智能指针作为参数传过去。而在LogicSystem逻辑层类的<code>HandleGet</code>函数中，就是在map容器里面去找对应的url，如果之前没有注册过这个url，就会返回false，底层就会返回404错误；如果注册过，就会调用对应的回调(处理器)。</p><p>对应写回包就是写好响应头，然后准备对端请求的数据发送过去即可，如果在规定时间内写完发送给对端，在触发的写回调中就会把定时器取消，否则定时器会进行检测，超时的话它就会把socket强制关闭。</p><p>2.在Qt中添加客户端的配置文件config.ini</p><p>在QT的pro文件中需要添加如下程序：这段程序主要用于在<strong>Windows平台</strong>的调试模式(<code>debug</code>配置)下，将配置文件(如<code>config.ini</code>)从工程目录拷贝到输出目录。可以这样理解，你的Qt程序需要使用<code>config.ini</code>配置文件来读取网络设置、数据库连接信息等。当你在调试时，程序从<code>debug</code>目录运行，而这个目录默认情况下并不包含<code>config.ini</code>。该脚本自动将配置文件从项目的根目录拷贝到<code>debug</code>目录，确保程序运行时可以正确找到配置文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">win32:<span class="built_in">CONFIG</span>(debug, debug | release)</span><br><span class="line">&#123;</span><br><span class="line">    #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\QT\Test</span><br><span class="line">    #PWD就为D:/QT/Test，DllFile = D:/QT/Test/release<span class="comment">/*.dll</span></span><br><span class="line"><span class="comment">    TargetConfig = $$&#123;PWD&#125;/config.ini</span></span><br><span class="line"><span class="comment">    #将输入目录中的&quot;/&quot;替换为&quot;\&quot;</span></span><br><span class="line"><span class="comment">    TargetConfig = $$replace(TargetConfig, /, \\)</span></span><br><span class="line"><span class="comment">    #将输出目录中的&quot;/&quot;替换为&quot;\&quot;</span></span><br><span class="line"><span class="comment">    OutputDir =  $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125;</span></span><br><span class="line"><span class="comment">    OutputDir = $$replace(OutputDir, /, \\)</span></span><br><span class="line"><span class="comment">    //执行copy命令</span></span><br><span class="line"><span class="comment">    QMAKE_POST_LINK += copy /Y \&quot;$$TargetConfig\&quot; \&quot;$$OutputDir\&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>3.创建一个获取验证码的grpc客户端VerifyGrpcClient：</p><p>先定义一个message.proto文件，这是一种用于定义结构化数据的序列化协议，常用于远程过程调用(RPC)系统或者消息格式的定义。代码定义了一个服务和两个消息，用于实现一个获取验证码的接口。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;        <span class="comment">//定义了Protobuf的语法版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> message;   <span class="comment">//定义了包名为message。包名在Protobuf中用于组织代码，避免命名冲突。不同的包中的服务和消息不会互相冲突。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务定义，这个服务叫做VarifyService，代表一个远程服务，用于提供某种功能。在这个服务中定义了一个RPC(远程过程调用)方法。</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">VarifyService</span> &#123;</span><br><span class="line"><span class="comment">//d定义一个rpc方法，方法名是GetVarifyCode， 输入是GetVarifyReq，输出是GetVarifyRsp，</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> GetVarifyCode (GetVarifyReq) <span class="keyword">returns</span> (GetVarifyRsp) </span>&#123;&#125;  <span class="comment">//当客户端调用GetVarifyCode时，会发送GetVarifyReq请求，服务端将返回GetVarifyRsp响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了消息结构体GetVarifyReq(发送请求时提供的参数)</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetVarifyReq</span> &#123;</span><br><span class="line"><span class="comment">//email是一个字符串字段，表示请求中用户提供的邮件。1是这个字段的标识符，用于在序列化和反序列化时识别字段，其在整个消息定义中是唯一的。</span></span><br><span class="line"><span class="type">string</span> email = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了响应消息体GetVarifyRsp(需要回复的参数)</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetVarifyRsp</span> &#123;</span><br><span class="line"><span class="type">int32</span> error = <span class="number">1</span>;      <span class="comment">//32位的整数字段，表示错误代码</span></span><br><span class="line"><span class="type">string</span> email = <span class="number">2</span>;     <span class="comment">//字符串字段，表示服务器返回的邮件</span></span><br><span class="line"><span class="type">string</span> code = <span class="number">3</span>;      <span class="comment">//字符串字段，表示服务器生成的验证码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是在message.proto所在文件夹的powershell上执行如下命令，利用grpc编译后生成的proc.exe来生成proto的grpc的头文件和源文件。即会生成message.grpc.pb.cc和message.grpc.pb.h文件，这两个文件里面保存了grpc通信的接口。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe  <span class="literal">-I</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--grpc_out</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--plugin</span>=protoc<span class="literal">-gen-grpc</span>=<span class="string">&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</span> <span class="string">&quot;message.proto&quot;</span></span><br></pre></td></tr></table></figure><p>对于通信的接口所使用的参数需要通过以下命令来生成，即会得到message.pb.cc和message.pb.h文件，这两个文件保存了通信使用的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe <span class="literal">--cpp_out</span>=. <span class="string">&quot;message.proto&quot;</span></span><br></pre></td></tr></table></figure><p>4.添加一个查询状态的grpc客户端StatusGrpcClient</p><h1 id="3-认证服务"><a href="#3-认证服务" class="headerlink" title="3. 认证服务"></a>3. 认证服务</h1><p>认证服务要给邮箱发送验证码，所以用nodejs较为合适，nodejs是一门IO效率很高而且生态完善的语言，用到发送邮件的库也方便。</p><p>1.初始化node.js项目的一个配置文件：在VarifyServer文件夹下打开PowerShell终端执行<code>npm init</code>，然后一路点击回车即可。</p><p>2.安装grpc-js包，也可以安装grpc，grpc是C++版本，grpc-js是js版本，C++版本停止维护了。所以用grpc-js版本。</p><p>在VarifyServer文件夹的PowerShell终端下执行<code>npm install @grpc/grpc-js</code>。</p><p>3.安装proto-loader用来动态解析proto文件，在PowerShell终端下继续执行<code>npm install @grpc/proto-loader</code>。</p><p>4.安装email处理的库，在PowerShell终端下继续执行<code>npm install nodemailer</code>。</p><p>5.启动程序：npm run serve</p><p>81.68.86.146</p><p>流程：</p><p>用Qt编写了一个client，它会把请求(获取验证码)给到visual Studio编写的服务端GateServer，而GateServer会调用grpc，把请求投递给验证服务Varify，验证服务就会调用邮箱服务，该邮箱是各个平台提供的邮箱接口API，调用该API，发送到指定的邮箱里。如果发送成功了，邮箱接口API还会把成功的请求告诉验证服务Varify，验证服务也就会通过grpc服务把这个发送成功的请求回复给GateServer。当然不管成功还是失败，GateServer得到结果后都会发送给Qt那边的客户端。</p><h1 id="4-设置验证码过期"><a href="#4-设置验证码过期" class="headerlink" title="4. 设置验证码过期"></a>4. 设置验证码过期</h1><p>验证码是要设置过期的，可以用redis管理过期的验证码自动删除，key为邮箱，value为验证码，过期时间为3min。</p><h2 id="4-1-redis服务搭建"><a href="#4-1-redis服务搭建" class="headerlink" title="4.1 redis服务搭建"></a>4.1 redis服务搭建</h2><p>1.在Redis-x64-5.0.14.1文件夹下的redis.windows.conf文件中处理如下：</p><p>修改端口：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br></pre></td></tr></table></figure><p>添加requirepass</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><p>2.通过<code>redis-server.exe</code>启动redis服务器(在Redis-x64-5.0.14.1目录下)：<code>.\redis-server.exe .\redis.windows.conf</code></p><p><img src="/.online//Users\PC\Desktop\聊天项目\1.png"></p><p>3.通过<code>redis-cli.exe</code>启动客户端并输入密码：</p><p><img src="/.online//Users\PC\Desktop\聊天项目\2.png"></p><p>4.widows编译和配置redis(很麻烦，省略)</p><h2 id="4-2-VerifyServer增加redis"><a href="#4-2-VerifyServer增加redis" class="headerlink" title="4.2 VerifyServer增加redis"></a>4.2 VerifyServer增加redis</h2><h2 id="4-3-mysql"><a href="#4-3-mysql" class="headerlink" title="4.3 mysql"></a>4.3 mysql</h2><p>1.在C:\cppsoft\mysql\mysql\bin目录下打开cmd输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装mysql,安装完成后Mysql会有一个随机密码</span><br><span class="line">.\mysqld.exe <span class="literal">--initialize</span> <span class="literal">--console</span></span><br></pre></td></tr></table></figure><p>得到如下图，随机密码要记住，以后我们改密码会用到</p><p><img src="/.online//Users\PC\Desktop\聊天项目\3.png"></p><p>2.在C:\cppsoft\mysql\mysql\bin目录下以管理员身份打开cmd输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装mysql服务并启动   </span><br><span class="line">.\mysqld.exe <span class="literal">--install</span> mysql</span><br></pre></td></tr></table></figure><p>3.修改mysql密码</p><p>首先是在本机启动mysql服务：电脑搜索服务，找到mysql，启动它。</p><p>然后在C:\cppsoft\mysql\mysql\bin目录下打开终端，执行命令：<code>.\mysql -uroot -p</code>，进入后先填写原始密码，上面保留那个</p><p>然后执行改命令，进行修改密码：<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></p><p>4.配置环境变量</p><p>新建系统变量：</p><ul><li><p>变量名：MYSQL_HOME</p></li><li><p>变量值：自己的msql目录(C:\cppsoft\mysql)</p></li></ul><p>修改系统的path变量：点击编辑path，进去后添加 %MYSQL_HOME%\bin</p><h1 id="5-状态服务器StatusServer"><a href="#5-状态服务器StatusServer" class="headerlink" title="5.状态服务器StatusServer"></a>5.状态服务器StatusServer</h1><h1 id="6-ChatServer类"><a href="#6-ChatServer类" class="headerlink" title="6.ChatServer类"></a>6.ChatServer类</h1><p>长连接的流程：客户端想要登录，首先需要将登录请求发给GataServer服务器，GataServer就去StatusServer服务器上去查询，如果校验没有任何问题的话，它就会分配一个ip和token，给到GataServer服务器，GataServer就会把这个消息给到客户端。客户端就会利用这个ip和token来登录，ChatServer服务器会验证这个ip和token(去StatusServer服务器上查询)，以及该用户的一些信息，如果都没有问题，它就会让其登录，返回一个rsp回包，这样客户端就和ChatServer服务器建立了连接，后续客户端需要发的信息内容，就可以发给ChatServer服务器。</p><p><img src="/.online//Users\PC\Desktop\聊天项目\4.png"></p><h1 id="7-usermgr类"><a href="#7-usermgr类" class="headerlink" title="7. usermgr类"></a>7. usermgr类</h1><h1 id="8-流程"><a href="#8-流程" class="headerlink" title="8.流程"></a>8.流程</h1><p>1.主窗口<code>mainwindow</code>(创建登录界面对象)展示登录界面<code>logindialog</code>。  mainwindow —–&gt; logindialog</p><p>2.登录界面<code>logindialog</code>点击注册按钮，发出信号switchRegister，主窗口<code>mainwindow</code>接收。 loginwindow —–&gt; mainwindow                     </p><p>3.主窗口<code>mainwindow</code>接收信号switchRegister，执行槽函数SlotSwitchReg(创建注册界面对象)，展示注册界面<code>registerdialog</code>。mainwindow —–&gt; registerdialog</p><p>4.注册界面registerdialog点击获取按钮(检查邮箱格式)，发送请求获取验证码(调用http管理者<code>httpmgr</code>的发送请求接口)。</p><p>5.注册界面<code>registerdialog</code>点击确定按钮执行槽函数on_sure_btn_clicked，检查输入框的内容，没有问题就发送请求注册用户(调用http管理者<code>httpmgr</code>的发送请求接口)。</p><p>6.管理者<code>httpmgr</code>执行完异步发送请求后(向网关服务器GateServer发送请求)，等待回复，收到回复后，无论成功与否，都发出信号sig_http_finish(附带请求模块)，由自己接收处理。          httpmgr —–&gt; httpmgr</p><p>7.管理者<code>httpmgr</code>收到回复成功信号后，执行槽函数slot_http_finish，根据不同请求，都发出信号sig_login_mod_finish(附带请求模块)</p><p>8.注册界面<code>registerdialog</code>根据接收的信号sig_login_mod_finish，会通过不同的id执行相应的函数对象(注册界面初始化时就注册进去的)，比如说有获取验证码的id、注册用户的id。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;本项目为c++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nod</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://lxx93.online/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lxx93.online/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-29T07:34:24.000Z</published>
    <updated>2024-09-16T15:46:09.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-设计模式三原则"><a href="#1-设计模式三原则" class="headerlink" title="1. 设计模式三原则"></a>1. 设计模式三原则</h1><p>在进行程序设计的时候，要尽可能地保证程序的可扩展性、可维护性和可读性，所以需要使用一些设计模式，这些设计模式都遵循了以下三个原则。</p><h2 id="1-1-单一职责原则"><a href="#1-1-单一职责原则" class="headerlink" title="1.1 单一职责原则"></a>1.1 单一职责原则</h2><p>C++面向对象三大特性之一的<code>封装</code>指的就是将单一事物抽象出来组合成一个类，所以我们在设计类的时候每个类中处理的是单一事物而不是某些事物的集合。</p><p>设计模式中所谓的单一职责原则：就是对一个类而言，应该仅有一个引起它变化的原因，其实就是将这个类所承担的职责单一化。</p><h2 id="1-2-开放封闭原则"><a href="#1-2-开放封闭原则" class="headerlink" title="1.2 开放封闭原则"></a>1.2 开放封闭原则</h2><p>开放封闭原则：指的是软件实体(类、模块、函数等)可以扩展，但是不可以修改。也就是说对于扩展是开放的，对于修改是封闭的。</p><p>开放封闭原则是面向对象设计的核心所在，这样可以给我们设计出的程序带来巨大的好处，使其可维护性、可扩展性、可复用性、灵活性更好。</p><h2 id="1-3-依赖倒转原则"><a href="#1-3-依赖倒转原则" class="headerlink" title="1.3 依赖倒转原则"></a>1.3 依赖倒转原则</h2><p>关于依赖倒转原则，对应的是两条非常抽象的描述：</p><ul><li>高层模块不应该依赖低层模块，两个都应该依赖抽象。<ul><li>高层模块：可以理解为上层应用，就是业务层的实现</li><li>低层模块：可以理解为底层接口，比如封装好的API、动态库等</li><li>抽象：指的就是抽象类或者接口，在C++中没有接口，只有抽象类</li></ul></li><li>抽象不应该依赖细节，细节应该依赖抽象。<ul><li>里氏代换原则：就是子类类型必须能够替换掉它们的父类类型。</li></ul></li></ul><h1 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h1><p>在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫<code>单例模式</code>。单例模式的典型应用就是任务队列。</p><p>在实现一个单例模式的类的时候，有两种处理模式：</p><ul><li>饿汉模式</li><li>懒汉模式</li></ul><h2 id="2-1-饿汉模式"><a href="#2-1-饿汉模式" class="headerlink" title="2.1 饿汉模式"></a>2.1 饿汉模式</h2><p>饿汉模式：定义类的时候就创建了单例实例，创建出来后，什么时候用，时候什么就调用静态的成员函数(得到单例对象)。</p><p>缺点：浪费空间</p><p>优点：在多线程的场景下，饿汉模式是没有线程安全问题的(多线程可以同时访问这个单例的对象)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;      <span class="comment">//通过类名来得到的对象是静态的，通过类名访问类里面的属性和方法，这个属性和方法是静态的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//堵死在外部创建对象的方法,防止通过拷贝构造或赋值操作来创建多个实例</span></span><br><span class="line"><span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;                   <span class="comment">//删除了拷贝构造函数</span></span><br><span class="line">TaskQueue&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;      <span class="comment">//赋值运算符重载函数</span></span><br><span class="line"><span class="comment">//静态的公共成员函数，把唯一的单例对象返回给调用者</span></span><br><span class="line"><span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_taskQ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是单例对象的一个成员函数...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;    <span class="comment">//定义了一个无参构造，它与默认的无参构造具有相同的行为</span></span><br><span class="line"><span class="comment">//TaskQueue(const TaskQueue&amp; t) = default;</span></span><br><span class="line"><span class="comment">//TaskQueue&amp; operator = (const TaskQueue&amp; t) = default;</span></span><br><span class="line"><span class="comment">//只能通过类名访问静态属性或方法</span></span><br><span class="line"><span class="type">static</span> TaskQueue* m_taskQ;      <span class="comment">//该静态成员指针只能通过静态成员方法访问</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;   <span class="comment">//类的作用域下，可以访问类的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-懒汉模式"><a href="#2-2-懒汉模式" class="headerlink" title="2.2 懒汉模式"></a>2.2 懒汉模式</h2><p>懒汉模式：什么时候使用这个单例对象，在使用的时候再去创建对应的实例。</p><p>优点：节省空间</p><p>缺点：在多线程的场景下，懒汉模式是有线程安全问题的(若干个线程同时访问单例的实例，会出问题)。</p><ul><li>解决办法：通过互斥锁，阻塞线程，依次访问这个单例对象，就可以避免在懒汉模式下，多线程同时访问单例对象而创建出多了类的实例这种问题</li></ul><p>双重检查锁定：如果没有第9行的判断，该方法对程序执行的效率就很低，因为不管什么时候，多个线程在访问单例对象的时候(执行getInstance()函数)，都是顺序访问的。但通过双重检查锁定可以解决这个问题，只有第一次的时候，多个线程是线性访问，当后面再访问该函数时(m_taskQ指针被实例化处理之后)，多个线程就是并行访问了，因为第9行代码判断为false，直接返回该实例对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;       <span class="comment">//像这种不需要初始化的，也需要在外部进行申明，因为它是静态的成员</span></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;       <span class="comment">//开始先置为空，什么时候使用，什么时候就实例化对象出来</span></span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>上面程序第14行代码对应的机器指令有3条，第1条是创建一块内存(无数据)；第2条是创建TaskQueue对象，并吧数据写入到创建的内存里面；第3条是将创建的有效地址传给m_taskQ指针。在底层执行程序的时候，可能会对这些指令做重排，就有可能是执行的顺序是132，在还没有执行第2条时，就先将内存地址传给了指针，这时的指针不为空，但没有TaskQueue对象，同一时刻的其它线程调用该函数就会直接返回指针使用，就造成了系统崩溃。所以下面可以通过原子变量来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;</span><br><span class="line">TaskQueue&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//静态的公共成员函数，把唯一的单例对象返回给调用者</span></span><br><span class="line"><span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TaskQueue* task = m_taskQ.<span class="built_in">load</span>();     <span class="comment">//从原子变量里面加载这个任务队列的实例</span></span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">nullptr</span>) &#123;     <span class="comment">//通过双重检查锁定来避免访问效率低的情况(顺序访问)</span></span><br><span class="line">m_mutex.<span class="built_in">lock</span>();                 <span class="comment">//加锁</span></span><br><span class="line">task = m_taskQ.<span class="built_in">load</span>();          <span class="comment">//通过原子变量加载实例对象</span></span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">task = <span class="keyword">new</span> TaskQueue;   <span class="comment">//使用时创建，创建单例实例---&gt;底层指执行这句话的顺序不一样(对应底层3条语句)--&gt;需要用原子变量进行管理</span></span><br><span class="line">m_taskQ.<span class="built_in">store</span>(task);        <span class="comment">//将创建的实例存储起来，保存在原子变量内部</span></span><br><span class="line">&#125;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是单例对象的一个成员函数...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;    <span class="comment">//定义了一个无参构造，它与默认的无参构造具有相同的行为</span></span><br><span class="line"><span class="type">static</span> mutex m_mutex;           <span class="comment">//静态变量互斥锁---&gt;需要在类的外面进行一个声明</span></span><br><span class="line"><span class="type">static</span> atomic&lt;TaskQueue*&gt;m_taskQ;         <span class="comment">//通过原子变量把类的实例对象保存起来，保存到了指针里面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line"><span class="comment">//TaskQueue* TaskQueue::m_taskQ = nullptr;</span></span><br><span class="line">atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;   <span class="comment">//</span></span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>当然，也可以使用静态的局部对象解决线程安全问题。</p><h1 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h1><h2 id="3-1-简单工厂模式"><a href="#3-1-简单工厂模式" class="headerlink" title="3.1 简单工厂模式"></a>3.1 简单工厂模式</h2><p>下面程序就是<code>简单工厂模式</code>实现的例子，首先创建一个产品类作为父类，里面只需要定义一些虚函数即可，供子类继承实现。然后创建一个工厂类，里面实现父类指针指向子类对象，以达到多态的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类的父亲 ---&gt; 人造恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSmile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ability</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractSmile</span>() &#123;&#125;    <span class="comment">//虚的析构函数，可以完全清除子类的内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 山羊人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将手臂变成绵羊角的招式--巨羊角&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 狮子人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;火遁 -- 豪火球之术...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 蝙蝠人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;声纳-引剑之万归宗...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义工厂类</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span> :<span class="type">char</span> &#123;Sheep,Lion,Bat&#125;; <span class="comment">//定义了一个枚举类(enum class)Type，并指定了其基础类型为 char。在这个枚举类中，有三个枚举常量：Sheep、Lion和Bat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmileFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">(Type type)</span></span>&#123;     <span class="comment">//父类指针指向了子类对象，实现多态</span></span><br><span class="line">AbstractSmile* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> Type::Sheep:</span><br><span class="line">ptr = <span class="keyword">new</span> SheepSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Type::Lion:</span><br><span class="line">ptr = <span class="keyword">new</span> LionSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Type::Bat:</span><br><span class="line">ptr = <span class="keyword">new</span> BatSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SmileFactory factory;      <span class="comment">//创建一个工厂对象</span></span><br><span class="line">AbstractSmile* obj = factory.<span class="built_in">createSmile</span>(Type::Lion);</span><br><span class="line">obj-&gt;<span class="built_in">transform</span>();</span><br><span class="line">obj-&gt;<span class="built_in">ability</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-工厂模式"><a href="#3-2-工厂模式" class="headerlink" title="3.2 工厂模式"></a>3.2 工厂模式</h2><p>在上面的简单工厂模式中是只创建了一个工厂类，用于生产需要的对象，但是这种方式有一个弊端，它违反了设计模式中的开放封闭原则，即如果想要生成更多的人造恶魔果实，那么就需要在工厂函数的switch语句中添加更多的case，很明显这违背了封闭原则。所以我们可以使用工厂模式很完美的解决上述的问题。总的来说，就是简单工厂模式是只有一个工厂类，而工厂模式是有很多的工厂类：</p><ul><li>一个基类，包含一个虚工厂函数，用于实现多态。</li><li>多个子类，重写父类的工厂函数。每个子工厂类负责生产一种恶魔果实，这相当于再次解耦，将工厂类的职责再次拆分、细化，如果要生产新品种的恶魔果实，那么只需要添加对应的工厂类，无需修改原有的代码。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式相对于简单工厂模式来说，对类的扩展更方便了</span></span><br><span class="line"><span class="comment">//产品类的父亲 ---&gt; 人造恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSmile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ability</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractSmile</span>() &#123;&#125;    <span class="comment">//虚的析构函数，可以完全清除子类的内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 山羊人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将手臂变成绵羊角的招式 -- 巨羊角&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 狮子人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;火遁 -- 豪火球之术...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 蝙蝠人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;声纳-引剑之万归宗...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义工厂类 --- 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;       <span class="comment">//抽象类(虚工厂)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产山羊的恶魔果实(通过子工厂来继承虚工厂)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;      <span class="comment">//父类指针指向子类对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SheepSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">SheepFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;SheppFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产狮子的恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LionSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">LionFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;LionFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产蝙蝠的恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BatSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">BatFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BatFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//AbstractFactory factory;    //AbstractFactory是抽象类了，不能这样实例化一个抽象类</span></span><br><span class="line">AbstractFactory* factory = <span class="keyword">new</span> LionFactory;      <span class="comment">//父类指针指向子类对象</span></span><br><span class="line">AbstractSmile* obj = factory-&gt;<span class="built_in">createSmile</span>();     <span class="comment">//同样也是父类指针指向子类对象，factory执行的函数是子类对象重写的</span></span><br><span class="line">obj-&gt;<span class="built_in">transform</span>();</span><br><span class="line">obj-&gt;<span class="built_in">ability</span>();</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line"><span class="keyword">delete</span> factory;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-抽象工厂模式"><a href="#3-3-抽象工厂模式" class="headerlink" title="3.3 抽象工厂模式"></a>3.3 抽象工厂模式</h2><p><code>抽象工厂模式</code>适用于比较复杂的多变的业务场景，总体上就是给一系列功能相同但是属性会发生变化的组件(如：船体材料、武器系统、动力系统)添加一个抽象类，这样就可以非常方便地进行后续的拓展，再搭配工厂类就可以创建出我们需要的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShipBody</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ShipBody</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//木头船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WoodBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;木材&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//钢铁船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IronBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;钢铁&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//合成金属船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MetalBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;合成金属&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Engine</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手动引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;手动&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内燃机引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diesel</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;内燃机&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手动引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nuclear</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;核反应堆&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getWeapon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Weapon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//枪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;枪&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加农炮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cannon</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;加农跑&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//激光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laser</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;激光&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span> &#123;    <span class="comment">//船这个类里面又还要三个子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//通过传进来的对于子类对象，实现父类指针指向子类对象</span></span><br><span class="line"><span class="built_in">Ship</span>(ShipBody* body, Engine* engine, Weapon* weapon) :       <span class="comment">//三个子对象之间这里是组合关系，当析构船对象的时候，一并析构掉这三个子对象</span></span><br><span class="line"><span class="built_in">m_body</span>(body), <span class="built_in">m_engine</span>(engine), <span class="built_in">m_weapon</span>(weapon) &#123;&#125;</span><br><span class="line">~<span class="built_in">Ship</span>() &#123;                                                   <span class="comment">//组合关系，析构掉三个子对象</span></span><br><span class="line"><span class="keyword">delete</span> m_body;</span><br><span class="line"><span class="keyword">delete</span> m_weapon;</span><br><span class="line"><span class="keyword">delete</span> m_engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string info = m_body-&gt;<span class="built_in">getBody</span>() + m_weapon-&gt;<span class="built_in">getWeapon</span>() + m_engine-&gt;<span class="built_in">getEngine</span>();</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ShipBody* m_body;             <span class="comment">//船体父类对象</span></span><br><span class="line">Engine* m_engine;             <span class="comment">//引擎父类对象</span></span><br><span class="line">Weapon* m_weapon;             <span class="comment">//武器父类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类 --- 抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Ship* <span class="title">createShip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> WoodBody, <span class="keyword">new</span> Human, <span class="keyword">new</span> Gun);    <span class="comment">//相当于通过传参构造Ship</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;基础型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> IronBody, <span class="keyword">new</span> Diesel, <span class="keyword">new</span> Cannon);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;标准型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旗舰型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UltimataFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> MetalBody, <span class="keyword">new</span> Nuclear, <span class="keyword">new</span> Laser);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;旗舰型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//下单为旗舰型海贼船</span></span><br><span class="line">AbstractFactory* factory = <span class="keyword">new</span> UltimataFactory;   <span class="comment">//父工厂指针指向子工厂对象</span></span><br><span class="line">Ship* ship = factory-&gt;<span class="built_in">createShip</span>();      <span class="comment">//创建对应的船，并返回</span></span><br><span class="line">cout &lt;&lt; ship-&gt;<span class="built_in">getProperty</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> factory;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后对<code>简单工厂模式</code>、<code>工厂模式</code>和<code>抽象工厂模式</code>的区别做如下总结：</p><ul><li>简单工厂模式不能遵守开放封闭原则，工厂和抽象工厂模式可以</li><li>简单工厂模式只有一个工厂类，工厂和抽象工厂有多个工厂类</li><li>工厂模式创建的产品对象相对简单，抽象工厂模式创建的产品对象相对复杂<ul><li>工厂模式创建的对象对应的类不需要提供抽象类(这产品类组件中没有可变因素)</li><li>抽象工厂模式创建的对象对应的类有抽象的基类(这个产品类组件中有可变因素)</li></ul></li></ul><h1 id="4-建造者-生成器-模式"><a href="#4-建造者-生成器-模式" class="headerlink" title="4. 建造者(生成器)模式"></a>4. 建造者(生成器)模式</h1><p>下面程序为创造模式的一个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义桑尼号的船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SunnyShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addParts</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_parts.<span class="built_in">push_back</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_parts) &#123;</span><br><span class="line">cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;string&gt; m_parts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义梅丽号的船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MerryShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assemble</span><span class="params">(string name, string parts)</span> </span>&#123;</span><br><span class="line">m_parts.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(parts,name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_parts) &#123;</span><br><span class="line">cout &lt;&lt; item.first&lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; item.second;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">map&lt;string, string&gt; m_parts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义生成器类：在这个抽象类中定义了建造海贼船所有零部件的方法，在这个类的子类中需要重写这些虚函数，分别完成桑尼号 和梅利号零件的建造。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShipBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ShipBuilder</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桑尼号生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SunnyBuilder</span> :<span class="keyword">public</span> ShipBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SunnyBuilder</span>() &#123;</span><br><span class="line"><span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny = <span class="keyword">new</span> SunnyShip;        <span class="comment">//创建一个桑尼号船</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SunnyShip* <span class="title">getSunnyShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SunnyShip* ship = m_sunny;     <span class="comment">//当在m_sunny对象里面存储了对应组件后，就可以返回给调用者了</span></span><br><span class="line">m_sunny = <span class="literal">nullptr</span>;             <span class="comment">//旧内存就不需要维护了(后面还需要创建不同型号的桑尼号)</span></span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;船体是神树亚当&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;狮吼炮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;可乐驱动的内燃机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;非常豪华的内室装修&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">SunnyBuilder</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sunny) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_sunny;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SunnyShip* m_sunny;          <span class="comment">//定义一个桑尼船的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梅丽号生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MerryBuilder</span> :<span class="keyword">public</span> ShipBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MerryBuilder</span>() &#123;</span><br><span class="line"><span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry = <span class="keyword">new</span> MerryShip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MerryShip* <span class="title">getMerryShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MerryShip* ship = m_merry;</span><br><span class="line">m_merry = <span class="literal">nullptr</span>;         <span class="comment">//旧内存就不需要维护了</span></span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;船体是优质木材&quot;</span>,<span class="string">&quot;船体&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;普通的四门大炮&quot;</span>,<span class="string">&quot;武器系统&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;烧煤的蒸汽机&quot;</span>,<span class="string">&quot;动力系统&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;非常豪华的内室装修&quot;</span>,<span class="string">&quot;内室&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MerryBuilder</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_merry) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_merry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MerryShip* m_merry;          <span class="comment">//定义一个桑尼船的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBuilder</span><span class="params">(ShipBuilder* builder)</span> </span>&#123;      <span class="comment">//多态实现，参数传进来的可能是桑尼号也可能是梅丽号</span></span><br><span class="line">m_builder = builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildSimpleShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_builder-&gt;<span class="built_in">buildBody</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildEngine</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildStandardShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildSimpleShip</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildWeapon</span>();      <span class="comment">//在简约型的基础上多了一个武器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildRegalShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildStandardShip</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildInterior</span>();     <span class="comment">//在标准型基础上多了一个内室装饰</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ShipBuilder* m_builder = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建桑尼号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildSunnyShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Director* director = <span class="keyword">new</span> Director;           <span class="comment">//创建出一个管理类对象</span></span><br><span class="line">SunnyBuilder* builder = <span class="keyword">new</span> SunnyBuilder;    <span class="comment">//创建一个桑尼号船对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line">director-&gt;<span class="built_in">setBuilder</span>(builder);               <span class="comment">//多态实现，父类指针指向子类对象</span></span><br><span class="line">director-&gt;<span class="built_in">buildSimpleShip</span>();                 <span class="comment">//创建一个简约型的桑尼号</span></span><br><span class="line">SunnyShip* ship = builder-&gt;<span class="built_in">getSunnyShip</span>();   <span class="comment">//取出它的一个ship，里面容器存了对应的字符串</span></span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();                           <span class="comment">//打印简约型桑尼号组件</span></span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();                           <span class="comment">//重新创建一个ship的子类(存对应桑尼号组件的)</span></span><br><span class="line">director-&gt;<span class="built_in">buildStandardShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getSunnyShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildRegalShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getSunnyShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> builder;</span><br><span class="line"><span class="keyword">delete</span> director;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建造梅丽号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMerryShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Director* director = <span class="keyword">new</span> Director;</span><br><span class="line">MerryBuilder* builder = <span class="keyword">new</span> MerryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line">director-&gt;<span class="built_in">setBuilder</span>(builder);</span><br><span class="line">director-&gt;<span class="built_in">buildSimpleShip</span>();</span><br><span class="line">MerryShip* ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildStandardShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildRegalShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> builder;</span><br><span class="line"><span class="keyword">delete</span> director;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildMerryShip</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">buildSunnyShip</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h1><p>通过父类指针把对应的子类对象拷贝出来，就是让子类重写了父类提供的克隆函数，然后在每个子类的克隆函数里面调用了子类对应的拷贝构造函数，再通过父类指针指向某一个子类对象，这样就通过指针能够调用某个子类里面的克隆函数了，执行的就是对应子类里面的拷贝动作，这样就能够得到对应的子类实例对象(不是原来那个了)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类(抽象类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GermaSoldier</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> GermaSoldier* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">whoAmI</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">GermaSoldier</span>() &#123;&#125;               <span class="comment">//虚析构(同时会析构子类对象)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier66</span> :<span class="keyword">public</span> GermaSoldier &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">GermaSoldier* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Soldier66</span>(*<span class="keyword">this</span>);      <span class="comment">//谁调用clone，this就是谁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">whoAmI</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我是soldier66的士兵!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier67</span> :<span class="keyword">public</span> GermaSoldier &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">GermaSoldier* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Soldier67</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">whoAmI</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我是soldier67的士兵!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GermaSoldier* obj = <span class="keyword">new</span> Soldier66;</span><br><span class="line">GermaSoldier* soldier = obj-&gt;<span class="built_in">clone</span>();   <span class="comment">//obj-&gt;clone克隆出来的是Soldier66的对象</span></span><br><span class="line">cout &lt;&lt; soldier-&gt;<span class="built_in">whoAmI</span>();</span><br><span class="line"><span class="keyword">delete</span> soldier;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> Soldier67;</span><br><span class="line">soldier = obj-&gt;<span class="built_in">clone</span>();                 <span class="comment">//obj-&gt;clone克隆出来的是Soldier67的对象</span></span><br><span class="line">cout &lt;&lt; soldier-&gt;<span class="built_in">whoAmI</span>();</span><br><span class="line"><span class="keyword">delete</span> soldier;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h1><p><code>适配器</code>就是将一个类的接口转换成用户希望的另一个接口，使不兼容的对象能够相互配合并一起工作，这种模式就叫适配器模式。</p><p>STL标准模板库有六大组件，其中之一的就是适配器。</p><ul><li>六大组件分别是：容器、算法、迭代器、仿函数、适配器、空间适配器。</li><li>适配器又可以分为：容器适配器、函数适配器、迭代器适配器</li></ul><p>1.适配器类和熊猫类是关联关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foreigner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">confession</span><span class="params">()</span> </span>= <span class="number">0</span>;         <span class="comment">//纯虚函数，让子类实现，美国人和法国人说的话</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setResult</span><span class="params">(string res)</span> </span>&#123;             <span class="comment">//收到熊猫的回复</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Panda say: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Foreigner</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//美国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ammerican</span> : <span class="keyword">public</span> Foreigner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">confession</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我有罪，呼呼呼!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//法国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">French</span> : <span class="keyword">public</span> Foreigner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">confession</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我不是人，哎哎哎!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//熊猫</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recvMessage</span><span class="params">(string msg)</span> </span>&#123;         <span class="comment">//接收的数据</span></span><br><span class="line">cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;                 <span class="comment">//发送的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;强盗、凶手，罪人是不可能被宽恕和原谅的!! &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractChopper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传入的参数是美国人对象或法国人对象</span></span><br><span class="line"><span class="built_in">AbstractChopper</span>(Foreigner* foreigner) : <span class="built_in">m_foreigner</span>(foreigner) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Panda m_panda;                 <span class="comment">//熊猫对象</span></span><br><span class="line">Foreigner* m_foreigner;        <span class="comment">//外国人对象(保存传进来的外国人的实例)  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器子类(熊猫语言与英语之间的转换)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishChopper</span> : <span class="keyword">public</span> AbstractChopper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractChopper::AbstractChopper;    <span class="comment">//在子类里面就继承了所有在父类中定义的构造函数</span></span><br><span class="line"><span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_foreigner-&gt;<span class="built_in">confession</span>();     <span class="comment">//取出美国人说的话</span></span><br><span class="line"><span class="comment">//解析熊猫的语言，并将数据传递给熊猫</span></span><br><span class="line">m_panda.<span class="built_in">recvMessage</span>(<span class="string">&quot;美国人说: &quot;</span> + msg);    <span class="comment">//熊猫接收到美国人的话</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_panda.<span class="built_in">sendMessage</span>();        <span class="comment">//取出熊猫回复的话</span></span><br><span class="line"><span class="comment">//将熊猫语言转换为英语，再传递给外国人</span></span><br><span class="line">m_foreigner-&gt;<span class="built_in">setResult</span>(<span class="string">&quot;美国佬: &quot;</span> + msg);  <span class="comment">//外国人接收到熊猫的话</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器子类(熊猫语言与法语之间的转换)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrechChopper</span> : <span class="keyword">public</span> AbstractChopper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractChopper::AbstractChopper;    <span class="comment">//在子类里面就继承了所有在父类中定义的构造函数</span></span><br><span class="line"><span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_foreigner-&gt;<span class="built_in">confession</span>();</span><br><span class="line"><span class="comment">//解析熊猫的语言，并将数据传递给熊猫</span></span><br><span class="line">m_panda.<span class="built_in">recvMessage</span>(<span class="string">&quot;法国人说: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_panda.<span class="built_in">sendMessage</span>();</span><br><span class="line"><span class="comment">//将熊猫语言转换为英语，再传递给外国人</span></span><br><span class="line">m_foreigner-&gt;<span class="built_in">setResult</span>(<span class="string">&quot;法国佬: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Foreigner* foreigner = <span class="keyword">new</span> Ammerican;                        <span class="comment">//定义一个外国人的对象(多态实现，指向美国人对象)</span></span><br><span class="line">AbstractChopper* adapter = <span class="keyword">new</span> <span class="built_in">EnglishChopper</span>(foreigner);    <span class="comment">//转换器对象(对应的是英语转换器)</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToPanda</span>();           <span class="comment">//英语转换为熊猫语言</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToHuman</span>();           <span class="comment">//熊猫语言转换为英语</span></span><br><span class="line"><span class="keyword">delete</span> foreigner;</span><br><span class="line"><span class="keyword">delete</span> adapter;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=====================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">foreigner = <span class="keyword">new</span> French;                         <span class="comment">//定义一个外国人的对象(多态实现，指向美国人对象)</span></span><br><span class="line">adapter = <span class="keyword">new</span> <span class="built_in">FrechChopper</span>(foreigner);    <span class="comment">//转换器对象(对应的是英语转换器)</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToPanda</span>();           <span class="comment">//英语转换为熊猫语言</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToHuman</span>();           <span class="comment">//熊猫语言转换为英语</span></span><br><span class="line"><span class="keyword">delete</span> foreigner;</span><br><span class="line"><span class="keyword">delete</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.适配器类和熊猫类是继承关系：因为熊猫类是没有子类的，所以可以让适配器父类来继承熊猫类，这样在适配器子类中使用熊猫类的<code>recvMessage()</code>函数和<code>sendMessage()</code>函数就可以直接使用，而不需要通过<code>m_panda.</code>来引用。当然，当外国人类也没有子类时，适配器父类就可以继承熊猫类和适配器类(多个类)来实现相应的功能了。</p><h1 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h1><p><code>桥接模式</code>的原则就是将抽象部分和它的实现部分分离，使它们可以独立的变化。</p><p>比如说在下面程序中，实现桥接模式的方案：</p><ul><li>海贼团之间是继承关系，但是此时的海贼团也只是一个抽象，因为组成海贼团的人已经被抽离了，船员已经和所属的海贼团没有了继承关系。</li><li>关于海贼世界的船员在船上对应不同的职责担任不同的职务，他们是一个团队，所以可以给船员抽象出一个团队类，用于管理船上的成员。</li><li>抽象的海贼团只有一个空壳子，所以要赋予其灵魂也就是给它添加船员，此时的海贼团和船员团队可以通过聚合的方式组合成为一个整体。</li><li>这种解决方案不仅适用于管理海贼团，用于管理海军的各个舰队也是没有问题的。</li></ul><p>测试程序：对海贼世界中的 海贼团 和 海军 通过桥接模式进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员对应的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string job, string ability, string reward, string beizhu) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;job = job;</span><br><span class="line"><span class="keyword">this</span>-&gt;ability = ability;</span><br><span class="line"><span class="keyword">this</span>-&gt;reward = reward;</span><br><span class="line"><span class="keyword">this</span>-&gt;beizhu = beizhu;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">string job;</span><br><span class="line">string ability;</span><br><span class="line">string reward;</span><br><span class="line">string beizhu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义实现部分 - 团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractTeam</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractTeam</span>(string name) : <span class="built_in">m_name</span>(name) &#123;&#125;       <span class="comment">//初始化团队的名字</span></span><br><span class="line"><span class="function">string <span class="title">getTeamName</span><span class="params">()</span> </span>&#123;                            <span class="comment">//获取团队的名字</span></span><br><span class="line"><span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMember</span><span class="params">(Person* p)</span> </span>&#123;</span><br><span class="line">m_teamMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(p-&gt;name, p));      <span class="comment">//插入成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_teamMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[name: &quot;</span> &lt;&lt; item.second-&gt;name</span><br><span class="line">&lt;&lt; <span class="string">&quot;, job: &quot;</span> &lt;&lt; item.second-&gt;job</span><br><span class="line">&lt;&lt; <span class="string">&quot;, abilite: &quot;</span> &lt;&lt; item.second-&gt;ability</span><br><span class="line">&lt;&lt; <span class="string">&quot;, reward: &quot;</span> &lt;&lt; item.second-&gt;reward</span><br><span class="line">&lt;&lt; <span class="string">&quot;, beizhu: &quot;</span> &lt;&lt; item.second-&gt;beizhu</span><br><span class="line">&lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractTeam</span>() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_teamMap) &#123;</span><br><span class="line"><span class="keyword">delete</span> item.second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> </span>= <span class="number">0</span>;          <span class="comment">//纯虚函数的任务函数，让子类来写</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_name;</span><br><span class="line">map&lt;string, Person*&gt; m_teamMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//草帽子团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaoMaoTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;          <span class="comment">//继承父类的构造函数(获取团队名)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在海上冒险，找到 ONE PIECE 成为海贼王!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//海军子团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmokerTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;          <span class="comment">//继承父类的构造函数(获取团队名)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;为了正义，先将草帽一网打尽!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义抽象部分 - 船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractShip</span>(AbstractTeam* team) :<span class="built_in">m_team</span>(team) &#123;&#125;       <span class="comment">//初始化一个团队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_team-&gt;<span class="built_in">show</span>();                              <span class="comment">//展示团队成员</span></span><br><span class="line">m_team-&gt;<span class="built_in">executeTask</span>();                       <span class="comment">//打印团队的目标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;              <span class="comment">//船的名字</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">feature</span><span class="params">()</span> </span>= <span class="number">0</span>;                <span class="comment">//船的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">AbstractTeam* m_team;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梅丽号子船类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Merry</span> :<span class="keyword">public</span> AbstractShip &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractShip::AbstractShip;      <span class="comment">//继承父类的构造函数</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;前进 - 梅利号&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feature</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;-- 船首为羊头，化身船精灵在司法岛舍己救下了草帽一伙!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//海军船子船类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HaiJunShip</span> :<span class="keyword">public</span> AbstractShip &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractShip::AbstractShip;      <span class="comment">//继承父类的构造函数</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;无敌海军号&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feature</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;-- 船底由海楼石建造，可以穿过无风带的巨大炮舰!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//CaoMaoTeam* team = new CaoMaoTeam(&quot;草帽海贼团&quot;);             //不通过多态实现也可以</span></span><br><span class="line">CaoMaoTeam* team = <span class="keyword">new</span> <span class="built_in">CaoMaoTeam</span>(<span class="string">&quot;草帽海贼团&quot;</span>);               <span class="comment">//创建一个团队</span></span><br><span class="line">Person* luffy = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;路飞&quot;</span>, <span class="string">&quot;船长&quot;</span>, <span class="string">&quot;橡胶果实能力者&quot;</span>, <span class="string">&quot;30亿贝利&quot;</span>, <span class="string">&quot;爱吃肉&quot;</span>);</span><br><span class="line">Person* zoro = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;索隆&quot;</span>, <span class="string">&quot;剑士&quot;</span>, <span class="string">&quot;三刀流&quot;</span>, <span class="string">&quot;12亿贝利&quot;</span>, <span class="string">&quot;路痴&quot;</span>);</span><br><span class="line">Person* sanji = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;山治&quot;</span>, <span class="string">&quot;厨师&quot;</span>, <span class="string">&quot;火焰腿&quot;</span>, <span class="string">&quot;10亿贝利&quot;</span>, <span class="string">&quot;好色&quot;</span>);</span><br><span class="line">Person* nami = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;娜美&quot;</span>, <span class="string">&quot;航海士&quot;</span>, <span class="string">&quot;天候棒&quot;</span>, <span class="string">&quot;3亿贝利&quot;</span>, <span class="string">&quot;喜欢钱&quot;</span>);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(luffy);                <span class="comment">//因为子团队继承了父团队，所以可以使用父团队的函数</span></span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(zoro);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(sanji);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(nami);</span><br><span class="line"><span class="comment">//Merry* ship = new Merry(team);            //不通过多态实现也可以</span></span><br><span class="line">AbstractShip* ship = <span class="keyword">new</span> <span class="built_in">Merry</span>(team);       <span class="comment">//创建梅丽船，传入的参数是草帽团队</span></span><br><span class="line">ship-&gt;<span class="built_in">show</span>();                    <span class="comment">//打印团队成员和目标(该函数里面就是通过传入的草帽团队调用了对应的函数)</span></span><br><span class="line">ship-&gt;<span class="built_in">feature</span>();                 <span class="comment">//打印船的属性</span></span><br><span class="line"><span class="keyword">delete</span> team;</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8. 组合模式"></a>8. 组合模式</h1><p>能将多个对象组成一个树状结构，用以描述部分—整体的层次关系，使得用户对单个对象和组合对象的使用具有一致性，这样的结构性设计模式叫做<code>组合模式</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义节点的抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractTeam</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractTeam</span>(string name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;                         <span class="comment">//获取团队名字</span></span><br><span class="line"><span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setParent</span><span class="params">(AbstractTeam* team)</span> </span>&#123;       <span class="comment">//设置父对象</span></span><br><span class="line">m_parent = team;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AbstractTeam* <span class="title">getParent</span><span class="params">()</span> </span>&#123;                <span class="comment">//获取父对象</span></span><br><span class="line"><span class="keyword">return</span> m_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasChild</span><span class="params">()</span> </span>&#123;          <span class="comment">//是否有子节点，默认返回false(叶子节点就可以不用重写该函数了，管理者节点需要重写)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这两个函数不能定义成纯虚函数：因为如果这个抽象类的子类是一个叶子节点，叶子节点是用不到这两个函数的，所以就不需要重写这两个</span></span><br><span class="line"><span class="comment">//虚函数。如果定义成纯虚函数，子类就必须重写，不然也是抽象类(不能被实例化)，所以不定义成虚函数，子类就算继承了，该函数也是什么都不执行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;&#125;        <span class="comment">//添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;&#125;     <span class="comment">//删除节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数(子类必须重写的)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractTeam</span>() &#123;&#125;         <span class="comment">//虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_name;                       <span class="comment">//记录团队的名字</span></span><br><span class="line">AbstractTeam* m_parent = <span class="literal">nullptr</span>;    <span class="comment">//记录父对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeafTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;         <span class="comment">//继承父类定义的所有构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() + m_name + <span class="string">&quot;与黑胡子的船员进行近距离肉搏战... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;下属的&quot;</span> &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">LeafTeam</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;下属的&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;,战斗已经结束，拜拜... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManagerTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;         <span class="comment">//继承父类定义的所有构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt;  m_name + <span class="string">&quot;与黑胡子的恶魔果实能力者战斗... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasChild</span><span class="params">()</span> </span>&#123;          <span class="comment">//是否有子节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;         <span class="comment">//添加下属团队</span></span><br><span class="line">node-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);                  <span class="comment">//上级节点就为这个类对象</span></span><br><span class="line">m_children.<span class="built_in">push_back</span>(node);             <span class="comment">//加入该团队的下属</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;      <span class="comment">//删除下属团队</span></span><br><span class="line">node-&gt;<span class="built_in">setParent</span>(<span class="literal">nullptr</span>);               <span class="comment">//给它的上级节点指为空</span></span><br><span class="line">m_children.<span class="built_in">remove</span>(node);                <span class="comment">//移除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;      <span class="comment">//如果是管理者节点，则就打印他的下属团队</span></span><br><span class="line">string info;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_children) &#123;         <span class="comment">//遍历他的下属团队</span></span><br><span class="line"><span class="keyword">if</span> (item == m_children.<span class="built_in">back</span>()) &#123;</span><br><span class="line">info += item-&gt;<span class="built_in">getName</span>();              <span class="comment">//如果是最后一个，就直接追加在后面即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">info += item-&gt;<span class="built_in">getName</span>() + <span class="string">&quot;, &quot;</span>;        <span class="comment">//如果不是最后一个，就添加逗号，继续追加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的船队是[&quot;</span> &lt;&lt; info &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">list&lt;AbstractTeam*&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;               <span class="comment">//取出他的下属</span></span><br><span class="line"><span class="keyword">return</span> m_children;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ManagerTeam</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是[ &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ] 战斗结束，拜拜...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">list&lt;AbstractTeam*&gt; m_children;        <span class="comment">//来记录它的孩子节点(记录它的下属)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gameover</span><span class="params">(AbstractTeam* root)</span> </span>&#123;             <span class="comment">//递归消除节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root &amp;&amp; root-&gt;<span class="built_in">hasChild</span>()) &#123;               <span class="comment">//不为空，且有下属</span></span><br><span class="line">ManagerTeam* team = <span class="built_in">dynamic_cast</span>&lt;ManagerTeam*&gt;(root);</span><br><span class="line">list&lt;AbstractTeam*&gt; children = team-&gt;<span class="built_in">getChildren</span>();        <span class="comment">//取出该节点的子节点(下属)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : children) &#123;           <span class="comment">//</span></span><br><span class="line"><span class="built_in">gameover</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">ManagerTeam* root = <span class="keyword">new</span> <span class="built_in">ManagerTeam</span>(<span class="string">&quot;草帽海贼团&quot;</span>);</span><br><span class="line">vector&lt;string&gt; nameList = &#123; <span class="string">&quot;俊美海贼团&quot;</span>,<span class="string">&quot;巴托俱乐部&quot;</span>,<span class="string">&quot;八宝水军&quot;</span>,<span class="string">&quot;艾迪欧海贼团&quot;</span>,<span class="string">&quot;咚塔塔海贼团&quot;</span>,</span><br><span class="line"><span class="string">&quot;巨兵海贼团&quot;</span>,<span class="string">&quot;约塔玛利亚大船团&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nameList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">ManagerTeam* child = <span class="keyword">new</span> <span class="built_in">ManagerTeam</span>(nameList.<span class="built_in">at</span>(i));</span><br><span class="line">root-&gt;<span class="built_in">addChild</span>(child);</span><br><span class="line"><span class="keyword">if</span> (i == nameList.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">LeafTeam* leaf = <span class="keyword">new</span> <span class="built_in">LeafTeam</span>(<span class="string">&quot;第&quot;</span> + <span class="built_in">to_string</span>(j + <span class="number">1</span>) + <span class="string">&quot;番队&quot;</span>);</span><br><span class="line">child-&gt;<span class="built_in">addChild</span>(leaf);</span><br><span class="line">leaf-&gt;<span class="built_in">fight</span>();</span><br><span class="line">leaf-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fighting</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-设计模式三原则&quot;&gt;&lt;a href=&quot;#1-设计模式三原则&quot; class=&quot;headerlink&quot; title=&quot;1. 设计模式三原则&quot;&gt;&lt;/a&gt;1. 设计模式三原则&lt;/h1&gt;&lt;p&gt;在进行程序设计的时候，要尽可能地保证程序的可扩展性、可维护性和可读性，所以需要使</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>c++11新特性</title>
    <link href="https://lxx93.online/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lxx93.online/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2024-08-26T10:34:13.000Z</published>
    <updated>2025-04-21T14:12:41.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原始自变量"><a href="#1-原始自变量" class="headerlink" title="1. 原始自变量"></a>1. 原始自变量</h1><p>定义原始字符串的方式为：R “xxx(原始字符串)xxx”，其中()两边的字符串可以省略(不省略的时候就要求一样)。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p><p>用途：主要是防止一些特殊字符，如\t，\n等对想输出的字符串产生影响。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;     <span class="comment">//后面的hello为world就会报错</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;</span></span><br><span class="line"><span class="string">海贼王</span></span><br><span class="line"><span class="string">&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;</span></span><br><span class="line"><span class="string">我是要成为海贼王的男人</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\hello\world\test.text</span><br><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">        海贼王</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">        我是要成为海贼王的男人</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2. 指针空值类型nullptr"></a>2. 指针空值类型nullptr</h1><p>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在c++11标准下，相比NULL和0，使用nullptr初始化空指针可以令编写的程序更加健壮。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* ptr3 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);        <span class="comment">//在c中，NULL是(void*)0---&gt;对0强制转换；而在c++中，NULL就是0</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);    <span class="comment">//c++中，对指针初始化用nullptr，它可以隐式转换为各种类型指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(int p)</span><br><span class="line">void func(int p)</span><br><span class="line">void func(char *p)</span><br></pre></td></tr></table></figure><h1 id="3-constexpr修饰常量表达式"><a href="#3-constexpr修饰常量表达式" class="headerlink" title="3. constexpr修饰常量表达式"></a>3. constexpr修饰常量表达式</h1><p>C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>注：const和constexpr是等价的，都可以在程序的编译阶段计算出结果。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;          <span class="comment">//对结构体用constexpr是不行的，只能在初始化一个结构体时才可以用该常量</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//a = 12;         报错，不能对常量进行修改了</span></span><br><span class="line"><span class="keyword">constexpr</span> T t&#123; <span class="number">13</span> &#125;;</span><br><span class="line"><span class="comment">//t.a = 12;       报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-自动类型推导"><a href="#4-自动类型推导" class="headerlink" title="4. 自动类型推导"></a>4. 自动类型推导</h1><p>当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字。<br>当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;     <span class="comment">//a1是const int类型 ---&gt; auto相当于是int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;            <span class="comment">//因为a2既没有指针也没有引用，所以a2是int类型,不是const int类型(const被消除了)</span></span><br><span class="line"><span class="comment">//保留赋值的const方法(加解引用或指针)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a3 = a1;           <span class="comment">//a3是const int类型</span></span><br><span class="line"><span class="keyword">auto</span>* pt1 = &amp;a1;         <span class="comment">//pt1是const int*类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许使用auto的四个场景：</p><p>1.不能作为函数参数使用，因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;                    <span class="comment">//错误的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不能用于类的非静态成员变量的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="number">0</span>;                       <span class="comment">//错误</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;                <span class="comment">//错误，类的静态非常量成员不允许在类的内部直接初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;         <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.不能使用auto关键字定义数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;            <span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">auto</span> t1 = array;                        <span class="comment">//正确，t1被推导为int*类型</span></span><br><span class="line"><span class="keyword">auto</span> t2[] = array;                      <span class="comment">//错误，t2相当于是重新定义数组，是无法成功的</span></span><br><span class="line"><span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;              <span class="comment">//错误，auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.无法使用auto推导出模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">Test&lt;<span class="keyword">auto</span>&gt;t1 = t;                 <span class="comment">//错误，无法推导出模板类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-decltype类型推导"><a href="#5-decltype类型推导" class="headerlink" title="5. decltype类型推导"></a>5. decltype类型推导</h1><p>它的作用是在编译器编译的时候推导出一个表达式的类型，如decltype (表达式)；</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure><p>decltype的应用多数出现在泛型编程中，下面编写一个类模板，在里边添加遍历容器的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//T::iterator m_it;                   // 这里不能确定迭代器类型</span></span><br><span class="line">    <span class="comment">//这样就能够推导出对应的T容器它的迭代器类型，基于这个类型定义出了它的迭代器变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;           <span class="comment">//通过T()来得到一个对象，调用它的begin()方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; st1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;list&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line">    c.<span class="built_in">func</span>(st1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历常量的迭代器容器(只读迭代器)</span></span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; st2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; c2;</span><br><span class="line">    c2.<span class="built_in">func</span>(st2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype返回值类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;           <span class="comment">//模板函数1</span></span><br><span class="line"><span class="function">R <span class="title">add1</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;                      <span class="comment">//模板函数2</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;               <span class="comment">//auto可以通过后面的decltype来判断</span></span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> u = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//模板函数1：可以编译，但不合理，外部调用的人，一般不会知道模板函数内部的代码内容，即不知道最后返回值是t+u</span></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">add1</span>&lt;<span class="keyword">decltype</span>(t + u), <span class="type">int</span>, <span class="type">double</span>&gt;(t , u);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//模板函数2：</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">add2</span>(t, u);</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-final和overrid关键字的使用"><a href="#6-final和overrid关键字的使用" class="headerlink" title="6. final和overrid关键字的使用"></a>6. final和overrid关键字的使用</h1><h2 id="6-1-final"><a href="#6-1-final" class="headerlink" title="6.1 final"></a>6.1 final</h2><p><code>final</code>关键字来限制某个类不能被继承，或者某个虚函数不能被重写。</p><div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">修饰函数</button><button type="button" class="tab " data-href="test4-2">修饰类</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>如果用final来修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了。</p><p>解释：当test()是基类中的一个虚函数时，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只能使用，而不能进行重写了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//父类虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>        <span class="comment">//用final修饰从父类继承下来的虚函数，表示之后再继承Child类时，不能重写Test</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span>             <span class="comment">// 语法错误, 不允许重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>如果使用final关键字来修饰类的话，表示该类是不允许被继承的，也就是说这个类不能有派生类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>                                 <span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span>: <span class="keyword">public</span> Base            <span class="comment">//子类继承父类，同时加上了final关键字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child           <span class="comment">//语法错误，不能在继承Child类了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="6-2-override"><a href="#6-2-override" class="headerlink" title="6.2 override"></a>6.2 override</h2><p><code>override</code>关键字确保在派生类中声明的重写函数与基类的虚函数有相同的名字，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span>              <span class="comment">//重写从父类继承下来的虚函数(当函数名不和父类的虚函数名一样时，会提示错误)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="7-委托构造函数和继承构造函数"><a href="#7-委托构造函数和继承构造函数" class="headerlink" title="7.委托构造函数和继承构造函数"></a>7.委托构造函数和继承构造函数</h1><h2 id="7-1-委托构造函数"><a href="#7-1-委托构造函数" class="headerlink" title="7.1 委托构造函数"></a>7.1 委托构造函数</h2><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类也可以通过以下方式来继承父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一个参数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">test</span>(num)&#123;                     <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个参数：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">test</span>(num, sum) &#123;      <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;二个参数：&quot; &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;三个参数：&quot;</span> &lt;&lt; tum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-2-继承构造函数"><a href="#7-2-继承构造函数" class="headerlink" title="7.2 继承构造函数"></a>7.2 继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num)&#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num),<span class="built_in">b</span>(sum),<span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">child(int num) :base(num)&#123;&#125;</span></span><br><span class="line"><span class="comment">child(int num, int sum) :base(num,sum) &#123;&#125;</span></span><br><span class="line"><span class="comment">child(int num, int sum, int tum) :base(num, sum,tum) &#123;&#125;*/</span></span><br><span class="line"><span class="keyword">using</span> base::base;        <span class="comment">//可以直接这样写(相当于上面3行代码)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">child <span class="title">x</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; x.a &lt;&lt; x.b &lt;&lt; x.c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum), <span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;and&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> base::base;</span><br><span class="line"><span class="keyword">using</span> base::func;               <span class="comment">//也可以通过这行来解决隐藏了父类同名函数的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;                   <span class="comment">//写了一个与父类中的同名函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;             <span class="comment">//这里必须是带参的构造函数，因为父类中没有默认构造函数</span></span><br><span class="line">    c.base::<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);     <span class="comment">//通过加定义域的方式来得到与父类相同的同名函数</span></span><br><span class="line">c.<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，如果基类没有默认构造函数，子类也不能自动生成默认构造函数。这是因为子类对象的构造需要先构造基类的部分，如果基类没有默认构造函数，子类在构造时就无法调用基类的构造函数来初始化基类部分。</p></blockquote><h1 id="8-可调用对象包装器和绑定器"><a href="#8-可调用对象包装器和绑定器" class="headerlink" title="8 .可调用对象包装器和绑定器"></a>8 .可调用对象包装器和绑定器</h1><h2 id="8-1-可调用对象"><a href="#8-1-可调用对象" class="headerlink" title="8.1 可调用对象"></a>8.1 可调用对象</h2><p>在c++中有四种可调用对象的定义</p><p>1.是一个函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print;      <span class="comment">// 定义函数指针，指向刚定义的函数</span></span><br></pre></td></tr></table></figure><p>2.是一个具有operator()成员函数的类对象(仿函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">&quot;lxxlxxlxx&quot;</span>);          <span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.是一个可被转换为函数指针的类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里返回的必须是静态的成员函数，因为静态的是属于类，非静态的属于对象，在还没有定义对象之前，非静态的成员函数是不存在的，而静态成员函数是存在的。</span></span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.是一个类成员函数指针或者类成员指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using func_ptr = void(*)(int, string);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number is: &quot;</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-可调用对象包装器"><a href="#8-2-可调用对象包装器" class="headerlink" title="8.2 可调用对象包装器"></a>8.2 可调用对象包装器</h2><p>可调用对象的包装器是<code>std::function</code>。它是一个类模板，可以容纳除了类(非静态)成员(函数)指针之外的所有可调用对象。使用<code>std::function</code>，必须包含头文件<code>functional</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;          <span class="comment">//打包之后的名字是f1，包装的函数是add</span></span><br><span class="line">    <span class="comment">// 绑定一个类的静态函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;      <span class="comment">//包装的函数需要指明具体的类和函数名</span></span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num, string name)</span> </span>&#123;             <span class="comment">//普通函数</span></span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> funcptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);          <span class="comment">//声明了一个函数指针别名，返回值是void，参数是int和string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;仿函数：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">world</span><span class="params">(<span class="type">int</span> a, string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数参数是一个包装器对象(可以给构造函数传入相同类型的可调用对象，然后通过可调用对象包装器进行打包，保存在了callback里面)</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>(<span class="type">int</span>, string)&gt;&amp; f) :<span class="built_in">callback</span>(f) &#123;&#125;</span><br><span class="line"><span class="comment">//相当于回调操作，通过函数指针就可以进行回调(传入一个函数指针的地址给另一个函数，在另一个函数里面就可以调用该指针，执行对应的函数体)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">int</span> id, string name)</span> </span>&#123;</span><br><span class="line"><span class="built_in">callback</span>(id, name);       <span class="comment">//调用通过构造函数得到的函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, string)&gt;callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">A <span class="title">aa</span><span class="params">(print)</span></span>;                 <span class="comment">//传入一种可调用对象</span></span><br><span class="line">aa.<span class="built_in">notify</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">ab</span><span class="params">(Test::world)</span></span>;           <span class="comment">//传入一种可调用对象</span></span><br><span class="line">ab.<span class="built_in">notify</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在编写程序的时候要用到多种类型的可调用对象，那么就可以通过可调用对象包装器对它们进行打包。因为只要给参数指定为可调用对象包装器类型，只要传进任意一种可调用对象类型(参数和返回值要求是相同类型)，它都会进行隐式的类型转换。通过可调用对象的包装器把这些不同类型的可调用对象封装成一种类型，这样程序就显得更加简洁和灵活。</p><h2 id="8-3-绑定器"><a href="#8-3-绑定器" class="headerlink" title="8.3 绑定器"></a>8.3 绑定器</h2><p><code>std::bind</code>用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用绑定器绑定可调用对象和参数，并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();            <span class="comment">//绑定了普通函数output，指定了2个参数，()表示调用了该仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">3</span>);     <span class="comment">//第一个参数指定了占位符，是后面()中的3</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">9</span>);     <span class="comment">//第二个参数指定了占位符，是后面()中的9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);   //占位符_2会去找()里面的第二个实参，会出问题，应该是_1</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//这种情况是参数1会用2，而不是会用10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可调用对象包装器<code>std::function</code>是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器<code>std::bind</code>的配合之后，就可以完美的解决这个问题了。</p><p>在下面程序中，使用绑定器函数bind()绑定了某一个可调用对象，最终得到一个仿函数f或f1，其实这个仿函数对应的还是绑定的那个可调用对象(参数1)，绑定的时候可以给它指定固定的参数(参数2和参数3)，固定的参数可以是一个变量也可以是一个常量。如果绑定的时候不给它指定一个固定的数值，可以指定占位符，当指定占位符后，它就需要从仿函数调用时候的参数列表里面去读对应的数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定器和包装器结合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&amp; f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">f</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\t x+y=&quot;</span> &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当绑定后，就得到一个仿函数f了 ---&gt; 也是可调用对象的一种</span></span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">bind</span>(output_add, i+<span class="number">100</span>, i+<span class="number">200</span>);     <span class="comment">//参2和参3已经指定了函数output_add的具体参数</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f);                             <span class="comment">//这里的i和i参数不会影响output_add的参数了</span></span><br><span class="line">        <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output_add, placeholders::_1, placeholders::_2);   <span class="comment">//参2和参3已经指定的是占位符</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f1);                            <span class="comment">//这里的i和i参数会影响output_add的参数了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=100    y=200   x+y=300</span><br><span class="line">x=0      y=0     x+y=0</span><br><span class="line">x=102    y=202   x+y=304</span><br><span class="line">x=2      y=2     x+y=4</span><br><span class="line">x=104    y=204   x+y=308</span><br><span class="line">x=4      y=4     x+y=8</span><br><span class="line">x=106    y=206   x+y=312</span><br><span class="line">x=6      y=6     x+y=12</span><br><span class="line">x=108    y=208   x+y=316</span><br><span class="line">x=8      y=8     x+y=16</span><br></pre></td></tr></table></figure><p>下面程序是对类的成员函数以及类的成员变进行绑定和封装。因为可调用包装器<code>std::function</code>不能对类成员函数和变量进行包装，但可以对仿函数进行包装，所以可以先通过绑定器bind来对类成员函数和变量进行绑定，然后可以得到对应的一个仿函数。这样包装器就可以间接的对其进行包装了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员函数绑定</span></span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);   <span class="comment">//&amp;t是output所属对象的地址，得到一个仿函数f2</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f22 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);    <span class="comment">//用包装器对可调用对象f2进行包装(间接包装)</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">1314</span>);       <span class="comment">//通过绑定，将一个二元函数变成一元函数</span></span><br><span class="line"><span class="comment">//成员变量绑定(因为成员变量没有参数，所以bind就没有参3和参4)</span></span><br><span class="line"><span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);  <span class="comment">//f3是一个仿函数，而下面的f33是一个将仿函数进行包装的包装器类型</span></span><br><span class="line">function&lt;<span class="type">int</span>&amp; (<span class="type">void</span>)&gt;f33 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t); <span class="comment">//如果要f33是可读可写，就使用取地址符&amp;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;        <span class="comment">//大于f3的值，它代表的是绑定的变量</span></span><br><span class="line"><span class="built_in">f3</span>() = <span class="number">666</span>;                  <span class="comment">//修改成员变量的值</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中，f3和f33的类型是不一样的，绑定器bind绑定完后得到的是一个仿函数，而f33它是把仿函数进行了包装，得到一个包装器类型，所以这两个不是等价的。需要了解的是，f33这一行是做了隐式的类型转换，f3这一行是做了自动的类型推导。</p><h1 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9. lambda表达式"></a>9. lambda表达式</h1><p><code>lambda</code>表达式的捕获列表可以捕获一定范围内的变量，具体如下：</p><ul><li>[]                     不捕抓任何变量</li><li>[&amp;]                  捕获外部作用域所有的变量，并作为引用在函数体内使用(按引用捕获)</li><li>[&#x3D;]                   捕获外部作用域所有的变量，并作为副本在函数体内使用(按值捕获) —&gt;拷贝的副本在匿名函数体内部是只读的</li><li>[&#x3D;,&amp;foo]         按值捕获外部作用域中的所有变量，并按引用捕获外部变量foo</li><li>[bar]                按值捕获bar变量，同时不捕获其他变量</li><li>[&amp;bar]             按引用捕获bar变量，同时不捕获其他变量</li><li>[this]               捕获当前类中的this指针</li></ul><p><code>lambda</code>表达式的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">[=, &amp;x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line"><span class="type">int</span> c = a;      <span class="comment">//拷贝得来的</span></span><br><span class="line"><span class="type">int</span> d = x;      <span class="comment">//引用得来的</span></span><br><span class="line">b++;            <span class="comment">//如果没有加上mutable，则只能读外部变量</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;();       <span class="comment">//不加()只是被定义，而没有被调用(如果上面()里面有参数，则这里也要相应的加上参数)</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;    <span class="comment">//lambda内部修改了值但不影响外面，因为是拷贝进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于通过值拷贝的方式捕获的外部变量是只读的原因：</p><ol><li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</li><li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li></ol><p>所以<code>mutable</code>选项的作用就在于取消operator()的const属性。</p><p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//1.当[]里面为空时，该匿名函数可以看成是一个函数指针</span></span><br><span class="line">    ptr p1 = [](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">p1</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*2.当[]里面有捕获外部变量时，该匿名函数不能看成是一个函数指针，它是一个仿函数</span></span><br><span class="line"><span class="comment">    ptr p2 = [=](int x)&#123;                //这里是有问题的，一个函数指针指的是仿函数</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    p2(9) */</span></span><br><span class="line">    <span class="comment">//3.用包装器包装lambda表达式(直接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff = [=](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fff</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//4.用绑定器绑定lambda表达式(通过绑定器间接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff1 = <span class="built_in">bind</span>([=](<span class="type">int</span> x)&#123;     <span class="comment">//返回的是一个仿函数，包装到包装器对象里面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;,placeholders::_1);</span><br><span class="line">    <span class="built_in">fff1</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-右值引用"><a href="#10-右值引用" class="headerlink" title="10. 右值引用"></a>10. 右值引用</h1><p>在C++11中增加了一个新的类型，即右值引用，标记为 &amp;&amp;。</p><ul><li><p><code>左值</code>是指存储在内存中、有明确存储地址(可取地址)的数据</p></li><li><p><code>右值</code>是指可以提供数据值的数据(不可取地址)</p></li></ul><p>区别方法：可以对表达式取地址(&amp;)就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//左值</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//左值引用</span></span><br><span class="line"><span class="type">int</span>&amp; a = num;           <span class="comment">//a不占用额外的内存地址，它是num的别名</span></span><br><span class="line"><span class="comment">//右值</span></span><br><span class="line"><span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; b = <span class="number">8</span>;            <span class="comment">//必须是使用右值来初始化，左值不行</span></span><br><span class="line"><span class="comment">//常量右值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; d = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//常量左值引用可以通过同类型的左值、同类型的右值引用、同类型的常量右值引用、同类型的常量右值引用都可以初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; c = num;     <span class="comment">//c只能是num的别名，因为它是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; f = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; g = d;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; h = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const int&amp;&amp; e = b;       //错误，常量的右值引用不能通过右值引用来初始化</span></span><br><span class="line"><span class="comment">//int&amp;&amp; f = b;             //错误。普通的右值引用也不能通过右值引用来初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面程序可以得出结论：右值引用只能通过右值来初始化；常量的左值引用是一个万能的引用类型，可以通过同类型的各种引用来初始化左值引用。</p><p>在下面程序中，是通过右值引用来模拟浅拷贝。移动构造(右值引用)是把临时对象的指针成员移动走了，临时对象析构的时候析构了一个空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造(作用是防止浅拷贝)</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数 -&gt; 复用其它对象中的资源(堆内存) ---&gt; 移动构造就是要使用浅拷贝</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num) &#123;                 <span class="comment">//让新对象的m_num指向了a里面的m_num(浅拷贝)</span></span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;         <span class="comment">//令a的m_num指向空，这样a析构的时候，释放的就是空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class .....&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结论：如果给某一个类指定了移动构造函数，在赋值的时候就有两种方式了，即直接赋值和通过右值引用的方式赋值(不管是哪种方式，要求右边的对象是临时对象)</span></span><br><span class="line">    Test t = <span class="built_in">getObj</span>();          <span class="comment">//只打印1次地址(默认构造时打印)</span></span><br><span class="line">    Test&amp;&amp; t1 = <span class="built_in">getObj</span>();       <span class="comment">//打印的1次地址(默认构造时打印)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;t1.m_num &lt;&lt; endl;     <span class="comment">//地址不变，与上面t1打印的地址一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用不带参数的构造函数和移动构造都可以实现浅拷贝，区别在于：不带参的构造函数使用浅拷贝，指针资源不会转移，是两个对象的指针指向同一块内存，析构就会出问题。而使用移动构造是实实在在的对资源进行了转移，转移完了之后，原来这个对象就不拥有这块资源了。</p><p>在上面程序中，<code>getObj()</code>函数里面创建了一个临时的<code>Test</code>对象并返回它。由于<code>t</code>是一个左值(即它有一个持久的名字)，编译器会调用<code>Test</code>类的拷贝构造函数来创建<code>t</code>。而t1是一个右值引用，因此，编译器会调用<code>Test</code>类的移动构造函数来创建<code>t1</code>。</p><p>右值可以分为两种：一个是将亡值，另一个是纯右值。</p><ul><li>纯右值：非引用返回的临时变量，运算表达式产生的临时变量、原始字面量和lambda表达式等。</li><li>将亡值：与右值引用相关的表达式，如T&amp;&amp;类型函数的返回值、std::move的返回值等。</li></ul><h2 id="10-1-的特性"><a href="#10-1-的特性" class="headerlink" title="10.1 &amp;&amp;的特性"></a>10.1 &amp;&amp;的特性</h2><p>在C++中，并不是所有情况下<code>&amp;&amp;</code>都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为<code>T&amp;&amp;</code>，如果是自动类型推导需要指定为<code>auto &amp;&amp;</code>，在这两种场景下<code>&amp;&amp;</code>被称作未定的引用类型。另外还有一点需要额外注意<code>const T&amp;&amp;</code>表示一个右值引用，不是未定引用类型(是不需要推导的)。</p><p>在C++11中引用折叠的规则如下：</p><ul><li><p>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型</p></li><li><p>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</p></li></ul><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">//这种是需要根据传进来的参数进行推导的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;        <span class="comment">//这种是不需要根据传进来的参数进行推导，就一定为右值引用类型</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);                           <span class="comment">//传入10(右值)，推导出为右值引用类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);                            <span class="comment">//传入x(左值)，推导出为左值引用类型</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">10</span>);                          <span class="comment">// 不需要推导，就为右值引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;                          <span class="comment">//x和y都为左值</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;                                  <span class="comment">//推导出v1为左值引用类型</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;                                <span class="comment">//推导出v2为右值引用类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;  <span class="comment">//可以得出decltype(x)为int，那么就为int&amp;&amp;，是int型的右值引用(不需要推导)，给它赋了一个左值，该语法是错误的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子3</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;                         <span class="comment">//a1为右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;                       <span class="comment">//因为a1本身是一个左值，得到bb是一个int型的左值引用(int&amp; bb)</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;                       <span class="comment">//bb1是一个右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;                           <span class="comment">//a2是左值</span></span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;                         <span class="comment">//a3是左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;                       <span class="comment">//cc是一个左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;                      <span class="comment">//cc1是左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;                  <span class="comment">//s1是常量左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;                 <span class="comment">//s2是常量的右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;                       <span class="comment">//dd是常量的左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;                       <span class="comment">//ee是常量的左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;                   <span class="comment">//常量的右值引用</span></span><br></pre></td></tr></table></figure><p>还有一种情况需要注意，例如在下面程序中，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span>                       <span class="comment">//参数在左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span>                      <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span>                        <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传进来右值后，k为右值引用，但如果对它进行传递，那么它就是左值引用(k为它的名字)</span></span><br><span class="line">    <span class="built_in">printValue</span>(k);                           <span class="comment">//用右值引用进行传递，会被看成是左值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;                     <span class="comment">//i是左值</span></span><br><span class="line">    <span class="built_in">printValue</span>(i);                   <span class="comment">//调用的是左值引用的函数</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);                <span class="comment">//调用的是右值引用的函数</span></span><br><span class="line">    forward(<span class="number">250</span>);                    <span class="comment">//传入参数右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">l-value: 520</span></span><br><span class="line"><span class="section">r-value: 1314</span></span><br><span class="line"><span class="section">l-value: 250</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</li><li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li><li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型(上面有例子)。</li><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</li></ul><h1 id="11-转移和完美转发"><a href="#11-转移和完美转发" class="headerlink" title="11. 转移和完美转发"></a>11. 转移和完美转发</h1><h2 id="11-1-move方法"><a href="#11-1-move方法" class="headerlink" title="11.1 move方法"></a>11.1 move方法</h2><p>std::move可以给右值引用进行初始化，把一些左值转换为右值；还有就是可以进行资源的转移，如果某一个对象后面不再被使用了，并且需要拷贝这个对象里面的数据到另一个对象中，这种情况下就可以进行资源转移，减少拷贝的次数，提高析构的允许效果。</p><p>程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//move作用1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;                   <span class="comment">//左值</span></span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// 通过左值对右值引用进行初始化是错误的，会报错</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// 通过move，将左值转换为右值，再对右值引用进行初始化，是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move作用2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">move</span>(a);           <span class="comment">//a失效了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-forward方法"><a href="#11-2-forward方法" class="headerlink" title="11.2 forward方法"></a>11.2 forward方法</h2><p>std::forward()函数实现的功能称之为完美转发。因为当一个<code>右值引用</code>作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，就可以使用forward()方法。</p><blockquote><p>std::forward<T>(t);</T></p><p>当T为左值引用类型时，t将被转换为T类型的左值<br>当T不是左值引用类型时，t将被转换为T类型的右值</p></blockquote><p>测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对于<span class="built_in">testForward</span>(<span class="number">520</span>);            <span class="comment">//传入的是右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对于<span class="built_in">testForward</span>(num);            <span class="comment">//传入的是左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));   <span class="comment">//因为int不是左值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));   <span class="comment">//因为int&amp;是左值引用类型，参数就被转换为左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));     <span class="comment">//因为int是右值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="12-智能指针"><a href="#12-智能指针" class="headerlink" title="12. 智能指针"></a>12. 智能指针</h1><p>智能指针能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。它的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。它的头文件是<code>#include &lt;memory&gt;</code>。</p><p>C++11中提供了如下三种智能指针：</p><ol><li>std::shared_ptr：共享的智能指针</li><li>std::unique_ptr：独占的智能指针</li><li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ol><h2 id="12-1-共享智能指针"><a href="#12-1-共享智能指针" class="headerlink" title="12.1 共享智能指针"></a>12.1 共享智能指针</h2><p>共享智能指针shared_ptr 是一个模板类，它可以让多个智能指针同时管理同一块有效的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;       <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;      <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;                    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;           <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;             <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;                     <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为2</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                   <span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;         <span class="comment">//调用移动构造函数(ptr1失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);    <span class="comment">//调用移动构造函数(ptr2失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过reset方法，它既可以初始化，也可以重置：对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存(通过make_shared来初始化智能指针)</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);        <span class="comment">//引用计数为1了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;                         <span class="comment">//引用计数为2了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                         <span class="comment">//引用计数为3了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;                         <span class="comment">//引用计数为4了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();       <span class="comment">//重置指针ptr4，原来指向的内存引用计数-1，现在ptr4没有指向任何内存，所以引用计数为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化和使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">m_num = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过构造函数初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过移动构造和拷贝函数初始化</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//移动资源了，ptr1失效了，引用计数为0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr3 = ptr2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3 use_count:&quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line"><span class="comment">//通过std::make_shared初始化</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line">shared_ptr&lt;Test&gt;ptr5 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">8</span>);                  <span class="comment">//通过int型构造类对象</span></span><br><span class="line">shared_ptr&lt;Test&gt;ptr6 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;hello, world&quot;</span>);     <span class="comment">//通过字符串构造类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过reset初始化</span></span><br><span class="line">ptr6.<span class="built_in">reset</span>();                 <span class="comment">//指针重置，现在ptr6引用计数为0，字符串构成的类对象调用析构函数(没有指针指向它)，</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr6 use_count:&quot;</span> &lt;&lt; ptr6.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//引用计数为0</span></span><br><span class="line">ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>));                                <span class="comment">//原来ptr5指向的对象会调用析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr5 use_count:&quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//初始化指针了，引用计数为1，指向完main，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过智能指针对象取出原始地址，基于原始地址调用函数</span></span><br><span class="line">Test* t = ptr5.<span class="built_in">get</span>();         <span class="comment">//这里是通过智能指针对象调用它所对应的类，该类是shared_ptr类里面提供的标准api，所以是加.</span></span><br><span class="line">t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">t-&gt;<span class="built_in">print</span>();</span><br><span class="line"><span class="comment">//通过智能指针对象直接操作</span></span><br><span class="line">ptr5-&gt;<span class="built_in">setValue</span>(<span class="number">999</span>);      <span class="comment">//这时通过智能指针对象去调用它管理的内存对应的类里面的api函数，就按照指针的方式使用对象，所以加-&gt;</span></span><br><span class="line">ptr5-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定删除器：当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。当然我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为<code>删除器</code>，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">m_num = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">pp</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">39</span>),[](Test* t)&#123;   <span class="comment">//在这里，不手动添加删除器也可以，系统会调用默认的删除器</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//释放内存的操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> t;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt; p1(new Test[5]);     //这样会报错，因为只构造5个对象了，但没有析构对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;     <span class="comment">//这样不会报错</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], [](Test* t) &#123;      <span class="comment">//正确</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">delete</span>[] t;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">    <span class="comment">//调用c++提供的默认删除器函数</span></span><br><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], default_delete&lt;Test[]&gt;())</span></span>;   <span class="comment">//这样也正确，默认删除器要指出删除的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：shared_ptr在通过指针对象去管理一块数组内存的时候，必须手动添加删除器，如果不是数组，智能指针默认提供的删除器就会删除这块内存。</p><h2 id="12-2-独占智能指针"><a href="#12-2-独占智能指针" class="headerlink" title="12.2 独占智能指针"></a>12.2 独占智能指针</h2><p><code>std::unique_ptr</code>是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个<code>unique_ptr</code>赋值给另一个<code>unique_ptr</code>。</p><p>初始化和使用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">9</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过移动构造函数初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);       <span class="comment">//ptr1失效了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过reset初始化</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">8</span>));                  <span class="comment">//ptr2原来指向的内存被析构了，重新指向了新的内存块</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 ---&gt; 和共享智能指针一样</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    Test* pt = ptr3.<span class="built_in">get</span>();                <span class="comment">//获取原始指针(普通指针)</span></span><br><span class="line">    pt-&gt;<span class="built_in">setValue</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    ptr3-&gt;<span class="built_in">setValue</span>(<span class="number">9</span>);                    <span class="comment">//直接使用指针调用指向的内存块里面的api</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除器：<code>unique_ptr</code>指定删除器和<code>shared_ptr</code>指定删除器是有区别的，<code>unique_ptr</code>指定删除器的时候需要确定删除器的类型，所以它不能像<code>shared_ptr</code>那样直接指定删除器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;  <span class="comment">// 正确的，不需要指定删除器类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;  <span class="comment">// 错误的，没有指定删除器的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//情况1：删除器的[]里面为空，则对应的lambda是函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);             <span class="comment">//定义一个函数指针类型</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;   <span class="comment">//需要在前面指定删除器类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//情况2：删除器的[]里面添加了=，则对应的lambda是仿函数类型，就需要通过可调用对象包装器对其类型进行包装，</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [=](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;        <span class="comment">//这种写法会报错</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);    <span class="comment">//正确的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//独占的智能指针可以管理数组类型的地址，能够自动释放</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//这是正确的</span></span><br><span class="line">    <span class="comment">//在c++11中shared_ptr不支持下面的写法，c++11之后才支持的</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//现在这是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆：对于lambda表达式，[]里面为空，则对应的lambda表达式为函数指针类型；否则为仿函数类型。</p><h2 id="12-3-弱引用智能指针"><a href="#12-3-弱引用智能指针" class="headerlink" title="12.3 弱引用智能指针"></a>12.3 弱引用智能指针</h2><p><code>std::weak_ptr</code>可以看做是<code>shared_ptr</code>的助手，它不管理<code>shared_ptr</code>内部的指针。<code>weak_ptr</code>没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在。</p><p>初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;                <span class="comment">//wp1没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;           <span class="comment">//wp2也没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;            <span class="comment">//wp3是被实例化了</span></span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;                        <span class="comment">//直接通过赋值的方式来初始化(实例化)</span></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;                       <span class="comment">//实例化了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他常用方法：</p><ul><li>通过调用<code>weak_ptr</code>类提供的<code>use_count()</code>方法可以获得当前所观测资源的引用计数。</li><li>通过调用<code>weak_ptr</code>类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，如果观察的资源的引用计数为0了，返回的就是true，否则返回false。</li><li>通过调用<code>weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的<code>shared_ptr</code>对象。</li><li>通过调用<code>weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源。</li></ul><p>演示程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);            <span class="comment">//给sp1管理了一块int类型的内存</span></span><br><span class="line">    wp = sp1;                                    <span class="comment">//初始化了wp，它可以观察sp1管理的内存了</span></span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();                             <span class="comment">//通过wp.lock()返回的共享指针的实例，初始化了sp2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//现在就有2个共享指针指向那块内存了，打印为2</span></span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();                                 <span class="comment">//sp1不管理该内存了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;       <span class="comment">//现在只有sp2管理该内存块，打印1</span></span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();   <span class="comment">//因为wp检测了那块内存还没有被释放，所以还可以返回对应的共享指针对象，实例化sp1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//现在是sp1和sp2两个共享指针管理该内存，打印2</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-4-智能指针的注意事项"><a href="#12-4-智能指针的注意事项" class="headerlink" title="12.4 智能指针的注意事项"></a>12.4 智能指针的注意事项</h2><p><code>shared_ptr</code>使用的注意事项：</p><p>1.<code>不能使用一个原始地址初始化多个共享智能指针</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class Test is disstruct...&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这种情况会报错，因为析构了两次</span></span><br><span class="line">    Test* t = <span class="keyword">new</span> Test;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(t);</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt;ptr2(t);      //这种情况会报错，因为析构了两次</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1;    <span class="comment">//这种就正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>函数不能返回管理了this的共享智能指针对象</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);      <span class="comment">//返回一个共享指针对象，管理的是this,即外面new出来的一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();   <span class="comment">//因为里面的this指的是ptr1初始化时的new Test，所以本质上是犯了注意事项1的问题，会报错</span></span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中使用同一个指针this构造了两个智能指针对象ptr1和ptr2，这二者之间是没有任何关系的，因为ptr2并不是通过ptr1初始化得到的实例对象。在离开作用域之后this将被构造的两个智能指针各自析构，导致重复析构的错误。</p><p>这个问题可以通过一个模板类叫做<code>std::enable_shared_from_this&lt;T&gt;</code>来解决，这个类中有一个方法叫做<code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，在该函数的底层就是使用<code>weak_ptr</code>来监测this对象，并通过调用<code>weak_ptr</code>的<code>lock()</code>方法返回一个<code>shared_ptr</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : enable_shared_from_this&lt;Test&gt;&#123;        <span class="comment">//把当前的类型指定在模板类型里面</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();       <span class="comment">//底层是通过弱引用类型对象返回一个share_ptr对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//weak_ptr初始化的地方：在ptr1初始化时，new出了一块内存Test让ptr1来管理，而Test类继承了enable_shared_from_this，那么其里面的weak_ptr被实例化了，指向了ptr1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>共享智能指针不能循环引用</code></p><h1 id="13-POD类型"><a href="#13-POD类型" class="headerlink" title="13. POD类型"></a>13. POD类型</h1><p>POD指的就是普通的旧数据 。它通常用于说明一个类型的属性，尤其是用户自定义类型的属性。</p><p>在C++11中将 POD划分为两个基本概念的合集，即∶<code>平凡的(trivial)</code> 和<code>标准布局的(standard layout)</code>。</p><p>## 13 .1 平凡类型</p><p>一个平凡的类或者结构体应该符合以下几点要求：</p><ol><li>拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor)。</li><li>拥有平凡的拷贝构造函数(trivial copy constructor)和移动构造函数(trivial move constructor)。</li><li>拥有平凡的拷贝赋值运算符(trivial assignment operator)和移动赋值运算符(trivial move operator)。</li><li>不包含虚函数以及虚基类。</li></ol><h2 id="13-2-非受限联合体"><a href="#13-2-非受限联合体" class="headerlink" title="13.2 非受限联合体"></a>13.2 非受限联合体</h2><p>在C++11之前我们使用的联合体是有局限性的，主要有以下三点：</p><ul><li>不允许联合体拥有非POD类型的成员</li><li>不允许联合体拥有静态成员</li><li>不允许联合体拥有引用类型的成员</li></ul><p>在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，规定任何<code>非引用类型</code>都可以成为联合体的数据成员，这样的联合体称之为非受限联合体(Unrestricted Union)。</p><h2 id="13-3-非受限联合体中静态成员的使用"><a href="#13-3-非受限联合体中静态成员的使用" class="headerlink" title="13.3 非受限联合体中静态成员的使用"></a>13.3 非受限联合体中静态成员的使用</h2><p>补充知识：</p><ul><li>如果在联合体里面出现了静态成员变量，那么它的初始化要放到联合体的外面(类和结构体也一样的)</li><li>静态成员是属于类的，而不是属于对象(类和结构体也一样的)</li><li>在联合体里面的静态成员和非静态成员使用的不是同一块内存(类和结构体也一样的)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//不允许出现静态成员(成员变量、成员函数)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t1.num1 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num  value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;        <span class="comment">//结果为3 ---&gt;外部初始化的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num1 value: &quot;</span> &lt;&lt; t1.num1 &lt;&lt; endl;              <span class="comment">//结果为100</span></span><br><span class="line"></span><br><span class="line">    Test t2;</span><br><span class="line">    t2.num = <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t2.num &lt;&lt; endl;   <span class="comment">//结果为50</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;   <span class="comment">//结果为50，静态成员被对象t2修改，t1和t2的静态成员是同一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-4-非受限联合体中非POD类型成员的使用"><a href="#13-4-非受限联合体中非POD类型成员的使用" class="headerlink" title="13.4 非受限联合体中非POD类型成员的使用"></a>13.4 非受限联合体中非POD类型成员的使用</h2><p>在c++11里面规定，如果在非受限联合体中使用了非POD里面的成员，编译器就会自动的删除这个联合体的构造函数和析构函数</p><p>placement new：一般情况下，使用new申请空间时，是从系统的堆(heap)中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做<code>placement new</code>即定位放置 new。</p><p>使用定位放置new申请内存空间：<code>ClassName* ptr = new (定位的内存地址)ClassName;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;         <span class="comment">//将该类定义为非TOB类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>() &#123;&#125;        <span class="comment">//不加这个就是TOB类型的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="built_in">Student</span>() &#123;      <span class="comment">//手动创建一个构造函数</span></span><br><span class="line">        <span class="keyword">new</span> (&amp;name)string;         <span class="comment">//选择一块占用空间最大的变量来定义联合体的内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Teacher t;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s.name = <span class="string">&quot;lxx&quot;</span>;</span><br><span class="line">    s.t.<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);         <span class="comment">//占用的都是同一块空间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.name=&quot;</span> &lt;&lt; s.name &lt;&lt; endl;      <span class="comment">//打印的是hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-5-标准布局的"><a href="#13-5-标准布局的" class="headerlink" title="13.5 标准布局的"></a>13.5 标准布局的</h2><p>标准布局类型主要主要指的是类或者结构体的结构或者组合方式。</p><p>标准布局类型的类应该符合以下五点定义，最重要的为前两条：</p><p>1.所有非静态成员有相同 的访问权限(public，private，protected)</p><ul><li>类成员拥有不同的访问权限(非标准布局类型)</li><li>类成员拥有相同的访问权限(标准布局类型)</li></ul><p>2.在类或者结构体继承时，满足以下两种情况之一∶ </p><ul><li>派生类中有非静态成员，基类中包含静态成员(或基类没有变量)。</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span>: <span class="keyword">public</span> Base&#123; <span class="type">int</span> b;&#125;;          <span class="comment">// POD类型，既是平凡类型，也是标准布局类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123; <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child1</span>: <span class="keyword">public</span> Base1&#123; <span class="type">static</span> <span class="type">int</span> c;&#125;; <span class="comment">// POD类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child2</span>:<span class="keyword">public</span> Base, <span class="keyword">public</span> Base1 &#123; <span class="type">static</span> <span class="type">int</span> d;); <span class="comment">// POD类型，子类和基类没有同时出现非静态成员变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child3</span>:<span class="keyword">public</span> Base1&#123; <span class="type">int</span> d;&#125;;         <span class="comment">// 不满足条件，子类和基类同时出现了非静态成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child4</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Child     <span class="comment">// 不满足条件。继承的多个基类中，有多个基类有非静态成员</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结论：非静态成员只要同时出现在派生类和基类间，即不属于标准布局。对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。</p><p>3.子类中第一个非静态成员的类型与其基类不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span>: <span class="keyword">public</span> Base&#123; </span><br><span class="line">    Base p;       <span class="comment">//Base p放到这里不是POD类型，如果放到int b之后，就是POD类型</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.没有虚函数和虚基类</p><p>5.所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义</p><h2 id="14-扩展的-friend-语法"><a href="#14-扩展的-friend-语法" class="headerlink" title="14. 扩展的 friend 语法"></a>14. 扩展的 friend 语法</h2><p>friend关键字用于声明类的友元，友元可以无视类中成员的属性(public、protected 或是 private)，友元类或友元函数都可以访问，这样虽然完全破坏了面向对象编程中封装性的概念。但有的时候friend关键字确实会让程序少写很多代码。</p><h2 id="14-1-语法改进"><a href="#14-1-语法改进" class="headerlink" title="14.1 语法改进"></a>14.1 语法改进</h2><p>声明一个类为另外一个类的友元时，不再需要使用class关键字，并且还可以使用类的别名(使用 typedef 或者 using 定义)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span>;                   <span class="comment">//先申明有该类</span></span><br><span class="line"><span class="keyword">using</span> Honey = Tom;           <span class="comment">//定义一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jack</span> &#123;</span><br><span class="line">    <span class="comment">//friend class Tom;           //c++98标准</span></span><br><span class="line">    <span class="keyword">friend</span> Tom;                   <span class="comment">//c++11标准</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lucy</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> Honey;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; j.name &lt;&lt; endl &lt;&lt; l.name &lt;&lt; endl;</span><br><span class="line">        j.<span class="built_in">print</span>();</span><br><span class="line">        l.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Jack j;</span><br><span class="line">    Lucy l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tom t;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-命名空间this-thread"><a href="#14-命名空间this-thread" class="headerlink" title="14. 命名空间this_thread"></a>14. 命名空间this_thread</h1><p><code>std::this_thread</code>是关于线程的命名空间，在这个命名空间中提供了四个公共的成员函数，通过这些成员函数就可以对当前线程进行相关的操作了。</p><h2 id="14-1-get-id"><a href="#14-1-get-id" class="headerlink" title="14. 1 get_id()"></a>14. 1 get_id()</h2><p>std::this_thread中的get_id()方法可以得到当前线程的线程ID。测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;     <span class="comment">//得到当前线程的线程ID(子线程)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;     <span class="comment">//得到当前线程的线程ID(主线程)</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;           <span class="comment">//指定的函数func()会在子线程中执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-2-sleep-for"><a href="#14-2-sleep-for" class="headerlink" title="14.2 sleep_for()"></a>14.2 sleep_for()</h2><p>与进程一样，线程被创建后也有五种状态：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code>。</p><p>众所周知的，在计算机中启动的多个线程都需要占用CPU资源，但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。为了能够实现并发处理，多个线程都是<code>分时复用</code>CPU时间片，快速的交替处理各个线程中的任务。因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行(因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况)。</p><p>而sleep_for()是用于让线程休眠的函数，调用这个函数的线程会马上从<code>运行态</code>变成<code>阻塞态</code>并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。这个函数的参数需要指定一个休眠时长，是一个时间段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));       <span class="comment">//休息1s</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：程序休眠完成之后，会从<code>阻塞态</code>重新变成<code>就绪态</code>，<code>就绪态</code>的线程需要再次争抢CPU时间片，抢到之后才会变成<code>运行态</code>，这时候程序才会继续向下运行。</p><h2 id="14-3-sleep-until"><a href="#14-3-sleep-until" class="headerlink" title="14.3 sleep_until()"></a>14.3 sleep_until()</h2><p><code>sleep_until()</code>也是一个休眠函数，它是指定线程阻塞到某一个指定的时间点(time_point类型)，之后解除阻塞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();         <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">        <span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;                         <span class="comment">// 时间间隔为2s</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_until</span>(now + sec);            <span class="comment">// 在当前时间点之后休眠两秒</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-4-yield"><a href="#14-4-yield" class="headerlink" title="14.4 yield()"></a>14.4 yield()</h2><p>当线程中调用这个函数<code>yield()</code>之后，如果它正处于运行态，那么它会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。需要注意的是，线程调用了<code>yield()</code>之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>yield() 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降</li><li>yield() 是让当前线程主动放弃了当前自己抢到的CPU资源，但是在下一轮还会继续抢</li></ul><h1 id="15-线程类"><a href="#15-线程类" class="headerlink" title="15. 线程类"></a>15. 线程类</h1><blockquote><p>可执行文件的运行过程：如果在磁盘上有一个可执行的文件a.exe(占用的是硬盘资源)，双击该文件，就可以得到一个应用程序(占用内存和cpu资源)，将该应用程序称为进程。这个进程在物理内存里面占一块虚拟地址空间，相对于应用程序来说只能算一个中转站，是我们把程序启动起来之后，程序里面所有的数据被加载到这块虚拟地址空间里面，然后通过cpu里面的MMU(cpu里面的内存管理单元)，它会把虚拟地址空间里面的数据映射到物理内存的另外一个位置。</p></blockquote><p>每一个启动起来的进程都对应一块虚拟空间，其由两部分组成，一部分是内核区，一部分是用户区。如果是多进程，每个进程都对应一个虚拟地址空间。比如说进程1创建了一个新的进程2，在操作系统里面就会额外的再次分配一个虚拟地址空间。每个进程都对应一个虚拟地址空间。如果是线程的话，不会创建额外的虚拟地址空间，即多个线程是共用同一个虚拟地址空间的。</p><p>虚拟内存空间是虚拟的，一个进程存储的数据都是存储在虚拟内存映射的那块物理内存中，作用就是保护数据，确保进程之间的隔离，提高系统的安全性和稳定性，其中磁盘作为辅助。具体来说，当进程访问虚拟地址时，操作系统会将这些地址映射到实际的物理内存地址中，物理内存满了的话，就会将物理内存的一些不常用的数据存到磁盘，从而空出多余的内存空间。我们通过代码打印出来的地址都是物理内存里面分配的虚拟空间地址。</p><p>虚拟内存地址到物理内存地址的映射是通过分页或分段等机制来实现的，当通过虚拟地址空间写入数据时，如果对应的虚拟页在物理内存中，则直接在物理内存中进行修改。如果物理内存满了，操作系统会将不常用的页面换出到磁盘，确保有足够的内存用于当前的写入操作。</p><h2 id="15-1-线程初始化"><a href="#15-1-线程初始化" class="headerlink" title="15.1 线程初始化"></a>15.1 线程初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是子线程，叫做lxx...&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是子线程，叫做&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;,age:&quot;</span> &lt;&lt; age &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//1.创建空的线程对象</span></span><br><span class="line">    thread t1;</span><br><span class="line">    <span class="comment">//2.创建一个可用的子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="comment">//3.创建一个带参数的可用子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(func1, <span class="string">&quot;罗罗诺亚&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="comment">//4.创建一个匿名函数的子线程(带一个参数)</span></span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">([=](<span class="type">int</span> id) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;arg id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">//5.通过移动构造的方式创建子线程</span></span><br><span class="line">    thread t5 = <span class="built_in">move</span>(t4);</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-2-常用的成员函数"><a href="#15-2-常用的成员函数" class="headerlink" title="15.2 常用的成员函数"></a>15.2 常用的成员函数</h2><p>1.<code>get_id()</code>：每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的。通过该函数可用获取线程的ID。</p><p>2.<code>join()</code>：调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p><p>3.<code>detach()</code>：因为在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。</p><p>4.<code>joinable()</code>：该函数用于判断主线程和子线程是否处于关联(连接)状态，一般情况下，二者之间的关系处于关联状态，会返回一个true，否则返回一个false。</p><p>5.<code>thread::hardware_concurrency()</code>：用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程。</p><h2 id="15-3-类的成员函数作为子线程的任务函数"><a href="#15-3-类的成员函数作为子线程的任务函数" class="headerlink" title="15.3 类的成员函数作为子线程的任务函数"></a>15.3 类的成员函数作为子线程的任务函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMsg</span><span class="params">(string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我的名字是：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;,今年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是罗罗诺亚!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello，欢迎来到新世界!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;                <span class="comment">//普通函数作为任务函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递静态成员函数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::message)</span></span>;      <span class="comment">//只需要指明静态函数属于的类，传入其地址即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递非静态成员函数</span></span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(&amp;Base::showMsg, b, <span class="string">&quot;卡卡罗特&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="comment">//thread t3(&amp;Base::showMsg, &amp;b, &quot;卡卡罗特&quot;, 23);        //也可用区b的地址</span></span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(bind(&amp;Base::showMsg, b, <span class="string">&quot;卡卡罗特&quot;</span>, <span class="number">23</span>))</span></span>;    <span class="comment">//通过仿函数传入，b也可用取地址</span></span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br><span class="line">t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-call-once"><a href="#16-call-once" class="headerlink" title="16. call_once"></a>16. call_once</h1><p>在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次，就可以使用<code>std::call_once()</code>来保证函数在多线程环境下只能被调用一次。特别注意的是，在使用<code>call_once()</code>的时候，需要一个<code>once_flag</code>作为<code>call_once()</code>的传入参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">once_flag g_flag;                  <span class="comment">//定义一个全局的once_flag变量，保证所有的线程都能访问到它</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> age, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">call_once</span>(g_flag, do_once, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);     <span class="comment">//call_once的do_once()函数只会被调用1次</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something() function num = &quot;</span> &lt;&lt; num++ &lt;&lt; endl;    <span class="comment">//每个线程都会调用这个多次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;ace&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;sabo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(do_something, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">name: luffy, age: 19</span></span><br><span class="line">do_something() function num = 1</span><br><span class="line">do_something() function num = 2</span><br><span class="line">do_something() function num = 3</span><br></pre></td></tr></table></figure><p>应用：实现单例模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个单例模式的类 ---&gt; 懒汉模式</span></span><br><span class="line">once_flag g_flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="type">const</span> Base&amp; obj) = <span class="keyword">delete</span>;                 <span class="comment">//拷贝构造显示的删除(也可用设为私有)</span></span><br><span class="line">Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; obj) = <span class="keyword">delete</span>;      <span class="comment">//拷贝赋值显示的删除</span></span><br><span class="line"><span class="comment">//获取单例类的对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> Base* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                    <span class="comment">//静态函数能够访问的成员只能是静态成员</span></span><br><span class="line"><span class="comment">//被call_once管理的这个匿名函数所对应的处理动作只会被调用1次</span></span><br><span class="line"><span class="built_in">call_once</span>(g_flag, [&amp;]() &#123;</span><br><span class="line">obj = <span class="keyword">new</span> Base;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;实例对象被创建.....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;&#125;;</span><br><span class="line"><span class="type">static</span> Base* obj;                            <span class="comment">//将单例对象设为静态的</span></span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line">Base* Base::obj = <span class="literal">nullptr</span>;                <span class="comment">//静态成员的初始化要放到外面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">Base::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">setName</span>(name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;my name is: &quot;</span> &lt;&lt; Base::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(myFunc, <span class="string">&quot;路飞&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(myFunc, <span class="string">&quot;艾斯&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(myFunc, <span class="string">&quot;萨博&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(myFunc, <span class="string">&quot;索隆&quot;</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br><span class="line">t4.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-C-线程同步之互斥锁"><a href="#17-C-线程同步之互斥锁" class="headerlink" title="17. C++线程同步之互斥锁"></a>17. C++线程同步之互斥锁</h1><p>解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，也可以称为互斥量，其头文件是<code>#include &lt;mutex&gt;</code>，在C++11中一共提供了四种互斥锁：</p><ul><li><code>std::mutex</code>：独占的互斥锁，不能递归使用</li><li><code>std::timed_mutex</code>：带超时的独占互斥锁，不能递归使用</li><li><code>std::recursive_mutex</code>：递归互斥锁，不带超时功能</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ul><h2 id="17-1-std-mutex"><a href="#17-1-std-mutex" class="headerlink" title="17.1 std::mutex"></a>17.1 std::mutex</h2><p>成员函数：</p><p>1.<code>lock()</code>：函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用。</p><p>2.<code>try_lock()</code>：获取互斥锁的所有权并对互斥锁加锁，它与lock()区别在于try_lock()不会阻塞线程，lock()会阻塞线程。</p><ul><li>如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true</li><li>如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false</li></ul><p>3.<code>unlock()</code>：给锁定的互斥锁解锁，只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。</p><blockquote><p> 线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问效率降低了，但是保证了数据的正确性。</p></blockquote><p>特别需要注意的是：当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行++操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">++number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));             <span class="comment">//休眠0.5s</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行--操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">--number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number = <span class="number">999</span>;</span><br><span class="line">mutex mx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::decrement, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-2-std-lock-guard"><a href="#17-2-std-lock-guard" class="headerlink" title="17.2 std::lock_guard"></a>17.2 std::lock_guard</h2><p><code>lock_guard</code>在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记<code>unlock()</code>操作而导致线程死锁。<code>lock_guard</code>使用了<code>RAII</code>技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行--操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mx)</span></span>;     <span class="comment">//创建了一个guard对象    </span></span><br><span class="line">                --number;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">            &#125;                                    <span class="comment">//声明周期结束，自动析构，解锁</span></span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-3-std-recursive-mutex"><a href="#17-3-std-recursive-mutex" class="headerlink" title="17.3 std::recursive_mutex"></a>17.3 std::recursive_mutex</h2><p>递归互斥锁<code>std::recursive_mutex</code>允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">++number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));             <span class="comment">//休眠0.5s</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;recursive_mutex&gt;<span class="built_in">lock_guard</span>(mx);   <span class="comment">//使用递归互斥锁(如果使用的不是递归互斥锁，该程序会报错)</span></span><br><span class="line"><span class="built_in">increment</span>(<span class="number">2</span>);</span><br><span class="line">--number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number = <span class="number">999</span>;</span><br><span class="line">recursive_mutex mx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::decrement, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-4-std-timed-mutex"><a href="#17-4-std-timed-mutex" class="headerlink" title="17.4 std::timed_mutex"></a>17.4 std::timed_mutex</h2><p><code>std::timed_mutex</code>是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。</p><h1 id="18-原子变量atomic"><a href="#18-原子变量atomic" class="headerlink" title="18. 原子变量atomic"></a>18. 原子变量atomic</h1><p>C++11提供了一个原子类型<code>std::atomic&lt;T&gt;</code>，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定<code>bool</code>、<code>char</code>、<code>int</code>、<code>long</code>、<code>指针</code>等类型作为模板参数。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="type">int</span> n, string s) : <span class="built_in">age</span>(n), <span class="built_in">name</span>(s) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">atomic&lt;<span class="type">char</span>&gt;<span class="built_in">c</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="function">atomic_char <span class="title">cc</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;       <span class="comment">//效果与上面这种写法一样</span></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"><span class="built_in">atomic_init</span>(&amp;b, <span class="number">9</span>);       <span class="comment">//对b进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">cc = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">b.<span class="built_in">store</span>(<span class="number">88</span>);</span><br><span class="line"><span class="type">char</span> ccc = c.<span class="built_in">exchange</span>(<span class="string">&#x27;e&#x27;</span>);         <span class="comment">//c现在存储的是e,exchange返回原来存的内容a,即ccc是a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function">Base <span class="title">base</span><span class="params">(<span class="number">123</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">atomic&lt;Base*&gt;<span class="built_in">atc_base</span>(&amp;base);        <span class="comment">//原子类型的模板类可以是指针类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c value: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ccc value: &quot;</span> &lt;&lt; ccc &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b value: &quot;</span> &lt;&lt; b.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">Base* tmp = atc_base.<span class="built_in">load</span>();        <span class="comment">//取出地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; tmp-&gt;name &lt;&lt; <span class="string">&quot;,age: &quot;</span> &lt;&lt; tmp-&gt;age &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>局限性：使用原子变量的时候，它不能够保护复合类型，比如说<code>atomic&lt;Base*&gt; base</code>，现在base里面存储的就是Base类的指针，Base原子变量里面现在不能保护base这块指针指向的内存块里面的数据安全，它只能保护这个指针做算术运算时的线程安全，即将地址做移动时安全。</p></blockquote><p>原子变量处理线程同步：使用原子变量或互斥量对公共资源进行处理，可以达到数据同步的效果，即以下程序最后可以刚好将number加到200，否则，可能小于200。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">number++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++ increment thread id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;,number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">number++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*** increment1 thread id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;,number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">atomic_int number = <span class="number">0</span>;       <span class="comment">//把一个整形数放到原子变量的类对象里面</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::increment1, &amp;b)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-原始自变量&quot;&gt;&lt;a href=&quot;#1-原始自变量&quot; class=&quot;headerlink&quot; title=&quot;1. 原始自变量&quot;&gt;&lt;/a&gt;1. 原始自变量&lt;/h1&gt;&lt;p&gt;定义原始字符串的方式为：R “xxx(原始字符串)xxx”，其中()两边的字符串可以省略(不省略</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>八股文2</title>
    <link href="https://lxx93.online/2024/08/23/%E5%85%AB%E8%82%A1%E6%96%872/"/>
    <id>https://lxx93.online/2024/08/23/%E5%85%AB%E8%82%A1%E6%96%872/</id>
    <published>2024-08-23T05:51:10.000Z</published>
    <updated>2025-06-04T03:26:25.762Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1.基本知识"></a>1.基本知识</h5><ul><li><p><code>sizeof</code> ：是C&#x2F;C++中的操作符，用来计算一个类型&#x2F;对象的所占用的内存大小(字节数)，包括最后的<code>\0</code></p></li><li><p><code>sizeof</code> 和 <code>strlen</code> 的区别：<code>strlen</code>是一个 C 标准库中的函数，用于计算以空字符 <code>\0</code> 结尾的字符串的实际长度(不包括结尾的空字符)</p></li><li><p><code>char array[]</code>数组作为函数参数时会退化为指针，大小要按指针的计算。这时sizeof()会返回指针的大小；strlen()还是返回字符串实际长度</p></li><li><p><code>volatile</code>：是 C 语言中的一个关键字，用于修饰变量，表示该变量的值可能在任何时候被外部因素更改，例如硬件设备、操作系统或其他线程。当一个变量被声明为<code>volatile</code>时，编译器会禁止对该变量进行优化，以确保每次访问变量时都会从内存中读取其值，而不是从寄存器或缓存中读取。避免因为编译器优化而导致出现不符合预期的结果</p></li><li><p><code>字节对齐</code>有助于提高内存访问速度，因为许多处理器都优化了对齐数据的访问。但是，这可能会导致内存中的一些空间浪费</p></li><li><p><code>字节序</code>是指在多字节数据类型(如整数、浮点数等)中，字节在内存中的存储顺序。主要有两种字节序：</p><ul><li>大端字节序(网络字节序)：高位字节存储在低地址处，低位字节存储在高地址处。大端字节序是符合人类阅读习惯的顺序</li><li>小端字节序：低位字节存储在低地址处，高位字节存储在高地址处。</li><li>判断系统的字节序：将一个整数num初始化为1，然后将其指针类型<code>int*</code>转化为<code>char*</code>，这样就可以访问该整数的第一个字节。如果系统是小端字节序，那么第一个字节是1；如果系统是大端字节序，那么第一个字节是0。</li></ul></li><li><p>typedef 是一种类型定义关键字，用于为现有类型创建新的名称。在编译阶段处理的，有严格的类型检查</p></li><li><p><code>mutable</code>是C++中的一个关键字，用于修饰类的成员变量，表示该成员变量即使在一个<code>const</code>成员函数中也可以被修改</p><ul><li>在C++中，如果一个成员函数被声明为<code>const</code>，那么它不能修改类的任何成员变量，除非这个成员变量被声明为<code>mutable</code></li></ul></li></ul><h5 id="2-宏定义和内联函数的区别与使用场景"><a href="#2-宏定义和内联函数的区别与使用场景" class="headerlink" title="2. 宏定义和内联函数的区别与使用场景"></a>2. 宏定义和内联函数的区别与使用场景</h5><ul><li>宏定义和内联函数都是为了减少函数调用开销和提高代码运行效率而引入的机制，但是它们的实现方式和作用机制略有不同。</li><li>宏定义用于在编译时替换宏定义中的代码，也就是 define 实际上只是做文本的替换。无类型检查、不能进行调试</li><li>内联函数用于在调用该函数的位置，直接替换函数体代码。有类型检查、可以进行调试</li></ul><h5 id="3-extern的作用"><a href="#3-extern的作用" class="headerlink" title="3. extern的作用"></a>3. extern的作用</h5><ul><li>可以在不同文件间共享变量数据。如果在某个文件中要使用其它文件里定义的全局变量时，可以使用关键字extern来声明</li><li>使用<code>extern C</code>表示以c语言的规则来编译c++程序</li></ul><h5 id="4-C-中四种强制类型转换"><a href="#4-C-中四种强制类型转换" class="headerlink" title="4. C++中四种强制类型转换"></a>4. C++中四种强制类型转换</h5><ul><li>static_cast <new_type> ()：其实 static_cast和 C 语言 () 做强制类型转换基本是等价的</new_type></li><li>dynamic_cast <new_type> ()：dynamic_cast在C++中主要应用于父子类层次结构中的安全类型转换</new_type></li><li>const_cast <new_type> ()：new_type 必须是一个指针、引用或者指向对象类型成员的指针。可以删除一个const变量中const属性</new_type></li><li>reinterpret_cast：</li></ul><h5 id="5-类对象的初始化顺序"><a href="#5-类对象的初始化顺序" class="headerlink" title="5. 类对象的初始化顺序"></a>5. 类对象的初始化顺序</h5><p>遵循以下规则顺序</p><ul><li><p>基类初始化顺序：如果当前类继承自一个或多个基类，它们将按照声明顺序进行初始化，但是在有虚继承和一般继承存在的情况下，优先虚继承。(先初始化的类，就先调用它的构造函数)</p></li><li><p>成员变量初始化顺序：类的成员变量按照它们在类定义中的声明顺序进行初始化</p></li><li><p>在基类和成员变量初始化完成后，执行类的构造函数。</p></li></ul><h5 id="6-析构函数可以抛出异常吗"><a href="#6-析构函数可以抛出异常吗" class="headerlink" title="6. 析构函数可以抛出异常吗"></a>6. 析构函数可以抛出异常吗</h5><ul><li>析构函数中不应该抛出异常<ul><li>如果一个对象在异常处理过程中被销毁，而它的析构函数又抛出了一个新的异常，此时有两个异常同时存在，就导致程序调用 terminate()，直接崩溃</li><li>在容器析构时，会逐个调用容器中的对象析构函数，而某个对象析构时抛出异常还会引起后续的对象无法被析构，导致资源泄漏</li></ul></li></ul><h5 id="7-浅拷贝和深拷贝"><a href="#7-浅拷贝和深拷贝" class="headerlink" title="7. 浅拷贝和深拷贝"></a>7. 浅拷贝和深拷贝</h5><ul><li><p>浅拷贝：它只是简单地将原对象所有成员变量的值复制给新对象，对于指针成员，两个对象中的指针指向同一块内存空间</p><ul><li>析构时会出现重复释放内存的问题</li></ul></li><li><p>深拷贝：它不仅将原对象所有成员变量的值复制给新对象，对于指针成员，它会分配新的内存空间，并将指针成员数据复制到新空间中</p></li></ul><h5 id="8-多态的实现方式"><a href="#8-多态的实现方式" class="headerlink" title="8. 多态的实现方式"></a>8. 多态的实现方式</h5><ul><li>C++实现多态的方法主要包括虚函数、纯虚函数和模板函数。其中<code>虚函数</code>、<code>纯虚函数</code>实现的多态叫<code>动态多态</code>；<code>模板函数</code>、<code>重载</code>等实现的叫<code>静态多态</code>。</li><li>区分<code>静态多态</code>和<code>动态多态</code>的一个方法就是看决定所调用的具体方法是在编译期还是运行时，运行时就叫<code>动态多态</code>。</li></ul><p><code>虚函数</code>和<code>纯虚函数</code>都可以用来实现多态，但它们适用于不同的场景：虚函数适合于为派生类提供默认行为的情况，而纯虚函数则更适合于定义接口，要求子类必须重写父类纯虚函数，除非也为抽象类</p><ul><li><p>模板函数可以根据传递参数的不同类型，自动生成相应类型的函数代码。模板函数可以用来实现多态。这种是在编译期就能确定下来的叫<code>静态多态</code></p></li><li><p>重载指的是在同一个作用域内定义多个同名但参数列表不同的函数，和模板函数一样，在编译期间就能确定调用具体版本的函数了</p></li><li><p>实现动态多态必须要满足条件： 1.基类指针或引用指向子类对象 2.子类必须重写父类的虚函数</p></li></ul><h5 id="9-纯虚函数"><a href="#9-纯虚函数" class="headerlink" title="9. 纯虚函数"></a>9. 纯虚函数</h5><ul><li>纯虚函数是一种在基类中声明但没有实现的虚函数。它的作用就是定义了一种接口，这个接口需要由派生类来实现</li><li>包含纯虚函数的类称为抽象类，抽象类无法实例化，仅仅提供了一些接口</li></ul><h5 id="10-为什么默认的析构函数不是虚函数"><a href="#10-为什么默认的析构函数不是虚函数" class="headerlink" title="10. 为什么默认的析构函数不是虚函数"></a>10. 为什么默认的析构函数不是虚函数</h5><ul><li>虚函数不同于普通成员函数，当类中有虚成员函数时，类会自动进行一些额外工作，比如说生成虚函数表和虚表指针。对于不使用多态的情况下，这些额外工作所带来的开销是没有必要的</li></ul><h5 id="11-函数参数传递常见的方式"><a href="#11-函数参数传递常见的方式" class="headerlink" title="11. 函数参数传递常见的方式"></a>11. 函数参数传递常见的方式</h5><ul><li>值传递是将实参的值传递给形参。在这种情况下，函数内对形参的修改不会影响到实参</li><li>引用传递是将实参的引用传递给形参。在这种情况下，函数内对形参的修改会影响到实参</li></ul><h5 id="12-使用智能指针的注意事项"><a href="#12-使用智能指针的注意事项" class="headerlink" title="12. 使用智能指针的注意事项"></a>12. 使用智能指针的注意事项</h5><ul><li>不能使用原始指针(地址)创建多个共享智能指针，这样会产生多个独立的引用计数，从而析构多次<ul><li>解决方法：1.使用 <code>make_shared</code>；2.使用已有 <code>shared_ptr</code> 进行拷贝；</li></ul></li><li>不能循环引用，即两个或多个<code>shared_ptr</code>互相引用，导致引用计数永远无法降为零，从而无法释放内存<ul><li>解决方法：weak_ptr，weak_ptr 是一种不控制对象生命周期的智能指针，它只观察对象，而不增加强引用计数。这可以避免循环引用导致的内存泄漏问题</li></ul></li></ul><h5 id="13-为什么用-Redis-作为-MySQL-的缓存"><a href="#13-为什么用-Redis-作为-MySQL-的缓存" class="headerlink" title="13. 为什么用 Redis 作为 MySQL 的缓存"></a>13. 为什么用 Redis 作为 MySQL 的缓存</h5><ul><li>主要是因为Redis具备<code>高性能</code>和<code>高并发</code>两种特性<ul><li>Redis 具备高性能，因为其数据主要存储在内存中，而 MySQL 的数据主要存储在磁盘上。当用户首次访问 MySQL 中的数据时，如果数据不在缓冲池中，就需要从磁盘读取，相对比较慢。此时可以将这部分数据缓存到 Redis 中。下次访问相同数据时，应用可以直接从 Redis 读取，由于 Redis 操作的是内存，因此响应速度非常快。</li><li>Redis具备高并发处理能力，由于其基于内存操作和高效的 I&#x2F;O 多路复用机制，能够承受的请求量远高于 MySQL。因此，在实际应用中，通常会将数据库中的热点数据缓存到 Redis 中，使得用户的部分请求可以直接从缓存中获取数据，而不必每次都访问数据库，从而提升系统性能并降低数据库负载</li></ul></li></ul><h5 id="14-介绍redis"><a href="#14-介绍redis" class="headerlink" title="14. 介绍redis"></a>14. 介绍redis</h5><ul><li>Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>。Redis 提供了丰富的数据类型，常见的有五种数据类型：String(字符串)，Hash(哈希)，List(列表)，Set(集合)、Zset(有序集合)。</li></ul><h5 id="15-Qt中connect-第5个参数的作用"><a href="#15-Qt中connect-第5个参数的作用" class="headerlink" title="15. Qt中connect()第5个参数的作用"></a>15. Qt中connect()第5个参数的作用</h5><p>该参数就是 连接类型，它决定了当信号被发射时，槽函数是如何被调用的。特别是在跨线程通信时，它的作用非常重要</p><ul><li>AutoConnection：默认值。根据接收者所在的线程自动选择使用。当接收者和发送者在同一个线程，则使用DirectConnection类型。如果接收者和发送者不在一个线程，则使用QueuedConnection类型</li><li>DirectConnection：这种情况是接收者和发送者在同一个线程，槽函数会在信号发送的时候直接被调用，槽函数是在发送信号的线程中执行的。emit语句后面的代码将在与信号关联的所有槽函数执行完毕后才被执行</li><li>QueuedConnection：当信号被发射时，不会立即调用槽函数，而是将这个调用请求放入接收对象所在线程的 事件队列中，等到该线程的事件循环运行时再执行。emit语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕</li><li>BlockingQueuedConnection：类似于QueuedConnection，但发送方线程会被阻塞，直到槽函数执行完毕。仅在不同线程之间使用时有效，否则会引发死锁。在多线程间需要同步的场合可能需要这个</li><li>UniqueConnection：它不能单独使用，必须与其他连接类型按位或组合使用。当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是为了避免重复连接</li></ul><h5 id="16-QObject的作用"><a href="#16-QObject的作用" class="headerlink" title="16. QObject的作用"></a>16. QObject的作用</h5><ul><li>支持信号与槽机制</li><li>支持对象树管理</li><li>支持元对象系统</li><li>支持事件处理机制</li></ul><h5 id="17-map容器的key如果是一个结构体的话，要怎么设计"><a href="#17-map容器的key如果是一个结构体的话，要怎么设计" class="headerlink" title="17. map容器的key如果是一个结构体的话，要怎么设计"></a>17. map容器的key如果是一个结构体的话，要怎么设计</h5><p>如果想要使用一个结构体作为 map 的键(key)，需要确保这个结构体支持比较操作，因为 <code>std::map</code> 需要通过某种方式来对键进行排序以维护其内部的红黑树结构。常用的方法如下：</p><ul><li>重载比较运算符 <code>operator&lt;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> field1;</span><br><span class="line">    <span class="type">double</span> field2;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyStruct&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (field1 != other.field1)</span><br><span class="line">            <span class="keyword">return</span> field1 &lt; other.field1;</span><br><span class="line">        <span class="keyword">return</span> field2 &lt; other.field2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::map&lt;MyStruct, <span class="type">int</span>&gt; myMap;</span><br></pre></td></tr></table></figure><ul><li>提供自定义比较函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> field1;</span><br><span class="line">    <span class="type">double</span> field2;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStructCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyStruct&amp; lhs, <span class="type">const</span> MyStruct&amp; rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lhs.field1 != rhs.field1)</span><br><span class="line">            <span class="keyword">return</span> lhs.field1 &lt; rhs.field1;</span><br><span class="line">        <span class="keyword">return</span> lhs.field2 &lt; rhs.field2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::map&lt;MyStruct, <span class="type">int</span>, MyStructCompare&gt; myMap;</span><br></pre></td></tr></table></figure><ul><li>使用c++11引入的 <code>std::tuple</code> 或者 <code>std::tie</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> field1;</span><br><span class="line">    <span class="type">double</span> field2;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyStruct&amp; lhs, <span class="type">const</span> MyStruct&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(lhs.field1, lhs.field2) &lt; std::<span class="built_in">tie</span>(rhs.field1, rhs.field2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::map&lt;MyStruct, <span class="type">int</span>&gt; myMap;</span><br></pre></td></tr></table></figure><h5 id="18-Redis是单线程吗"><a href="#18-Redis是单线程吗" class="headerlink" title="18. Redis是单线程吗"></a>18. Redis是单线程吗</h5><ul><li>Redis单线程指的是<code>接收客户端请求</code>-&gt;<code>解析请求</code> -&gt;<code>进行数据读写等操作</code>-&gt;<code>发送数据给客户端</code>这个过程是由一个线程(主线程)来完成的，这也是我们常说 Redis 是单线程的原因。</li><li>但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动一些后台线程的</li></ul><h5 id="19-redis是单线程处理请求，效率会不会慢"><a href="#19-redis是单线程处理请求，效率会不会慢" class="headerlink" title="19. redis是单线程处理请求，效率会不会慢"></a>19. redis是单线程处理请求，效率会不会慢</h5><ul><li>不慢，因为它的设计非常高效，几乎没有任何阻塞操作。<ul><li>redis的数据主要存储在内存的，那么Redis 的大部分操作都在内存中完成，读写速度快</li><li>redis的单线程避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，也不需要考虑同步问题(不需要加锁)</li></ul></li></ul><h5 id="20-Redis-如何实现数据不丢失"><a href="#20-Redis-如何实现数据不丢失" class="headerlink" title="20. Redis 如何实现数据不丢失"></a>20. Redis 如何实现数据不丢失</h5><ul><li><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据</p></li><li><p>Redis共有三种数据持久化的方式：</p><ul><li>AOF 日志：Redis 在执行完一条写数据操作命令(删除和修改)后，就会把该命令以追加的方式写入到一个AOF文件里，然后 Redis 重启时，会读取该文件记录的命令，然后以逐一执行命令的方式来进行数据恢复</li><li>RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘(RDB文件)。因为AOF 文件记录的是命令，而RDB文件记录的是某一个瞬间内存的数据。所以恢复数据时，直接将 RDB 文件读入内存就可以</li><li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RDB 的优点</li></ul></li><li><p>RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以。不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据</p></li></ul><h5 id="21-AOF日志知识"><a href="#21-AOF日志知识" class="headerlink" title="21. AOF日志知识"></a>21. AOF日志知识</h5><ul><li><p>为什么先执行命令，再把数据写入AOF日志呢？</p><ul><li>好处：避免额外的检查开销(如果该命令有问题，Redis 在使用日志恢复数据时，就可能会出错)；不会阻塞当前写操作命令的执行</li><li>坏处：数据可能会丢失( 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险)</li></ul></li><li><p>Redis 写入 AOF 日志的过程</p><ul><li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区</li><li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据(命令)写入内核缓冲区 page cache，等待内核将数据写入硬盘</li><li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定，主要有如下3种策略：<ul><li>Always：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘</li><li>Everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li>No：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机。每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</li></ul></li></ul></li><li><p>AOF 日志过大，会触发什么机制</p><ul><li>AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会触发AOF 重写机制，来压缩 AOF 文件</li></ul></li><li><p>重写 AOF 日志的过程是怎样的</p><ul><li>重写 AOF 过程是由<code>后台子进程</code>来完成的</li><li>好处：子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程</li></ul></li></ul><h5 id="22-RDB快照知识"><a href="#22-RDB快照知识" class="headerlink" title="22. RDB快照知识"></a>22. RDB快照知识</h5><ul><li><p>Redis 提供了两个命令来生成 RDB 文件，分别是save和bgsave，他们的区别就在于是否在<code>主线程</code>里执行</p><ul><li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程</li><li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞；</li></ul></li><li><p>RDB 在执行快照的时候，数据能修改吗</p><ul><li>可以的，执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于写时复制技术</li></ul></li></ul><h5 id="23-为什么会有混合持久化"><a href="#23-为什么会有混合持久化" class="headerlink" title="23. 为什么会有混合持久化"></a>23. 为什么会有混合持久化</h5><ul><li><p>RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p></li><li><p>AOF 优点是丢失数据少，但是数据恢复不快</p></li><li><p>所以混合持久化既保证了 Redis 重启速度，又降低数据丢失风险</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-基本知识&quot;&gt;&lt;a href=&quot;#1-基本知识&quot; class=&quot;headerlink&quot; title=&quot;1.基本知识&quot;&gt;&lt;/a&gt;1.基本知识&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt; ：是C&amp;#x2F;C++中的操作符，用来计算一个类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文1</title>
    <link href="https://lxx93.online/2024/08/21/%E5%85%AB%E8%82%A1%E6%96%871/"/>
    <id>https://lxx93.online/2024/08/21/%E5%85%AB%E8%82%A1%E6%96%871/</id>
    <published>2024-08-21T05:51:10.000Z</published>
    <updated>2025-06-04T15:06:40.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-C-的三大特性"><a href="#0-C-的三大特性" class="headerlink" title="0. C++的三大特性"></a>0. C++的三大特性</h3><ul><li><strong>封装</strong>是指将数据和操作这些数据的方法绑定在一起作为一个单元(通常是一个类)，并通过访问修饰符(public、protected和private)来限制对这些成员的直接访问。封装的主要目的是保护对象的内容不被外部随意修改，从而提高安全性并减少错误的发生</li><li><strong>继承</strong>允许一个类(子类或派生类)继承另一个类(父类或基类)的属性和方法。这有助于代码重用，并能建立类之间的层次关系。<ul><li><strong>单继承与多重继承</strong>：C++支持单继承(一个子类继承自一个基类)和多重继承(一个子类同时继承多个基类)</li><li><strong>继承方式</strong>：包括公有继承(public)、保护继承(protected)和私有继承(private)，不同的继承方式会影响派生类对外部可见性的处理</li></ul></li><li><strong>多态</strong>指的是能够在运行时决定调用哪个函数的能力，即同一个函数接口可能对应多种实现形式。在C++中，多态主要通过虚函数实现<ul><li><strong>虚函数</strong>：在基类中声明为虚函数的成员函数可以在派生类中被重写，以提供特定的行为</li><li><strong>动态绑定</strong>：当使用基类指针或引用指向派生类对象时，如果调用了虚函数，则实际调用的是派生类中的版本，这种机制称为动态绑定或晚绑定</li></ul></li></ul><h3 id="1-malloc、free和new、delete的区别"><a href="#1-malloc、free和new、delete的区别" class="headerlink" title="1. malloc、free和new、delete的区别"></a>1. malloc、free和new、delete的区别</h3><p>背景：malloc、free是c语言的库函数；new、delete是c++中的操作符</p><ul><li><p>new会自动计算所需分配内存的大小；malloc需要手动计算(使用sizeof)</p></li><li><p>new返回的是对象类型的指针；malloc返回的是void*类型，需要进行强制类型转换</p></li><li><p>new分配失败会抛出异常；malloc分配失败返回的是NULL</p></li><li><p>new是在freestore上分配内存；malloc是在堆上分配</p><ul><li>new 和 malloc本质上都在堆上分配内存，freestore 是 C++ 标准对 <code>new/delete</code> 管理内存区域的术语</li><li>执行new时，会先在堆上申请到空间，再调用对象的构造函数；执行delete时，会先调用对象的析构函数(销毁对象，释放资源)，再释放之前申请的那块堆内存</li></ul></li><li><p>delete需要对象类型的指针(因为要调用对象的析构函数，所以需要是哪个对象)；free只需要void*类型的指针</p></li></ul><p>补：new和delete的一个过程：</p><ul><li>new：1.调用operator new函数；2.分配一块内存；3.运行相应的构造函数来构造对象，传入初值；4返回指向该对象(地址)的指针</li><li>delete：1.调用对象的析构函数；2.调用调用operator delete函数；3.释放内存空间</li></ul><h3 id="2-malloc是怎么分配内存空间的"><a href="#2-malloc是怎么分配内存空间的" class="headerlink" title="2. malloc是怎么分配内存空间的"></a>2. malloc是怎么分配内存空间的</h3><ul><li><p><code>malloc</code> 本质是调用了 系统的内存分配器（如 glibc 的 <code>ptmalloc</code>、<code>jemalloc</code>、<code>tcmalloc</code>）。</p></li><li><p>内存分配器会维护一个“空闲链表”或“内存池”，管理所有堆上的空闲&#x2F;已分配块。</p></li><li><p>如果堆不够大了，分配器可能调用系统调用（如 <code>sbrk()</code> 或 <code>mmap()</code>）向操作系统申请更多的虚拟内存</p></li></ul><p>注意：分配器为malloc()实际分配空间的大小会大于指定分配大小的字节数（因为需要额外存储元数据，比如块大小、是否空闲等）。</p><p>问题：malloc分配的是物理内存还是虚拟内存？</p><ul><li>malloc分配的是虚拟内存，在现代操作系统中(如 Linux、Windows)，每个进程都有<strong>独立的虚拟地址空间</strong>。<code>malloc</code> 只是从这个地址空间中“划出”一块区域，不涉及物理内存。实际的物理内存是在<strong>真正访问这块内存时</strong>(如读写它)才由操作系统通过“<strong>页表映射</strong>”机制分配的(也叫做<strong>按需分配、缺页中断</strong>)。</li></ul><p>问题：malloc 调用后是否立刻得到物理内存？</p><ul><li>malloc 返回的指针<strong>确实指向一块虚拟内存</strong>，但<strong>这块内存对应的物理页可能并没有立即分配</strong>，只有你第一次访问(如写入)它时，操作系统才通过<code>缺页中断</code>分配物理页，物理内存才被分配出来。</li></ul><p>如果分配的内存区域之前已经被分配并访问过(即已经触发了缺页中断，并且操作系统已经为其分配了物理页)，那么在这种情况下，新的 <code>malloc</code> 调用返回的指针指向的内存地址如果正好对应于之前已经分配了物理页的位置，那么该指针指向的内存将可以直接使用而无需等待物理内存的分配。</p><p>问题：free(p) 怎么知道该释放多大的空间？</p><ul><li>当调用malloc(size)的时候，内存分配器会分配多于size字节的空间，在返回的地址p前面，会有一个隐式头部，记录这块内存的大小和状态(是否空闲)，所以free(p)时，通过访问p前面的这段元数据来判断释放多少字节空间</li></ul><p>注意：malloc 和 free 是一对，free 只能释放 malloc 分配出来的内存，并且不能随便改指针！</p><p>问题：free 释放内存后，内存还在吗？</p><ul><li>内存还存在(不会清除内容)，只是标记为“空闲”了，如果继续使用这块内存，就会出现未定义的行为，可能报错、崩溃或写到其它正在用的内存</li></ul><h3 id="3-虚函数是怎么实现的？它存放在哪里？什么时候生成的？"><a href="#3-虚函数是怎么实现的？它存放在哪里？什么时候生成的？" class="headerlink" title="3. 虚函数是怎么实现的？它存放在哪里？什么时候生成的？"></a>3. 虚函数是怎么实现的？它存放在哪里？什么时候生成的？</h3><ul><li>虚函数是通过**虚函数表(vtable)<strong>和</strong>虚函数指针(vptr)**实现的。当某个类中有虚函数时，编译器会为该类生成一张虚函数表，其中存储着该类中所有虚函数的地址(虚函数表是一个由指针构成的数组)。在对象的内存布局中(在构造对象的过程中)，编译器会添加一个额外的指针，称为虚函数指针(虚表指针)，这个指针指向该对象<code>对应</code>的虚函数表，当某个类对象调用虚函数时，程序会先通过对象中的 <strong>vptr</strong> 找到对应的虚函数表，再从中查找实际要调用的函数地址，从而实现多态。</li><li>虚函数和普通函数一样存放在代码段，只是它的指针(地址)又存放在了虚表之中</li><li>虚函数是编译阶段生成的</li></ul><p>注意：1.虚函数表是一个全局的静态结构，存储在程序的数据段(.data)，是在程序加载时就已经构造好的；2.虚函数表是属于类的，不是属于对象的，所有该类的对象<strong>共享同一张虚函数表</strong>。</p><h3 id="4-虚拟地址空间分布结构"><a href="#4-虚拟地址空间分布结构" class="headerlink" title="4. 虚拟地址空间分布结构"></a>4. 虚拟地址空间分布结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----------高地址--------------</span><br><span class="line">栈区(向下增长)    : 函数的局部变量</span><br><span class="line">空洞区           : 栈和堆之间的保护区(防止溢出)</span><br><span class="line">堆区(向上增长)    : 程序运行时动态分配的内存(如malloc/new)</span><br><span class="line">bss段           : 未初始化的全局变量或静态变量</span><br><span class="line">数据段(.data)    : 初始化的全局变量或静态变量</span><br><span class="line">代码段(.text)    : 程序的机器指令，函数体(是只读的)</span><br><span class="line">-----------低地址--------------</span><br></pre></td></tr></table></figure><h3 id="5-智能指针的本质是什么，它们的实现原理是什么？"><a href="#5-智能指针的本质是什么，它们的实现原理是什么？" class="headerlink" title="5. 智能指针的本质是什么，它们的实现原理是什么？"></a>5. 智能指针的本质是什么，它们的实现原理是什么？</h3><ul><li>智能指针本质上是一个封装了原始 C++ 指针的类模板，目的是为了安全、自动地管理动态内存资源。它可以在对象生命周期结束时，依靠析构函数自动释放资源，从而有效防止内存泄漏和资源泄露。</li><li>常用的智能指针：<ul><li>独占智能指针：对资源独占所有权，即同一时间只能有一个unique_ptr指向资源对象。由于其独占性，unique_ptr不支持复制操作，但可以通过move进行转移</li><li>共享智能指针：对资源共享所有权，允许多个共享智能指针同时共享同一个对象，并通过引用计数来管理对象的生命周期</li><li>弱引用智能指针：是一种不控制所指向对象生命周期的智能指针，它不会增加共享智能指针的引用计数。主要作用是监视<code>shared_ptr</code>中管理资源的情况(辅助共享智能指针来使用的)</li></ul></li></ul><h3 id="6-匿名函数的本质是什么？它的优点是什么？"><a href="#6-匿名函数的本质是什么？它的优点是什么？" class="headerlink" title="6. 匿名函数的本质是什么？它的优点是什么？"></a>6. 匿名函数的本质是什么？它的优点是什么？</h3><ul><li><p>匿名函数<strong>本质</strong>上是一个没有名字的函数对象，在其定义的过程中会创建出一个栈对象，内部通过重载()符号来实现函数的调用。</p></li><li><p><strong>优点</strong>：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="comment">//编译器大致生成了类似的代码(编译器自动生成了一个未命名的类，比如 __Lambda)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__Lambda</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__Lambda f;    <span class="comment">//f 是该类的一个 局部对象</span></span><br></pre></td></tr></table></figure><h3 id="7-右值引用是什么，为什么要引入右值引用-作用-？"><a href="#7-右值引用是什么，为什么要引入右值引用-作用-？" class="headerlink" title="7. 右值引用是什么，为什么要引入右值引用(作用)？"></a>7. 右值引用是什么，为什么要引入右值引用(作用)？</h3><ul><li><p>左值：是指那些具有持久存储地址的表达式，并且可以使用地址运算符<code>&amp;</code>来获取其地址。</p></li><li><p>右值：是指那些没有明确内存地址的临时值或者是在表达式的求值过程中产生的临时结果。它们不能被取址</p></li><li><p>右值引用是用来操作“临时对象”的，它可以更高效地转移资源，而不是复制，从而提升程序性能。</p><ul><li>支持移动语义：节省资源，提升程序性能(对资源进行浅拷贝，而非昂贵的深拷贝，所有权的转移，而不是复制资源)</li><li>绑定临时对象：可以修改和复用临时变量</li><li>支持完美转发：模板中保留参数的原始特性(因为当一个<code>右值引用</code>作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，就可以使用forward()方法)</li></ul></li></ul><h3 id="8-左值引用和指针的区别？"><a href="#8-左值引用和指针的区别？" class="headerlink" title="8. 左值引用和指针的区别？"></a>8. 左值引用和指针的区别？</h3><ul><li>指针是一个变量，保存的是一个地址；引用是对被引用的对象取一个别名，不能单独存在(与被引用对象共享内存地址)</li><li>指针(除指针常量)可以被重新赋值，指向不同的变量；引用在初始化后不能更改，始终指向同一个变量</li><li>指针可以为 nullptr，表示不指向任何变量；引用必须绑定到一个变量，不能为 nullptr</li></ul><h3 id="9-指针是什么？"><a href="#9-指针是什么？" class="headerlink" title="9. 指针是什么？"></a>9. 指针是什么？</h3><ul><li>指针变量是用来<strong>保存其他变量地址</strong>的一种变量。因为计算机把数据按地址顺序存放在内存中，我们就可以通过指针来找到、访问或操作那些数据。简单来说，<strong>指针就是“指向某个变量”的变量</strong>。</li></ul><h3 id="10-weak-ptr占计数吗？在哪分配的空间？"><a href="#10-weak-ptr占计数吗？在哪分配的空间？" class="headerlink" title="10. weak_ptr占计数吗？在哪分配的空间？"></a>10. weak_ptr占计数吗？在哪分配的空间？</h3><ul><li>会增加弱引用计数，智能指针是一种用于自动管理动态内存资源的类模板，当创建一个<code>共享智能指针</code> 时，系统会在堆上分配一个控制块，用于记录<code>强引用计数</code>和<code>弱引用计数</code>，分别追踪 <code>共享智能指针</code> 和 <code>弱引用智能指针</code> 的数量。当 <code>use_count</code> 降为0 时，资源会被释放；当 <code>weak_count</code> 也为0时，控制块自身也会被销毁。</li></ul><p>注意：智能指针的创建方式会影响资源和控制块的内存分布</p><ul><li>使用 <code>std::make_shared&lt;T&gt;()</code> 会在堆上一次性分配一块连续的内存，同时包含资源对象和控制块，内存布局更紧凑、效率更高</li><li>使用 <code>shared_ptr&lt;T&gt;(new T)</code> 则会分别分配资源对象和控制块两块内存，两者分离，效率较低，并存在异常安全风险</li></ul><h3 id="11-malloc的内存分配的方式，有什么缺点？"><a href="#11-malloc的内存分配的方式，有什么缺点？" class="headerlink" title="11. malloc的内存分配的方式，有什么缺点？"></a>11. malloc的内存分配的方式，有什么缺点？</h3><p>使用malloc来分配内存的时候，首先会查看已有的内存池或空闲链表，寻找一个足够大的连续空闲块来满足请求。如果找到了合适的块，它可能会将这个块分割成两部分：一部分用于满足此次请求，另一部分则保持为空闲状态以供将来使用。但当请求的内存大于当前堆内存时，malloc需要向操作系统申请更多的内存，这通常是通过 sbrk 或 mmap 系统调用来完成的</p><ul><li><p>在使用malloc分配内存的时候会有两种方式向操作系统申请堆内存</p><ul><li>使用 <code>brk/sbrk</code>(小内存时使用)：将堆顶指针向高地址移动，获取内存空间。优点是简单快速，分配连续内存，效率高；缺点就是内存不能轻易归还给操作系统(即使调用了 free())，释放的内存通常被保留在 <code>malloc</code> 的内存池中以备复用</li><li>使用 <code>mmap</code>(大内存时使用)：直接在虚拟内存空间中映射一块新的虚拟地址区域，通过free()释放内存时，会把内存归还给操作系统，内存得到真正释放。</li></ul></li><li><p>缺点：1.只是分配了内存，不会调用构造函数；2.返回的是void*，容易发生类型错误或忘记转换；3.容易造成内存碎片(不同大小的内存反复分配和释放后，可能导致堆中出现大量不可用的碎片内存)—&gt;这是<code>堆上空间能够满足请求内存</code>的情况下产生</p></li></ul><p>注：malloc并不是系统调用，而是C库中的函数，用于动态内存分配</p><ul><li>外部碎片：指系统中有足够的总空闲内存，但这些内存是分散的、不连续的，导致无法用来满足特定大小的内存分配请求。</li><li>内部碎片：指的是已经被分配给某个进程或数据结构的内存块中未被使用的部分。换句话说，当一个内存块被分配给一个请求大小小于该块实际大小的任务时，剩余未使用的那部分内存就是内部碎片</li></ul><h3 id="12-为什么不全部使用mmap来分配内存"><a href="#12-为什么不全部使用mmap来分配内存" class="headerlink" title="12. 为什么不全部使用mmap来分配内存"></a>12. 为什么不全部使用mmap来分配内存</h3><ul><li>频繁系统调用：因为向操作系统申请内存的时候，是要通过系统调用的，执行系统调用要进入内核态，然后再回到用户态，状态的切换会耗费不少时间，所以申请内存的操作应该避免频繁的系统调用，如果都使用mmap来分配内存，等于每次都要执行系统调用(brk则没有那么频繁)。</li><li>频繁缺页中断：因为mmap分配的内存每次释放的时候都会归还给操作系统，于是每次mmap分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候就会触发缺页中断，从而降低程序的性能。</li></ul><p>注意：brk相比mmap会更少的触发缺页中断，因为 brk 是在虚拟地址空间中的堆区连续地扩展内存，操作系统有时会提前为堆区映射好物理页，所以第一次访问就不一定会触发缺页中断；而 mmap 每次分配都是新区域，通常采用按需分配策略，首次访问更容易导致缺页中断。</p><h3 id="13-为什么不全部都用brk"><a href="#13-为什么不全部都用brk" class="headerlink" title="13. 为什么不全部都用brk"></a>13. 为什么不全部都用brk</h3><ul><li><code>brk</code> 申请的堆内存只能<strong>线性向高地址扩展</strong>，不能向低地址缩回，就导致释放的中间内存不能被系统真正回收，如果频繁的调用malloc和free，容易产生越来越多不可用的内存碎片。</li></ul><h3 id="14-传入一个指针，它如何确定具体要清理多少空间呢？"><a href="#14-传入一个指针，它如何确定具体要清理多少空间呢？" class="headerlink" title="14. 传入一个指针，它如何确定具体要清理多少空间呢？"></a>14. 传入一个指针，它如何确定具体要清理多少空间呢？</h3><ul><li>malloc在申请内存的时候，内存分配器(如 glibc)通常会在用户请求的内存前面额外分配一段“元数据区域，里面保存了内存块的详细信息，<code>free</code> 就是靠这段信息知道要释放多大的空间。</li></ul><p>注意：<code>new/delete</code> 底层机制类似，但它还会自动调用构造和析构函数。</p><h3 id="15-宏定义define和常量定义const的区别是什么？"><a href="#15-宏定义define和常量定义const的区别是什么？" class="headerlink" title="15. 宏定义define和常量定义const的区别是什么？"></a>15. 宏定义define和常量定义const的区别是什么？</h3><ul><li><p>编译阶段：define是在预处理阶段进行文本替换；const是在编译阶段确定其值</p></li><li><p>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查，容易出错；const定义的常量是有具体类型的，是要在编译时进行类型判断的，更安全</p></li><li><p>调试：define定义的宏常量不能调试，因为在预处理阶段就已经进行替换了；const定义的常量是有地址和类型，可以进行调试的。</p></li><li><p>内存占用：define通常<strong>不占内存</strong>，仅是文本替换；const是一个变量，<strong>会占用内存</strong>（但可能优化）</p></li></ul><h3 id="16-程序运行的步骤是什么？"><a href="#16-程序运行的步骤是什么？" class="headerlink" title="16. 程序运行的步骤是什么？"></a>16. 程序运行的步骤是什么？</h3><ul><li><p>预处理：在这个阶段主要做了三件事：展开头文件、宏替换、去掉注释行。这个阶段需要调用预处理器来完成，最终得到的还是源文件(.i文件)</p></li><li><p>编译：逐行检查程序中出现的语法、词法错误和逻辑错误，并翻译成汇编指令，最终生成一个汇编文件(.s文件)</p></li><li><p>汇编：将汇编文件里面的汇编指令翻译成二进制的机器码，这个过程没有错误检查，只是机械的翻译工作，最终生成一个二进制文件（.o文件）</p></li><li><p>链接：将二进制文件链接库文件、数据段合并、地址回填，最终生成一个可执行的二进制文件</p></li></ul><h3 id="17-原子操作是什么？"><a href="#17-原子操作是什么？" class="headerlink" title="17. 原子操作是什么？"></a>17. 原子操作是什么？</h3><ul><li>指的是不可分割的操作，在执行过程中不会被线程调度机制中断。这意味着，一旦这个操作开始执行，它就会一直执行到完成，而不会被其他线程或进程的执行所打断。原子操作可以确保在多线程或多进程环境下对共享资源的安全访问，避免了竞态条件的发生。</li></ul><h3 id="18-class与struct的区别"><a href="#18-class与struct的区别" class="headerlink" title="18. class与struct的区别"></a>18. class与struct的区别</h3><ul><li>默认继承权限不同：class默认继承的是private继承，struct默认是public继承。</li><li>c++中的struct与c语言中的不一样，其它功能完全与class相同，都可以有成员函数、构造&#x2F;析构函数、继承、多态等</li><li>class 可以用于定义模板参数，struct 不能用于定义模板参数</li></ul><h3 id="19-内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？"><a href="#19-内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？" class="headerlink" title="19. 内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？"></a>19. 内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？</h3><ul><li><p>内存对齐是处理器为了提高处理性能而对存取数据的起始地址所提出的一种要求。</p></li><li><p>有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定的地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时将进行对齐，这就具有平台的移植性。CPU每次寻址有时需要消耗时间的，并且CPU访问内存的时候并不是逐个字节访问，而是以字长为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐内存，处理器需要做多次内存访问，而对齐的内存访问可以减少访问次数，提升性能。</p></li><li><p>优点分别是：增强程序的可移植性；提高程序的运行效率</p></li></ul><h3 id="20-进程之间的通信方式有哪些？"><a href="#20-进程之间的通信方式有哪些？" class="headerlink" title="20. 进程之间的通信方式有哪些？"></a>20. 进程之间的通信方式有哪些？</h3><p>进程之间通信的方式有很多，主要用于在不同进程之间<code>交换数据</code>、<code>传递消息</code>或<code>同步行为</code>。常见的 IPC 方式如下：</p><ul><li><p>管道：管道只能用于具有亲缘关系的进程间通信，管道本质上是内核中的一个缓存区，当进程创建管道后会返回两个文件描述符，一个写入端一个输出端</p></li><li><p>命名管道：支持任意进程间通信。是通过创建一个管道文件来完成的，需要写的进程以写的方式打开该文件，需要读的进程以读的方式打开该文件，最后通过返回的文件描述符来完成通信过程</p></li><li><p>存储映射mmap：创建一个指定文件，通过mmap()将该文件映射到存储区域，把互相要通信的进程打开同一个映射区域，这样这些进程就可以通过这个映射区域进行通信了</p></li><li><p>本地套接字：只能用于本机的两个进程通信。稳定性强，双向全双工，流程和网络套接字类似，但网络套接字绑定的是ip和端口，而本地套接字绑定的是一个文件，类似于管道</p></li></ul><h3 id="21-线程之间的通信方式有哪些？"><a href="#21-线程之间的通信方式有哪些？" class="headerlink" title="21. 线程之间的通信方式有哪些？"></a>21. 线程之间的通信方式有哪些？</h3><ul><li>互斥量：A线程加锁、访问资源，B线程必须等A释放后才能继续 → B线程“知道”A线程已经完成；</li><li>条件变量：A线程等待某个条件，B线程满足条件后通知A → B线程“告诉”A线程可以继续了；</li><li>信号量：控制线程的进入数量，也可以用作通知机制。</li><li>消息队列：一个线程将消息放入队列中，另一个线程从队列中取出并处理这些消息。这通常需要结合互斥锁和条件变量来保证线程安全</li><li>promise 和 future：一种用于在线程之间传递数据的方式。promise用于在某一线程中设置值，而与promise相关联的future则用于在另一线程中获取这个值</li><li>async 和 future：async会返回一个future对象，并启动一个异步任务函数，后面可以通过这个future对象来获取异步任务函数的结果，</li></ul><h3 id="22-介绍一下ARP协议"><a href="#22-介绍一下ARP协议" class="headerlink" title="22. 介绍一下ARP协议"></a>22. 介绍一下ARP协议</h3><ul><li><p>ARP是一种网络层协议，用于在已知ip地址情况下获取对应的mac地址。</p></li><li><p>流程：假如数据路径为客户端、默认网关(路由器)B、默认网关(路由器)C、服务端</p><ul><li>客户端A首先检查其自身的IP地址和子网掩码，判断目标IP地址是否与其处于同一子网。如果在同一个子网中，就可以根据目标IP广播一个ARP请求报文，服务器收到该ARP报文后就会回应一个ARP响应报文，并包含mac地址；如果不在同一个子网中，客户端就知道它不能直接发送数据给服务端，而是需要通过默认网关来进行转发，于是客户端就会查找路由表，路由表会根据目标IP来提供下一跳(路由器B)的IP地址，客户端就可以通过下一跳的IP地址来广播一个ARP请求报文，然后路由器B接收到后回应一个响应ARP请求，并带上mac地址。</li></ul></li><li><p>注意：</p><ul><li>路由器不会盲目地向所有邻居发送ARP请求，而是根据目标IP地址查找路由表，确定下一跳IP后，再根据改IP广播一个ARP请求，从而获取对应的MAC地址用于转发。</li><li>默认网关通常是一个路由器的接口地址，负责接收这些出站(去另一个广播域)的数据包，并根据路由表决定如何进一步转发这些数据包。</li></ul></li></ul><h3 id="23-父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？"><a href="#23-父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？" class="headerlink" title="23. 父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？"></a>23. 父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？</h3><ul><li><p>构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的虚函数指针指向，该指针是在构造过程中由编译器设置的，如果构造函数为虚函数，那就意味着构造前就要通过 vptr 找到构造函数，而此时 vptr 还未被正确初始化(可能指向其它的虚函数表)，导致无法构造对象。</p></li><li><p>析构函数可以且应该为虚函数：如果父类的析构函数不为虚函数，当使用父类指针指向子类，进行析构时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。</p></li></ul><h3 id="24-多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？"><a href="#24-多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？" class="headerlink" title="24. 多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？"></a>24. 多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？</h3><ul><li><p>死锁指的是多个线程因互相<strong>等待对方持有的资源</strong>，导致所有线程都无法继续执行下去的情况。</p></li><li><p>死锁通常发生在多线程访问<strong>共享资源</strong>时，比如两个线程互相持有对方需要的锁（mutex），并且都不释放，导致相互等待，程序卡死。</p></li><li><p>死锁产生的四个条件：</p><ul><li>互斥条件：资源不能共享，一次只能被一个线程持有</li><li>占有且等待：线程在等待其他资源的同时不释放已持有的资源</li><li>不可抢占：线程占有的资源在释放前不能被其它线程强行夺走</li><li>循环等待：存在一个线程链，每个线程都在等待下一个线程所持有的资源</li></ul></li><li><p>解决死锁的方法就是破坏上述任意一种条件</p><ul><li><strong>破坏“循环等待”</strong>：规定获取多个锁时的顺序，例如总是先锁 A 后锁 B</li><li><strong>破坏“不可抢占”</strong>：如果获取不到所需资源，就主动释放已有资源，稍后重试。</li></ul></li></ul><h3 id="25-描述一下面向过程和面向对象"><a href="#25-描述一下面向过程和面向对象" class="headerlink" title="25. 描述一下面向过程和面向对象"></a>25. 描述一下面向过程和面向对象</h3><ul><li><p>面向过程：是一种以“<strong>步骤</strong>”为核心的编程思想，它关注<strong>“做什么”</strong>和<strong>“怎么做”</strong>，程序就是由一系列函数(步骤)组成的。相比面向对象，代码效率更高。</p></li><li><p>面向对象：是一种以“<strong>对象</strong>”为核心的编程思想，它强调把现实世界中的事物抽象成一个个“对象”，通过对象之间的交互完成任务。相比面向过程，代码更易维护和复用</p></li></ul><h3 id="26-i是左值还是右值，-i和i-哪个效率更高？"><a href="#26-i是左值还是右值，-i和i-哪个效率更高？" class="headerlink" title="26. ++i是左值还是右值，++i和i++哪个效率更高？"></a>26. ++i是左值还是右值，++i和i++哪个效率更高？</h3><ul><li><p>++i是左值，因为它返回的是i本身；而i++是右值，因为它返回的是临时值(i的值)，</p></li><li><p>++i效率更高，因为它是直接把i自增，然后返回引用；而i++要先保存旧值的副本，再自增，再返回新副本，多了一次拷贝构造(赋值操作)</p></li></ul><h3 id="27-介绍一下vector、list的底层实现原理和优缺点"><a href="#27-介绍一下vector、list的底层实现原理和优缺点" class="headerlink" title="27. 介绍一下vector、list的底层实现原理和优缺点"></a>27. 介绍一下vector、list的底层实现原理和优缺点</h3><ul><li><p>Vector底层是由一块连续的内存空间组成，由三个指针实现的，分别是头指针(指向当前数据存储区域的起始地址)，尾指针(指向最后一个原始之后的位置)和可用空间尾指针(指向当前分配内存的末尾)</p><ul><li>优点：可使用下标随机访问，尾插尾删效率高</li><li>缺点：头插头删效率低，扩容有消耗</li></ul></li><li><p>list底层是由双向链表实现的</p><ul><li>优点：按需申请内存，不需要扩容，不会造成内存空间浪费。在任意位置的插入删除下效率高。</li><li>不支持下标随机访问</li></ul></li></ul><h3 id="28-变量在哪个阶段初始化、在哪个阶段分配内存？"><a href="#28-变量在哪个阶段初始化、在哪个阶段分配内存？" class="headerlink" title="28. 变量在哪个阶段初始化、在哪个阶段分配内存？"></a>28. 变量在哪个阶段初始化、在哪个阶段分配内存？</h3><ul><li><p>静态变量，全局变量，常量都在<code>编译阶段</code>完成初始化和内存分配</p></li><li><p>局部变量在<code>编译阶段</code>完成初始化，但是在<code>运行阶段</code>完成内存分配</p></li></ul><h3 id="29-空对象指针为什么能调用函数？"><a href="#29-空对象指针为什么能调用函数？" class="headerlink" title="29. 空对象指针为什么能调用函数？"></a>29. 空对象指针为什么能调用函数？</h3><ul><li>在 C++ 中，即使一个对象指针是空指针，也可以调用类的成员函数，<strong>前提是该函数内部不使用任何成员变量或访问 <code>this</code> 指针</strong>。这是因为成员函数的代码并不保存在对象中，而是<strong>由类共享并存放在代码区</strong>，函数调用时编译器会隐式地传入一个 <code>this</code> 指针。如果函数内部没有用到 <code>this</code>，那么即使这个 <code>this</code> 是空指针，也不会造成错误。</li></ul><p>注意：对象只存数据，不存函数。在 C++ 中，一个类的对象只包含它的成员变量(也就是数据成员），而 <strong>成员函数并不存储在对象中</strong>。因为如果每个对象都复制一份函数代码，内存就太浪费了。</p><h3 id="30-智能指针线程安全吗？"><a href="#30-智能指针线程安全吗？" class="headerlink" title="30. 智能指针线程安全吗？"></a>30. 智能指针线程安全吗？</h3><ul><li>智能指针中的引用计数操作是线程安全的，但智能指针所指向的资源本身并不是线程安全的。也就是说，智能指针可以保证资源在多个线程中被安全地析构和释放，但并不保证多个线程同时访问或修改该资源时的安全性。换句话说，它仅保证资源的生命周期管理是线程安全的，而不保证资源本身的访问是线程安全的(多线程读写资源需要加锁、保护等操作)。</li></ul><h3 id="31-push-back-左值和右值的区别是什么？"><a href="#31-push-back-左值和右值的区别是什么？" class="headerlink" title="31. push_back()左值和右值的区别是什么？"></a>31. push_back()左值和右值的区别是什么？</h3><ul><li><code>push_back()</code> 接收左值时会调用拷贝构造函数，将数据复制到容器中；接收右值时会调用移动构造函数，将数据“搬”进容器。使用右值或 <code>std::move()</code> 可以减少资源拷贝，提升性能，尤其在操作大型对象时非常重要。</li></ul><h3 id="32-move底层是怎么实现的？"><a href="#32-move底层是怎么实现的？" class="headerlink" title="32. move底层是怎么实现的？"></a>32. move底层是怎么实现的？</h3><ul><li><p>move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。</p></li><li><p>优点(这样做的一个好处)：可以将一个左值变成右值(改变它身份)，避免拷贝构造，而实现移动构造，这样就只是将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝，继而节省空间，提高效率。</p></li></ul><p>注意：如果一个类有移动构造函数，那么编译器在初始化新对象时，会根据右侧是左值还是右值，自动决定是调用拷贝构造还是移动构造函数。当右边是左值时，调用的是拷贝构造，当右边是右值时，调用的是移动构造</p><h3 id="33-完美转发的原理是什么？"><a href="#33-完美转发的原理是什么？" class="headerlink" title="33. 完美转发的原理是什么？"></a>33. 完美转发的原理是什么？</h3><ul><li>完美转发是指函数模板可以将自己的参数完美的转发给内部调用的其他函数，完美是指不仅能够准确的转发参数的值，还能保证被转发参数的左、右值属性不变，使用引用折叠的规则，将传递进来的左值以左值传递出来，将传递进来的右值以右值的方式传出。从而实现语义上的“完美转发”。</li></ul><h3 id="34-空类中有什么函数？"><a href="#34-空类中有什么函数？" class="headerlink" title="34. 空类中有什么函数？"></a>34. 空类中有什么函数？</h3><ul><li>空类默认有：默认构造函数、拷贝构造函数、默认析构函数、默认赋值运算符、移动构造函数(c++11)</li></ul><p>注意：c++11规定，如果显式地声明了<code>拷贝构造函数</code>、<code>拷贝赋值函数</code>、<code>析构函数</code>中的任何一个，编译器就不会再为你隐式生成移动构造函数和移动赋值函数。</p><h3 id="35-explicit用在哪里？有什么作用？"><a href="#35-explicit用在哪里？有什么作用？" class="headerlink" title="35. explicit用在哪里？有什么作用？"></a>35. explicit用在哪里？有什么作用？</h3><ul><li>用于修饰只有一个参数的类构造函数(有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效)，它的作用是表明该构造函数是显示的，而非隐式的(不能隐式转换)，类构造函数默认情况下声明为implicit。explicit作用是防止类构造函数的隐式自动转换，增强类型安全</li></ul><h3 id="36-成员变量初始化的顺序是什么？"><a href="#36-成员变量初始化的顺序是什么？" class="headerlink" title="36. 成员变量初始化的顺序是什么？"></a>36. 成员变量初始化的顺序是什么？</h3><ul><li>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与类中定义成员变量的顺序有关。</li><li>如果不使用初始化列表初始化，在构造函数内赋值时(这里不能说是初始化，因为真正的初始化其实在构造函数体执行之前就已经完成了，可能是默认值，构造函数体里面只是做了二次赋值操作)，此时与成员变量在构造函数中的位置有关。</li><li>类中const成员常量必须在构造函数初始化列表中初始化。</li><li>类中static成员变量，只能在类外初始化，因为<code>static</code> 成员属于整个类共享，不属于具体对象，不能在构造函数或初始化列表中初始化。。</li></ul><h3 id="37-指针占用的大小是多少？"><a href="#37-指针占用的大小是多少？" class="headerlink" title="37. 指针占用的大小是多少？"></a>37. 指针占用的大小是多少？</h3><ul><li>64位电脑上占8字节，32位的占4字节，我们平时所说的计算机多少位是指计算机CPU中通用寄存器一次性处理、传输、暂时保存的信息的最大长度。即CPU在单位时间内能一次处理的二进制的位数</li></ul><h3 id="38-野指针和内存泄漏是什么？如何避免？"><a href="#38-野指针和内存泄漏是什么？如何避免？" class="headerlink" title="38. 野指针和内存泄漏是什么？如何避免？"></a>38. 野指针和内存泄漏是什么？如何避免？</h3><ul><li><p>野指针：指向一个已经释放的内存或申明了指针，但没有初始化，这时指针可能指向任意内存地址。</p><ul><li>避免方法：1.声明指针后，及时初始化，指向nullptr都可以；2.释放后及时将指针设为nullptr；3.使用智能指针</li></ul></li><li><p>内存泄漏：是指程序中以动态分配的堆内存由于某种原因程序未释放或无法释放，造成这部分内存无法再次使用(内存浪费)，导致程序运行速度减慢甚至系统崩溃等严重后果</p><ul><li>避免方法：1.每new一块内存，都要有对应的delete；2.不手动管理内存时，尽量使用智能指针；3.避免中途覆盖指针变量，导致原有地址丢失</li></ul></li></ul><h3 id="39-多线程会发生什么问题？线程同步有哪些手段？"><a href="#39-多线程会发生什么问题？线程同步有哪些手段？" class="headerlink" title="39. 多线程会发生什么问题？线程同步有哪些手段？"></a>39. 多线程会发生什么问题？线程同步有哪些手段？</h3><ul><li><p>会引发资源竞争的问题；频繁上锁又会导致程序运行效率低下，甚至会导致发生死锁。</p></li><li><p>线程同步手段：使用atomic原子变量，使用互斥量也就是上锁，使用条件变量或信号量制约对共享资源的并发访问。</p></li></ul><h3 id="40-什么是STL？"><a href="#40-什么是STL？" class="headerlink" title="40. 什么是STL？"></a>40. 什么是STL？</h3><ul><li>STL是C++标准库的重要组成部分，提供了大量常用的、高效的算法和数据结构。STL 的设计目标是为了提供通用的、高性能的组件，使得开发者能够专注于解决更高层次的问题，而不是重新发明基础工具。STL 主要由以下四个部分组成：</li><li>容器：用于存储和管理数据</li><li>算法，STL 提供了一套丰富的算法，用于操作容器中的数据。比如 <code>sort()</code>, <code>find()</code>, <code>for_each()</code>, <code>count()</code>, <code>binary_search()</code> 等</li><li>迭代器：迭代器是一种类似于指针的对象，用于遍历容器中的元素</li><li>函数对象：重载了 <code>()</code> 运算符的类对象，它像函数一样可以调用，用于自定义操作行为</li></ul><h3 id="41-迭代器和指针的区别"><a href="#41-迭代器和指针的区别" class="headerlink" title="41. 迭代器和指针的区别"></a>41. 迭代器和指针的区别</h3><ul><li><p>迭代器不是指针，是一个模板类，通过重载了指针的一些运算符来模拟了指针的一些功能，迭代器返回的是容器中元素的引用(T&amp;&amp;)，而不是对应的值(T)。</p></li><li><p>虽然迭代器通常用于 STL 容器，但本质上它是访问一段区间的工具，不具备像指针那样能指向任意对象(如函数)的能力。</p></li></ul><h3 id="42-线程有哪些状态，线程锁有哪些？"><a href="#42-线程有哪些状态，线程锁有哪些？" class="headerlink" title="42. 线程有哪些状态，线程锁有哪些？"></a>42. 线程有哪些状态，线程锁有哪些？</h3><ul><li><p>五种状态：</p><ul><li>创建：线程被创建，但尚未开始执行</li><li>就绪：线程已经准备好运行，正在等待 CPU 时间片</li><li>运行：获得了CPU时间片，线程正在执行</li><li>阻塞：正在等待某个资源，例如锁、IO操作等(当线程因某些原因被阻塞时，操作系统会挂起该线程，将它从“就绪队列”中移除，不再分配 CPU 时间片，直到它重新变为“就绪”状态)</li><li>终止：线程已经完成执行或被终止</li></ul></li><li><p>线程锁的种类：</p><ul><li>互斥锁：最基本的锁，一个线程获得锁，其他线程必须等待</li><li>条件锁(条件变量)：用于线程之间的等待-通知机制。类似“生产者-消费者模型”</li><li>自旋锁(尝试锁)：不阻塞线程，而是在循环中等待锁释放。适用于锁竞争不激烈，锁持有时间很短的情况，缺点是浪费CPU资源</li><li>读写锁：多个线程可以同时读取资源，但写入时必须独占。适用于读线程多写线程少的情况。</li><li>递归锁：同一线程可重复获得多次锁，不会死锁。适用于一个线程内多次调用相同的加锁函数</li></ul></li></ul><h3 id="43-介绍一下线程、进程和协程"><a href="#43-介绍一下线程、进程和协程" class="headerlink" title="43. 介绍一下线程、进程和协程"></a>43. 介绍一下线程、进程和协程</h3><ul><li><p>进程是操作系统资源分配的基本单位，一个程序启动时，操作系统会为其创建一个进程，每个进程拥有<strong>独立的内存空间</strong>、代码段、数据段、堆和栈</p><ul><li>因为每个进程都有独立的内存空间，所以进程间的通信需要通过特定的机制来实现，比如管道、共享内存mmap，本地套接字等</li></ul></li><li><p>线程是操作系统调度的基本单位，一个进程可以包含<strong>多个线程</strong>，多个线程共享该进程的资源。相比进程，创建和销毁线程的开销较小。</p><ul><li>由于资源共享，多个线程访问相同资源时可能需要同步机制(如锁)以避免数据竞争</li></ul></li><li><p>协程是一种“可以暂停执行”的函数，当遇到一个异步操作时(如 <code>async_read_some</code>)，协程可以挂起自己，并释放当前的资源，待异步操作完成后，自动恢复执行。</p><ul><li>协程是用户级的轻量线程，因为<strong>协程是在用户空间完成调度的，不需要进入内核态</strong>，而线程的调度通常涉及用户态和内核态之间的切换</li></ul></li></ul><h3 id="44-vector中的push-back-和emplace-back-的区别、以及使用场景"><a href="#44-vector中的push-back-和emplace-back-的区别、以及使用场景" class="headerlink" title="44. vector中的push_back()和emplace_back()的区别、以及使用场景"></a>44. vector中的push_back()和emplace_back()的区别、以及使用场景</h3><ul><li>push_back和emplace_back的参数都是左值时，两者都会触发一次拷贝构造函数，因此这种情况下两者的没有太大差别；而当push_back和emplace_back的参数都是右值时，push_back会触发构造函数和移动构造函数，emplace_back只会在容器尾部触发构造函数，少了一次移动构造函数，因此在性能上通常优于 <code>push_back</code>。</li><li>emplace_back适用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中最好使用push_back。</li><li>push_back会更加安全；emplace_back会更加高效</li></ul><p>注：如果push_back()传入的是已有的对象，那么调用的就只有拷贝构造函数，如果是push_back(Person(“lxx”,25))，那么调用的就是构造函数+移动构造函数(因为调用构造函数后，这是一个临时对象，即右值，就会进行调用移动构造函数)。<code>emplace_back</code> 的优势体现在：原地构造 + 避免临时对象的拷贝或移动</p><h3 id="45-如何实现线程安全，除了加锁还有没有其它的方式？"><a href="#45-如何实现线程安全，除了加锁还有没有其它的方式？" class="headerlink" title="45. 如何实现线程安全，除了加锁还有没有其它的方式？"></a>45. 如何实现线程安全，除了加锁还有没有其它的方式？</h3><ul><li>原子操作(原子操作是不可分割的，使用原子操作可以确保在多线程环境中操作是安全的)，</li><li>条件变量(协调线程之间的协作，用来在线程之间传递信号，从而控制线程的执行流程)等方式</li></ul><h3 id="46-vector扩容，resize和reserve的区别"><a href="#46-vector扩容，resize和reserve的区别" class="headerlink" title="46. vector扩容，resize和reserve的区别"></a>46. vector扩容，resize和reserve的区别</h3><ul><li><strong><code>resize()</code></strong> 改变的是<code>vector</code>的<strong>大小</strong>(即元素的数量)，并可能间接影响容量(当需要更多空间时)</li><li><strong><code>reserve()</code></strong> 改变的是<code>vector</code>的<strong>容量</strong>(即预分配的内存大小)，但不会影响当前的大小(元素数量)</li></ul><h3 id="47-vector扩容为了避免重复扩容做了哪些机制？"><a href="#47-vector扩容为了避免重复扩容做了哪些机制？" class="headerlink" title="47. vector扩容为了避免重复扩容做了哪些机制？"></a>47. vector扩容为了避免重复扩容做了哪些机制？</h3><ul><li><p>当 <code>vector</code> 的大小超过当前 <code>capacity</code> 时，它会自动扩容到原来容量的两倍左右，而不是只增加一点点空间。</p></li><li><p>可手动调用 <code>reserve()</code> 提前分配空间</p></li></ul><h3 id="48-C-中空类的大小是多少？为什么？"><a href="#48-C-中空类的大小是多少？为什么？" class="headerlink" title="48. C++中空类的大小是多少？为什么？"></a>48. C++中空类的大小是多少？为什么？</h3><ul><li>1字节，这样主要就是起占位的作用，保证每个对象都有一个唯一的地址。如果空类大小为0，那么p1和p2 的地址就可能完全一样，编译器无法区分两个对象，也就破坏了对象的基本属性(每个对象应有唯一地址)</li></ul><p>问题：为什么空类大小为0，p1和p2的地址可能一样？</p><p>由于空类占 0 字节，编译器在内存中不需要为它分配任何空间，其对象也就没有空间，那么它们的地址该指向哪里，就可能会相同</p><h3 id="49-weak-ptr是怎么实现的？"><a href="#49-weak-ptr是怎么实现的？" class="headerlink" title="49. weak_ptr是怎么实现的？"></a>49. weak_ptr是怎么实现的？</h3><ul><li><code>weak_ptr</code> 的底层实现依赖于一个控制块，它是由共享智能指针创建的，该控制块中包含两个计数器：一个记录强引用(shared_ptr)的数量，另一个记录弱引用(weak_ptr)的数量。<code>weak_ptr</code> 不拥有资源，不会影响资源的生命周期，只用于观察资源是否存在，并在需要时临时获取 <code>shared_ptr</code><ul><li>强引用计数(use_count)：记录有多少个 <code>shared_ptr</code> 实例指向这个资源</li><li>弱引用计数(weak_count)：记录有多少个 <code>weak_ptr</code> 实例指向这个资源。</li></ul></li></ul><h3 id="50-一个函数f-int-a-int-b-，其中a和b的地址关系是什么？"><a href="#50-一个函数f-int-a-int-b-，其中a和b的地址关系是什么？" class="headerlink" title="50. 一个函数f(int a,int b)，其中a和b的地址关系是什么？"></a>50. 一个函数f(int a,int b)，其中a和b的地址关系是什么？</h3><ul><li><p>函数参数如 <code>f(int a, int b)</code> 中的 <code>a</code> 和 <code>b</code> 是值传递的，也就是说它们是实参的副本，会在函数栈帧中被依次压栈分配空间。</p></li><li><p>因为<code>a</code> 和 <code>b</code> 都是局部变量，位于函数的栈帧中，<strong>栈空间通常是从高地址向低地址增长的</strong>，则会按声明顺序依次入栈，即 <code>&amp;a &gt; &amp;b</code>。</p></li></ul><h3 id="51-移动构造和拷贝构造的区别是什么？"><a href="#51-移动构造和拷贝构造的区别是什么？" class="headerlink" title="51. 移动构造和拷贝构造的区别是什么？"></a>51. 移动构造和拷贝构造的区别是什么？</h3><ul><li>移动构造函数本质上是对资源指针的“<strong>浅拷贝</strong>”，通过<strong>资源所有权的转移</strong>，避免了昂贵的深拷贝操作。它常用于处理<strong>右值对象</strong>(如临时变量)或通过 <code>std::move()</code> 转换后的左值对象。在这种场景下，可以显著提高性能，减少不必要的堆内存分配和数据复制。</li><li>相比之下，<strong>拷贝构造函数</strong>会分配新的内存空间，并将原对象的内容<strong>逐一复制</strong>过去，适用于需要保留原始对象副本的情况。</li></ul><h3 id="52-lambda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？"><a href="#52-lambda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？" class="headerlink" title="52. lambda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？"></a>52. lambda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？</h3><ul><li>Lambda 表达式的捕获列表是用来捕获外部作用域变量的，捕获的方式有按值捕获和按引用捕获。</li><li>引用捕获要注意什么？<ul><li>生命周期问题：Lambda可能会延后执行(如在异步、线程、回调中)，此时被引用的变量若已销毁(被引用的对象生命周期短)，就会造成悬空引用，这是未定义行为，极易导致崩溃</li><li>线程安全问题：若在多线程中使用引用捕获的变量，没有同步机制(如互斥锁)，可能导致<strong>数据竞争</strong></li></ul></li></ul><p><strong>解决办法</strong>：应尽量避免对生命周期短的变量使用引用捕获，特别是在 lambda 延后执行的情况下。此时可以对关键变量采用**值捕获([&#x3D;] 或 [a])**来避免悬挂引用</p><h3 id="53-哈希碰撞的处理方法"><a href="#53-哈希碰撞的处理方法" class="headerlink" title="53. 哈希碰撞的处理方法"></a>53. 哈希碰撞的处理方法</h3><ul><li><p>在哈希表中，每个键(key)通过哈希函数映射到一个表的索引位置。但因为哈希函数输出是有限的，而输入可能无限，<strong>多个不同的键可能映射到同一个索引位置</strong>，这就叫做<strong>哈希碰撞</strong></p></li><li><p>处理方法：</p><ul><li>开放地址法：如果某个位置已经被占，就往下去寻找一个新的空闲的哈希地址。</li><li>优点：空间利用率高</li><li>缺点：容易产生<strong>聚集效应</strong>(指多个键值对在哈希表中聚集到相邻位置的现象)，查找效率下降</li><li>链地址法：每个数组槽位存放一个链表(或其他容器)，将多个哈希地址相同的元素“挂”在同一个槽位下<ul><li>优点：碰撞处理简单，插入效率高</li><li>缺点：空间开销大，需要额外内存；可能会导致链表太长，查找性能变差</li></ul></li><li>再哈希法：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数直到不发生冲突为止<ul><li>优点：不易发生聚集，</li><li>缺点：增加了计算时间</li></ul></li><li>建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中</li></ul></li></ul><h3 id="54-unordered-map的扩容过程"><a href="#54-unordered-map的扩容过程" class="headerlink" title="54. unordered_map的扩容过程"></a>54. unordered_map的扩容过程</h3><ul><li>当 <code>unordered_map</code> 中的元素数量超过桶数量的负载因子(当前元素个数 ÷ 桶的总数量，默认是 0.75)时，容器会自动扩容</li><li>1.创建更大的数组(空间)，桶数量会扩大(通常是原来的2倍)；2.重新哈希：把所有元素根据新的桶数重新计算哈希值并分配到新的桶中，以保持哈希查找的高性能。3.更新容器内部记录的相关信息(当前的桶数量和负载因子等)</li></ul><h3 id="55-vector如何判断应该扩容？"><a href="#55-vector如何判断应该扩容？" class="headerlink" title="55. vector如何判断应该扩容？"></a>55. vector如何判断应该扩容？</h3><ul><li>由当前容器内元素数量的大小和容器容量的大小进行比较如果二者相等就会进行扩容，一般是1.5倍，部分的有两倍</li></ul><h3 id="56-this指针是什么？"><a href="#56-this指针是什么？" class="headerlink" title="56. this指针是什么？"></a>56. this指针是什么？</h3><ul><li><code>this</code> 指针是一个指向当前对象本身的指针。它只有在对象调用非静态成员函数时才存在。因为<code>this</code> 是每个对象调用非静态成员函数时，<strong>编译器隐式传入的一个指针参数</strong>，实际上就是当前对象的地址。</li></ul><h3 id="56-类中static函数是否能声明为虚函数？"><a href="#56-类中static函数是否能声明为虚函数？" class="headerlink" title="56. 类中static函数是否能声明为虚函数？"></a>56. 类中static函数是否能声明为虚函数？</h3><ul><li>不能，因为类中的static函数是所有类实例化对象所共有的，也就是说无论创建多少个类的实例对象，静态成员函数只有一个版本，而虚函数底层是通过虚函数表和虚函数指针来完成的，是为了实现多态，一方面静态成员函数没有this指针，也就不能调用虚函数指针，另一方面静态成员函数不具备多态性的基础，因此静态成员函数不能声明为虚函数</li><li>虚函数机制依赖对象(实例)<ul><li>虚函数是面向对象的特性，它依赖于具体的对象来实现多态</li><li>static 成员函数不属于任何对象实例，它们没有 this 指针，无法访问对象的状态</li></ul></li><li>虚函数机制需要动态绑定<ul><li>虚函数的核心是根据对象的实际类型在运行时决定调用哪个函数</li><li><code>static</code> 函数是编译时解析的，不涉及运行时类型判断</li></ul></li></ul><h3 id="57-哪些函数不能被声明为虚函数？"><a href="#57-哪些函数不能被声明为虚函数？" class="headerlink" title="57. 哪些函数不能被声明为虚函数？"></a>57. 哪些函数不能被声明为虚函数？</h3><ul><li>构造函数，静态成员函数，非类成员函数</li><li>内联函数：内联函数有实体，在编译时展开，没有this指针</li><li>友元函数：因为虚函数必须是类的成员函数，而友元函数不是类的成员函数。友元函数只是提供一种机制，允许外部函数访问类的私有和保护成员</li></ul><p>注：内联函数的处理主要发生在编译阶段。编译器会根据<code>inline</code>关键字的建议，尝试将函数的定义直接插入到每个调用点，从而减少函数调用的开销。然而，编译器可能会根据函数的大小、调用频率等因素决定是否真正内联某个函数。</p><h3 id="58-如何保证类的对象只能被开辟在堆上？"><a href="#58-如何保证类的对象只能被开辟在堆上？" class="headerlink" title="58. 如何保证类的对象只能被开辟在堆上？"></a>58. 如何保证类的对象只能被开辟在堆上？</h3><ul><li>1.将类的构造函数设置为私有，这样外部就不能在栈上创建对象了(MyClass obj)；2.提供一个公共(public)的static函数来在new上创建对象并返回(public是因为允许外部调用该函数，static是因为在没有对象的情况下，只能调用static函数)</li></ul><p>注意：如果只能在栈上分配呢？则是重载new操作符，使得new操作符的功能为空，这样就使得外部程序无法在堆上分配对象，只可以在栈上分配</p><h3 id="59-讲讲你理解的虚基类"><a href="#59-讲讲你理解的虚基类" class="headerlink" title="59. 讲讲你理解的虚基类"></a>59. 讲讲你理解的虚基类</h3><ul><li><p>虚基类是C++中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份来自虚基类的实例，从而引发一系列的问题。因此为了解决这个问题，就可以将两个基类共同继承的类作为虚基类，派生类中就采用虚继承的方式来继承</p></li><li><p>虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突</p></li><li><p>虚基类是可以被实例化的，只是被别的类以虚继承的方式使用。它是一个继承方式的描述</p></li></ul><h3 id="60-C-哪些运算符不能被重载？"><a href="#60-C-哪些运算符不能被重载？" class="headerlink" title="60. C++哪些运算符不能被重载？"></a>60. C++哪些运算符不能被重载？</h3><ul><li><p>成员访问运算符(.)、作用域限定符(::)、成员指针访问运算符(.*)</p></li><li><p>为什么不能重载：这些运算符涉及 C++ 的<code>核心语言机制</code>和<code>编译器的行为</code>，如果允许重载，可能会破坏语言的基本规则或引起歧义。</p></li></ul><h3 id="61-动态链接和静态链接的区别"><a href="#61-动态链接和静态链接的区别" class="headerlink" title="61. 动态链接和静态链接的区别"></a>61. 动态链接和静态链接的区别</h3><ul><li><p>区别：最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前(链接阶段)，而动态链接的进行则是程序执行时(运行阶段)</p></li><li><p>静态链接：在静态链接过程中，链接器会将程序所需的库代码直接复制到生成的可执行文件中。这意味着每个使用静态库编译的程序都会包含一份完整的库代码</p><ul><li><strong>优点</strong>：<ul><li>独立性：生成的可执行文件不依赖于外部库，因此可以在没有安装相应库的系统上运行。</li><li>性能：由于所有需要的代码都已经包含在可执行文件中，所以在运行时不需要额外的加载时间</li></ul></li><li><strong>缺点</strong>：<ul><li>存储空间浪费：如果多个程序都使用了同一个静态库，那么每个程序都会包含一份该库的副本</li><li>更新不便：如果静态库有更新，所有使用该库的应用都需要重新编译并发布新的版本</li></ul></li></ul></li><li><p>动态链接：动态链接(或共享库)则是在编译时只记录对库函数的引用(符号引用)，实际的库代码不会被复制到可执行文件中。当程序运行时，操作系统会加载这些共享库，并解决符号引用。</p><ul><li><p><strong>优点</strong>：</p><ul><li>节省磁盘空间：多个程序可以共享同一份动态库，减少了重复存储的情况</li><li>易于维护：如果共享库更新了，只要库的接口不变，应用程序无需重新编译即可享受到新版本的好处</li></ul></li><li><p>缺点：</p><ul><li><p>依赖性：程序运行时需要相应的动态库存在，并且版本兼容。如果缺少必要的动态库或版本不匹配，程序可能无法运行。</p></li><li><p>启动时间：程序启动时需要加载动态库，可能会增加一些启动时间。</p></li></ul></li></ul></li></ul><h3 id="62-说一下内联函数及其优缺点"><a href="#62-说一下内联函数及其优缺点" class="headerlink" title="62. 说一下内联函数及其优缺点"></a>62. 说一下内联函数及其优缺点</h3><ul><li><p>内联函数：是一种<code>建议</code>编译器在调用该函数的地方直接展开函数代码(但保留类型检查和作用域规则，不像宏那样易出错)，而不是进行常规的函数调用(压栈、跳转、返回等操作)。</p></li><li><p>优点：节省了函数调用的开销，让程序运行更加快速。</p></li><li><p>缺点：如果函数体过长，频繁使用内联函数会导致代码编译膨胀问题；不能内联递归调用，容易导致死循环的展开</p></li></ul><h3 id="63-auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？"><a href="#63-auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？" class="headerlink" title="63. auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？"></a>63. auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？</h3><ul><li><code>auto</code> 是编译器在声明变量时自动根据右边的表达式类型推导变量类型；而模板则是编译器根据传入实参，推导模板参数(T)类型，并<strong>在编译期生成对应的代码版本</strong>，两者都依赖于编译期的<strong>类型推导机制</strong>。</li></ul><h3 id="64-map和set的区别和底层实现是什么？map取值的find、-、at方法的区别"><a href="#64-map和set的区别和底层实现是什么？map取值的find、-、at方法的区别" class="headerlink" title="64. map和set的区别和底层实现是什么？map取值的find、[]、at方法的区别"></a>64. map和set的区别和底层实现是什么？map取值的find、[]、at方法的区别</h3><ul><li><p>map和set都是通过红黑树实现的平衡二叉搜索树。插入、删除、查找的时间复杂度为 **O(log n)**。</p></li><li><p>1.find()查找需要判断返回的结果才知道有没有查询成功；2.[]下标访问，如果原先不存在该key则插入，如果存在则返回对应的value值；3.at方法则会进行越界检查，如果存在则返回它的value值，如果不存在则抛出异常。</p></li></ul><h3 id="65-fcntl的作用"><a href="#65-fcntl的作用" class="headerlink" title="65. fcntl的作用"></a>65. fcntl的作用</h3><ul><li><p><code>fcntl</code> 是 Linux 系统调用中的一个多功能函数，属于文件控制接口，主要用于对文件描述符进行各种控制操作</p></li><li><p>功能：1.获取&#x2F;设置文件描述符的标志(如非阻塞)；2.复制文件描述符(类似于dup())；</p></li></ul><h3 id="66-extern-C关键字是什么，为什么会有这个关键字？"><a href="#66-extern-C关键字是什么，为什么会有这个关键字？" class="headerlink" title="66. extern C关键字是什么，为什么会有这个关键字？"></a>66. extern C关键字是什么，为什么会有这个关键字？</h3><ul><li>作用：用C语言的方式来编译C++代码，</li></ul><h3 id="67-迭代器失效及其解决方法"><a href="#67-迭代器失效及其解决方法" class="headerlink" title="67. 迭代器失效及其解决方法"></a>67. 迭代器失效及其解决方法</h3><ul><li>迭代器失效：是指容器结构发生变化(如插入、删除、扩容等)，导致原来保存的迭代器不再有效</li><li><strong>序列式容器迭代器失效</strong>：当当前元素的迭代器被删除后，后面所有元素的迭代器都会失效.他们都是一块连续存储的空间，所以当使用erase函数操作时，其后的每一个元素都会向前移动一个位置，此时可以使用erase函数操作可以返回下一个有效的迭代器。</li></ul><p>注意：1.容器内部重新分配内存，导致原迭代器指向旧空间，也会造成迭代器失效；2.对于双向链表结构list，节点插入和删除不会影响其它节点，所以一般不会发生节点失效</p><h3 id="68-编译器是如何实现重载的？"><a href="#68-编译器是如何实现重载的？" class="headerlink" title="68. 编译器是如何实现重载的？"></a>68. 编译器是如何实现重载的？</h3><ul><li><p>c++底层实现函数重载是通过<code>名称修饰</code>这一机制。编译器会把函数名和参数类型编码在一起，形成一个“唯一的标识符”用于定位函数地址，并保存在一个符号表中。</p></li><li><p>1.当编译器遇到一个函数声明或定义时，通过名称修饰生成唯一的一个标识符注册到符号表中，并关联一个地址或占位符。</p><ul><li>如果这个函数是已经定义好的，编译器可以直接将这个函数地址记录在该函数标识符关联的地址上</li><li>如果这个函数只是声明(没有函数体)，那么编译器就在这个函数的标识符关联地址上创建一个未解析的占位符</li></ul></li><li><p>2.当遇到函数调用时，会通过类型推导找到正确的重载函数，然后找到它在符号表中的修饰名称，如果这个函数在符号表中绑定的是一个地址(说明之前已经定义好)，就可以直接使用；如果这个函数在符号表中绑定的是一个占位符(说明之前没有定义好)，编译器就会记录这个标识符(函数)为未解析，需要在链接时完成解析</p></li><li><p>3.链接时，链接器会将多个文件的符号表合并，把这些“占位符”用真正的地址替换</p></li></ul><p>补：在C语言中的符号表是以函数名为符号来绑定函数地址，就会存在歧义和冲突，因此C语言不支持函数重载；而C++符号表中的符号是以函数名+参数类型等信息，通过名称修饰生成唯一的内部符号来绑定函数地址的，所以不会产生查询歧义的问题，使得函数可以重载</p><p>注意：1.同一个作用域下(同一个类内)，多个函数拥有相同的函数名，但参数类型或个数不同，这叫做<strong>函数重载</strong>；2.子类中重新定义父类的虚函数，并且函数名称、参数类型和个数、返回值都必须<strong>完全一致</strong>，这叫做<strong>函数重写</strong>；3.在继承关系中，子类实现了一个和父类名字名字一样的函数。这样子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关。</p><h3 id="69-使用条件变量的时候需要注意什么？"><a href="#69-使用条件变量的时候需要注意什么？" class="headerlink" title="69. 使用条件变量的时候需要注意什么？"></a>69. 使用条件变量的时候需要注意什么？</h3><h3 id="70-类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？"><a href="#70-类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？" class="headerlink" title="70. 类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？"></a>70. 类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？</h3><ul><li>类内普通成员函数可以调用类内静态变量，因为静态变量是整个类共享的，不依赖于对象，在第一次使用它时就会被初始化并分配内存，所以只要作用域允许，不管是通过对象还是普通成员函数，都可以访问静态变量。</li><li>静态函数可以直接访问静态变量，静态函数不能直接访问非静态变量。如果要访问非静态成员变量，必须传入对象。</li></ul><p>注意：静态成员函数不能直接访问非静态成员变量，是因为调用静态成员函数时，没有隐式传入 this 指针，而访问非静态成员变量需要通过对象(即 this 指针)来访问，因此在静态成员函数中就不知道是哪个对象，也就无法调用非静态成员变量。</p><h3 id="71-回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？"><a href="#71-回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？" class="headerlink" title="71. 回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？"></a>71. 回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？</h3><ul><li><p>回调函数：将一个函数作为参数传递给另一个函数，当条件满足或某个事件发生时，这个函数被“回调”执行</p></li><li><p>回调函数的目的就是让程序更加灵活，把“调用者”与“实现逻辑”分离开，只关注“什么时候执行什么操作”即可</p></li><li><p>优点：解耦合(调用方和实现方不直接依赖，逻辑更加清晰)、可重用(同一个接口，多个回调函数可以复用)</p></li><li><p>缺点：调试困难(回调函数过多会导致代码难以维护)、可读性差(程序流程不再线性，阅读难度上升)</p></li><li><p>回调的本质：将函数作为参数传递，使得程序能够在运行时动态地调用这些函数，从而实现更灵活和通用的设计。回调函数的核心在于动态性和灵活性</p></li></ul><h3 id="72-什么是尾递归？"><a href="#72-什么是尾递归？" class="headerlink" title="72. 什么是尾递归？"></a>72. 什么是尾递归？</h3><ul><li>尾递归：在一个函数中，最后一步调用自己本身，并且调用完成后，没有其他额外的操作需要继续执行</li><li>普通递归：因为每次递归都有未完成的任务，所以必须开新的栈帧存着，保存每一层的一个状态，当递归层数太深，就会导致栈空间耗尽，程序崩溃。</li></ul><p>为什么尾递归可以不新开栈帧：调用自己之后，当前函数就彻底结束了<strong>，</strong>没有任何后续操作，所以当前栈帧就没有必要保留，可以直接用当前的栈帧给下一次调用复用，不用重新申请新的栈空间</p><p>补：栈帧就是函数调用时，编译器在栈上为这个函数专门分配的一块空间，用来保存这个函数运行所需要的一切信息</p><h3 id="73-为什么会有栈溢出，为什么栈会设置容量？"><a href="#73-为什么会有栈溢出，为什么栈会设置容量？" class="headerlink" title="73. 为什么会有栈溢出，为什么栈会设置容量？"></a>73. 为什么会有栈溢出，为什么栈会设置容量？</h3><ul><li><p>1.栈空间通常用于存放临时变量，如果定义了大量的临时变量(局部变量)，就可能超过设置的栈空间大小，就会出现栈溢出。2.如果函数嵌套太多，也会发生栈溢出，因为函数没有结束前，函数占用的变量也不被释放，占用了栈空间。</p></li><li><p>栈如果不设置容量，函数一旦无限递归，就会影响其他程序甚至操作系统，会给内存管理带来困难。当然也不能设置太大，对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大。</p></li></ul><h3 id="74-平衡二叉树的优缺点"><a href="#74-平衡二叉树的优缺点" class="headerlink" title="74. 平衡二叉树的优缺点"></a>74. 平衡二叉树的优缺点</h3><ul><li>优点：可以避免二叉排序树可能出现最极端情况(退化为链表)，其平均查找的时间复杂度为logN</li><li>缺点：对AVL树做一些结构修改的操作时，性能非常低下。比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置</li></ul><h3 id="75-make-shared函数的优点、缺点？"><a href="#75-make-shared函数的优点、缺点？" class="headerlink" title="75. make_shared函数的优点、缺点？"></a>75. make_shared函数的优点、缺点？</h3><ul><li><p>make_shared是一个函数模板，用于创建 <code>std::shared_ptr</code>。它的作用是通过单次内存分配来创建一个对象，并且返回一个管理该对象的 <code>shared_ptr</code>。</p></li><li><p>优点：相较于new构造减少了内存分配的次数，降低了系统开销，提高了效率。(<code>make_shared</code> 会在一个单独的内存块中同时分配对象和控制块，而new方法会分别为对象和控制块分配内存）</p></li><li><p>缺点：1.只能创建共享智能指针，不能创建其它类型的指针；2.当构造函数是保护或者私有的时候无法使用make_shared函数(make_shared本质上需要访问类的构造函数来创建对象)；3.会导致weak_ptr保持控制块的生命周期，连带着保持了对象分配的内存，只有当最后一个weakptr被销毁时，内存才会被释放，对于内存要求高的场景来说，是一个需要注意的问题</p></li></ul><h3 id="76-函数调用进行的操作"><a href="#76-函数调用进行的操作" class="headerlink" title="76. 函数调用进行的操作"></a>76. 函数调用进行的操作</h3><h3 id="77-Qt-中常用的五大模块是哪些？"><a href="#77-Qt-中常用的五大模块是哪些？" class="headerlink" title="77. Qt 中常用的五大模块是哪些？"></a>77. Qt 中常用的五大模块是哪些？</h3><ul><li><p>QtCore：提供了 Qt 的核心模块，负责非图形类支持，比如事件循环、定时器、文件操作、多线程、数据结构等</p></li><li><p>QtGui：负责图形界面支持，主要提供是像绘图(QPainter)、图像管理(QImage)和字体的能力</p></li><li><p>QtWidgets：提供窗口控件(比如按钮、表单、表格、树形结构等)，主要用于构建传统桌面应用</p></li><li><p>QtNetwork：提供网络通信功能，支持TCP、UDP、HTTP等协议编程</p></li><li><p>QtSql：数据库模块，提供数据库访问API，支持连接和操作主流数据库(如MySQL、SQLite等)</p></li></ul><h3 id="78-什么是信号和槽机制？如何使用信号和实现对象间通信？"><a href="#78-什么是信号和槽机制？如何使用信号和实现对象间通信？" class="headerlink" title="78. 什么是信号和槽机制？如何使用信号和实现对象间通信？"></a>78. 什么是信号和槽机制？如何使用信号和实现对象间通信？</h3><ul><li><p>信号和槽是Qt框架中用于对象间通信的机制。信号是一种特殊类型的函数，用于发出通知(对象已经发生了某个事件)。而槽是接收信号的函数，当一个信号触发时，与之相连接的将被自动调用。这样可以实现对象间的解耦和灵活的事件处理流程。</p></li><li><p>其他对象如果通过 <code>connect</code> 建立了某个信号与自己槽函数的连接关系，当该信号触发时，Qt 框架就会根据之前的连接记录，自动调用这些对象的对应槽函数，从而进行处理。</p></li></ul><p>补：使用信号和机制可以在一个对象内部或之间实现<strong>异步</strong>编程，也可以帮助开发者解耦不同组件、模块的代码，提高系统的可维护性和扩展性。</p><h3 id="79-为什么握手是三次而挥手需要四次"><a href="#79-为什么握手是三次而挥手需要四次" class="headerlink" title="79. 为什么握手是三次而挥手需要四次"></a>79. 为什么握手是三次而挥手需要四次</h3><ul><li><p>三次握手是为了确保双方都有发送和接收数据的能力，如果没有第三次握手，服务器就无法确认客户端是否具备收到自己回复的能力</p><ul><li>第一次是客户端发送一个SYN报文給服务器，请求建立连接。这个报文携会携带客户端的初始序列化(seq&#x3D;x)；</li><li>第二次是服务器回应客户端，如果同意连接，会发送一个SYN+ACK的报文，ACK会携带客户端初始化序列+1，SYN会携带服务器的初始化序列(seq&#x3D;y)；</li><li>第三次是客户端回复服务端，当收到服务器的同意连接后，会发送一个ACK报文，携带的是服务器的初始化序列+1。这一步完成后，双方都建立好了连接，可以开始传输数据了。</li></ul></li><li><p>四次挥手是为了双方都确认彼此数据发送完毕，由于TCP是全双工通信，双方都需要分别关闭各自的发送通道。一来一回两次，就是一个方向的关闭，因为双向独立，所以需要四次挥手</p><ul><li>第一次挥手是<code>主动</code>关闭连接请求端发送一个FIN报文，请求断开连接，表示没有应用数据发送了。(只能收，不能发应用数据)</li><li>第二次挥手是<code>被动</code>关闭连接请求端收到断开连接请求后做出的回应，会发送一个ACK报文。(半关闭完成)</li><li>第三次挥手是<code>被动</code>关闭连接请求端发送一个FIN报文，表示它也没有应用数据发送了</li><li>第四次挥手是<code>主动</code>关闭连接请求端回复被动关闭连接请求端，发送一个ACK报文，进入TIME_WAIT状态，等待2MSL时间</li></ul></li></ul><p>注意：第一次挥手后主动端只能收，而不能发应用数据，但可以发TCP控制信息(比如ACK确认)，因此第四次挥手能正常应答</p><p>问题：为什么TIME_WAIT状态要等待2MSL时长？</p><ul><li>MSL：指的是一个 TCP 报文在网络中能存在的最长时间，等待2MSL主要就是为了被动关闭端能接收到最后的ACK，正常关闭连接。在等待期间，被动关闭端如果长时间没有收到ACK回应，还有时间可以重新发一个FIN，主动关闭端收到FIN后继续发送ACK进行回应</li></ul><h3 id="80-tcp和udp的原理、区别、应用场景。"><a href="#80-tcp和udp的原理、区别、应用场景。" class="headerlink" title="80.tcp和udp的原理、区别、应用场景。"></a>80.tcp和udp的原理、区别、应用场景。</h3><ul><li>1.TCP是面向连接的，通信前必须先建立连接(三次握手)，结束时要四次挥手，而UDP不需要；2.TCP是可靠传输，保证数据完整、有序、无丢失，而UDP是尽最大努力交付，不保证这些；总结就是TCP慢，可靠，UDP快，不可靠</li><li>TCP适合<strong>准确性</strong>要求高的应用：网页浏览、电子邮件、远程登录</li><li>UDP适合<strong>实时性</strong>要求高但允许偶尔丢包的应用：视频直播、语音通话、游戏</li></ul><h3 id="81-TCP的流量控制和拥塞控制"><a href="#81-TCP的流量控制和拥塞控制" class="headerlink" title="81. TCP的流量控制和拥塞控制"></a>81. TCP的流量控制和拥塞控制</h3><ul><li><p>流量控制的实现机制是滑动窗口，主要就是防止发送方发送太快，导致接收方来不及处理、缓存溢出。</p><ul><li>在三次握手完成，建立连接后，发送方发送数据给接收方，接收方会回复一个报文，这个TCP报文(确认ACK报文)的首部有一个窗口大小字段，接收方通过这个字段告诉发送方，它还能接收的字节数，发送方根据通知的这个大小来控制后续发送的数据量</li><li>TCP 首部里面确实有一个 <code>Window Size</code> 字段，它是动态变化的，实时反映接收方的缓冲区剩余大小</li><li>发送方可以是客户端，也可以是服务器端，接收方同理也可以是客户端或服务器端</li><li>窗口更新并不一定非得等收到数据之后，接收方可以单独发一个 ACK 报文更新窗口大小，即使没有数据(叫作“窗口更新”)</li></ul></li><li><p>拥塞控制是为了避免网络出现拥塞崩溃，即太多数据注入到网络中，导致路由器、链路处理不过来，产生丢包<strong>、</strong>延迟上升，严重时整个网络瘫痪。TCP 拥塞控制分成四大阶段：</p><ul><li><p>慢开始：初始时，发送方的拥塞窗口(cwnd)很小(通常为一个最大报文段长度)，每收到一个 ACK(确认应答)，cwnd 加倍(指数增长)，主要就是先一点点试探网络能力</p></li><li><p>拥塞避免：当cwnd大于等于ssthresh(慢启动门限)时，就不能指数增加了，否则网络容易冲爆，这时cwnd呈线性增长</p></li><li><p>快速重传：当发送方收到三个重复的ACKs时，即认为发生了数据包丢失，不等待超时就立即重传丢失的数据包。</p><ul><li>注意：如果接收方发现收到的数据包不是它期待的数据(乱序)，就会不停地回复上一次正确接收的序号的 ACK</li><li>超时重传：当发送方发送一个数据包后，会启动一个定时器。如果在这个定时器到期之前没有收到该数据包对应的确认(ACK)，则认为这个数据包可能已经丢失，并触发重传操作</li></ul></li><li><p>快速恢复：当发送丢包后避免像慢启动那样剧烈地减少拥塞窗口(cwnd)，而是采用一种更加温和的方式调整发送速率，调整cwnd和ssthresh，从而提高整体的发送效率</p></li></ul></li></ul><h3 id="82-HTTP和HTTPS"><a href="#82-HTTP和HTTPS" class="headerlink" title="82. HTTP和HTTPS"></a>82. HTTP和HTTPS</h3><ul><li>HTTP是一种用于在Web浏览器和Web服务器之间传输超文本的应用层协议。它基于请求-响应模型工作，客户端发送一个请求到服务器，服务器处理该请求并返回一个响应</li><li>HTTPS是HTTP的安全版本，通过SSL或TLS加密来保护通信安全。这意味着从客户端到服务器的所有通信都是加密的。</li></ul><p>注意：HTTP作为一种应用层协议，主要用于Web浏览器和Web服务器之间进行信息交换，例如请求网页、提交表单等。它依赖于下面各层提供的服务来保证数据能够正确无误地传输。在实际操作中，HTTP通常使用TCP作为其传输层协议，以确保数据传输的可靠性。</p><p>补：OSI模型(开放系统互联模型)是一个概念性的框架，用于理解不同网络协议如何交互并促进数据在网络上的传输</p><h3 id="83-HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？"><a href="#83-HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？" class="headerlink" title="83. HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？"></a>83. HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？</h3><ul><li><p>HTTPS实际上结合使用了对称加密和非对称加密，以确保数据传输的安全性和效率</p><ul><li>非对称加密主要体现：在TLS的握手阶段，用来安全传输对称加密所需要的密钥</li><li>对称加密主要体现：在真正传输数据阶段，用来加密大量数据通信内容。</li></ul></li><li><p>非对称加密：采用了一对密钥，一个是公开密钥(公钥)，另一个是私有密钥(私钥)。公钥用于加密信息，而私钥则用于解密。</p></li><li><p>对称加密：指的是加密和解密使用相同密钥的方式。这意味着发送方和接收方必须事先共享这个密钥，并且保证其保密性，以确保只有他们能够加密和解密信息。</p></li><li><p>详细流程：</p><ul><li>初始时，服务器有一对密钥(公钥和私钥)，客户端(浏览器)发起 HTTPS 请求</li><li>服务器发送自己的数字证书，里面有公钥(Public Key)</li><li>客户端验证证书的合法性(是否被受信的证书颁发机构 CA 签名过)，合法的话客户端会生成一个“随机对称加密密钥”</li><li>客户端使用服务器公钥<strong>，</strong>加密这个随机对称密钥，发送给服务器</li><li>服务器用自己的私钥解密，拿到这个随机对称密钥</li><li>至此，双方拥有了同一个对称加密密钥，后续数据传输就可以用对称加密了(即通过相同密钥进行加密和解密)</li></ul></li></ul><h3 id="84-HTTP-1-0-和-HTTP-1-1-的主要区别"><a href="#84-HTTP-1-0-和-HTTP-1-1-的主要区别" class="headerlink" title="84. HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 的主要区别"></a>84. HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 的主要区别</h3><ul><li><p>连接方式：</p><ul><li>HTTP&#x2F;1.0：默认短连接，也就是即每次请求和响应之后都会关闭TCP连接。这意味着每个HTTP请求都需要建立一个新的TCP连接，重新三次握手，非常耗时</li><li>HTTP&#x2F;1.1：默认长连接，允许在一个TCP连接中发送多个请求和响应。显著减少了建立和断开TCP连接的开销，提高了效率。</li></ul></li><li><p>请求的改进：HTTP&#x2F;1.0只支持GET、POST、HEAD方法，功能比较简单，HTTP&#x2F;1.1新增了PUT、DELETE、OPTIONS、TRACE等方法，提供了更丰富的交互方式。</p></li><li><p>错误状态码：在版本HTTP&#x2F;1.0的基础上增加了更多的状态码</p></li></ul><p>总结：HTTP&#x2F;1.1 比 HTTP&#x2F;1.0 更快(长连接)、更灵活(更多方法)、更高效(缓存优化、分块传输)，而且支持虚拟主机。</p><h3 id="85-get和post区别"><a href="#85-get和post区别" class="headerlink" title="85. get和post区别"></a>85. get和post区别</h3><p>GET和POST是HTTP协议中最常用的两种请求方法，它们的区别：</p><ul><li><p>作用：GET用于从服务器获取资源，如网页的加载、搜索查询等；而POST主要用于向服务器提交数据</p></li><li><p>数据传输方式：GET是将参数附加在URL后面作为查询字符串发送给服务器，由于URL长度限制，GET请求的数据量有限；POST是通过HTTP请求体发送数据，不在URL中显示，因此它的大小限制主要取决于服务器设置而非URL长度</p></li><li><p>安全性：GET因为参数是暴露在 URL 上的，所以不安全，而POST就相对更安全</p></li><li><p>幂等性：GET被认为是幂等的，即多次执行同样的GET请求应该产生相同的效果，不会对服务器端资源造成影响；而POST不是幂等的，同样的POST请求多次执行可能会导致不同的结果</p></li></ul><h3 id="86-WebSocket-是什么？"><a href="#86-WebSocket-是什么？" class="headerlink" title="86. WebSocket 是什么？"></a>86. WebSocket 是什么？</h3><ul><li>WebSocket是通过HTTP协议来启动连接建立的过程，但一旦握手完成，后续的通信就完全按照WebSocket协议来进行。WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。它让客户端和服务器之间可以建立一个持续的连接，双方都可以随时主动发送数据，不需要每次通信都重新建立连接<ul><li>客户端首先发起一个标准的HTTP请求到服务器，请求中包含特殊的HTTP头部信息，表明这是一个升级为WebSocket协议的请求</li><li>如果服务器支持WebSocket协议，并且愿意接受此次升级请求，则会返回一个HTTP 101状态码。响应中同样包含特定的头部字段来确认升级</li><li>一旦握手成功完成，TCP连接就不再遵循HTTP协议，而是转变为WebSocket协议。此时，双方可以通过这个连接进行双向、实时的数据交换，而无需像传统的HTTP那样每次交互都需要重新建立连接</li></ul></li><li>为什么需要 WebSocket：WebSocket 的出现是为了弥补传统 HTTP 协议在某些场景下的不足，特别是在需要实时通信和低延迟的应用中。HTTP 是一种请求-响应模型，客户端必须主动发起请求，服务器才能返回数据</li></ul><h3 id="87-网络通信模型"><a href="#87-网络通信模型" class="headerlink" title="87. 网络通信模型"></a>87. 网络通信模型</h3><p>两种常见的网络通信模型是五层模型和七层模型</p><ul><li><p>七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p></li><li><p>五层模型：应用层、传输层、网络层、数据链路层、物理层</p></li><li><p>应用层：负责为应用程序提供网络服务接口，包括HTTP、FTP、SMTP等协议</p></li><li><p>传输层：管理端到端的通信会话，确保数据可靠地从一个节点传输到另一个节点。常见的协议有TCP和UDP</p></li><li><p>网络层：负责路由选择和数据包转发，决定数据如何从源地址发送到目的地址。这一层还涉及到逻辑地址(如IP地址)的分配和管理</p></li><li><p>数据链路层：</p></li><li><p>物理层</p></li></ul><p>应用层(应用程序生成数据)—&gt;传输层(头部添加TCP或UDP信息)—&gt;网络层(添加IP头部信息)—&gt;数据链路层(添加MAC头部和尾部信息)—&gt;物理层(讲数据帧转换为电信号或其它形式的信号，通过物理媒介传输到目标设备)</p><h3 id="88-DNS服务器用的是什么协议"><a href="#88-DNS服务器用的是什么协议" class="headerlink" title="88. DNS服务器用的是什么协议"></a>88. DNS服务器用的是什么协议</h3><ul><li><p>DNS服务器(域名系统服务器)是一种提供<code>域名解析服务</code>的服务器。它将域名转换为对应的IP地址，以便计算机能够在互联网上找到并访问目标服务器。</p></li><li><p>DNS服务器大部分使用的是UDP协议，少数情况会使用TCP协议。因为DNS的查询请求数据都比较小，而UDP可以满足，且速度快，开销低。以及DNS查询本身是简单的“请求-应答”模式，也就不需要持续的双向通信，所以在大多数情况下，UDP协议就可以满足，且更高效</p></li><li><p>DNS查询过程：1.当用户尝试访问一个网站时，其设备上的浏览器会首先检查<code>本地缓存</code>是否有该域名对应的IP地址。如果没有，则向预配置的<code>DNS服务器</code>发送查询请求。2.如果本地<code>DNS服务器</code>没有所需的信息，就会代表客户端进行递归查询，向其他<code>权威的DNS服务器</code>询问直到获得答案。3.一旦找到正确的IP地址，这个信息就会沿着查询路径返回给最初的客户端，同时也会被沿途的DNS服务器缓存起来以便未来快速响应类似请求。</p></li></ul><p>补：DNS不仅是一种服务，也是一种协议。DNS协议主要工作在应用层</p><h3 id="89-ping命令用的是什么协议？在哪一层。"><a href="#89-ping命令用的是什么协议？在哪一层。" class="headerlink" title="89. ping命令用的是什么协议？在哪一层。"></a>89. ping命令用的是什么协议？在哪一层。</h3><ul><li>ping命令主要是用来测试连通性、测延迟、诊断网络问题，用的是 ICMP 协议，ICMP是网络层协议(严格来说属于IP层的子协议)。</li><li>过程：当在终端输入 <code>ping www.example.com</code>，系统会先把这个域名解析成IP地址(DNS查询)；然后用ICMP协议构造一个回显请求 报文，发到目标IP；目标主机会回复一个回显应答报文回来；客户端根据收到的回复，显示结果(网络的一些情况)</li></ul><p>补：1.ICMP是没有端口号的，因为端口号是传输层的概念，而ICMP在网络层；2.ping失败常见原因：目标主机关闭了ICMP响应、防火墙拦截了ICMP等；3.ping虽然用的是ICMP协议(在网络层)，但整个处理过程仍然严格遵循五层模型，从应用层开始，从上到下逐层处理，只不过某些层的工作量很轻</p><h3 id="90-如果解析http请求的时候，用户一次性没传完数据，怎么办"><a href="#90-如果解析http请求的时候，用户一次性没传完数据，怎么办" class="headerlink" title="90. 如果解析http请求的时候，用户一次性没传完数据，怎么办"></a>90. 如果解析http请求的时候，用户一次性没传完数据，怎么办</h3><ul><li>在解析 HTTP 请求时，发生这种情况是常见的，特别是在网络不稳定或客户端分块发送数据的情况下。为了解决这个问题，通常需要设计一个渐进式解析器，用于逐步解析流式数据。</li><li>能够在接收到部分数据时就开始解析，并在后续数据到达时继续完成解析过程，而不需要一次性接收全部数据。通过维护内部状态和使用缓冲区保存未完成的数据片段，渐进式解析器可以逐步解析各个部分</li></ul><h3 id="91-路由器"><a href="#91-路由器" class="headerlink" title="91. 路由器"></a>91. 路由器</h3><ul><li><p>路由器是网络层的一个设备，是一种具有多个输入&#x2F;输出端口的专用计算机，其任务是连接不同的网络(异构网络)并完成路由转发。在多个逻辑网络(多个广播域)互联时必须使用路由器</p><ul><li>源主机和目标主机在同一个网络(同一个广播域)时，使用的是直接交付(不需要路由器转发，只是经过路由器)</li><li>源主机和目标主机不在同一个网络时，需要路由器转发(间接交付)</li><li>路由器隔离了广播域(一个广播域就可以称为网络)</li></ul></li><li><p>路由器的两个功能：路由选择和分组转发</p><ul><li>路由选择：根据路由选择协议(不同网络的路由选择协议可能不同，因此选择的方式就不同)构造路由表，同时根据一定的算法来更新和维护路由表。路由选择是规划路线(更新路由表)</li><li>分组转发：分组转发是指当一个数据包到达路由器后，路由器根据已经建立好的路由表，快速查找匹配的出接口和下一跳地址，并将数据包发送出去的过程。分组转发是搬运数据(查路由表发包)</li></ul></li></ul><p>路由表：它包含了一系列规则，帮助确定从一个网络到另一个网络的数据包应该通过哪个接口发送出去以及下一跳应指向哪个网关。当一个数据包到达网络设备时，设备会检查其路由表，寻找与目标IP地址最匹配的路由条目，并依据该条目指定的接口和下一跳地址将数据包转发出去</p><h3 id="92-路由表为空怎么找到下一跳"><a href="#92-路由表为空怎么找到下一跳" class="headerlink" title="92. 路由表为空怎么找到下一跳"></a>92. 路由表为空怎么找到下一跳</h3><ul><li>当路由表为空时，路由器或主机将无法确定如何转发数据包到非本地网络的目的地。如果路由表为空，路由器根本无法找到下一跳，数据包无法转发，一般会直接丢弃数据包，并根据情况返回一个 ICMP (目标不可达)错误给源主机。因此为了避免路由表完全为空，通常会配置一个默认路由，如果查不到详细路由，就把数据包发往默认下一跳。</li></ul><h3 id="93-粘包拆包是什么，发生在哪一层"><a href="#93-粘包拆包是什么，发生在哪一层" class="headerlink" title="93. 粘包拆包是什么，发生在哪一层"></a>93. 粘包拆包是什么，发生在哪一层</h3><p>粘包和拆包都是网络通信中常见的两个现象</p><ul><li><p>粘包：指的是在传输层协议中，由于数据传输机制的原因，多个小的数据包可能会被合并成一个较大的数据包进行发送，或者相反地，单个大的数据包被分割成多个小的数据包发送。因此，在接收方可能无法区分发送方发出的不同消息边界，接收方就需要根据一些方法自行解析这些数据包并进行重组(udpz这种基于消息的协议一般不会出现这种问题)</p><ul><li>发生粘包的原因：1.为了提高网络效率，减少小包的数量，TCP协议栈可能会将多个小的数据片段合并成一个更大的数据包发送。2客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连</li><li>粘包问题通常发生在传输层(如TCP)与应用层之间。虽然它是由于传输层的行为引起的，但是解决这个问题往往需要在应用层实现特定的规则来正确解析接收到的数据流</li></ul></li><li><p>拆包：是当发送的ip数据报太大，超过所支持的最大传输单元，而无法一次性传输时，该数据报会被分割成若干个小的数据片段，每个片段作为一个独立的IP数据报进行传输。目标主机上的IP层负责重新组装这些片段为原始的数据报。</p><ul><li>拆包则是网络层(IP层)的现象</li></ul></li></ul><h3 id="94-TCP在什么情况下会出现大量time-wait"><a href="#94-TCP在什么情况下会出现大量time-wait" class="headerlink" title="94. TCP在什么情况下会出现大量time_wait"></a>94. TCP在什么情况下会出现大量time_wait</h3><ul><li>在高并发短连接的情况下会出现大量的time_wait，即客户端和服务器迅速建立连接，但传输少量数据后就立即关闭，这种情况下大量的并发短连接会导致系统中有大量的<code>TIME_WAIT</code>连接</li></ul><h3 id="95-TCP-建立连接过程，SYN-ACK包能不能拆开来发"><a href="#95-TCP-建立连接过程，SYN-ACK包能不能拆开来发" class="headerlink" title="95. TCP 建立连接过程，SYN + ACK包能不能拆开来发"></a>95. TCP 建立连接过程，SYN + ACK包能不能拆开来发</h3><ul><li>SYN+ACK是一个TCP报文段，它不是两个可以拆开的包，而是一个包中同时设置了 SYN 和 ACK 两个标志位。在规范 TCP 建连流程中，不允许将它们拆分为两个报文发送</li><li>如果拆成两个包会发生什么：客户端会认为这是异常行为，可能丢弃或忽略后续的 <code>ACK</code> 包，客户端可能进入错误状态，导致连接无法正常建立。而且从效率(合并SYN和ACK为一个数据包减少了通信次数)和简化实现考虑，SYN+ACK没有必要拆分来发，也不能这样做</li></ul><h3 id="96-黏包怎么解决？"><a href="#96-黏包怎么解决？" class="headerlink" title="96. 黏包怎么解决？"></a>96. 黏包怎么解决？</h3><ul><li><p>粘包问题是由于TCP是一个流式协议以及它数据传输过程中的一些机制引起的</p><ul><li>TCP是流式协议就意味着，它只保证发送数据的准确性和顺序性，而没有消息边界(TCP并不关心你发送的数据是由多少个独立的消息组成的)</li></ul></li><li><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为TLV协议。</p></li><li><p>这种方法是在每一个要发送的数据内容前面加入一段<strong>固定格式的头部信息</strong>，这段头部通常包括：要发数据的类型和长度。比如说客户端要发送一些业务数据给服务器，在客户端应用层这边会先在这个数据前面加入一个固定大小的头部信息(如5字节，1字节描述类型，剩下4个字节描述长度)；在服务器的应用层先缓存接收到的数据，确保读到完整的头部(5字节)后再解析，了解接下来要收的数据类型，要收多少字节，然后根据记录的长度继续读取剩下的部分。这样就可以解决黏包问题了</p></li></ul><h3 id="97-阻塞和非阻塞-网上两种解释"><a href="#97-阻塞和非阻塞-网上两种解释" class="headerlink" title="97. 阻塞和非阻塞(网上两种解释)"></a>97. 阻塞和非阻塞(网上两种解释)</h3><p>第一种：</p><ul><li>阻塞：指的是当发起一个I&#x2F;O请求后，程序会暂停当前线程的执行，直到该I&#x2F;O操作完成并返回结果为止。在这段时间里，线程处于等待状态，无法执行其他任务</li><li>非阻塞，指的是当发起一个I&#x2F;O请求后，如果I&#x2F;O操作不能立即完成(例如没有数据可读或缓冲区满了)，相应的系统调用(如<code>read()</code>或<code>write()</code>)不会挂起当前线程或进程，而是立刻返回一个错误代码(通常是<code>EAGAIN</code>或<code>EWOULDBLOCK</code>)。这允许应用程序继续执行其他工作，而不是等待I&#x2F;O操作完成。</li></ul><p>第二种：</p><ul><li><p>一个典型的网络IO接口调用，分为两个阶段，分别是<code>数据准备</code>和<code>数据读写</code></p><ul><li><code>数据准备阶段</code>指的是数据到达内核缓冲区或 socket 状态可读&#x2F;可写这一过程。此阶段的阻塞与非阻塞，决定了应用在调用 API 时是等待内核准备数据，还是立即返回由应用自行轮询检查。</li><li><code>数据读写阶段</code>是指从内核缓冲区与用户空间之间的数据传输</li></ul></li><li><p>在数据准备和数据读写阶段，如果fd是阻塞的，应用程序都会阻塞在函数调用处(read)，需要等待内核准备好数据，再将数据从内核缓冲区拷贝到用户空间(应用程序来完成)。如果fd是非阻塞的，在数据准备阶段，应用程序在函数调用处(read)不断返回，进行轮询检测内核的数据有无准备好；在数据读写阶段，应用程序还会阻塞在函数调用处进行数据读取，将数据从内核缓冲区读到用户空间。</p></li></ul><p>补：五种IO模型：阻塞、非阻塞、IO复用、信号驱动(异步+同步)、异步</p><h3 id="98-为什么非阻塞几乎总是和IO复用一起使用"><a href="#98-为什么非阻塞几乎总是和IO复用一起使用" class="headerlink" title="98. 为什么非阻塞几乎总是和IO复用一起使用"></a>98. 为什么非阻塞几乎总是和IO复用一起使用</h3><ul><li><p>单独使用非阻塞模型时，如果在循环中不断进行读取，它会一直忙轮询在函数调用处，这样太浪费CPU资源了</p></li><li><p>单独使用IO复用(默认是阻塞的)不够完善，因为在处理的过程中，像read()、write()等函数都会阻塞当前线程，这样线程就不能及时处理其它socket上的IO事件了(无法及时响应其他事件)</p></li><li><p>因此为了高效管理大量并发连接并避免 CPU 浪费，通常将非阻塞 I&#x2F;O 与 I&#x2F;O 复用结合使用，从而提高效率</p></li></ul><h3 id="99-相比select和poll，为什么epoll更好"><a href="#99-相比select和poll，为什么epoll更好" class="headerlink" title="99. 相比select和poll，为什么epoll更好"></a>99. 相比select和poll，为什么epoll更好</h3><ul><li><p>epoll 相较于 select 和 poll 在处理大量文件描述符(尤其是高并发场景)时表现得更为出色</p></li><li><p>性能优势：</p><ul><li>select和poll每次调用都需要重新扫描整个文件描述符集，随着文件描述符数量的增加，效率显著下降</li><li>epoll则不需要每次都遍历所有注册的文件描述符，它底层是使用一个事件通知机制，当某个描述符有事件触发时，内核会将其添加到就绪队列，最后只需要返回这个就绪队列中的描述符即可，大大提升了效率</li></ul></li><li><p>epoll 在内部使用高效的结构(如红黑树或哈希表)来管理所有注册的文件描述符。这样做的好处是，添加、删除和查找文件描述符的操作都非常高效</p></li><li><p>对于select和poll，每次调用都需要将整个文件描述符集合从用户态复制到内核态，并且在返回时还需要再次复制回用户态。对于频繁的I&#x2F;O操作来说，这会增加系统开销。而epoll不需要这样(底层采用了事件驱动机制和高效的数据结构)</p></li></ul><p>由于上述提到的优点，特别是在处理成千上万个并发连接时，<code>epoll</code> 显示出了明显的优势。它可以有效地管理大规模的文件描述符集合，而不会像 <code>select</code> 和 <code>poll</code> 那样随着文件描述符数量的增长而导致性能急剧下降。</p><h3 id="100-epoll实现原理，epoll使用的哪种模式"><a href="#100-epoll实现原理，epoll使用的哪种模式" class="headerlink" title="100. epoll实现原理，epoll使用的哪种模式"></a>100. epoll实现原理，epoll使用的哪种模式</h3><ul><li><code>epoll</code> 的实现基于事件驱动模型，首先是需要通过epoll_creat()先创建一个epoll实例；再通过epoll_ctl()来控制这个epoll实例上的文件描述符，即对epoll树上的文件描述符进行删除和修改，或添加新的描述符；最后就是通过epoll_wait()等待事件触发</li><li>epoll支持两种工作模式：水平触发(LT)和边沿触发(ET)<ul><li>LT模式：在LT模式下，即使之前没有完全读取所有可用的数据，在后续的epoll_wait调用中，只要仍有数据可读，该文件描述符就会继续被标记为就绪。也就是说在第一次epoll_wait时，没有读完某个fd缓冲区中的数据，在第二次调用epoll_wait时，它还会被标记为就绪的fd来返回</li><li>ET模式：如果应用程序未能在第一次事件触发时读取完所有数据，在没有新的数据到达的情况下，后续的 <code>epoll_wait</code> 调用不会再次报告该文件描述符已就绪</li></ul></li></ul><p>补：</p><ul><li><strong>边沿触发（ET）</strong>：只在状态变化时（如从不可读变为可读）触发一次事件通知。</li><li><strong>非阻塞I&#x2F;O</strong>：当尝试读取或写入操作时，如果当前不能立即完成，则立即返回而不是等待。</li></ul><p>注意：select 和 poll 主要采用一种类似于水平触发的方式工作，它们没有实现像 epoll 那样的边沿触发模式</p><p>补：事件驱动指的是应用程序可以监听多个文件描述符的状态变化(如数据到达、连接请求等)，并在状态变化时得到通知。这与传统的轮询方式不同，后者需要不断检查每个文件描述符的状态，效率较低。</p><h3 id="101-怎么理解IO多路复用机制的"><a href="#101-怎么理解IO多路复用机制的" class="headerlink" title="101. 怎么理解IO多路复用机制的"></a>101. 怎么理解IO多路复用机制的</h3><ul><li>多路复用机制主要用于解决如何高效管理多个I&#x2F;O操作的问题，特别是在处理大量并发连接时。其核心思想是通过一个线程或进程同时监控多个文件描述符(如网络套接字)，以确定哪些描述符事件触发，可以进行读写操作。</li></ul><h3 id="102-select和poll底层实现"><a href="#102-select和poll底层实现" class="headerlink" title="102. select和poll底层实现"></a>102. select和poll底层实现</h3><ul><li>select底层实现是通过 <code>select()</code> 向内核传递三个 fd 集合（<code>readfds</code>, <code>writefds</code>, <code>exceptfds</code>），本质上是三个大小固定的位图。内核会遍历所有传入的文件描述符，检查是否有就绪事件，如果没有事件，线程会被挂起，如果有事件发送，内核在返回前会修改传入的 fd 集合，清除未就绪的 fd。而poll和select类似，但底层实现是维护一个pollfd结构体组成的数组或链表</li><li>但由于 poll 不受固定大小的限制，因此在某些情况下可能比 <code>select</code> 更加灵活和适用。然而，对于非常大量的文件描述符，这两种方法都不是最高效的解决方案，这时通常推荐使用 <code>epoll</code> 等更高级的I&#x2F;O多路复用机制</li></ul><h3 id="103-select为什么只能支持1024个？poll和epoll是怎么解决这个问题的"><a href="#103-select为什么只能支持1024个？poll和epoll是怎么解决这个问题的" class="headerlink" title="103. select为什么只能支持1024个？poll和epoll是怎么解决这个问题的"></a>103. select为什么只能支持1024个？poll和epoll是怎么解决这个问题的</h3><ul><li>因为select底层是通过大小固定的位图来实现的，这些位图并且受限于系统定义的最大值(通过一个宏)，所以就限制了select可以处理的文件描述符数量。而poll底层是使用一个结构体数组或链表来存储fd以及关心的事件，所以理论上可以根据需要支持任意数量的文件描述符。而epoll底层则是根据红黑树，通过事件驱动设计，不仅解决了文件描述符的数量限制，还显著提高了在高并发场景下的性能表现</li></ul><h3 id="104-epoll底层为什么用红黑树不用hash"><a href="#104-epoll底层为什么用红黑树不用hash" class="headerlink" title="104. epoll底层为什么用红黑树不用hash"></a>104. epoll底层为什么用红黑树不用hash</h3><ul><li>支持高效的插入&#x2F;删除&#x2F;查找：红黑树保证了 O(log n) 时间复杂度的插入、删除和查找操作；虽然哈希表在理想情况下可以达到 O(1) 的查找时间，但这是基于理想的哈希函数和低碰撞率的前提下的。在实际应用中，处理哈希冲突可能会影响性能，并且哈希表的扩容和重组操作也可能带来额外的开销</li><li>稳定性和可预测性：红黑树提供了更加稳定和可预测的时间复杂度，这对于系统级别的编程尤其重要。尽管哈希表平均情况下表现优异，但在最坏情况下(例如大量哈希冲突)，其性能可能会大幅下降。对于像 <code>epoll</code> 这样的底层机制，确保一致的性能表现是至关重要的。</li></ul><h3 id="105-Qt中的信号与槽机制，说明其原理及使用场景"><a href="#105-Qt中的信号与槽机制，说明其原理及使用场景" class="headerlink" title="105. Qt中的信号与槽机制，说明其原理及使用场景"></a>105. Qt中的信号与槽机制，说明其原理及使用场景</h3><ul><li>信号与槽是Qt开发当中最核心的机制。用于实现对象之间的通信。当某个事件发生时，对象会发出一个信号，而槽是对信号的响应函数。一个信号可以连接多个槽，多个信号也可以连接同一个槽。信号和槽的连接是通过QObject类里面的connect()函数完成的，当信号一触发，与它连接的槽就会被自动调用。</li><li>使用场景：<ul><li>图形用户界面(GUI)开发：按钮点击事件处理、菜单项选择、定时器事件</li><li>事件驱动的多模块通信：不同窗口或组件之间的状态同步、跨模块事件通知</li></ul></li></ul><h3 id="106-请讲述Qt的元对象系统，主要有哪些组成部分和作用"><a href="#106-请讲述Qt的元对象系统，主要有哪些组成部分和作用" class="headerlink" title="106. 请讲述Qt的元对象系统，主要有哪些组成部分和作用"></a>106. 请讲述Qt的元对象系统，主要有哪些组成部分和作用</h3><ul><li><p>主要由三个部分组成：QObject类、元对象编译器(MOC)、信号与槽机制</p></li><li><p>作用：</p><ul><li>提供信号与槽机制，实现对象之间的安全通信、高效通信</li><li>事件处理：更灵活地管理事件的分发和处理流程(自定义事件的处理，这通常涉及重写 event() 方法或特定事件处理函数)</li></ul></li></ul><h3 id="107-Qt框架当中，有哪些布局管理器？使用场景？"><a href="#107-Qt框架当中，有哪些布局管理器？使用场景？" class="headerlink" title="107. Qt框架当中，有哪些布局管理器？使用场景？"></a>107. Qt框架当中，有哪些布局管理器？使用场景？</h3><ul><li>水平布局：常用于将多个部件水平排列(从左到右)</li><li>垂直布局：常用于将多个部件垂直排列(从上到下)</li><li>网格布局：常用于创建表单或矩阵形式的布局</li></ul><h3 id="108-阐述一下Qt中的事件处理机制，如何自定义事件处理？"><a href="#108-阐述一下Qt中的事件处理机制，如何自定义事件处理？" class="headerlink" title="108. 阐述一下Qt中的事件处理机制，如何自定义事件处理？"></a>108. 阐述一下Qt中的事件处理机制，如何自定义事件处理？</h3><p>事件处理机制是Qt开发中核心特性之一，可以通过灵活的方式来管理和响应标准事件(如鼠标移动、点击、键盘输入等)。这些事件可以由用户交互(如鼠标点击、键盘输入)、系统通知(如定时器到期)产生，过程如下：</p><ul><li><p>事件：在 Qt 中，事件是由 <code>QEvent</code> 类及其子类表示的对象。每个事件对象都有一个类型标识符（<code>type()</code>），用于区分不同种类的事件，比如鼠标事件、键盘事件、定时器事件等。</p></li><li><p>事件分发器：Qt 应用程序运行在一个事件循环中，这个循环不断地从系统的事件队列中取出事件，并将它们分发给相应的对象进行处理。事件分发通常通过 <code>QCoreApplication::exec()</code> 或 <code>QApplication::exec()</code> 启动。</p></li><li><p>事件接收者：事件被分发到具体的 <code>QObject</code> 子类对象上，这些对象负责处理事件。如果某个对象不处理特定类型的事件，则该事件会被转发给其父对象，直到找到一个能够处理该事件的对象或最终被丢弃。</p></li><li><p>Qt中的事件处理是基于事件循环和事件队列。事件首先会加入到事件队列当中，然后由事件循环不断的从事件队列中取出事件，并且根据事件的类型分发给相应的对象器处理。每一个通过QOject派生出来的类，它都可以重写事件处理函数来自定义事件的响应逻辑。同时支持事件过滤和自定义事件的发送，实现了灵活、高效的事件驱动编程模型。</p></li><li><p>自定义事件处理：</p><ul><li>1.创建自定义事件类：继承QEvent并定义一个事件类型，在构造函数中添加需要传递的数据</li><li>2.发送事件：使用 <code>QApplication::sendEvent()</code> 同步发送事件，或使用 <code>QApplication::postEvent()</code> 异步发送事件到指定的目标对象。</li><li>3.处理事件：在目标对象中重写 <code>event()</code> 方法来捕获并处理自定义事件。在该方法中需要检查事件类型，如果是自定义事件类型，则进行相应的处理逻辑。</li></ul></li></ul><p>补：自定义事件处理：涉及创建新的事件类型，并且这些事件不是由系统自动产生的，而是由应用程序自身根据需要手动创建和发送的。</p><h3 id="109-Qt的内存管理机制？与传统C-内存管理区别？"><a href="#109-Qt的内存管理机制？与传统C-内存管理区别？" class="headerlink" title="109. Qt的内存管理机制？与传统C++内存管理区别？"></a>109. Qt的内存管理机制？与传统C++内存管理区别？</h3><ul><li><p>Qt内存管理机制：采用基于对象树的内存管理方式。在创建一个QObject派生类对象的时候，如果这个对象的父对象被指定了，那么该对象会被添加到父对象的子对象列表中，当父对象被销毁的时候，它会自动销毁其所有的子对象，确保这些子对象所占用的资源也被释放，这样就可以避免内存泄漏的问题。这种机制它能够使得内存管理更加的自动化和方便</p></li><li><p>区别：</p><ul><li>手动内存管理和自动管理：传统C++的内存管理主要是通过手动new和delete来分配和释放；而Qt是通过父子关系和智能指针来处理的，很多情况下都可以自动管理</li><li>对象生命周期管理的便捷性：传统C++中管理对象的生命周期较复杂，比如说一个复杂的系统，需要设计类的构造函数和析构函数，并确保对象在正确的时间被创建和销毁；Qt通过父子关系简化了对象生命周期的管理。只要正确设置了父子关系，对象的生命周期就会自动被管理。这种层次结构使得对象生命周期管理更加直观和易于理解，减少了人为错误的可能性</li></ul></li></ul><h3 id="110-Qt如何实现多线程？阐述QThread的基本流程"><a href="#110-Qt如何实现多线程？阐述QThread的基本流程" class="headerlink" title="110. Qt如何实现多线程？阐述QThread的基本流程"></a>110. Qt如何实现多线程？阐述QThread的基本流程</h3><ul><li><p>在Qt中，实现多线程主要有两种方式，一种是继承QThread类并重写其run()函数；另一种是使用Qt的线程池QThraedPool结合QRunnable类</p></li><li><p>QThread的基本流程：</p><ul><li>创建一个新类，即子线程类，让其继承QT中的线程类QThread</li><li>在新类中重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程</li><li>在主线程或其它合适的位置创建子线程对象，new 一个就可以了</li><li>调用该实例对象的start()方法，启动子线程</li><li>当子线程执行完毕或不再需要时，可以调用quit()</li></ul></li></ul><h3 id="111-在qt中使用了多线程，有些事项是需要额外注意的："><a href="#111-在qt中使用了多线程，有些事项是需要额外注意的：" class="headerlink" title="111. 在qt中使用了多线程，有些事项是需要额外注意的："></a>111. 在qt中使用了多线程，有些事项是需要额外注意的：</h3><ul><li>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</li><li>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</li><li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制(即如果子线程需要对窗口的数据进行修改，只能先通过connect发送给主线程，由主线程对窗口进行修改，而子线程不能直接对窗口进行修改)。</li></ul><h3 id="112-Qt中图形绘制的基本原理及常用的绘图类"><a href="#112-Qt中图形绘制的基本原理及常用的绘图类" class="headerlink" title="112. Qt中图形绘制的基本原理及常用的绘图类"></a>112. Qt中图形绘制的基本原理及常用的绘图类</h3><ul><li><p>原理：图形绘制是指通过在绘图设备上使用绘图工具进行图形的绘制。绘图设备可以是窗口部件(QWidget&#x2F;QMainWindow等)、图片对象(QPixmap&#x2F;QImage等)。绘制过程通常在部件的painEvent()函数中进行，当部件窗口需要重绘的时候，painEvent()函数会被自动调用。</p></li><li><p>常用的绘图类：1.QPainter类(最基本也是最常用)用于绘制基本形状、文本等；2.QBrush类用于设置填充图案；3.QPen类用于设置线条样式</p></li><li><p>手动重绘两种方法：</p><ul><li><p>update() ：它不会立即导致重绘，而是将一个绘制事件加入到事件队列中，</p><ul><li>优点：性能较好多次调用 <code>update()</code>，Qt只会生成一个 <code>paintEvent()</code>，这有助于减少不必要的绘制操作</li><li>缺点：不是立即刷新，可能有视觉延迟。如果更新太频繁，可能导致部分更新被合并而丢失中间状态</li></ul></li><li><p>repaint()：立即调用 <code>paintEvent()</code>，强制立即重绘(不建议使用)。</p><ul><li><p>优点：立即刷新，画面更新无延迟，适合实时性要求高的场景</p></li><li><p>性能差，多次调用 <code>repaint()</code> 会导致多次重绘，浪费资源</p></li></ul></li></ul></li></ul><h3 id="113-Qt的模型视图架构及优点-不懂"><a href="#113-Qt的模型视图架构及优点-不懂" class="headerlink" title="113. Qt的模型视图架构及优点(不懂)"></a>113. Qt的模型视图架构及优点(不懂)</h3><h3 id="114-Qt中如何进行文件读写操作"><a href="#114-Qt中如何进行文件读写操作" class="headerlink" title="114. Qt中如何进行文件读写操作"></a>114. Qt中如何进行文件读写操作</h3><ul><li><p>在 Qt 中进行文件读写操作可以通过多种方式实现，主要就是使用 <code>QFile</code>类 、 <code>QTextStream</code> 类和 <code>QDataStream</code>类来完成的</p><ul><li>单独使用 QFile：可以进行基本的文件读写操作，但处理复杂的数据结构(如文本、数字、对象等)会比较繁琐</li><li>QFile结合QTextStream：非常适合处理文本数据，能够简化文本文件的读写操作</li><li>QFile结合QDataStream：适用于处理二进制数据</li></ul></li><li><p>使用：创建一个Qfile对象，主要是用它来打开和关闭文件，也可以直接基于Qfile对象调用读写函数来进行读写，但常用的还是将它结合QTextStream和QDataStream这两个类来使用，具体使用方法就是将Qfile对象作为参数传给QTextStream和QDataStream的对象，然后基于它们的对象进行读写</p></li></ul><h3 id="115-Qt开发中，如何实现应用程序的国际化支持，讲述其步骤"><a href="#115-Qt开发中，如何实现应用程序的国际化支持，讲述其步骤" class="headerlink" title="115. Qt开发中，如何实现应用程序的国际化支持，讲述其步骤"></a>115. Qt开发中，如何实现应用程序的国际化支持，讲述其步骤</h3><h3 id="116-Proactor模式和Reactor模式"><a href="#116-Proactor模式和Reactor模式" class="headerlink" title="116.Proactor模式和Reactor模式"></a>116.Proactor模式和Reactor模式</h3><ul><li>Proactor 模式和 Reactor 模式是两种不同的事件处理模型，主要用于处理并发网络操作</li><li>Proactor模式(前摄器模式)是一种异步 I&#x2F;O 模型。应用程序会启动相应的异步操作，当 I&#x2F;O 操作完成后，由内核或操作系统通知应用程序进行结果处理。Boost.Asio 中的异步操作就是采用这种模式工作的<ul><li>应用程序发起异步操作，操作系统开始执行这个异步 I&#x2F;O</li><li>当 I&#x2F;O 完成，操作系统通知应用程序(如读&#x2F;写完成事件)</li><li>应用程序只处理完成事件的后续操作，而不需要主动读写</li></ul></li><li>Reactor模式(反应堆模式)是一种同步 I&#x2F;O 模型。应用程序注册监听事件，当事件就绪时，操作系统通知应用程序，再由程序负责处理这个事件(包括读写)<ul><li>应用程序注册事件(如读、写)到 Reactor(事件多路复用器，如 <code>epoll</code>、<code>select</code>)</li><li>当 I&#x2F;O 就绪时，Reactor 被触发，并调用注册的回调函数(事件处理器)</li><li>应用程序就进行读写操作</li></ul></li></ul><p>补：同步和异步(关注谁来执行和等结果)，同步是指调用方等待操作完成才能继续执行，操作完成的过程由调用者自己等待和处理；异步是指调用方不等待操作完成，而是立即返回，等完成后再被通知</p><p>阻塞和非阻塞(关注程序是否挂起)，阻塞是指当执行 I&#x2F;O 时，如果数据没准备好，程序就会挂起等待结果；非阻塞是指执行I&#x2F;O操作时会立即返回，不管数据准备好没，程序可以继续执行其他操作。</p><h3 id="117-如果一个程序中申明了多个命名空间，会有什么隐患"><a href="#117-如果一个程序中申明了多个命名空间，会有什么隐患" class="headerlink" title="117.如果一个程序中申明了多个命名空间，会有什么隐患"></a>117.如果一个程序中申明了多个命名空间，会有什么隐患</h3><ul><li>可能会造成命名空间的污染，因为多个命名空间里面可能包含相同的内容(API)，比如说智能指针等</li></ul><h3 id="118-boost-asio进行网络编程的流程"><a href="#118-boost-asio进行网络编程的流程" class="headerlink" title="118. boost.asio进行网络编程的流程"></a>118. boost.asio进行网络编程的流程</h3><ul><li><p>对于服务端：</p><ul><li>创建io_context和网络端点endpoint，io_context是负责管理异步操作、事件循环的，而网络端点是定义本机ip和端口的</li><li>创建接收器acceptor，它是基于刚刚创建的io_context和网络端点来初始化的接收器对象</li><li>创建一个套接字socket，它是基于io_context初始化的，当与客户端连接成功后，该套接字就负责与新连接进行通信</li><li>这些都创建好后，就通过接收器对象调用accept(socket)函数来进行监听连接</li></ul></li><li><p>对于客户端：</p><ul><li>创建io_context和网络端点endpoint，网络端点定义的是要连接服务端的IP和端口</li><li>创建socket套接字，基于io_context来初始化的</li><li>通过套接字对象调用connect(endpoint)函数来向服务端发起请求</li></ul></li><li><p>连接成功后，客户端和服务端都可以通过各自的 <code>tcp::socket</code> 对象来进行数据的发送和接收。</p></li></ul><h3 id="119-Protobuf和JSON"><a href="#119-Protobuf和JSON" class="headerlink" title="119. Protobuf和JSON"></a>119. Protobuf和JSON</h3><ul><li><p>Protobuf和 JSON都是用于数据序列化和反序列化的工具</p></li><li><p>在网络编程中，尤其是使用像TCP这样的流协议时，直接发送结构体可能会出现问题，这时就需要将结构体序列化为某种格式的数据(如文本或二进制)，以便于在网络上传输。Protobuf 和 JSON 是两种非常流行的解决方案，它提供了高效且跨平台的数据序列化机制，非常适合用于网络通信中的数据交换</p></li><li><p>protobuf流程：</p><ul><li>定义消息格式：通过 <code>.proto</code> 文件定义消息格式。</li><li><pre><code class="c++">syntax = &quot;proto3&quot;;message Book&#123;   string name = 1;   int32 pages = 2;   float price = 3;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ 编译 `.proto` 文件：使用 `protoc` 编译器将 `.proto` 文件编译为目标语言的代码(如 C++, Java, Python 等)。</span><br><span class="line">+ 序列化/反序列化：使用生成的代码进行数据的序列化和反序列化操作。</span><br><span class="line">+ ```c++</span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">      Book book;</span><br><span class="line">      book.set_name(&quot;CPP programing&quot;);</span><br><span class="line">      book.set_pages(100);</span><br><span class="line">      book.set_price(200);</span><br><span class="line">      std::string bookstr;</span><br><span class="line">      book.SerializeToString(&amp;bookstr);              //序列化</span><br><span class="line">      std::cout &lt;&lt; &quot;serialize str is &quot; &lt;&lt; bookstr &lt;&lt; std::endl;</span><br><span class="line">      Book book2;</span><br><span class="line">      book2.ParseFromString(bookstr);                //反序列化</span><br><span class="line">      std::cout &lt;&lt; &quot;book2 name is &quot; &lt;&lt; book2.name() &lt;&lt; &quot; price is &quot; </span><br><span class="line">          &lt;&lt; book2.price() &lt;&lt; &quot; pages is &quot; &lt;&lt; book2.pages() &lt;&lt; std::endl;</span><br><span class="line">      getchar();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>JSON流程：</p><ul><li><p>构造一个JSON::value节点</p></li><li><p>通过这个节点编写要发送的数据(类似于key-value的形式)，然后通过toStyledString将该节点序列化为文本格式的字符串</p></li><li><p>发送序列化的字符串给对端，发送之前为了防止粘包先要发送序列化后的数据长度，还要将本地字节序转化为网络字节序</p></li><li><pre><code class="c++">int main()&#123;    Json::Value root;    root[&quot;id&quot;] = 1001;    root[&quot;data&quot;] = &quot;hello world&quot;;    std::string request = root.toStyledString();           //序列化    std::cout &lt;&lt; &quot;request is &quot; &lt;&lt; request &lt;&lt; std::endl;    Json::Value root2;    Json::Reader reader;    reader.parse(request, root2);            //反序列化    std::cout &lt;&lt; &quot;msg id is &quot; &lt;&lt; root2[&quot;id&quot;] &lt;&lt; &quot; msg is &quot; &lt;&lt; root2[&quot;data&quot;] &lt;&lt; std::endl;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ Protobuf 序列化后的数据是以二进制形式存在的。这种格式非常紧凑，因此相比于文本格式(如 JSON)，它占用更少的带宽，并且在序列化和反序列化过程中通常更快。由于它是二进制的，所以对人类来说不易读，但在机器处理上效率很高。protobuf方式会经常用来处理服务器与服务器之间的通信(服务之间的调用)</span><br><span class="line">  </span><br><span class="line">  + 优点：体积小、传输快；</span><br><span class="line">  + 缺点：不可读性</span><br><span class="line">  </span><br><span class="line">+ JSON 序列化后的数据是一种文本格式，易于人阅读和编写，同时也易于机器解析和生成。JSON 数据以文本字符串的形式存在，这使得它非常适合用于调试和快速开发。json序列化方式经常用来做客户端和服务器之间的通信</span><br><span class="line">  + 优点：可读性好、灵活性高(无需预先定义数据结构，适合快速迭代开发)</span><br><span class="line">  + 缺点：效率低</span><br><span class="line"></span><br><span class="line">### 120. boost.asio里面除了使用线程来完成并发操作，还有其它方法吗</span><br><span class="line"></span><br><span class="line">+ 还可以使用协程来完成并发操作。协程是一种“可以暂停执行”的函数，当遇到一个异步操作时(如 `async_read_some`)，协程可以挂起自己，并释放当前的资源，待异步操作完成后，自动恢复执行</span><br><span class="line">+ 优点：协程调度比线程调度更轻量化，因为协程是运行在用户空间的，而线程可能涉及用户空间和内核空间切换</span><br><span class="line"></span><br><span class="line">+ co_spawn：启动一个协程任务，绑定到某个执行器上运行。如：co_spawn(io_context, listener(), detached)</span><br><span class="line">+ co_await：挂起协程，等待异步操作完成</span><br><span class="line">+ use_awaitable：告诉 Asio 异步操作应该以协程方式处理</span><br><span class="line"></span><br><span class="line">### 121. 两者并发设计模式actor和CSP</span><br><span class="line"></span><br><span class="line">+ actor模式是通过消息传递的方式来处理并发问题的，它的好处就是可以消除共享状态，而不用考虑锁机制。比如说多个线程想要访问同一个共享资源(读和写)，就可以设计一个专门用于管理对该共享资源的逻辑类，就将所有线程对该共享资源的访问请求封装成任务并发送给这个逻辑类中的队列，逻辑类就负责依次从队列中取出任务并安全的处理这些请求，处理完一个请求就返回结果给对应的线程</span><br><span class="line">+ CSP和Actor类似，只不过CSP将消息投递给channel，不关注谁从channel中取数据和发送的一方是谁。而Actor在发送消息前是知道接收方是谁，接受方收到消息后也知道发送方是谁，更像是邮件的通信模式。而csp是完全解耦合的。</span><br><span class="line"></span><br><span class="line">总结：但它们有一个共同的特性：**要通过共享内存来通信，而是通过通信来共享内存**</span><br><span class="line"></span><br><span class="line">### 122. Qt如何建立与数据库的连接</span><br><span class="line"></span><br><span class="line">+ 安装ODBC驱动程序，并配置好了数据源</span><br><span class="line"></span><br><span class="line">+ 创建数据库表，在Qt项目文件(`.pro`)中添加了`QT += sql`，以便链接Qt的SQL库</span><br><span class="line"></span><br><span class="line">+ 在Qt中加入相关头文件，使用`QSqlDatabase::addDatabase()`方法并指定&quot;QODBC&quot;作为驱动名称来创建一个新的数据库连接</span><br><span class="line"></span><br><span class="line">+ 然后配置连接参数，如数据库名称、主机名、端口、用户名和密码等。</span><br><span class="line"></span><br><span class="line">  + ```c++</span><br><span class="line">    // 创建数据库连接</span><br><span class="line">    QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</span><br><span class="line">    db.setHostName(&quot;localhost&quot;);  // 数据库主机地址</span><br><span class="line">    db.setDatabaseName(&quot;your_database_name&quot;);  // 数据库名称</span><br><span class="line">    db.setUserName(&quot;your_username&quot;);  // 数据库用户名</span><br><span class="line">    db.setPassword(&quot;your_password&quot;);  // 数据库密码</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>一旦连接成功打开，你就可以使用<code>QSqlQuery</code>对象来执行SQL语句，对数据库进行查询或修改。</p></li></ul><h3 id="123-qt如何执行SQL语句，有哪些不同执行方法"><a href="#123-qt如何执行SQL语句，有哪些不同执行方法" class="headerlink" title="123. qt如何执行SQL语句，有哪些不同执行方法"></a>123. qt如何执行SQL语句，有哪些不同执行方法</h3><ul><li><p>对于不带参数的简单SQL语句，可以直接通过<code>QSqlQuery</code>对象调用<code>exec()</code>方法来执行。</p></li><li><p>也可以使用绑定值执行带有参数的查询，通过<code>QSqlQuery</code>对象的prepare()函数来完成，最后调用<code>exec()</code>方法来执行</p></li></ul><h3 id="124-Qt中执行数据库操作出现错误，如何获取和处理错误"><a href="#124-Qt中执行数据库操作出现错误，如何获取和处理错误" class="headerlink" title="124. Qt中执行数据库操作出现错误，如何获取和处理错误"></a>124. Qt中执行数据库操作出现错误，如何获取和处理错误</h3><ul><li>每次通过<code>QSqlQuery</code>对象调用exec()执行sql语句后，检查其返回状态，如果有异常，就可以通过执行query.lastError().text();来获取详细的错误信息。</li></ul><h3 id="125-Qt支持哪些常见的数据库驱动"><a href="#125-Qt支持哪些常见的数据库驱动" class="headerlink" title="125. Qt支持哪些常见的数据库驱动"></a>125. Qt支持哪些常见的数据库驱动</h3><ul><li>Qsqlite、Qmysql、Qodbc、Qpsql</li><li>使用上述任何一个数据库驱动，需要确保相应的Qt模块已经安装，并在项目的<code>.pro</code>文件中添加适当的配置</li></ul><h3 id="126-什么是数据库连接池？在Qt中是否有内置的数据库连接池功能"><a href="#126-什么是数据库连接池？在Qt中是否有内置的数据库连接池功能" class="headerlink" title="126. 什么是数据库连接池？在Qt中是否有内置的数据库连接池功能"></a>126. 什么是数据库连接池？在Qt中是否有内置的数据库连接池功能</h3><ul><li>数据库连接池是一种用于管理数据库连接的技术，它通过预先创建一定数量的数据库连接并将其保存在一个池中，以便在应用程序需要执行数据库操作时能够快速获取一个可用的连接，用完后又放回池中。这可以显著减少每次请求数据库连接所需的时间，从而提高应用性能和响应速度</li><li>没有，需要自己实现</li></ul><h3 id="127-在qt中，show-和exec-函数的区别"><a href="#127-在qt中，show-和exec-函数的区别" class="headerlink" title="127. 在qt中，show()和exec()函数的区别"></a>127. 在qt中，show()和exec()函数的区别</h3><ul><li>函数功能都用于显示窗口，但本质不同，show()函数是一种非模态显示方式(QWidget、QMainWindow、QDialog等)；exec()函数是一种模态事件循环显示方式(阻塞当前代码执行)</li><li>返回值区别：show()函数没有返回值；exec()函数有返回值</li><li>事件处理区别：使用show()显示窗口之后，可以接收和处理事件，同时程序的其它部分也可以运行；执行exec()后，则会启动一个局部的事件循环，专门用于处理本模态对话框事件，在没有关闭之前，其它窗口的事件处理会受到限制</li></ul><h3 id="128-C-中有栈溢出的情况怎么解决"><a href="#128-C-中有栈溢出的情况怎么解决" class="headerlink" title="128. C++中有栈溢出的情况怎么解决"></a>128. C++中有栈溢出的情况怎么解决</h3><ul><li>检查递归调用是否有明确的退出条件、通过尾递归优化来优化程序、减少局部变量的使用，需要动态分配内存的情况，尽量使用智能指针或容器</li></ul><h3 id="129-数据库中的一对一，一对多，多对多的关系能具体讲一下吗"><a href="#129-数据库中的一对一，一对多，多对多的关系能具体讲一下吗" class="headerlink" title="129. 数据库中的一对一，一对多，多对多的关系能具体讲一下吗"></a>129. 数据库中的一对一，一对多，多对多的关系能具体讲一下吗</h3><ul><li>一对一关系：指的是两个实体之间存在一种相互唯一对应的关系，如每个人只能有一个护照，每个护照也只属于一个人</li><li>一对多关系：表示一个实体可以关联到多个其他实体，但反过来，那些实体各自仅能关联到一个前者，如一个作者可以写多本书，但每本书只能由一个作者撰写</li><li>多对多关系意味着任何一方都可以关联到另一方的多个实例，如一个学生可以选择多门课程，一门课程也可以被多名学生选择</li></ul><h3 id="130-模板和模板特化"><a href="#130-模板和模板特化" class="headerlink" title="130. 模板和模板特化"></a>130. 模板和模板特化</h3><ul><li><p>模板是指在定义函数或类的时候，不需要指定具体的数据类型，在使用时再由编译器根据上下文自动推断</p></li><li><p>模板特化在C++中主要用于为特定的数据类型提供专门的实现，从而优化性能、处理特殊情况或解决通用模板无法解决的问题。如打印<code>std::vector&lt;int&gt;</code>类型的值，默认实现可能不会给出你想要的结果(比如，它可能只是打印出一些内存地址而不是向量的内容)。这时可以通过模板特化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板特化实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> print&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#123; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="131-假如你的代码在多线程环境下出现崩溃的现象，怎么去解决"><a href="#131-假如你的代码在多线程环境下出现崩溃的现象，怎么去解决" class="headerlink" title="131. 假如你的代码在多线程环境下出现崩溃的现象，怎么去解决"></a>131. 假如你的代码在多线程环境下出现崩溃的现象，怎么去解决</h3><ul><li>可能是竞态条件、死锁、非法内存访问、资源泄漏等问题引起。</li><li>可以在容易出错的代码处打印日志，通过调试工具看有无执行到该处，特别是要检查锁、条件变量的使用是否正确；确保每次调用 <code>new</code> 或 <code>malloc</code> 都有相应的 <code>delete</code> 或 <code>free</code> 来释放内存</li></ul><h3 id="132-解释一下这两个关键字Static，volatile"><a href="#132-解释一下这两个关键字Static，volatile" class="headerlink" title="132. 解释一下这两个关键字Static，volatile"></a>132. 解释一下这两个关键字Static，volatile</h3><ul><li><p><strong><code>static</code></strong> 主要影响变量或函数的作用域和生命周期</p><ul><li>静态局部变量：当应用于函数内部的变量时，它使得该变量在整个程序运行期间都存在（而不是每次函数调用时创建并销毁），但其作用域仅限于定义它的函数内</li><li>静态全局变量&#x2F;函数：主要是限制它们的作用域在声明所在的源文件中</li><li>静态成员变量&#x2F;函数：<code>static</code>成员属于类本身而非任何对象实例，所有对象共享同一份副本</li></ul></li><li><p><strong><code>volatile</code></strong> 主要用于告诉编译器不要对该变量进行优化，它可能在程序之外被修改(如硬件中断、另一个线程等)。这确保了每次访问<code>volatile</code>变量时都会从内存中读取最新的值，而不是使用缓存或寄存器中的旧值。</p></li></ul><h3 id="133-分治和贪心这两种算法思想"><a href="#133-分治和贪心这两种算法思想" class="headerlink" title="133. 分治和贪心这两种算法思想"></a>133. 分治和贪心这两种算法思想</h3><ul><li><p><code>分治算法</code>的基本思想是将一个问题分解成若干个规模更小的子问题，递归地解决这些子问题，然后合并这些子问题的解以获得原问题的解(分解-解决-合并)。如归并排序和快速排序</p></li><li><p><code>贪心算法</code>的基本思想是在每个决策点上做出在当前看来最优的选择，希望通过一系列这样的局部最优解能够得到全局最优解。这种方法并不总是能得到全局最优解，但对于某些特定问题却是有效的。如最小生成树和背包问题</p></li></ul><p>总结：分治算法侧重于将问题分解为独立的子问题，并通过解决子问题间接解决问题，适用于那些可以通过分解简化的问题；贪心算法则强调每一步都做出最佳选择，试图通过一系列局部最优解达到全局最优解，但其有效性依赖于具体问题结构。</p><h3 id="134-Mysql-和-Redis"><a href="#134-Mysql-和-Redis" class="headerlink" title="134. Mysql 和 Redis"></a>134. Mysql 和 Redis</h3><h3 id="135-在C-中创建一个类对象在C-的内存分布是什么样的"><a href="#135-在C-中创建一个类对象在C-的内存分布是什么样的" class="headerlink" title="135. 在C++中创建一个类对象在C++的内存分布是什么样的"></a>135. 在C++中创建一个类对象在C++的内存分布是什么样的</h3><ul><li>在C++中创建一个类对象时，其内存分布主要取决于类的成员变量(包括静态成员和非静态成员)、继承层次结构以及是否有虚函数等因素<ul><li>非静态成员变量：直接存储在类对象的内存空间中。它们按照声明顺序排列，但编译器可能会为了对齐目的插入填充字节以满足特定硬件平台上的对齐要求</li><li>静态成员变量：静态成员变量不属于任何具体对象实例，而是属于整个类本身。因此，它们不占用类对象实例的内存空间，而是单独存储在全局数据区或静态数据区中</li><li>当一个类从另一个类派生时，基类的成员变量会被包含在派生类的对象中</li><li>如果一个类定义了虚函数，那么该类的对象通常会包含一个隐藏的指向虚函数表的指针(虚函数指针)。这个指针指向一个包含该类及其基类虚函数地址的表(虚函数表)</li></ul></li></ul><h3 id="136-C-中使用new创建一个类对象过程是怎么样的"><a href="#136-C-中使用new创建一个类对象过程是怎么样的" class="headerlink" title="136. C++中使用new创建一个类对象过程是怎么样的"></a>136. C++中使用new创建一个类对象过程是怎么样的</h3><ul><li>使用 <code>new</code> 创建类对象的过程主要包括三个主要阶段：内存分配、构造函数调用以及返回指向新对象的指针<ul><li>当你使用 <code>new</code> 来创建一个对象时，首先会在自由存储区（通常称为堆）上为该对象分配足够的内存空间。所需的空间大小取决于类定义中的成员变量以及是否包含虚函数等因素</li><li>一旦分配了足够的内存，接下来会调用相应的构造函数来初始化这块内存</li><li><code>new</code> 表达式最后返回一个指向新创建对象的指针</li></ul></li></ul><h3 id="137-斗地主项目"><a href="#137-斗地主项目" class="headerlink" title="137. 斗地主项目"></a>137. 斗地主项目</h3><ul><li>这个项目模拟了斗地主的整个过程，从发牌、叫地主、出牌到游戏结算，其中叫地主和出牌阶段，回创建子线程来模拟两个机器人玩家的行为，结合信号与槽机制实现各玩家之间的交互</li></ul><p>桌面布局：首先是每次启动游戏主窗口时，都会随机加载一张图片作为游戏背景，在游戏主窗口正下方会嵌入stackedwidget组件窗口，它会根据不同的游戏状态来显示对应的一页按钮组，比如说刚开始时，就只有一个开始按钮，在叫地主时，就有4个按钮，出牌时按钮又不同；其次就是右上角的得分面板，它是记录各玩家的一个得分情况，这两个窗口都是通过主窗口的一个按钮提升嵌入进来的</p><p>玩家的头像、每个玩家的出牌区域等信息都是记录在一个结构体里面，每个玩家都有这样一个结构体，特别是在出牌阶段的时候，会经常用到这个结构体里面的信息</p><p>动画效果：它是在出牌过程中，打出了特殊牌型触发的，比如说飞机、炸弹、连对等。这是每个玩家出牌后都会记录它的牌型，会将该牌型发给动画效果类，动画效果就根据不同的牌型，显示不同的效果，静态效果就是一张图片，动态效果就是使用定时器模拟</p><p>洗牌：是在一个游戏控制类中有一个存放卡牌类的容器，每次游戏开始前，都会先清空这个容器，然后用双层循环遍历所有花色和卡牌点数，创建卡牌对象了插入到这个容器中</p><p>发牌：发牌是用定时器模拟的过程，每次触发移动一点距离，当牌从窗口中心移动到当前玩家的卡牌区域时，就会为该玩家随机生成一张牌，然后放入该玩家对象的手牌容器中(当然要从总牌里面移除这张卡牌)，就切换下一个玩家为当前玩家，然后继续这样操作，直到总牌里面只剩下3张的时候，就停止发牌了，进入叫地主状态</p><p>叫地主：进入叫地主状态时，如果当前玩家是用户玩家，用户玩家是通过窗口的按钮来完成是否抢地主；如果是机器人玩家，则是创建一个线程，线程执行的操作就是根据该机器人玩家的手牌来计算得分，根据分数来确定下注几分发出信号，该信号携带下注玩家和分数，游戏控制类接收该信号处理，当某个玩家直接下注3分时，它就获得地主</p><p>出牌：如果是用户玩家，通过鼠标选择对应卡牌窗口，点击出牌按钮就会触发信号，由主窗口执行槽函数，这个槽函数里面会先检查当前玩家是不是用户玩家，如果不是，就退出函数，如果是，就会结合playhand类根据用户打出的牌，分析这个牌型，看是不是合规的牌，而且如果不是只有出牌的情况，还要看是否能压住上一家的牌，如果都满足，就可以打出这些牌，这里就要从玩家手牌中移除这些牌，还要通过发送信号给主窗口，窗口显示对应动画效果；如果是机器人玩家，会创建一个出牌的线程来完成这些操作，它会根据该机器人玩家的手牌调用Strategy类，这个类里面的函数封装的是一些出牌策略，根据手中的牌和上一个玩家打出的牌来选择出要打出的牌</p><p>胜负判断：每个玩家出牌后，都要判断该玩家还剩下多少手牌，如果还有，就切换下一个玩家为当前玩家，如果没有了就发出用户状态变化的信号，游戏主窗口接收了就处理各玩家的得分、显示本局结束面板</p><h3 id="138-多反应堆的高并发项目"><a href="#138-多反应堆的高并发项目" class="headerlink" title="138. 多反应堆的高并发项目"></a>138. 多反应堆的高并发项目</h3><p>这个项目使用了主从反应堆模型来实现一个高并发的HTTP服务器，主线程维护一个主反应堆，线程池中的每个子线程也都会维护一个子反应堆，当主反应堆中监听到客户端的连接后，会取出一个子线程，由子线程里面的反应堆模型来处理读写事件，其中每个反应堆里面都可以任意指定特定的多路IO复用模型，如select、epoll和poll。服务器底层实现了TCPServer、TcpConnection、反应堆和Channel等重要模块</p><ul><li><p>TcpServer结构体对象：主反应堆模型mainLoop、线程池threadPool、负责监听的描述符lfd和监听端口port</p></li><li><p>反应堆模型结构体对象EventLoop：是否工作变量isQuit、分发模型指针dispatcher、对应分发模型的数据块指针、任务队列ChannelElement、Channel结构体数组ChannelMap、线程id、互斥锁(包含任务队列)、本地通信fd</p></li><li><p>线程池结构体ThreadPool：主线程反应堆模型mainLoop、是否启动变量isStart、线程池子线程数量threadNum、工作线程数组指针workerThread、</p></li><li><p>工作线程结构体WorkerThread：线程id、互斥锁、条件变量、子反应堆模型evLoop</p></li></ul><p>解决粘包问题：把接收到的客户端发来的信息全部存到一个readbuf里面，这是一个结构体，提供读数据位置和写数据位置，因为http协议发来的信息每行是以&#x2F;r&#x2F;n结尾的，所以可以通过这个结尾符号进行截取，得到请求行的内容，然后一行一行进行解析，把请求方式、请求资源、版本号以及下面请求头的内容都存在一个请求结构体里面，自定义的，就是用来存放解析的内容。然后通过该结构体来处理要相应的状态行、状态头信息都存在另一个相应结构体里面。最后就是通过相应结构体来组织信息存到writebuf里面，发送给客户端</p><ul><li><p>主反应堆模型负责监听连接，也就是说主反应堆里面的多路io模型监听的描述符只有监听描述符的读事件，当读事件触发后，会调用之前写好的回调函数，这个回调函数里面就负责取出线程池里面子线程的子反应堆模型，并将通信描述符添加到子反应堆模型的多路io模型中</p></li><li><p>子反应堆模型就负责监与客户端通信，客户端发来数据，就会触发读回调函数，该回调函数里面就负责解析http请求，处理并响应</p></li><li><p>事件分发的实现：申明一个dispatcher结构体，里面的成员都是函数指针，比如说开始检测函数指针、添加&#x2F;删除&#x2F;修改channel在检测集合里面的事件函数指针等；然后分别通过多路io的三种模型来初始化该结构体里面的函数，这样在反应堆里面就可以设置分发指针dispatcher的指向来使用对应的io模型了</p></li></ul><h3 id="139-条件变量和信号量"><a href="#139-条件变量和信号量" class="headerlink" title="139. 条件变量和信号量"></a>139. 条件变量和信号量</h3><ul><li>条件变量和信号量都是是用于线程同步的两种机制，它们都涉及到了唤醒(通知)和阻塞(等待)的机制</li><li>条件变量工作原理：<ul><li>条件变量需要配合互斥锁使用。</li><li>当一个线程检查到某个条件不满足时，它会调用 <code>wait()</code> 方法释放持有的互斥锁并进入等待状态。</li><li>另一个线程在修改了相关条件后，可以通过调用 <code>notify_one()</code> 或 <code>notify_all()</code> 来唤醒一个或所有等待的线程。</li><li>被唤醒的线程重新获得互斥锁，并再次检查条件是否满足</li></ul></li><li>信号量工作原理：<ul><li>信号量有一个内部计数器，表示当前可用资源的数量。</li><li>当一个线程想要访问资源时，它会执行 P 操作(即 <code>wait()</code>)，如果计数器大于0，则减少计数器并继续执行；否则该线程会被阻塞直到有其他线程释放资源(执行 V 操作)。</li><li>当一个线程完成对资源的使用后，它会执行 V 操作(即 <code>signal()</code>)s，增加计数器并可能唤醒一个正在等待的线程</li></ul></li></ul><h3 id="140-委托构造函数和继承构造函数"><a href="#140-委托构造函数和继承构造函数" class="headerlink" title="140. 委托构造函数和继承构造函数"></a>140. 委托构造函数和继承构造函数</h3><ul><li>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数</li><li>继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数</li></ul><h3 id="141-补充问题"><a href="#141-补充问题" class="headerlink" title="141. 补充问题"></a>141. 补充问题</h3><ul><li><p>为什么选择多线程而没有选用多进程？</p><ul><li>是因为线程之间共享内存资源，通信和资源复用效率更高，非常适合基于 epoll 的事件驱动架构。而进程之间是完全隔离的，通信成本大、调度开销高。在高并发场景下，线程模型更轻量、更易管理</li></ul></li><li><p><code>final</code>关键字来限制某个类不能被继承，或者某个虚函数不能被重写</p></li><li><p>**尖括号 <code>&lt; &gt;</code><strong>：主要用于标准库或已安装库的头文件，编译器直接从标准路径中查找。</strong>双引号 <code>&quot;&quot;</code>**：主要用于项目内部的头文件，首先在当前文件所在目录查找，然后才转向标准路径。</p></li><li><p>c++中怎么去引用c代码：使用 <code>extern &quot;C&quot;</code> 声明，表示使用c语言的方式来编译c++程序，因为C和C++在名称修饰（name mangling）、类型检查等方面存在差异。如果不正确处理这些差异，可能会导致链接错误或运行时错误</p></li><li><p>当一个进程调用 <code>fork()</code> 函数创建子进程时，操作系统会为子进程创建一个新的地址空间，并将父进程的内存内容(包括全局变量、data段、text段、栈和堆等)复制到子进程的地址空间中</p></li></ul><h3 id="142-IO多路复用模型的作用是什么，如果要实现高并发的多线程或多进程，是否一定需要用到IO多路复用模型"><a href="#142-IO多路复用模型的作用是什么，如果要实现高并发的多线程或多进程，是否一定需要用到IO多路复用模型" class="headerlink" title="142. IO多路复用模型的作用是什么，如果要实现高并发的多线程或多进程，是否一定需要用到IO多路复用模型"></a>142. IO多路复用模型的作用是什么，如果要实现高并发的多线程或多进程，是否一定需要用到IO多路复用模型</h3><ul><li><p>IO多路复用是一种允许单个进程或线程下监视多个文件描述符的技术，一旦某个描述符就绪(通常是读就绪或写就绪)，就能进行相应的IO系统调用</p></li><li><p>对于实现高并发的多线程或多进程服务，并不一定非要使用IO多路复用模型，但它是解决高并发问题的一种非常有效的方式，特别是在需要处理大量并发连接的情况下。</p><ul><li>如果不使用IO多路复用，就得通过增加更多的线程或进程来处理并发请求，在处理成千上万甚至更多并发连接时效率低下，因为每个线程&#x2F;进程都需要占用一定的内存和CPU时间，这可能导致系统资源耗尽</li><li>如果使用IO多路复用，单个线程或进程就可以同时监听多个文件描述符的状态变化，只有当某个描述符准备好执行IO操作时才去处理它。这种方式极大地提高了资源利用率，适合于大规模并发场景</li></ul></li></ul><h3 id="143-编译时和运行时"><a href="#143-编译时和运行时" class="headerlink" title="143. 编译时和运行时"></a>143. 编译时和运行时</h3><ul><li>编译时：是源代码被转化为机器码的过程，期间会进行语法分析、类型检查等。主要包括以下几个过程：预处理、编译、汇编、链接</li><li>运行时：是程序被执行的过程，在这个阶段，计算机按照编译后生成的机器码指令序列执行相应的操作。涉及如下几个方面：</li><li>内存管理：包括堆和栈的分配与回收</li><li>异常处理：捕获并处理程序运行过程中出现的异常情况</li><li>动态绑定：在面向对象编程中，方法调用可能要到运行时才能确定具体调用哪个版本的方法(比如虚函数调用)</li><li>输入输出：与用户或其他系统交互，读取输入数据或输出结果</li></ul><h3 id="144-g-链接动态库怎么链接"><a href="#144-g-链接动态库怎么链接" class="headerlink" title="144. g++链接动态库怎么链接"></a>144. g++链接动态库怎么链接</h3><ul><li><p>需要使用-L来指定动态库的路径</p></li><li><p>需要使用-l来指定动态库的库名</p></li><li><p>通过-rpath设置运行时库搜索路径：默认情况下，操作系统会在标准位置（如 <code>/usr/lib</code>, <code>/usr/local/lib</code>）查找共享库。如果你的共享库不在这些标准位置之一，你需要告诉操作系统去哪里找它。这可以通过设置环境变量 <code>LD_LIBRARY_PATH</code> 或者在链接时使用 <code>-rpath</code> 选项来实现。</p></li></ul><h3 id="145-使用的是UDP来连接，但尽可能的达到TCP的效果需要怎么去修改"><a href="#145-使用的是UDP来连接，但尽可能的达到TCP的效果需要怎么去修改" class="headerlink" title="145. 使用的是UDP来连接，但尽可能的达到TCP的效果需要怎么去修改"></a>145. 使用的是UDP来连接，但尽可能的达到TCP的效果需要怎么去修改</h3><p>这种情况是希望在使用 UDP 的前提下，尽可能实现 TCP 的功能和效果，比如：可靠传输、顺序交付、流量控制、拥塞控制等</p><ul><li><p>可靠传输</p><ul><li>给每个发送的数据包分配一个序列号，发送方维护一个未确认包的队列，接收方收到数据包后发送 ACK，发送方超时未收到 ACK 则重发</li></ul></li><li><p>有序交付</p><ul><li>每个数据包带上序列号，接收端先缓存乱序到达的包，按照顺序将数据提交给应用层</li></ul></li><li><p>流量控制</p><ul><li>接收方告知发送方当前可接收的数据大小，发送方根据接收窗口大小控制发送速度</li></ul></li></ul><h3 id="146-数据结构"><a href="#146-数据结构" class="headerlink" title="146. 数据结构"></a>146. 数据结构</h3><ul><li><p>数组与链表有什么区别</p><ul><li>数组静态分配内存，链表动态分配内存</li><li>数组在内存中连续，链表不连续</li><li>数组利用下标定位，时间复杂度为 O (1)，链表定位元素时间复杂度 O (n)</li><li>数组插入或删除元素的时间复杂度 O (n)，链表的时间复杂度 O (1)</li></ul></li><li><p>线性表的存储结构</p></li><li><p>顺序存储(内存连续)、链式存储(内存不连续)</p></li><li><p>头指针和头结点的区别</p><ul><li>头指针：是指向链表第一个节点的指针</li><li>头结点：是一种特殊的节点，它位于链表的第一个实际数据节点之前。头结点不存储有效数据，主要用于简化某些操作。</li></ul></li><li><p>栈和队列的区别：栈和队列都是操作受限的线性表</p><ul><li>栈：只能在栈尾入栈、出栈，是先进后出</li><li>队列：队尾进，队首出，是先进先出</li></ul></li><li><p>度为2的树与二叉树有什么区别</p><ul><li>度为2的树指这棵树中最大的节点度为2，也就是说至少有一个节点的度是2；而二叉树可以为空</li><li>度为2的树其子节点没有顺序之分；二叉树需要明确指出左子节点和右子节点</li></ul></li><li><p>唯一确定一棵二叉树：中序 + 先序&#x2F;后序&#x2F;层序</p></li><li><p>二叉排序树：若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左、右子树也分别为二叉排序树</p></li><li><p>最小生成树有几种方法</p><ul><li>Prim(普里姆)算法：在图中取任意顶点 v 作为起始顶点，并加入集合 V；之后遍历与 V 中顶点相邻的边，选择权值最小且顶点未加入集合 V 的边，把其加入集合 V，直到集合 V 包含所有顶点结束。(根据节点来选择，适用于节点少的图)</li><li>Kruskal(克鲁斯卡尔)算法：在含有 n 个顶点的图中始终选择权值最小且不会产生回路的边，一直进行此步骤直到选择 n-1 条边为止。(根据边来选择，适用于边少的图)</li></ul></li><li><p>图的存储方式有哪些？每一种方式优缺点</p><ul><li>邻接矩阵：使用一个二维数组<code>A</code>来表示图，其中<code>A[i][j]</code>表示顶点<code>i</code>到顶点<code>j</code>之间是否有边以及边的权重（如果有的话）。对于无权图，<code>A[i][j]=1</code>表示存在从<code>i</code>到<code>j</code>的边，<code>A[i][j]=0</code>表示不存在；对于有权图，<code>A[i][j]</code>直接存储边的权重，若无边则通常设为无穷大或特定值如-1<ul><li>对于稠密图(边数接近最大可能边数)，空间利用率高；判断两点间是否存在边的操作时间复杂度为O(1)。</li></ul></li><li>邻接表：每个顶点都有一个链表或者列表，用于存储所有与该顶点相连的其他顶点。对于有权图，每个元素不仅包含目标顶点的信息，还包含边的权重<ul><li>节省空间，特别是对于稀疏图而言；插入和删除操作较为高效</li></ul></li><li>十字链表、邻接多重表</li></ul></li><li><p>树的存储结构：双亲表示法、孩子表示法、孩子兄弟表示法</p></li><li><p>图的遍历与树的遍历有什么区别：图的遍历可能会出现循环遍历的情况，要设置标记数组。而树的遍历则不会出现这种情况。其次，图可能存在不连通的情况，而树不存在，所以图的遍历要对所有的顶点都循环一遍</p></li><li><p>什么是稳定的算法：对于拥有相同键值的元素，它们的相对顺序保持不变。</p><ul><li>稳定的排序算法：冒泡排序、插入排序、归并排序、基数排序</li><li>不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0-C-的三大特性&quot;&gt;&lt;a href=&quot;#0-C-的三大特性&quot; class=&quot;headerlink&quot; title=&quot;0. C++的三大特性&quot;&gt;&lt;/a&gt;0. C++的三大特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;封装&lt;/strong&gt;是指将数据和操作这些数据的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Http高并发服务器项目</title>
    <link href="https://lxx93.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    <id>https://lxx93.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-08-20T14:09:56.000Z</published>
    <updated>2025-05-11T13:00:42.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。</p><p>过程：</p><p>客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会自动下载到本地，如果能够展示，它在本地指定的下载目录是不会有对应文件的，因为它下载到本地之后，就直接将内容显示到窗口上了，可以理解为它下载下来的只是一个缓存，该缓存能够支撑它在浏览器上把内容显示出来，当数据显示完成之后，浏览器会定期地清除缓存，那么该资源也就不存在了。</p><h1 id="2-单反应堆的服务器模型"><a href="#2-单反应堆的服务器模型" class="headerlink" title="2. 单反应堆的服务器模型"></a>2. 单反应堆的服务器模型</h1><p>在网络编程中，为了提高访问通信的效率，就可以使用单反应堆的服务器模型，它是IO多路复用与多线程相结合的一种技术。</p><p>设计思路：</p><p>在主线程里面，服务器绑定本地的ip和端口来得到一个通信的套接字，因为通信的套接字需要监听它的读事件，所以就将它的读事件注册给Reactor，也就是反应堆模型。该反应堆模型底层用到的是poll、epoll或select，这三种IO多路转接技术不是同时用，而是选择其中的某一种。在选择了底层的IO模型之后，把用于监听的文件描述符的读事件注册给该模型，然后内核就可以帮助我们检测这用于监听的文件描述符的读事件是否被激活了。如果被激活了，说明有新连接到达，那么我们就需要调用用于监听的文件描述符对应的处理函数，该处理函数其实就是负责与对端建立新连接，主要的处理核心动作核就是调用accept()函数，因此就能得到一个用于通信的文件描述符，然后对该通信描述符进行一个封装。在封装的时候，给该用于通信的文件描述符指定了读回调和写回调，至于为什么要指定读写回调，是因为反应堆模型就是基于回调的。TcpConnection模型当检测到了对应的文件描述符它的读事件或写事件被触发了之后，该框架就会自动的调用这个事件的处理函数，这种机制就称为反应堆机制。其实本质就是回调函数。</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_10.png" style="zoom:67%;"><h1 id="3-多反应堆的服务器模型"><a href="#3-多反应堆的服务器模型" class="headerlink" title="3. 多反应堆的服务器模型"></a>3. 多反应堆的服务器模型</h1><p>对于多反应堆模型，反应堆的数量取决于线程的数量。</p><p>在主线程里面，它是有一个用于监听的套接字Listener，我们需要将它注册给主线程的MainReactor反应堆模型。在主线程的反应堆模型里面可以选择poll、epoll或select，它们就能帮助我们检测对应的监听文件描述符的读事件是否被触发。如果被触发了，就需要建立一个新连接，调用accept()函数得到一个新的用于通信的文件描述符connfd。然后对它进行封装，封装时为它指定一个读回调和写回调。又因为这是一个多反应堆模型，在得到了用于通信的套接字之后，就不要在主线程里面做通信了，把通信交给主线程的线程池，在主线程的线程池里面有多个子线程，每个子线程里面也有一个反应堆模型，该反应堆模型里面主要就是指定的IO多路转接poll、epoll或select。</p><p>然后我们只需要把用于通信的文件描述符的事件注册给到对应的子线程的反应堆模型(随机给的)，因为这个过程是做了注册的，所以当用于通信的套接字，它的读事件或写事件触发了，对应的回调函数就会知道。当真正的事件被触发之后，子线程里的反应堆模型就会调用响应的处理函数。</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_11.png" style="zoom:67%;"><h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-http请求"><a href="#4-1-http请求" class="headerlink" title="4.1 http请求"></a>4.1 http请求</h2><p>属于应用层协议，位于最上层，通过这个协议就可以对通信的数据进行封装。如果网络模型是B&#x2F;S结构，就必须使用<code>http</code>协议，<code>https</code>协议是在<code>http</code>协议的基础上做了加密。</p><p>在数据发送之前，使用协议对数据进行封装，接收到数据之后，按照协议格式解析接收到的数据。</p><p>Http协议分为两部分：</p><p>1.http请求</p><ul><li><p>客户端给服务器发送数据，叫<code>http</code>请求，有两种请求方式</p><ul><li><p>get请求</p></li><li><p>post请求</p></li></ul></li></ul><p>2.http响应</p><ul><li>服务器给客户端回复数据叫做<code>http</code>响应</li></ul><p><code>http</code>协议封装好数据之后是一个数据块，得到若干行数据，使用的换行符是<code>\r\n</code>。通过这个<code>\r\r</code>进行判断，就知道这行是否结束了。</p><blockquote><p>http请求消息分为四部分：</p><p>1.请求行</p><ul><li>不管get请求还是post请求，请求行是分为三部分</li></ul><p>2.请求头</p><p>3.空行</p><p>4.客户端向服务器提交的数据</p></blockquote><p>如果使用get方式提交数据，第四部分是空的。</p><p>get与post分析比较:</p><ol><li><p>从给服务器发送的数据的量上来分析</p><ul><li>get：主要是向服务器索取数据，提交的数据量比较少</li><li>post：上传文件一般都会使用post，可以提交的数据量是非常大的</li></ul></li><li><p>从上传的数据安全性来分析</p><ul><li>get：提交的数据不安全，提交的数据会显示到地址栏中，数据容易被泄露</li><li>post：提交的数据并不会显示到地址栏中，完全不可见的，因此更安全</li></ul></li></ol><h2 id="4-2-get请求"><a href="#4-2-get请求" class="headerlink" title="4.2 get请求"></a>4.2 get请求</h2><p>下面是浏览器对用户的请求数据进行了封装之后，得到的原始的http请求数据：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93:9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>第1行是请求行：分为3部分，</p><ul><li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p></li><li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p></li><li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p></li></ul><p>第2-8行是请求头：由若干个键值对组成：</p><ul><li><p>Host表示要连接的服务器是192.168.88.93，绑定的端口是9393；</p></li><li><p>Connection的keep-alive表示客户端想要与服务器一直保持连接</p></li><li><p>User-Agent表示浏览器的版本，指的是内核版本</p></li><li><p>Accept-Encoding设置压缩的方式使用的是gzip</p></li><li><p>Accept-Language设置默认的语言</p></li></ul><p>注意：如果我们使用的是get请求，并且get请求里面携带了一些动态数据，这些数据会出现在浏览器的地址栏里面，而该地址栏它的缓存是有上限的，因此如果携带的数据量很多，后面的数据就会丢失。</p><p>第9行是空行，空行完之后，就是通过这个请求协议给服务器提交的数据。如果是get请求，这部分内容是空的。因为如果通过get请求向服务器提交动态数据，这个动态数据也不会出现在请求协议的第4部分，而是出现在请求行的第2部分，即：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_12.png" style="zoom:67%;"><h2 id="4-3-post请求"><a href="#4-3-post请求" class="headerlink" title="4.3 post请求"></a>4.3 post请求</h2><p>下面是post请求数据的格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93：9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>98</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">username</span>=subwen%<span class="number">40</span>qq.com&amp;phon=<span class="number">111111</span>&amp;email=sub%<span class="number">40</span>qq.com&amp;date=<span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>&amp;sex=male&amp;class=<span class="number">1</span>&amp;rule=<span class="literal">on</span></span></span><br></pre></td></tr></table></figure><p>如果我们通过post向服务器提交数据，那么这个数据肯定是动态的，即请求的数据在服务器上是不存在的。如注册账号，向服务器提供用户名和密码等信息。</p><p>第1行是请求行：分为3部分，</p><ul><li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p></li><li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p></li><li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p></li></ul><p>第2-12行是请求头：由若干个键值对组成：</p><ul><li>Content-Length表示提交的内容长度</li><li>Content-Type表示客户端向服务器提交的数据块的格式(还有其它很多种格式)</li></ul><p>第13行是空行\r\n</p><p>第14行是客户端向服务器提交的数据块</p><h2 id="4-4-http响应"><a href="#4-4-http响应" class="headerlink" title="4.4 http响应"></a>4.4 http响应</h2><blockquote><p>服务器给客户端回复数据，称之为http响应，协议的格式分为四部分：：<br>1.状态行</p><p>2.消息报头&#x2F;响应头</p><p>3.空行</p><p>4.回复给客户端的数据块</p><ul><li>http响应消息也是一个数据块，若干行组成，换行是\r\n</li></ul></blockquote><p>响应消息(Response)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Http/1.1 200 Ok</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>micro_httpd</span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Fri, 18 Jul 2014 14:34:26 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain; charset=iso-8859-1 (必选项)</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>32</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://www.lxx93.online</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>zh-CN</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 18 Jul 2014 08:36:36 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1行是状态行，分为3部分：</p><ol><li><p>Http的版本</p></li><li><p>服务器对客户端请求的处理状态(状态码)，200就代表处理成功了</p></li><li><p>是对状态码的描述</p></li></ol><p>第2到9行是响应头，由一系列的键值对组成：</p><ul><li>Content-Type：表示的是http响应消息，响应的数据块的格式，text&#x2F;plain代表的是一个纯文本，charset表示使用的字符编码</li><li>Content-Length：表示服务器给客户端回复的数据块的大小(要准确，不确定的话就不写)</li></ul><p>第10行是空行</p><p>第11到16行是http响应给客户端的信息</p><p>http状态码类别：</p><p>状态码有三位数字组成，第一个数字定义了响应的类别，共分5种类别：</p><ul><li>1xx：指示信息–表示请求已经被接收，没有处理完，还正在处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作(网络地址的重新访问)</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul><p>常见的状态码：</p><table><thead><tr><th align="center">状态码</th><th align="center">状态描述</th><th align="center">文字描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td align="center">客户端请求成功</td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求有语法错误，不能被服务器所理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器收到请求，但是拒绝提供服务</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">请求资源不存在，如：输入了错误的URL</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器发送不可预期的错误</td></tr><tr><td align="center">503</td><td align="center">Server Unavailable</td><td align="center">服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td></tr></tbody></table><p>整个处理流程：</p><p>首先调用threadPoolInit()函数，得到线程池的实例，得到该实例后，调用threadPoolRun()把线程池启动起来，即把线程池里面的子线程启动起来。然后就可以通过takeWorkerEventLoop()从线程池里面取出某一个子线程，得到子线程就能够得到对应的反应堆evLoop实例，将其返回给函数的调用者。调用者就可以通过这个evLoop实例往它的任务队列里面添加任务，当任务添加到evLoop对应的任务队列过后，就可以开始处理这个任务队列了，再根据这个任务队列节点的类型来处理这个dispatcher的检测集合。有3种情况，第1种是往检测集合里面添加新的节点；第2种是往检测集合里面删除节点；第3种情况就是修改检测集合里面某个文件描述符对应的事件。dispatcher这个检测集合处理完毕之后，对应的反应堆模型就开始进行循环了，它需要循环的调用底层的poll、epoll_wait或select来检测这个集合里面有没有激活的文件描述符。如果有激活的文件描述符，那么就通过这个文件描述符找到对应的channel，找到chennel后，然后再基于激活的事件，调用事件对应的回调函数，该回调函数调用完之后，对应的事件也就处理完毕了。</p><h1 id="5-多反应堆-线程池高并发服务器"><a href="#5-多反应堆-线程池高并发服务器" class="headerlink" title="5. 多反应堆+线程池高并发服务器"></a>5. 多反应堆+线程池高并发服务器</h1><p>该项目的结构如下：</p><p><img src="/.online//图床数据\project\6_23.png"></p><p>在main()函数中，接收外部传来的两个参数，即<code>监听的端口</code>和<code>资源目录</code>，通过传入端口和指定线程池中子线程的个数，得到一个TcpServer服务器实例，并对其进行启动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;./a.out port path\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);      <span class="comment">//将端口进行类型转换</span></span><br><span class="line">    <span class="built_in">chdir</span>(argv[<span class="number">2</span>]);                   <span class="comment">//切换服务器的工作路径，切换为资源文件</span></span><br><span class="line">    <span class="comment">//启动服务器</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TcpServer</span>* server = <span class="built_in">tcpServerInit</span>(port, <span class="number">4</span>);     <span class="comment">//得到一个tcp服务器实例</span></span><br><span class="line">    <span class="built_in">tcpServerRun</span>(server);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1反应堆模型"><a href="#5-1反应堆模型" class="headerlink" title="5.1反应堆模型"></a>5.1反应堆模型</h2><h3 id="文件描述符封装类channel"><a href="#文件描述符封装类channel" class="headerlink" title="文件描述符封装类channel"></a>文件描述符封装类channel</h3><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*handleFunc)</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FDEvent</span> &#123;</span><br><span class="line">TimeOut = <span class="number">0x01</span>,                <span class="comment">//二进制：1</span></span><br><span class="line">ReadEvent = <span class="number">0x02</span>,              <span class="comment">//二进制：10</span></span><br><span class="line">WriteEvent = <span class="number">0x04</span>              <span class="comment">//二进制：100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"><span class="comment">//文件描述符</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="type">int</span> events;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line">handleFunc readCallback;</span><br><span class="line">handleFunc writeCallback;</span><br><span class="line">handleFunc destroyCallback;         <span class="comment">//回收资源的回调函数(释放tcpConnection)</span></span><br><span class="line"><span class="comment">//回调函数的参数</span></span><br><span class="line"><span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个channnel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* <span class="built_in">channelInit</span>(<span class="type">int</span> fd, <span class="type">int</span> events, handleFunc readFunc, handleFunc writeFunc, handleFunc destroyFunc, <span class="type">void</span>* arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = (<span class="keyword">struct</span> Channel*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel));</span><br><span class="line">channel-&gt;arg = arg;</span><br><span class="line">channel-&gt;fd = fd;</span><br><span class="line">channel-&gt;events = events;</span><br><span class="line">channel-&gt;readCallback = readFunc;</span><br><span class="line">channel-&gt;writeCallback = writeFunc;</span><br><span class="line">channel-&gt;destroyCallback = destroyFunc;</span><br><span class="line"><span class="keyword">return</span> channel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对channel封装的描述符是否添加监听写事件功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeEventEnable</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">channel-&gt;events |= WriteEvent;                <span class="comment">//往events里面追加写事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">channel-&gt;events = channel-&gt;events &amp; ~WriteEvent;      <span class="comment">//将第3位标志位清0，这样就不做写事件检测了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回channel封装fd是否有监听写事件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWriteEventEnable</span><span class="params">(<span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> channel-&gt;events &amp; WriteEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装channel的容器类ChannelMap"><a href="#封装channel的容器类ChannelMap" class="headerlink" title="封装channel的容器类ChannelMap"></a>封装channel的容器类ChannelMap</h3><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该结构体主要就是想通过list下标，即fd来找到对应的channel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span> &#123;</span><br><span class="line"><span class="type">int</span> size;         <span class="comment">//记录指针指向的数组的元素总个数</span></span><br><span class="line"><span class="comment">//list是一个指针数组(数组里面全部是指针)，数组的下标对应的是文件描述符的值，如果文件描述符为9，那么其数组下标就为9，一一对应的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>** list; <span class="comment">//相当于是一个数组list,里面存的是struct Channel*类型的指针，即struct Channel* list[]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化channelmap容器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* <span class="built_in">channelMapInit</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* map = (<span class="keyword">struct</span> ChannelMap*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ChannelMap));</span><br><span class="line">map-&gt;size = size;</span><br><span class="line">map-&gt;list = (<span class="keyword">struct</span> Channel**)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel*));</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空channelmap容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ChannelMapClear</span><span class="params">(<span class="keyword">struct</span> ChannelMap* map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map != <span class="literal">NULL</span>) &#123;                         <span class="comment">//判断map如果不为空，就清理map数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; map-&gt;size; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map-&gt;list[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(map-&gt;list[i]);            <span class="comment">//数组里面的元素指向的内存不为空就释放掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(map-&gt;list);                       <span class="comment">//数组对应的内存地址也要释放掉</span></span><br><span class="line">map-&gt;list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">map-&gt;size = <span class="number">0</span>;                    <span class="comment">//所有的释放掉后，map里面的大小就变为了0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数：fd-channel数组；需要插入的fd；每个元素占的大小</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">makeMapRoom</span><span class="params">(<span class="keyword">struct</span> ChannelMap* map, <span class="type">int</span> newSize, <span class="type">int</span> unitSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map-&gt;size &lt; newSize) &#123;                <span class="comment">//如果map中的size比newsize小，才做扩容操作</span></span><br><span class="line"><span class="type">int</span> curSize = map-&gt;size;              <span class="comment">//取出当前map的size容量</span></span><br><span class="line"><span class="comment">//容量每次扩大原来的1倍</span></span><br><span class="line"><span class="keyword">while</span> (curSize &lt; newSize) &#123;             <span class="comment">//当cursize扩容到比newSize大时，就退出循环</span></span><br><span class="line">curSize *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容realloc -----&gt;参1是需要扩容的起始地址；参2是要扩容的大小</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span> ** temp = <span class="built_in">realloc</span>(map-&gt;list, curSize * unitSize);    <span class="comment">//返回的是扩容成功之后，对应的起始地址</span></span><br><span class="line"><span class="keyword">if</span>(temp == <span class="literal">NULL</span>)&#123;                       <span class="comment">//如果为空，说明没有扩容成功，就返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">map-&gt;list = temp;                       <span class="comment">//更新将list指向起始地址</span></span><br><span class="line"><span class="comment">//将参1所指的内存前参3的字节设置为参2(参1指向的是原来空间个数的大小所对应的地址，并将其后面的地址空间初始化，即扩容的部分)</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;map-&gt;list[map-&gt;size], <span class="number">0</span>, (curSize - map-&gt;size) * unitSize);       <span class="comment">//将扩展的地址进行初始化</span></span><br><span class="line">map-&gt;size = curSize;                    <span class="comment">//更新将size变为扩容的大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO复用技术类dispatcher"><a href="#IO复用技术类dispatcher" class="headerlink" title="IO复用技术类dispatcher"></a>IO复用技术类dispatcher</h3><p>结构体成员都是函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>;    <span class="comment">//不管该结构体现在是否被定义出来，先告诉编译器有这种类型，下面就可以用这种类型去定义变量(Dispatcher和eventloop互包含了)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line"><span class="comment">// init --- 初始化epoll、poll或者select需要的数据块</span></span><br><span class="line"><span class="type">void</span>* (*init)();                    <span class="comment">//返回值为什么是泛型void*，是为了兼容epoll、poll和select对应的不同的数据块</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="built_in">int</span> (*add)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">int</span> (*remove)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="built_in">int</span> (*modify)(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line"><span class="comment">// 事件检测</span></span><br><span class="line"><span class="built_in">int</span> (*dispatch)(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout);</span><br><span class="line"><span class="comment">// 清除数据(关闭fd或者释放内存)</span></span><br><span class="line"><span class="built_in">int</span> (*clear)(<span class="keyword">struct</span> EventLoop* evLoop);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>epoll实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 520</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span> &#123;</span><br><span class="line"><span class="type">int</span> epfd;                        <span class="comment">//epoll树根节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span>* events;      <span class="comment">//epoll_wait在工作时需要的传出参数，是一个结构体数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">epollInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体Dispatcher的变量EpollDispatcher</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> EpollDispatcher = &#123;     <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">epollInit,</span><br><span class="line">epollAdd,</span><br><span class="line">epollRemove,</span><br><span class="line">epollModify,</span><br><span class="line">epollDispatch,</span><br><span class="line">epollClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">epollInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EpollData));     <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line">data-&gt;epfd = <span class="built_in">epoll_create</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (data-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开辟空间，参1是元素的个数；参2是每个元素占多大的内存</span></span><br><span class="line">data-&gt;events = (<span class="keyword">struct</span> epoll_event*)<span class="built_in">calloc</span>(Max, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> epoll_event));    <span class="comment">//calloc相较于malloc,会将开辟的空间初始化为0</span></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollCtl</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line"><span class="comment">//epfd和events都存储在EventLoop里面的Dispatcherdata里面</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.data.fd = channel-&gt;fd;                <span class="comment">//要添加的文件描述符</span></span><br><span class="line"><span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;          <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">events |= EPOLLIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line">events |= EPOLLOUT;                    <span class="comment">//保存写事件</span></span><br><span class="line">&#125;</span><br><span class="line">ev.events = events;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(data-&gt;epfd, op, channel-&gt;fd, &amp;ev);      <span class="comment">//参数：树的根节点；添加操作；对应的文件描述符；epoll_event结构体</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_ADD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_DEL);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl delete&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过channel释放对应的TcpConnection资源</span></span><br><span class="line">channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);       <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epollCtl</span>(channel, evLoop, EPOLL_CTL_MOD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl modify&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="type">int</span> count = <span class="built_in">epoll_wait</span>(data-&gt;epfd, data-&gt;events, Max, timeout * <span class="number">1000</span>);    <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="type">int</span> events = data-&gt;events[i].events;</span><br><span class="line"><span class="type">int</span> fd = data-&gt;events[i].data.fd;</span><br><span class="line"><span class="comment">//对端断开连接后，就会产生EPOLLERR事件；对端断开连接后，还在发数据给对端就会产生EPOLLHUP事件</span></span><br><span class="line"><span class="keyword">if</span> (events &amp; EPOLLERR || events &amp; EPOLLHUP) &#123;             <span class="comment">//如果对端断开连接</span></span><br><span class="line"><span class="comment">//对方断开了连接，删除fd</span></span><br><span class="line"><span class="comment">//epollRemove(Channel, evLoop);</span></span><br><span class="line"><span class="keyword">continue</span>;             <span class="comment">//退出本轮循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (events &amp; EPOLLIN) &#123;                    <span class="comment">//如果读事件触发</span></span><br><span class="line"><span class="comment">//epoll、poll、select只要触发了读写事件，调用的都是该函数</span></span><br><span class="line"><span class="built_in">eventActivate</span>(evLoop, fd, ReadEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (events &amp; EPOLLOUT) &#123;                   <span class="comment">//如果写事件触发</span></span><br><span class="line"><span class="built_in">eventActivate</span>(evLoop, fd, WriteEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">epollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EpollData</span>* data = (<span class="keyword">struct</span> EpollData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="built_in">free</span>(data-&gt;events);             <span class="comment">//释放</span></span><br><span class="line"><span class="built_in">close</span>(data-&gt;epfd);              <span class="comment">//关闭树根节点</span></span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span> &#123;</span><br><span class="line">fd_set readSet;</span><br><span class="line">fd_set writeSet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">selectInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">clearFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> SelectDispatcher = &#123;     <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">selectInit,</span><br><span class="line">selectAdd,</span><br><span class="line">selectRemove,</span><br><span class="line">selectModify,</span><br><span class="line">selectDispatch,</span><br><span class="line">selectClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">selectInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> SelectData));     <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;data-&gt;readSet);               <span class="comment">//读集合清空</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(&amp;data-&gt;writeSet);              <span class="comment">//写集合清空</span></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(channel-&gt;fd, &amp;data-&gt;readSet);            <span class="comment">//将fd添加到读事件中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line"><span class="built_in">FD_SET</span>(channel-&gt;fd, &amp;data-&gt;writeSet);           <span class="comment">//将fd添加到写事件中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">clearFdSet</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> SelectData* data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(channel-&gt;fd, &amp;data-&gt;readSet);     <span class="comment">//从读集合中移除fd，在读集合中对应的fd标志位被设为了0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent) &#123;</span><br><span class="line"><span class="built_in">FD_CLR</span>(channel-&gt;fd, &amp;data-&gt;writeSet);           <span class="comment">//写集合中移除fd</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="keyword">if</span> (channel-&gt;fd &gt;= Max) &#123;              <span class="comment">//如果channel的fd是大于最大值的，就没有必须执行下面了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setFdSet</span>(channel, data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="built_in">clearFdSet</span>(channel, data);</span><br><span class="line"><span class="comment">//通过channel释放对应的TcpConnection资源</span></span><br><span class="line">channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);       <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="comment">//睡先调用都可以</span></span><br><span class="line"><span class="built_in">setFdSet</span>(channel, data);</span><br><span class="line"><span class="built_in">clearFdSet</span>(channel, data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> val;</span><br><span class="line">val.tv_sec = timeout;</span><br><span class="line">val.tv_usec = <span class="number">0</span>;</span><br><span class="line">fd_set rdtmp = data-&gt;readSet;</span><br><span class="line">fd_set wrtmp = data-&gt;writeSet;</span><br><span class="line"><span class="type">int</span> count = <span class="built_in">select</span>(Max, &amp;rdtmp, &amp;wrtmp, <span class="literal">NULL</span>, &amp;val);    <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量读集合和写集合，看是哪个集合里面的文件描述符被激活了，如果被激活，在集合中对应标志位为1，否则为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;rdtmp)) &#123;           <span class="comment">//如果i在rdtmp里面，说明对应的文件描述符i的读数据就绪</span></span><br><span class="line"><span class="built_in">eventActivate</span>(evLoop, i, ReadEvent);       <span class="comment">//调用对应的回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;wrtmp)) &#123;            <span class="comment">//如果i在rdtmp里面，说明对应的文件描述符i的写数据就绪</span></span><br><span class="line"><span class="built_in">eventActivate</span>(evLoop, i, WriteEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">selectClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectData</span>* data = (<span class="keyword">struct</span> SelectData*)evLoop-&gt;dispatcherData;</span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 1024</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PollData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxfd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[Max];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上前缀static表示当前的函数为局部函数，作用域为当前的源文件</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">pollInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span>; <span class="comment">// 单位: s</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span> PollDispatcher = &#123;          <span class="comment">//该结构体是全局变量，在要使用的文件中，添加extern即可</span></span><br><span class="line">    pollInit,</span><br><span class="line">    pollAdd,</span><br><span class="line">    pollRemove,</span><br><span class="line">    pollModify,</span><br><span class="line">    pollDispatch,</span><br><span class="line">    pollClear</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化epoll需要的数据</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">pollInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> PollData));    <span class="comment">//开辟一个结构体的空间</span></span><br><span class="line">    data-&gt;maxfd = <span class="number">0</span>;                               <span class="comment">//初始化为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        data-&gt;fds[i].fd = <span class="number">-1</span>;                      <span class="comment">//指定为-1，为无效文件描述符</span></span><br><span class="line">        data-&gt;fds[i].events = <span class="number">0</span>;                    <span class="comment">//事件都指定为0</span></span><br><span class="line">        data-&gt;fds[i].revents = <span class="number">0</span>;                  <span class="comment">//事件都指定为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollAdd</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent)                  <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLOUT;                           <span class="comment">//保存写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找空位，将events写进去</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == <span class="number">-1</span>)                 <span class="comment">//找到空位了</span></span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = events;</span><br><span class="line">            data-&gt;fds[i].fd = channel-&gt;fd;</span><br><span class="line">            data-&gt;maxfd = i &gt; data-&gt;maxfd ? i : data-&gt;maxfd;              <span class="comment">//maxfd记录的是最大文件描述符</span></span><br><span class="line">            <span class="keyword">break</span>;                                 <span class="comment">//找到空位存储后，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                                <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollRemove</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == channel-&gt;fd)</span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = <span class="number">0</span>;</span><br><span class="line">            data-&gt;fds[i].revents = <span class="number">0</span>;</span><br><span class="line">            data-&gt;fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;                             <span class="comment">//找到要删除的fd后，进行重置(从检测集合中删除)，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 channel 释放对应的 TcpConnection 资源(给channel的回收资源回调函数指向销毁TcpConnection的函数即可)</span></span><br><span class="line">    channel-&gt;<span class="built_in">destroyCallback</span>(channel-&gt;arg);   <span class="comment">//arg对应的是调用channelInit()的时候的conn，即TcpConnection</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                               <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollModify</span><span class="params">(<span class="keyword">struct</span> Channel* channel, <span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//channel里面有要更改为什么样的事件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; ReadEvent)             <span class="comment">//如果不为0，就保存读事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel-&gt;events &amp; WriteEvent)</span><br><span class="line">    &#123;</span><br><span class="line">        events |= POLLOUT;                      <span class="comment">//保存写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; Max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == channel-&gt;fd)</span><br><span class="line">        &#123;</span><br><span class="line">            data-&gt;fds[i].events = events;          <span class="comment">//得到更改好的events</span></span><br><span class="line">            <span class="keyword">break</span>;                                 <span class="comment">//找到空位存储后，就可以退出循环了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= Max)                             <span class="comment">//如果i&gt;Max了，说明没有找到，就直接退出返回-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollDispatch</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">poll</span>(data-&gt;fds, data-&gt;maxfd + <span class="number">1</span>, timeout * <span class="number">1000</span>);         <span class="comment">//检测满足就绪的事件，timeout是秒，需要转为毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= data-&gt;maxfd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].fd == <span class="number">-1</span>)                          <span class="comment">//如果为-1，说明是没有用的一块空间,无效元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;                                       <span class="comment">//退出本轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是有效，判断它的revents是读事件还是写事件</span></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].revents &amp; POLLIN)                    <span class="comment">//如果读事件触发，调用对应的读回调</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过fd找到对应的channel</span></span><br><span class="line">            <span class="built_in">eventActivate</span>(evLoop, data-&gt;fds[i].fd, ReadEvent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (data-&gt;fds[i].revents &amp; POLLOUT)                   <span class="comment">//如果写事件触发，调用对应的写回调</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">eventActivate</span>(evLoop, data-&gt;fds[i].fd, WriteEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">pollClear</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PollData</span>* data = (<span class="keyword">struct</span> PollData*)evLoop-&gt;dispatcherData;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件循环类EventLoop"><a href="#事件循环类EventLoop" class="headerlink" title="事件循环类EventLoop"></a>事件循环类EventLoop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> EpollDispatcher;           <span class="comment">//如果在某个文件中要使用其它文件里定义的全局变量时，需要添加关键字extern</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> PollDispatcher;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">Dispatcher</span> SelectDispatcher;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理该节点中的channel的方式</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Elemtype</span> &#123;ADD, DELETE, MODIFY&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务队列的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span> &#123;</span><br><span class="line"><span class="type">int</span> type;                    <span class="comment">//如何处理该节点中的channel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChanenlElenmet</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span>;  <span class="comment">//不管该结构体现在是否被定义出来，先告诉编译器有这种类型，下面就可以用这种类型去定义变量(Dispatcher和eventloop互包含了)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="type">bool</span> isQuit;                     <span class="comment">//EventLoop是否在工作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span>* dispatcher;        <span class="comment">//使用的io多路转接技术结构体，指向的是三个中其中一个</span></span><br><span class="line"><span class="type">void</span>* dispatcherData;            <span class="comment">//dispatcher指向哪种io技术，这就指向对应的数据块</span></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* head;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* tail;</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap;</span><br><span class="line"><span class="comment">//线程id，name，mutex</span></span><br><span class="line"><span class="type">pthread_t</span> threadID;</span><br><span class="line"><span class="type">char</span> threadName[<span class="number">32</span>];</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;           <span class="comment">//互斥锁，保护任务队列的</span></span><br><span class="line"><span class="type">int</span> socketPair[<span class="number">2</span>];               <span class="comment">//存储本地通信的fd，通过socketpair初始化(用于激活阻塞的io复用)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInit</span>();                             <span class="comment">//如果eventloop是主线程，就使用这个</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInitEx</span>(<span class="type">const</span> <span class="type">char</span>* threadName);     <span class="comment">//如果创建的eventloop属于子线程，就使用这个</span></span><br><span class="line"><span class="comment">//启动反应堆模型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRun</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;           <span class="comment">//参数为启动的实例</span></span><br><span class="line"><span class="comment">//处理被激活的文件fd(在evloop模型里面通过fd找到了对应的channel，然后就可以通过传进来的event来判断执行读回调或写回调)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventActivate</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> fd, <span class="type">int</span> event)</span></span>;   <span class="comment">//参数：evloop；要激活的fd；对应的事件</span></span><br><span class="line"><span class="comment">//添加任务到任务队列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAddTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel, <span class="type">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">//子线程处理任务队列中的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopProcessTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span>;</span><br><span class="line"><span class="comment">//处理dispatcher中的节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAdd</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRemove</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopModify</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br><span class="line"><span class="comment">//释放channel(断开连接，不需要用fd时调用)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">destroyChannel</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span>;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInit</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">eventLoopInitEx</span>(<span class="literal">NULL</span>);                   <span class="comment">//使用子线程的初始化函数即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写数据(这是主线程用来唤醒阻塞子线程的调用函数，在主线程执行eventLoopAddTask时会调用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskWakeup</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>;</span><br><span class="line"><span class="built_in">write</span>(evLoop-&gt;socketPair[<span class="number">0</span>], msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读数据(主线程用来唤醒的读回调函数)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readLocalMessage</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evloop = (<span class="keyword">struct</span> EventLoop*)arg;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">read</span>(evloop-&gt;socketPair[<span class="number">1</span>], buf, <span class="built_in">sizeof</span>(buf));       <span class="comment">//主要目的不是读数据处理，而是触发一次读回调，解除阻塞</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">eventLoopInitEx</span>(<span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = (<span class="keyword">struct</span> EventLoop*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> EventLoop));          <span class="comment">//先创建出一个反应堆结构体</span></span><br><span class="line">evLoop-&gt;isQuit = <span class="literal">false</span>;                    <span class="comment">//刚开始还没有运行，赋值为false</span></span><br><span class="line">evLoop-&gt;threadID = <span class="built_in">pthread_self</span>();         <span class="comment">//哪个线程调用该函数，pthread_self()就会是该线程的id</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;evLoop-&gt;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(evLoop-&gt;threadName, threadName == <span class="literal">NULL</span> ? <span class="string">&quot;MainThread&quot;</span> : threadName);     <span class="comment">//如果是主线程，就固定名字，是子线程就设置为指定的名字</span></span><br><span class="line">evLoop-&gt;dispatcher = &amp;EpollDispatcher;                        <span class="comment">//使用epoll模型</span></span><br><span class="line"><span class="comment">//evLoop-&gt;dispatcher = &amp;PollDispatcher;                        //使用poll模型</span></span><br><span class="line"><span class="comment">//evLoop-&gt;dispatcher = &amp;SelectDispatcher;                        //使用select模型</span></span><br><span class="line">evLoop-&gt;dispatcherData = evLoop-&gt;dispatcher-&gt;<span class="built_in">init</span>();  <span class="comment">//通过函数指针init得到epoll模型需要的数据(根节点、检测集合)</span></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line">evLoop-&gt;head = evLoop-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">evLoop-&gt;channelMap = <span class="built_in">channelMapInit</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决子线程在epoll、poll或select中阻塞的情况</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">socketpair</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, evLoop-&gt;socketPair);  <span class="comment">//调用成功后，evloop结构体里的socketPair数组里面就有2个可用的文件描述符，可进行本地的网络通信</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;socketpair&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定规则：evLoop-&gt;socketPair[0]发送数据；evLoop-&gt;socketPair[1]接收数据</span></span><br><span class="line"><span class="comment">// 1.当子线程发送阻塞时，通过socketPair[0]发送数据，socketPair[1]就会接收数据，读事件被激活</span></span><br><span class="line"><span class="comment">// 2.底层epoll、poll或select阻塞时，它们检测对应的读集合里面没有处于激活状态的，然后在该读激活里面添加了socketPair[1]，当从socketPair[0]</span></span><br><span class="line"><span class="comment">//   发送数据时，它们就可以检测到socketPair[1]被激活了，然后它们就解除阻塞了</span></span><br><span class="line"><span class="comment">//初始化一个channel，当socketPair[0]发送数据后，socketPair[1]就会被激活，然后执行读回调readLocalMessage</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = <span class="built_in">channelInit</span>(evLoop-&gt;socketPair[<span class="number">1</span>], ReadEvent,</span><br><span class="line">readLocalMessage, <span class="literal">NULL</span>, <span class="literal">NULL</span>, evLoop);  <span class="comment">//参数：通信描述符；事件；读回调；写回调；回调函数的参数</span></span><br><span class="line"><span class="comment">//channel添加到任务队列</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(evLoop, channel, ADD);           <span class="comment">//ADD添加到检测集合里面(但还没有开始进行监听)</span></span><br><span class="line"><span class="keyword">return</span> evLoop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRun</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(evLoop != <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//取出事件分发和检测模型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dispatcher</span>* dispatcher = evLoop-&gt;dispatcher;</span><br><span class="line"><span class="comment">//比较线程id是否正常</span></span><br><span class="line"><span class="keyword">if</span> (evLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;                    <span class="comment">//异常情况就退出返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环进行事件处理</span></span><br><span class="line"><span class="keyword">while</span> (!evLoop-&gt;isQuit) &#123;</span><br><span class="line"><span class="comment">////超时时长2s,如果evLoop-&gt;dispatcher分别可以指向三张种io多路的其中一个，指向的不同，该行执行的也不同</span></span><br><span class="line">dispatcher-&gt;<span class="built_in">dispatch</span>(evLoop, <span class="number">2</span>);    <span class="comment">//如果发生阻塞，就是阻塞在该行程序，里面执行的是就绪的读和写回调函数</span></span><br><span class="line"><span class="comment">//dispatch函数里面只是监听fd，对有事件的fd调用对应的执行函数(所以每次执行完一系列fd的回调函数后，就查看处理一下任务队列eventLoopProcessTask)</span></span><br><span class="line"><span class="built_in">eventLoopProcessTask</span>(evLoop);       <span class="comment">//子线程处理任务队列中的任务(dispatch没有对fd中的读和写事件进行修改的模块)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventActivate</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="type">int</span> fd, <span class="type">int</span> event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span> || evLoop == <span class="literal">NULL</span>) &#123;             <span class="comment">//如果出现异常情况，直接退出</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取出channel</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = evLoop-&gt;channelMap-&gt;list[fd];</span><br><span class="line"><span class="built_in">assert</span>(channel-&gt;fd == fd);             <span class="comment">//理论上是相等的，因为list指向的数组下标与fd相等，且一一对应</span></span><br><span class="line"><span class="comment">//初始化channel的时候，可能没有指定回调函数，所以当为空的时候，也不执行回调函数</span></span><br><span class="line"><span class="keyword">if</span> (event &amp; ReadEvent &amp;&amp; channel-&gt;readCallback) &#123;</span><br><span class="line">channel-&gt;<span class="built_in">readCallback</span>(channel-&gt;arg);            <span class="comment">//如果是读事件，就调用对应的读回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (event &amp; WriteEvent  &amp;&amp; channel-&gt;writeCallback) &#123;</span><br><span class="line">channel-&gt;<span class="built_in">writeCallback</span>(channel-&gt;arg);           <span class="comment">//如果是写事件，就调用对应的写回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加任务到任务队列(主线程和子线程都可能执行该函数)</span></span><br><span class="line"><span class="comment">//2条路径：(1)子线程往任务队列里面添加任务，然后自己处理该任务；(2)主线程给任务队列添加入任务了，因为它是不能处理的，而它又不清楚子线程目前</span></span><br><span class="line"><span class="comment">// 是在工作还在阻塞，就默认是阻塞，因此主线程就调用一个唤醒函数，这样就能保证子线程是在工作了，即子线程都从run()函数的dispatch函数中解除阻塞</span></span><br><span class="line"><span class="comment">// 解除阻塞了，就可以执行任务队列中的任务了。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAddTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel, <span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//添加链表节点的时候，有可能是主线程添加，也有可能是子线程添加，所以得加互斥锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;evLoop-&gt;mutex);               <span class="comment">//加锁，保护共享资源</span></span><br><span class="line"><span class="comment">//创建新节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* node = (<span class="keyword">struct</span> ChannelElement*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ChannelElement));</span><br><span class="line"><span class="comment">//对节点的成员做初始化</span></span><br><span class="line">node-&gt;channel = channel;</span><br><span class="line">node-&gt;type = type;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;              <span class="comment">//先让其指向空</span></span><br><span class="line"><span class="comment">//插入链表</span></span><br><span class="line"><span class="keyword">if</span> (evLoop-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">evLoop-&gt;head = evLoop-&gt;tail = node;         <span class="comment">//如果链表还为空，就将头指针和尾指针都指向node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;            <span class="comment">//不为空，就后插法</span></span><br><span class="line">evLoop-&gt;tail-&gt;next = node;              <span class="comment">//添加</span></span><br><span class="line">evLoop-&gt;tail = node;                    <span class="comment">//后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;evLoop-&gt;mutex);             <span class="comment">//解锁，防止死锁</span></span><br><span class="line"><span class="comment">//处理节点(主线程只负责监听有无客户端连接，子线程负责通信任务)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">细节：</span></span><br><span class="line"><span class="comment">1.对于链表节点的添加：可能是当前线程也可能是其它线程(主线程)---&gt;前提条件是当前的eventloop反应堆属于子线程</span></span><br><span class="line"><span class="comment">(1)修改fd事件，当前子线程发起，当前子线程处理</span></span><br><span class="line"><span class="comment">(2)添加新的fd，添加任务节点的操作是由主线程发起的</span></span><br><span class="line"><span class="comment">2.不能让主线程处理任务队列，需要由当前的子线程取消处理(因为每个线程都有一个eventloop反应堆，底层都有一个dispatcher,每个dispatcher都</span></span><br><span class="line"><span class="comment">有epoll、poll或select，给它们提供服务的就是任务队列，都是一一对应的关系，对应错了，程序也就错了)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (evLoop-&gt;threadID == <span class="built_in">pthread_self</span>()) &#123;       <span class="comment">//如果evloop是主线程发反应堆模型，而目前执行该函数的线程也是主线程，就可以直接执行下面</span></span><br><span class="line"><span class="comment">//当作为子线程，直接处理任务(遍历任务链表执行)</span></span><br><span class="line"><span class="built_in">eventLoopProcessTask</span>(evLoop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当前为主线程 ---&gt;告诉子线程处理任务队列的任务</span></span><br><span class="line"><span class="comment">// 情况：主线程监听到客户端连接后，执行它的读回调函数(取子反应堆与cfd，将channel添加到evloop的任务队列里)</span></span><br><span class="line"><span class="comment">//子线程此时在：1.子线程在工作 </span></span><br><span class="line"><span class="comment">// 2.子线程被阻塞了：select,poll,epoll(子线程被阻塞(没有激活事件)，如果主线程与客户端又来连接，主线程将任务添加到任务队列，子线程因为阻塞不会去执行)</span></span><br><span class="line"><span class="built_in">taskWakeup</span>(evLoop);                  <span class="comment">//通过socketPair[0]向socketPair[1]写数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理任务队列中的任务</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopProcessTask</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;evLoop-&gt;mutex);           <span class="comment">//加锁</span></span><br><span class="line"><span class="comment">//取出头节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* head = evLoop-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = head-&gt;channel;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;type == ADD) &#123;</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line"><span class="built_in">eventLoopAdd</span>(evLoop, channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;type == DELETE) &#123;</span><br><span class="line"><span class="comment">//删除(将channel里面的fd从evloop里面dispatch检测集合删除)</span></span><br><span class="line"><span class="built_in">eventLoopRemove</span>(evLoop, channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (head-&gt;type == MODIFY) &#123;</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="built_in">eventLoopModify</span>(evLoop, channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelElement</span>* tmp = head;</span><br><span class="line">head = head-&gt;next;                      <span class="comment">//后移</span></span><br><span class="line"><span class="built_in">free</span>(tmp);                              <span class="comment">//释放刚刚处理的任务节点</span></span><br><span class="line">&#125;</span><br><span class="line">evLoop-&gt;head = evLoop-&gt;tail = <span class="literal">NULL</span>;         <span class="comment">//退出循环后，说明任务队列里面的任务已经处理完了，将头指针和尾指针都指向空</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;evLoop-&gt;mutex);           <span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将channel添加到map集合中和dispatcher的检测集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopAdd</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符(要添加的)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line"><span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= channelMap-&gt;size) &#123;                 <span class="comment">//说明channelMap容量不够，没有位置来存储与channel(每个channel有一个fd)的关系</span></span><br><span class="line"><span class="comment">//没有足够空间存储键值对 fd - channel ==》扩容</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">makeMapRoom</span>(channelMap, fd, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> Channel*))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;              <span class="comment">//如果没有成功就退出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到fd对应的数组元素位置，并存储</span></span><br><span class="line"><span class="keyword">if</span> (channelMap-&gt;list[fd] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">channelMap-&gt;list[fd] = channel;              <span class="comment">//存储fd与channel对应关系</span></span><br><span class="line"><span class="comment">//把channel的文件描述符fd添加到对应的文件描述符检测集合中</span></span><br><span class="line">evLoop-&gt;dispatcher-&gt;<span class="built_in">add</span>(channel, evLoop);    <span class="comment">//选择的dispatcher模型(epoll、poll、select)不一样，该指针指向的函数add处理动作也就不一样</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopRemove</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符(要删除的)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line"><span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= channelMap-&gt;size) &#123;                 <span class="comment">//说明要删除的文件描述符不在channelMap容器里存储，即要删除的描述符不在检测的集合里面</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//不在就直接退出即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ret = evLoop-&gt;dispatcher-&gt;<span class="built_in">remove</span>(channel, evLoop);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eventLoopModify</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> fd = channel-&gt;fd;                                 <span class="comment">//取出文件描述符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChannelMap</span>* channelMap = evLoop-&gt;channelMap;</span><br><span class="line"><span class="comment">//文件描述符对应的就是channelMap数组的下标</span></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=channelMap-&gt;size || channelMap-&gt;list[fd] == <span class="literal">NULL</span>) &#123;         <span class="comment">//说明要修改的文件描述符不在channelMap容器里存储(相比视频多了一个判断，更严谨)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;               <span class="comment">//不在就直接退出即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ret = evLoop-&gt;dispatcher-&gt;<span class="built_in">modify</span>(channel, evLoop);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">destroyChannel</span><span class="params">(<span class="keyword">struct</span> EventLoop* evLoop, <span class="keyword">struct</span> Channel* channel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除 channel 和 fd 的对应关系</span></span><br><span class="line">evLoop-&gt;channelMap-&gt;list[channel-&gt;fd] = <span class="literal">NULL</span>;    <span class="comment">//将该反应堆里面channelMap对应fd的位置置为null</span></span><br><span class="line"><span class="comment">//关闭fd</span></span><br><span class="line"><span class="built_in">close</span>(channel-&gt;fd);</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="built_in">free</span>(channel);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-多线程"><a href="#5-2-多线程" class="headerlink" title="5.2 多线程"></a>5.2 多线程</h2><h3 id="线程池类ThreadPool"><a href="#线程池类ThreadPool" class="headerlink" title="线程池类ThreadPool"></a>线程池类ThreadPool</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义线程池</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="comment">//主线程的反应堆模型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* mainLoop;         <span class="comment">//主要做备份用，只负责与客户端建立连接(只有在线程池没有子线程的情况下，它才负责出来与客户端的连接通信)</span></span><br><span class="line"><span class="type">bool</span> isStart;                       <span class="comment">//当前线程池是否启动</span></span><br><span class="line"><span class="type">int</span> threadNum;                      <span class="comment">//线程池中子线程的数量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorkerThread</span>* workerThreads;      <span class="comment">//指向子线程数组的指针</span></span><br><span class="line"><span class="type">int</span> index;                               <span class="comment">//编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* <span class="built_in">threadPoolInit</span>(<span class="keyword">struct</span> EventLoop* mainLoop, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* pool = (<span class="keyword">struct</span> ThreadPool*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> ThreadPool));<span class="comment">//给线程池申请一块堆内存</span></span><br><span class="line">pool-&gt;index = <span class="number">0</span>;                     <span class="comment">//下标先置为0</span></span><br><span class="line">pool-&gt;isStart = <span class="literal">false</span>;               <span class="comment">//线程池默认情况下没有启动的，置为false</span></span><br><span class="line">pool-&gt;mainLoop = mainLoop;           <span class="comment">//主线程的反应堆模型(当线程池没有子线程时，也就没有子反应堆，可以使用主反应堆模型)</span></span><br><span class="line">pool-&gt;threadNum = count;             <span class="comment">//线程池中子线程的个数</span></span><br><span class="line">pool-&gt;workerThreads = (<span class="keyword">struct</span> WorkerThread*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> WorkerThread) * count);    <span class="comment">//存储子线程实例的数组</span></span><br><span class="line"><span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPoolRun</span><span class="params">(<span class="keyword">struct</span> ThreadPool* pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pool &amp;&amp; !pool-&gt;isStart);        <span class="comment">//如果pool还为空(说明还没有创建线程池) 或线程池已经启动了都是有问题的</span></span><br><span class="line"><span class="comment">//线程池里面存的是主线程反应堆，如果里面的线程号与当前的线程不一样，说明调用该函数的不是主线程，就退出</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;mainLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;            <span class="comment">//如果现在要启动线程池的不是主线程，就退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上都没有出错，就开始启动线程池</span></span><br><span class="line">pool-&gt;isStart = <span class="literal">true</span>;                               <span class="comment">//是否启动置为true</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadNum) &#123;                              <span class="comment">//如果线程池里面的子线程大于0的。就初始化它们，再启动   </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;threadNum; i++) &#123;</span><br><span class="line"><span class="built_in">workerThreadInit</span>(&amp;pool-&gt;workerThreads[i], i);       <span class="comment">//初始化。参数：子线程的地址，第i个</span></span><br><span class="line"><span class="comment">//启动子线程(创建子反应堆--&gt;启动子反应堆--&gt;evloop的dispatcher开始一直检测)</span></span><br><span class="line"><span class="built_in">workerThreadRun</span>(&amp;pool-&gt;workerThreads[i]);        <span class="comment">//启动，参数：子线程实例化后的地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* <span class="built_in">takeWorkerEventLoop</span>(<span class="keyword">struct</span> ThreadPool* pool)    <span class="comment">//该函数的调用由主线程来完成</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pool-&gt;isStart);                 <span class="comment">//此时如果线程池pool还没有运行，说明是错误的</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;mainLoop-&gt;threadID != <span class="built_in">pthread_self</span>()) &#123;            <span class="comment">//如果调用该函数的线程的不是主线程，是错误的，退出</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从线程池中找到一个子线程，然后取出里边的反应堆实例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = pool-&gt;mainLoop;                  <span class="comment">//赋值主线程反应堆实例的地址</span></span><br><span class="line"><span class="keyword">if</span> (pool-&gt;threadNum &gt; <span class="number">0</span>) &#123;                                  <span class="comment">//判断线程池里面的线程数量是否大于0</span></span><br><span class="line">evLoop = pool-&gt;workerThreads[pool-&gt;index].evLoop;       <span class="comment">//取出子线程的反应堆模型</span></span><br><span class="line">pool-&gt;index = ++pool-&gt;index % pool-&gt;threadNum;          <span class="comment">//使得每个子线程的反应堆模型都可以获取到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> evLoop;         <span class="comment">//如果线程池里面的子线程&lt;=0，那么返回的就是主线程的反应堆模型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作线程类WorkerThread"><a href="#工作线程类WorkerThread" class="headerlink" title="工作线程类WorkerThread"></a>工作线程类WorkerThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义子线程对应的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorkerThread</span> &#123;</span><br><span class="line"><span class="type">pthread_t</span> threadID;              <span class="comment">//ID</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">24</span>];                   <span class="comment">//线程名</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;           <span class="comment">//互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;             <span class="comment">//条件变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop;        <span class="comment">//反应堆模型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">workerThreadInit</span><span class="params">(<span class="keyword">struct</span> WorkerThread* thread, <span class="type">int</span> index)</span>    <span class="comment">//参1是在外部创建好的一块结构体空间，然后传入的是指向该结构体的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">thread-&gt;evLoop = <span class="literal">NULL</span>;                           <span class="comment">//默认情况下，子线程的反应堆模型是没有的，所以指为空</span></span><br><span class="line">thread-&gt;threadID = <span class="number">0</span>;                            <span class="comment">//线程还没有启动起来，id也指为0</span></span><br><span class="line"><span class="built_in">sprintf</span>(thread-&gt;name, <span class="string">&quot;SubThread-%d&quot;</span>, index);    <span class="comment">//根据编号起名字</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;thread-&gt;mutex, <span class="literal">NULL</span>);        <span class="comment">//初始化互斥锁</span></span><br><span class="line"><span class="built_in">pthread_cond_init</span>(&amp;thread-&gt;cond, <span class="literal">NULL</span>);          <span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程的回调函数(创建子反应堆模型)</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">subThreadRunning</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WorkerThread</span>* thread = (<span class="keyword">struct</span> WorkerThread*)arg;</span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;thread-&gt;mutex);                     <span class="comment">//加锁</span></span><br><span class="line">thread-&gt;evLoop = <span class="built_in">eventLoopInitEx</span>(thread-&gt;name);         <span class="comment">//给当前的子线程实例化一个反应堆模型</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;thread-&gt;mutex);                   <span class="comment">//解锁</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(&amp;thread-&gt;cond);                     <span class="comment">//唤醒主线程，说明子线程创建反应堆成功</span></span><br><span class="line"><span class="comment">//底层就是启动dispatcher，开始检测</span></span><br><span class="line"><span class="built_in">eventLoopRun</span>(thread-&gt;evLoop);                           <span class="comment">//将该反应堆运行起来</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThreadRun</span><span class="params">(<span class="keyword">struct</span> WorkerThread* thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建子线程</span></span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;thread-&gt;threadID, <span class="literal">NULL</span>, subThreadRunning, thread);</span><br><span class="line"><span class="comment">//阻塞主线程，让当前函数不会直接结束(如果主线程执行该函数结束了，而子线程的回调函数还没有结束，即反应堆还没有创建出来，那当我们使用该</span></span><br><span class="line"><span class="comment">// 子线程的反应堆模型时，就会出现错误)</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;thread-&gt;mutex);        <span class="comment">//因为子线程的反应堆evLoop是共享资源(主线程和子线程都在访问，这里就是主线程访问)，所以需要加锁</span></span><br><span class="line"><span class="keyword">while</span> (thread-&gt;evLoop == <span class="literal">NULL</span>) &#123;                     <span class="comment">//如果没有创建好，就阻塞在互斥锁上</span></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;thread-&gt;cond, &amp;thread-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;thread-&gt;mutex);      <span class="comment">//退出循环，说明子线程执行完了，就解锁退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-IO模型"><a href="#5-3-IO模型" class="headerlink" title="5.3 IO模型"></a>5.3 IO模型</h2><h3 id="读写缓存区类Buffer"><a href="#读写缓存区类Buffer" class="headerlink" title="读写缓存区类Buffer"></a>读写缓存区类Buffer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"><span class="type">char</span>* data;                 <span class="comment">//指向内存的指针</span></span><br><span class="line"><span class="type">int</span> capacity;               <span class="comment">//buffer内存块的总大小</span></span><br><span class="line"><span class="type">int</span> readPos;                <span class="comment">//读数据的位置</span></span><br><span class="line"><span class="type">int</span> writePos;               <span class="comment">//写数据的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要使用memmem()函数不仅要有头文件&lt;strings.h&gt;，还需要定义宏_GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>* <span class="built_in">bufferInit</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>* buffer = (<span class="keyword">struct</span> Buffer*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Buffer));        <span class="comment">//申请出一块Buffer堆内存</span></span><br><span class="line"><span class="keyword">if</span> (buffer != <span class="literal">NULL</span>) &#123;                              <span class="comment">//如果开辟成功</span></span><br><span class="line">buffer-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size);            <span class="comment">//让buffer里面的data指针指向char型的数组，长度为size</span></span><br><span class="line">buffer-&gt;capacity = size;</span><br><span class="line">buffer-&gt;writePos = buffer-&gt;readPos = <span class="number">0</span>;        <span class="comment">//初始情况下，读位置和写位置都为0</span></span><br><span class="line"><span class="built_in">memset</span>(buffer-&gt;data, <span class="number">0</span>, size);                 <span class="comment">//将data指针指向的大小为size的内存块都置为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferDestroy</span><span class="params">(<span class="keyword">struct</span> Buffer* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buf != <span class="literal">NULL</span>) &#123;                          <span class="comment">//首先判断buf是否为空</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;data != <span class="literal">NULL</span>) &#123;                <span class="comment">//再判断buf里面的data成员指向的内存是否为空</span></span><br><span class="line"><span class="built_in">free</span>(buf-&gt;data);                    <span class="comment">//如果都不为空，说明它是指向了一块有效的堆内存，然后就释放该data堆内存</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);                   <span class="comment">//释放buf堆内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bufferExtendRoom</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.内存够用 - 不需要扩容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bufferWriteableSize</span>(buffer) &gt;= size) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.内存需要合并才够用 - 不需要扩容</span></span><br><span class="line"><span class="comment">// 已读的内存 + 剩余的可写的内存 &gt;= size</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buffer-&gt;readPos + <span class="built_in">bufferWriteableSize</span>(buffer) &gt;= size) &#123;</span><br><span class="line"><span class="comment">//得到未读的内存大小</span></span><br><span class="line"><span class="type">int</span> readable = <span class="built_in">bufferReadableSize</span>(buffer);</span><br><span class="line"><span class="comment">//移动内存(将未读的数据移动到初始点)</span></span><br><span class="line"><span class="built_in">memcpy</span>(buffer-&gt;data, buffer-&gt;data + buffer-&gt;readPos, readable);   <span class="comment">//将未读数据移动到初始点data,移动的长度为未读数据长度</span></span><br><span class="line"><span class="comment">//更新位置</span></span><br><span class="line">buffer-&gt;readPos = <span class="number">0</span>;                <span class="comment">//将读数据位置设为起点</span></span><br><span class="line">buffer-&gt;writePos = readable;        <span class="comment">//将写数据位置设为未读数据的长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3，内存不够用 - 扩容</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">void</span>* temp = <span class="built_in">realloc</span>(buffer-&gt;data, buffer-&gt;capacity + size);          <span class="comment">//参数：扩容内存块的起始地址；新的内存块需要多大</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;                    <span class="comment">//失败了直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(temp + buffer-&gt;capacity, <span class="number">0</span>, size);                <span class="comment">//将新扩充的内存初始为0</span></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line">buffer-&gt;data = temp;                 <span class="comment">//更新起点</span></span><br><span class="line">buffer-&gt;capacity += size;            <span class="comment">//更新容量大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferWriteableSize</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> buffer-&gt;capacity - buffer-&gt;writePos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferReadableSize</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> buffer-&gt;writePos - buffer-&gt;readPos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferAppendData</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || data &lt;= <span class="number">0</span>) &#123;               <span class="comment">//这三种情况任何一种发送都是异常的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="built_in">bufferExtendRoom</span>(buffer, size);         <span class="comment">//这个函数里面不一定真的会扩容</span></span><br><span class="line"><span class="comment">//数据拷贝</span></span><br><span class="line"><span class="built_in">memcpy</span>(buffer-&gt;data + buffer-&gt;writePos, data, size);             <span class="comment">//从可写位置开始拷贝数据data，长度为size</span></span><br><span class="line">buffer-&gt;writePos += size;                 <span class="comment">//更新写数据位置</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当data数据的中间没有\0的时候，可以使用该函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferAppendString</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">const</span> <span class="type">char</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">strlen</span>(data);        <span class="comment">//strlen是遇到\0就结束统计</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bufferAppendData</span>(buffer, data, size);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将客户端发来的信息存到readbuffer里面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferSocketRead</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// read/recv/readv都可以(readv接收数据时可以往多个数组里面放，第一个用完，就用第二个，以此类推)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iovec</span> vec[<span class="number">2</span>];                            <span class="comment">//定义结构体数组，大小为2</span></span><br><span class="line"><span class="comment">//初始化数组元素</span></span><br><span class="line"><span class="type">int</span> writeable = <span class="built_in">bufferWriteableSize</span>(buffer);             <span class="comment">//接收buffer还有多长的能写区域</span></span><br><span class="line">vec[<span class="number">0</span>].iov_base = buffer-&gt;data + buffer-&gt;writePos;       <span class="comment">//成员base指向buffer的写数据位置</span></span><br><span class="line">vec[<span class="number">0</span>].iov_len = writeable;                              <span class="comment">//成员len赋值为能写区域的大小</span></span><br><span class="line"><span class="type">char</span>* tmpbuf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">40960</span>);                     <span class="comment">//重新申请一块空间，大小为4k</span></span><br><span class="line">vec[<span class="number">1</span>].iov_base = tmpbuf;                                <span class="comment">//第2个结构体的base指向刚才申请的空间</span></span><br><span class="line">vec[<span class="number">1</span>].iov_len = <span class="number">40960</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">readv</span>(fd, vec, <span class="number">2</span>);         <span class="comment">//接收数据，返回值是接收的字节数。参数：文件描述符；vec地址；vec里面元素的个数</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;                          <span class="comment">//出现错误，退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result &lt;= writeable) &#123;         <span class="comment">//说明全部数据都写到了vec[0]这个结构体里面</span></span><br><span class="line">buffer-&gt;writePos += result;         <span class="comment">//直接更新写数据位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                 <span class="comment">//这种情况就是vec[0]的内存不够写，写了一部分数据到刚申请的空间vec[1]结构体里面</span></span><br><span class="line">buffer-&gt;writePos = buffer-&gt;capacity;           <span class="comment">//更新buffer里面的写数据位置(因为这张情况是写满了，所以就等于它的容量)</span></span><br><span class="line"><span class="comment">//将vec[1]里面的数据拷贝到buffer的data里面(会进行扩容)</span></span><br><span class="line"><span class="built_in">bufferAppendData</span>(buffer, tmpbuf, result - writeable);    <span class="comment">//参数：buffer；要写入的数据；写入的长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(tmpbuf);             <span class="comment">//释放为vec[1]开辟的内存</span></span><br><span class="line"><span class="keyword">return</span> result;            <span class="comment">//将接受到的字节返回出去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">bufferFindCRLF</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//strstr ---&gt;大字符串中匹配子字符串(遇到\0结束)</span></span><br><span class="line"><span class="comment">//memmem ---&gt;大数据块中匹配子数据块(需要指定数据块大小)</span></span><br><span class="line"><span class="type">char</span>* ptr = <span class="built_in">memmem</span>(buffer-&gt;data + buffer-&gt;readPos, <span class="built_in">bufferReadableSize</span>(buffer), <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>);  <span class="comment">//读数据起始位置；数据块大小；子数据块；子数据块大小</span></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bufferSendData</span><span class="params">(<span class="keyword">struct</span> Buffer* buffer, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断有无数据</span></span><br><span class="line"><span class="type">int</span> readable = <span class="built_in">bufferReadableSize</span>(buffer);              <span class="comment">//buffer中还有多少待处理(未读)的数据 ---&gt;待发送的数据</span></span><br><span class="line"><span class="keyword">if</span> (readable &gt; <span class="number">0</span>) &#123;                                     <span class="comment">//如果大于0的，就把数据发送出去</span></span><br><span class="line"><span class="comment">//将未读的数据都发送出去(为了防止管道破裂，需要指定参4为非0)</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">send</span>(socket, buffer-&gt;data + buffer-&gt;readPos, readable, MSG_NOSIGNAL); <span class="comment">//参4指定为一个信号，表示忽略底层发来的该信号</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;                   <span class="comment">//说明发送成功了</span></span><br><span class="line">buffer-&gt;readPos += count;      <span class="comment">//移动buffer里面的读数据位置</span></span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">1</span>);                     <span class="comment">//睡眠一会，让接收端休息一下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;             <span class="comment">//返回发送数据的长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Tcp通信类TcpConnection"><a href="#Tcp通信类TcpConnection" class="headerlink" title="Tcp通信类TcpConnection"></a>Tcp通信类TcpConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释该宏，就是边读边写模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_SEND_AUTO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TcpConnection是运行在某个子线程里面的，其在哪个子线程，evloop就属于哪个子线程，即TcpConnection是属于evloop的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>* readBuf;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Buffer</span>* writeBuf;</span><br><span class="line"><span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* request;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子线程反应堆对应的读回调函数(处理读到的数据,即客户端给服务器发生的数据。将要发送的数据写到writebuf)</span></span><br><span class="line"><span class="comment">// 细节：</span></span><br><span class="line"><span class="comment">// 1.当使用的是一起发模式，读回调函数执行完后，所有要发送的数据都写到了wirtebuf,然后通过写回调函数进行一起发送</span></span><br><span class="line"><span class="comment">// 2.当使用的是边读边发模式，读回调函数执行完后，所有数据也都发送完了(因此在读回调函数末尾，就可以断开连接了)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processRead</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line"><span class="comment">//接收数据，存到readBuffer里面</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">bufferSocketRead</span>(conn-&gt;readBuf, conn-&gt;channel-&gt;fd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Debug</span>(<span class="string">&quot;接收到的http请求数据：%s&quot;</span>, conn-&gt;readBuf-&gt;data + conn-&gt;readBuf-&gt;readPos);</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;                              <span class="comment">//读到数据了</span></span><br><span class="line"><span class="comment">//接收到了http请求，解析http请求</span></span><br><span class="line"><span class="type">int</span> socket = conn-&gt;channel-&gt;fd;  <span class="comment">//初始化时，channel记录的只有检测文件描述符的读事件，而没有写事件(所以需要在检测集合对fd添加写事件)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSG_SEND_AUTO                          <span class="comment">//如果定义了该宏，就执行下面代码</span></span></span><br><span class="line"><span class="comment">//由于写回调和读回调都是同一个线程来完成，所以执行完下来两行代码后，写事件不会立即生效，要等该读回调执行完后，线程继续执行下一轮的</span></span><br><span class="line"><span class="comment">//dispatcher检测，这时就会检测到fd的写事件触发，就调用写回调函数，这时writebuf里面是肯定有数据的，因为写读调执行parseHttpRequest时，</span></span><br><span class="line"><span class="comment">//就对http协议进行解析、处理、组织响应块，并存储到了writebuf里面。那么写回调函数就可以把writebuf里面的数据发送给客户端了，并断开连接</span></span><br><span class="line"><span class="comment">//这种方法的弊端：只有将所有响应数据放到writebuf过后，才能把数据发送出去，如果要发送的数据很大，writebuf或许装不下(不能将所有发送的数据</span></span><br><span class="line"><span class="comment">// 放到writebuf，就不能进行数据的发送)</span></span><br><span class="line"><span class="comment">//解决方法：写一部分，发一部分</span></span><br><span class="line"><span class="built_in">writeEventEnable</span>(conn-&gt;channel, <span class="literal">true</span>);   <span class="comment">//参数2为true，会往channel的检测添加写事件，这时channel记录的就是检测文件描述符的读写事件了</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, MODIFY);   <span class="comment">//在eventLoop里面修改节点，从原来的检测读事件变为了检测读写事件(只要能检测写事件，就会触发其写回调函数)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//接收到的数据在readbuf，通过readbuf处理响应体，将响应数据写到writebuf</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="built_in">parseHttpRequest</span>(conn-&gt;request, conn-&gt;readBuf, conn-&gt;response, conn-&gt;writeBuf, socket);</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;      <span class="comment">//如果为false就是解析失败，为true就是成功了，说明要发送的数据已经写到了writeBuf</span></span><br><span class="line"><span class="comment">//解析失败，回复一个简单的html</span></span><br><span class="line"><span class="type">char</span>* errMsg = <span class="string">&quot;Http/1.1 400 Bad Request\r\n\r\n&quot;</span>;</span><br><span class="line"><span class="built_in">bufferAppendString</span>(conn-&gt;writeBuf, errMsg);          <span class="comment">//将errMsg写入到writeBuf</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MSG_SEND_AUTO</span></span><br><span class="line"><span class="comment">//断开连接，把用于通信的文件描述符conn对应的channel里面的fd从反应堆模型的dispatcher检测集合中删除</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE);       <span class="comment">//没有读到数据，断开连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO           <span class="comment">//如果没有定义了该宏，就执行下面代码(边读边发送模式)--&gt;读回调执行完，数据也就发完了，直接断开连接</span></span></span><br><span class="line"><span class="comment">//断开连接，把用于通信的文件描述符conn对应的channel里面的fd从反应堆模型的dispatcher检测集合中删除</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE);      <span class="comment">//这里直接进行了统一断开连接，因为上面多种情况都会断开连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理写(写回调函数)---&gt;当没有注释宏MSG_SEND_AUTO时，下面的写回调函数是永远不会执行的(因为没有在检测集合里面对fd进行修改事件)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">processWrite</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">Debug</span>(<span class="string">&quot;开始发送数据了(基于写回调发送).....&quot;</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">bufferSendData</span>(conn-&gt;writeBuf, conn-&gt;channel-&gt;fd);     <span class="comment">//返回发送数据长度</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//判断数据是否被全部发送出去了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">bufferReadableSize</span>(conn-&gt;writeBuf) == <span class="number">0</span>) &#123;            <span class="comment">//满足条件(可读的长度为0)，说明数据发送完了</span></span><br><span class="line"><span class="comment">//数据全部发送出去，就不检测写事件了(修改检测集合)--&gt;但由于B/S架构是 建立连接-请求-响应-断开 这一过程，所以发送完数据说明响应结束</span></span><br><span class="line"><span class="comment">//1. 不再检测事件 -- 修改channel中保存的事件(可忽略)</span></span><br><span class="line"><span class="built_in">writeEventEnable</span>(conn-&gt;channel, <span class="literal">false</span>);        <span class="comment">//参1是要修改的channel；参2未false，表示不检测写事件了</span></span><br><span class="line"><span class="comment">//2. 修改dispatcher检测的集合 -- 添加任务节点(可忽略)</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, MODIFY);  <span class="comment">//上面对channel从检测读写事件，改为了检测读事件，这里才是真正修改节点数据</span></span><br><span class="line"><span class="comment">//3. 删除这个节点(上面的1和2步都可以不要，只留下这一句即可)</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(conn-&gt;evLoop, conn-&gt;channel, DELETE); <span class="comment">//删除这个channel，客户端与服务端就断开连接了</span></span><br><span class="line"><span class="comment">//数据发送完，断开连接：就将当前的文件描述符从eventLoop检测集合中删除就行，这样客户端与服务器的连接就断开了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* <span class="built_in">tcpConnectionInit</span>(<span class="type">int</span> fd, <span class="keyword">struct</span> EventLoop* evloop)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TcpConnection));  <span class="comment">//给TcpConnection申请一块堆内存</span></span><br><span class="line">conn-&gt;evLoop = evloop;                        <span class="comment">//赋值为传进来的反应堆模型(子线程的反应堆)</span></span><br><span class="line">conn-&gt;readBuf = <span class="built_in">bufferInit</span>(<span class="number">10240</span>);            <span class="comment">//初始化一块内存</span></span><br><span class="line">conn-&gt;writeBuf = <span class="built_in">bufferInit</span>(<span class="number">10240</span>);           <span class="comment">//初始化一块内存</span></span><br><span class="line"><span class="comment">//得到实例</span></span><br><span class="line">conn-&gt;request = <span class="built_in">httpRequestInit</span>();</span><br><span class="line">conn-&gt;response = <span class="built_in">httpResponseInit</span>();</span><br><span class="line"><span class="built_in">sprintf</span>(conn-&gt;name, <span class="string">&quot;Connection-%d&quot;</span>, fd);     <span class="comment">//初始化名字</span></span><br><span class="line"><span class="comment">//对通信描述符fd进行封装(参数：通信描述符；检测读事件；读回调函数；写回调函数；回调函数参数)</span></span><br><span class="line">conn-&gt;channel = <span class="built_in">channelInit</span>(fd, ReadEvent, processRead, processWrite, tcpConnectionDestroy, conn);  <span class="comment">//初始只定义为检测读事件，当需要发的时候再改</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(evloop, conn-&gt;channel, ADD);           <span class="comment">//将channel添加到事件循环的任务队列里面(子反应堆模型evloop的任务队列)</span></span><br><span class="line"><span class="built_in">Debug</span>(<span class="string">&quot;和客户端建立连接，threadName: %s, threadID: %s, connName: %s&quot;</span>, evloop-&gt;threadName, evloop-&gt;threadID, conn-&gt;name);</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存tcpConnection(在服务器和客户端断开连接过后调用，即在epoll、poll、select的remove函数中调用)---&gt;channel的销毁回调函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcpConnectionDestroy</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpConnection</span>* conn = (<span class="keyword">struct</span> TcpConnection*)arg;</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="literal">NULL</span>) &#123;                        <span class="comment">//conn不为空，就可以执行下面的销毁操作</span></span><br><span class="line"><span class="comment">//如果readBuf和wirteBuf都指向有效内存，且在这两块内存里面没有可处理的数据了</span></span><br><span class="line"><span class="keyword">if</span> (conn-&gt;readBuf &amp;&amp; <span class="built_in">bufferReadableSize</span>(conn-&gt;readBuf) == <span class="number">0</span> &amp;&amp; conn-&gt;writeBuf &amp;&amp; <span class="built_in">bufferReadableSize</span>(conn-&gt;writeBuf) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//就可以把TcpConnection里面保存的所有的资源释放掉</span></span><br><span class="line"><span class="built_in">destroyChannel</span>(conn-&gt;evLoop, conn-&gt;channel);                 <span class="comment">//释放channel(把属于哪个反应堆模型evLoop的channel删除)</span></span><br><span class="line"><span class="built_in">bufferDestroy</span>(conn-&gt;readBuf);                                <span class="comment">//释放readBuf</span></span><br><span class="line"><span class="built_in">bufferDestroy</span>(conn-&gt;writeBuf);                               <span class="comment">//释放writeBuf</span></span><br><span class="line"><span class="built_in">httpRequestDestroy</span>(conn-&gt;request);                           <span class="comment">//释放request</span></span><br><span class="line"><span class="built_in">httpResponseDestroy</span>(conn-&gt;response);                         <span class="comment">//释放response</span></span><br><span class="line"><span class="built_in">free</span>(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Debug</span>(<span class="string">&quot;连接断开，释放资源， gameover, connName: %s&quot;</span>, conn-&gt;name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-服务器"><a href="#5-4-服务器" class="headerlink" title="5.4 服务器"></a>5.4 服务器</h2><h3 id="TcpServer类"><a href="#TcpServer类" class="headerlink" title="TcpServer类"></a>TcpServer类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line"><span class="type">int</span> lfd;                                 <span class="comment">//监听的描述符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> port;                     <span class="comment">//端口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span> &#123;</span><br><span class="line"><span class="type">int</span> threadNum;                             <span class="comment">//线程池里面子线程的个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* mainLoop;                <span class="comment">//反应堆模型(主线程)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadPool</span>* threadPool;             <span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span>* listener;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对结构体TcpServer进行初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span>* <span class="built_in">tcpServerInit</span>(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">int</span> threadNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span>* tcp = (<span class="keyword">struct</span> TcpServer*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TcpServer)); <span class="comment">//给tcpserver申请一块内存</span></span><br><span class="line">tcp-&gt;listener = <span class="built_in">listenerInit</span>(port);       <span class="comment">//传入端口，得到通信fd，进行监听</span></span><br><span class="line">tcp-&gt;mainLoop = <span class="built_in">eventLoopInit</span>();          <span class="comment">//初始化主线程的反应堆模型</span></span><br><span class="line">tcp-&gt;threadNum = threadNum;               <span class="comment">//子线程的个数</span></span><br><span class="line"><span class="comment">//实例化线程池</span></span><br><span class="line">tcp-&gt;threadPool = <span class="built_in">threadPoolInit</span>(tcp-&gt;mainLoop, threadNum);     <span class="comment">//参数：主线程的反应堆实例；线程池里面子线程的个数</span></span><br><span class="line"><span class="keyword">return</span> tcp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过端口，创建监听fd</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span>* <span class="built_in">listenerInit</span>(<span class="type">unsigned</span> <span class="type">short</span> port)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Listener</span>* listener = (<span class="keyword">struct</span> Listener*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Listener));       <span class="comment">//创建一块Listener结构体</span></span><br><span class="line"><span class="comment">//1.创建监听的fd(基于tcp的套接字) ---&gt;参三写0即可，因为这里是用流式协议，写0就代表使用的式流式协议的tcp;如果使用的是报文协议，写0就代表使用的是报文协议的udp</span></span><br><span class="line"><span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);    <span class="comment">//参数：指定使用的ip协议是ipv4还是ipv6；指定使用的套接字是基于流式协议还是报文协议</span></span><br><span class="line"><span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.设置端口复用</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span> opt);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.绑定</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(port);               <span class="comment">//将转进来的端口转为网络字节序再进行存储</span></span><br><span class="line"><span class="comment">//该0地址就表示这里绑定本地任意一个ip地址，假如本地计算机有多个网卡，0地址就可以监听所有网卡上面指定的port端口(INADDR_ANY没有大小端之分，所以直接使用即可)</span></span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">//如果有客户端将连接请求发给了网卡a或网卡b对应的port端口，在本地都可以接收到该请求</span></span><br><span class="line">ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span> addr);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.设置监听</span></span><br><span class="line">ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);             <span class="comment">//一次性最多接收128个请求</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回fd</span></span><br><span class="line">listener-&gt;lfd = lfd;</span><br><span class="line">listener-&gt;port = port;</span><br><span class="line"><span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程反应堆模型中监听描述符的读回调函数(与客户端连接)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">acceptConnection</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TcpServer</span>* server = (<span class="keyword">struct</span> TcpServer*)arg;</span><br><span class="line"><span class="comment">//和客户端建立连接</span></span><br><span class="line"><span class="type">int</span> cfd = <span class="built_in">accept</span>(server-&gt;listener-&gt;lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);     <span class="comment">//参数：监听描述符；存储对端信息结构体；参2的大小</span></span><br><span class="line"><span class="comment">//从线程池中取出一个子线程的反应堆实例。去处理这个cfd通信</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EventLoop</span>* evLoop = <span class="built_in">takeWorkerEventLoop</span>(server-&gt;threadPool);     <span class="comment">//从线程池中取出一个子子线程，得到该子线程的反应堆模型</span></span><br><span class="line"><span class="comment">//将cfd放到TcpConnection中处理</span></span><br><span class="line"><span class="built_in">tcpConnectionInit</span>(cfd, evLoop);            <span class="comment">//对fd进行封装，封装好后放到子线程的反应堆模型里面</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tcpServerRun</span><span class="params">(<span class="keyword">struct</span> TcpServer* server)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Debug</span>(<span class="string">&quot;服务器程序已经启动了..........&quot;</span>);</span><br><span class="line"><span class="comment">//启动线程池</span></span><br><span class="line"><span class="built_in">threadPoolRun</span>(server-&gt;threadPool);</span><br><span class="line"><span class="comment">//给主线程的反应堆模型添加检测的任务(监听连接)</span></span><br><span class="line"><span class="comment">//初始化一个channel实例。参数：监听的文件描述符；检测什么事件；事件触发处理的动作(读回调)；写回调；前面回调函数的参数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Channel</span>* channel = <span class="built_in">channelInit</span>(server-&gt;listener-&gt;lfd,</span><br><span class="line">ReadEvent, acceptConnection, <span class="literal">NULL</span>, <span class="literal">NULL</span>, server);       <span class="comment">//因为是监听描述符，所以不需要写回调，同时运行期间不应该释放lfd,所以销毁回调也会为空</span></span><br><span class="line"><span class="comment">//下面先将任务添加到任务队列进行处理，最后添加到对应检测集合中，再启动反应堆模型</span></span><br><span class="line"><span class="built_in">eventLoopAddTask</span>(server-&gt;mainLoop, channel, ADD);      <span class="comment">//参数：主线程的反应堆模型；channel(里面封装了文件描述符)；</span></span><br><span class="line"><span class="comment">//启动主线程的反应堆模型</span></span><br><span class="line"><span class="built_in">eventLoopRun</span>(server-&gt;mainLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-Http"><a href="#5-5-Http" class="headerlink" title="5.5 Http"></a>5.5 Http</h2><h3 id="接收请求类HttpRequest"><a href="#接收请求类HttpRequest" class="headerlink" title="接收请求类HttpRequest"></a>接收请求类HttpRequest</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求头键值对</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestHeader</span> &#123;</span><br><span class="line"><span class="type">char</span>* key;</span><br><span class="line"><span class="type">char</span>* value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前的解析状态(用来记录)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpRequestState</span> &#123;</span><br><span class="line">ParseReqLine,                      <span class="comment">//请求行</span></span><br><span class="line">ParseReqHeaders,                   <span class="comment">//请求头</span></span><br><span class="line">ParseReqBody,                      <span class="comment">//请求的数据块(get请求没有该状态)</span></span><br><span class="line">ParseReqDone                       <span class="comment">//表示当前的请求协议已经解析完了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义http请求结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span> &#123;</span><br><span class="line"><span class="comment">//请求行</span></span><br><span class="line"><span class="type">char</span>* method;                          <span class="comment">//请求方式</span></span><br><span class="line"><span class="type">char</span>* url;                             <span class="comment">//请求资源</span></span><br><span class="line"><span class="type">char</span>* version;                         <span class="comment">//使用的版本</span></span><br><span class="line"><span class="comment">//请求头(有若干个键值对组成)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RequestHeader</span>* reqHeaders;     <span class="comment">//比如说01234下的键值对已经添加，reqHeadersNum就为5，下次继续添加键值对时，直接从5下标开始</span></span><br><span class="line"><span class="type">int</span> reqHeadersNum;                   <span class="comment">//键值对的个数</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpRequestState</span> curState;             <span class="comment">//记录当前的解析状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* <span class="built_in">httpRequestInit</span>();</span><br><span class="line"><span class="comment">//重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestReset</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestResetEx</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestDestroy</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span>;       <span class="comment">//内存释放函数</span></span><br><span class="line"><span class="comment">//获取处理状态</span></span><br><span class="line"><span class="function"><span class="keyword">enum</span> HttpRequestState <span class="title">httpRequestState</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request)</span></span>;</span><br><span class="line"><span class="comment">//添加请求头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span>;</span><br><span class="line"><span class="comment">//根据key得到请求头的value</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">httpRequestGetHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key)</span></span>;</span><br><span class="line"><span class="comment">//解析请求行</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestLine</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析请求头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span>;</span><br><span class="line"><span class="comment">//解析http请求协议(readbuf里面存了有待解析的数据)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理http请求协议(处理前需要先解析http请求)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">processHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> HttpResponse* response)</span></span>;</span><br><span class="line"><span class="comment">//解码字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decodeMsg</span><span class="params">(<span class="type">char</span>* to, <span class="type">char</span>* from)</span></span>;</span><br><span class="line"><span class="comment">//响应数据类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getFileType</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">//发送目录</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span>;</span><br><span class="line"><span class="comment">//发送文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span>;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HeaderSize 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* <span class="built_in">httpRequestInit</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpRequest</span>* request = (<span class="keyword">struct</span> HttpRequest*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HttpRequest));     <span class="comment">//为HttpRequest结构体申请一块空间</span></span><br><span class="line"><span class="built_in">httpRequestReset</span>(request);</span><br><span class="line">request-&gt;reqHeaders = (<span class="keyword">struct</span> RequestHeader*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> RequestHeader) * HeaderSize);   <span class="comment">//给请求头开辟一块空间</span></span><br><span class="line"><span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数主要是用来数据重置的(每发完一次，回到初始设置)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestReset</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">req-&gt;curState = ParseReqLine;                        <span class="comment">//刚开始默认状态是处理请求行</span></span><br><span class="line">req-&gt;method = <span class="literal">NULL</span>;</span><br><span class="line">req-&gt;url = <span class="literal">NULL</span>;</span><br><span class="line">req-&gt;version = <span class="literal">NULL</span>;</span><br><span class="line">req-&gt;reqHeadersNum = <span class="number">0</span>;            <span class="comment">//放数据时从该下标开始放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestResetEx</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(req-&gt;url);</span><br><span class="line"><span class="built_in">free</span>(req-&gt;method);</span><br><span class="line"><span class="built_in">free</span>(req-&gt;version);</span><br><span class="line"><span class="keyword">if</span> (req-&gt;reqHeaders != <span class="literal">NULL</span>) &#123;                            <span class="comment">//先判断指向结构体数值的指针是否为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; req-&gt;reqHeadersNum; i++) &#123;         <span class="comment">//遍历数组释放元素</span></span><br><span class="line"><span class="built_in">free</span>(req-&gt;reqHeaders[i].key);</span><br><span class="line"><span class="built_in">free</span>(req-&gt;reqHeaders[i].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(req-&gt;reqHeaders);                                <span class="comment">//释放完元素，就释放组数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">httpRequestReset</span>(req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestDestroy</span><span class="params">(<span class="keyword">struct</span> HttpRequest* req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (req != <span class="literal">NULL</span>) &#123;                                            <span class="comment">//先判断req是否为空</span></span><br><span class="line"><span class="built_in">httpRequestResetEx</span>(req);</span><br><span class="line"><span class="built_in">free</span>(req);                              <span class="comment">//释放结构体地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">enum</span> HttpRequestState <span class="title">httpRequestState</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> request-&gt;curState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpRequestAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//外面是创建好的一块key和value的结构体，这里面直接赋值即可，不需要申请内存</span></span><br><span class="line">request-&gt;reqHeaders[request-&gt;reqHeadersNum].key = (<span class="type">char</span>*)key;</span><br><span class="line">request-&gt;reqHeaders[request-&gt;reqHeadersNum].value = (<span class="type">char</span>*)value;</span><br><span class="line">request-&gt;reqHeadersNum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">httpRequestGetHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="type">const</span> <span class="type">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (request != <span class="literal">NULL</span>) &#123;               <span class="comment">//如果request不指向空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; request-&gt;reqHeadersNum; i++) &#123;                     <span class="comment">//遍历键值对</span></span><br><span class="line"><span class="comment">//strncasecmp是指比较n个不区分大小写的字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(request-&gt;reqHeaders[i].key, key, <span class="built_in">strlen</span>(key)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> request-&gt;reqHeaders[i].value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;                    <span class="comment">//为空或没有找到对应的键值对，就直接返回空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拆分请求行(解决下面函数parseHttpRequestLine的冗余问题) 参数：起始位置；结束位置；子数据块</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">splitRequestLine</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* start, <span class="type">const</span> <span class="type">char</span>* end, <span class="type">const</span> <span class="type">char</span>* sub, <span class="type">char</span>** ptr)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span>* space = end;</span><br><span class="line"><span class="keyword">if</span> (sub != <span class="literal">NULL</span>) &#123;                              <span class="comment">//第一个和第二个需要用到，获取版本时传入sub==NULL即可</span></span><br><span class="line">space = <span class="built_in">memmem</span>(start, end - start, sub, <span class="built_in">strlen</span>(sub));</span><br><span class="line"><span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                       <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> length = space - start;           <span class="comment">//没有进if()，space就是end</span></span><br><span class="line"><span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(length + <span class="number">1</span>);     <span class="comment">//开辟一块空间</span></span><br><span class="line"><span class="built_in">strncpy</span>(tmp, start, length);</span><br><span class="line">tmp[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">*ptr = tmp;</span><br><span class="line"><span class="keyword">return</span> space + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析请求行(将发来的http请求信息(在readbuf里面)解析后存到requeset结构体里面)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestLine</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//保存字符串结束地址\r\n的位置(该函数并没有对buffer进行读取操作，即readpos的位置没有变)</span></span><br><span class="line"><span class="type">char</span>* end = <span class="built_in">bufferFindCRLF</span>(readBuf);</span><br><span class="line"><span class="comment">//保存字符串起始地址</span></span><br><span class="line"><span class="type">char</span>* start = readBuf-&gt;data + readBuf-&gt;readPos;</span><br><span class="line"><span class="comment">//请求行总长度</span></span><br><span class="line"><span class="type">int</span> lineSize = end - start;</span><br><span class="line"><span class="keyword">if</span> (lineSize) &#123;                       <span class="comment">//如果请求行总长度大于0</span></span><br><span class="line">start = <span class="built_in">splitRequestLine</span>(start, end, <span class="string">&quot; &quot;</span>, &amp;request-&gt;method);    <span class="comment">//调用辅助函数，完成method的截取</span></span><br><span class="line">start = <span class="built_in">splitRequestLine</span>(start, end, <span class="string">&quot; &quot;</span>, &amp;request-&gt;url);       <span class="comment">//静态资源的截取</span></span><br><span class="line"><span class="built_in">splitRequestLine</span>(start, end, <span class="literal">NULL</span>, &amp;request-&gt;version);          <span class="comment">//版本号的截取</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// get /xxx/xxx.txt http/1.1\r\n       ---&gt;end指向的是\r</span></span><br><span class="line"><span class="comment">//请求方式</span></span><br><span class="line"><span class="type">char</span>* space = <span class="built_in">memmem</span>(start, lineSize, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);      <span class="comment">//大数据块起始位置；大数据块长度；子数据块；子数据块长度</span></span><br><span class="line"><span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                              <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line"><span class="type">int</span> methodSize = space - start;                     <span class="comment">//获取method长度</span></span><br><span class="line">request-&gt;method = (<span class="type">char</span>*)<span class="built_in">malloc</span>(methodSize + <span class="number">1</span>);    <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line"><span class="built_in">strncpy</span>(request-&gt;method, start, methodSize);        <span class="comment">//从起始位置读methodSize长度(get)放到request-&gt;method里面</span></span><br><span class="line">request-&gt;method[methodSize] = <span class="string">&quot;\0&quot;</span>;                 <span class="comment">//在get后面加\0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//请求的静态资源</span></span><br><span class="line">start = space + <span class="number">1</span>;                                  <span class="comment">//重新设置起始位置，原来是get后面的空格+1即可</span></span><br><span class="line"><span class="type">char</span>* space = <span class="built_in">memmem</span>(start, end-start, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);     <span class="comment">//大数据块起始位置；大数据块长度；子数据块；子数据块长度</span></span><br><span class="line"><span class="built_in">assert</span>(space != <span class="literal">NULL</span>);                              <span class="comment">//等于空就报错(NULL不等于空格)</span></span><br><span class="line"><span class="type">int</span> urlSize = space - start;                        <span class="comment">//获取静态资源长度</span></span><br><span class="line">request-&gt;url = (<span class="type">char</span>*)<span class="built_in">malloc</span>(urlSize + <span class="number">1</span>);          <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line"><span class="built_in">strncpy</span>(request-&gt;url, start, urlSize);              <span class="comment">//从起始位置读urlSize长度(静态资源)放到request-&gt;url里面</span></span><br><span class="line">request-&gt;url[urlSize] = <span class="string">&quot;\0&quot;</span>;                       <span class="comment">//在静态资源后面加\0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//http版本</span></span><br><span class="line">start = space + <span class="number">1</span>;                                  <span class="comment">//重新设置起始位置，原来是静态资源后面的空格+1即可</span></span><br><span class="line">request-&gt;version = (<span class="type">char</span>*)<span class="built_in">malloc</span>(end - start + <span class="number">1</span>);  <span class="comment">//多加一个字节是为了在尾部加\0</span></span><br><span class="line"><span class="built_in">strncpy</span>(request-&gt;version, start, end - start);      <span class="comment">//从起始位置读相应长度(静态资源)放到request-&gt;version里面</span></span><br><span class="line">request-&gt;version[end - start] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为解析请求头做准备</span></span><br><span class="line">readBuf-&gt;readPos += lineSize;              <span class="comment">//令读数据位置为请求行的\r</span></span><br><span class="line">readBuf-&gt;readPos += <span class="number">2</span>;                     <span class="comment">//再加2个位置(\r\n)，读数据位置就为请求头行了</span></span><br><span class="line"><span class="comment">//修改状态</span></span><br><span class="line">request-&gt;curState = ParseReqHeaders;        <span class="comment">//当前状态为请求头状态</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数处理请求头中的一行(如果要处理请求头中的多行，需要循环调用)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequestHeader</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf)</span>    <span class="comment">//传进来的readBuf已经处理完请求头，读数据位置在请求头行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* end = <span class="built_in">bufferFindCRLF</span>(readBuf);         <span class="comment">//正常情况下end指向\r</span></span><br><span class="line"><span class="keyword">if</span> (end != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">char</span>* start = readBuf-&gt;data + readBuf-&gt;readPos;           <span class="comment">//请求头的起始位置</span></span><br><span class="line"><span class="type">int</span> lineSize = end - start;              <span class="comment">//获取长度</span></span><br><span class="line"><span class="comment">//基于: 搜索字符串</span></span><br><span class="line"><span class="type">char</span>* middle = <span class="built_in">memmem</span>(start, lineSize, <span class="string">&quot;: &quot;</span>, <span class="number">2</span>);       <span class="comment">//在请求头的某一行搜索子数据块&quot;: &quot;，标准的http请求key和value之间是&quot;: &quot;</span></span><br><span class="line"><span class="keyword">if</span> (middle != <span class="literal">NULL</span>) &#123;                                  <span class="comment">//如果不等于NULL，说明middle指向了:</span></span><br><span class="line"><span class="type">char</span>* key = <span class="built_in">malloc</span>(middle - start + <span class="number">1</span>);            <span class="comment">//为key开辟一块空间，加1是为了最后存\0</span></span><br><span class="line"><span class="built_in">strncpy</span>(key, start, middle - start);</span><br><span class="line">key[middle - start] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//middle+2的位置就是value值的初始位置</span></span><br><span class="line"><span class="type">char</span>* value = <span class="built_in">malloc</span>(end - middle - <span class="number">2</span> + <span class="number">1</span>);            <span class="comment">//为value开辟一块空间</span></span><br><span class="line"><span class="built_in">strncpy</span>(value, middle+<span class="number">2</span>, end - middle - <span class="number">2</span>);</span><br><span class="line">key[end - middle - <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="comment">//httpRequestAddHeader函数里面是没有对key和value申请内存的，所以在本函数为它们开辟有效内存</span></span><br><span class="line"><span class="built_in">httpRequestAddHeader</span>(request, key, value);          <span class="comment">//将得到key和value存放到结构体数组中</span></span><br><span class="line"><span class="comment">//移动读数据的位置</span></span><br><span class="line">readBuf-&gt;readPos += lineSize;</span><br><span class="line">readBuf-&gt;readPos += <span class="number">2</span>;                              <span class="comment">//readBuf里面的读数据位置移动到下一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;            <span class="comment">//否则说明请求头已经的内容已经获取完了(请求头的下面是空行\r\n，里面是没有&quot;: &quot;的)</span></span><br><span class="line"><span class="comment">//请求头被解析完了，跳过空行</span></span><br><span class="line">readBuf-&gt;readPos += <span class="number">2</span>;</span><br><span class="line"><span class="comment">//修改解析状态</span></span><br><span class="line"><span class="comment">//忽略post请求(空行下面是有数据的)，按照get请求处理(空行下面是没有数据的)</span></span><br><span class="line">request-&gt;curState = ParseReqDone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析http协议(先解析请求行，再解析请求头)，调用辅助函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">parseHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> Buffer* readBuf, <span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (request-&gt;curState != ParseReqDone) &#123;                    <span class="comment">//当前状态不是结束状态就循环</span></span><br><span class="line"><span class="keyword">switch</span> (request-&gt;curState) &#123;</span><br><span class="line"><span class="keyword">case</span> ParseReqLine:</span><br><span class="line">flag = <span class="built_in">parseHttpRequestLine</span>(request, readBuf);        <span class="comment">//解析请求行存到request，将状态改为解析请求头</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ParseReqHeaders:</span><br><span class="line">flag = <span class="built_in">parseHttpRequestHeader</span>(request, readBuf);       <span class="comment">//解析请求头存到request，将状态改为解析完毕ParseReqDone</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ParseReqBody:               <span class="comment">//只有post请求才会用到这种状态</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;                     <span class="comment">//当解析请求行或请求头出现问题时，会使flag为false，这种情况就直接退出</span></span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否解析完毕了，如果完毕了，需要准备回复的数据</span></span><br><span class="line"><span class="keyword">if</span> (request-&gt;curState == ParseReqDone) &#123;</span><br><span class="line"><span class="comment">// 1. 根据解析出的原始数据，对客户端的请求做出处理(主要完成http协议响应的格式)</span></span><br><span class="line"><span class="built_in">processHttpRequest</span>(request,response);      <span class="comment">//该函数调用后，response指针指向的结构体地址被写入了要发送的数据</span></span><br><span class="line"><span class="comment">// 2. 组织相应数据写到sendBuf，并发送给客户端</span></span><br><span class="line"><span class="built_in">httpResponsePrepareMsg</span>(response, sendBuf, socket); <span class="comment">//根据response里面写入的结构体数据，组织了一个发送给客户端的响应数据块存到sendBuf</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request-&gt;curState = ParseReqLine;       <span class="comment">//还原状态，保证还能继续处理第二条以及以后的请求(从客户端读来的数据都存到buffer里面的)</span></span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理http请求(http协议的响应格式发送)---&gt;没有发送，只是进行了存储，存储在了response结构体中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">processHttpRequest</span><span class="params">(<span class="keyword">struct</span> HttpRequest* request, <span class="keyword">struct</span> HttpResponse* response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(request-&gt;method, <span class="string">&quot;get&quot;</span>) != <span class="number">0</span>) &#123;        <span class="comment">//若干客户端的请求不是get请求，就不处理，直接返回-1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">decodeMsg</span>(request-&gt;url, request-&gt;url);            <span class="comment">//将参2url解码后又存到参1url(中文的utf-8形式转纯中文)</span></span><br><span class="line"><span class="comment">//处理客户端请求的静态资源</span></span><br><span class="line"><span class="type">char</span>* file = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(request-&gt;url, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>) &#123;              <span class="comment">//若干客户端的请求路径是/</span></span><br><span class="line">file = <span class="string">&quot;./&quot;</span>;                    <span class="comment">//将目录改为资源文件的根目录(因为有操作会将当前目录切换为资源目录，所以才是./)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">file = request-&gt;url + <span class="number">1</span>;         <span class="comment">//若不是，就移动位置，取客户端想要的文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取文件的属性</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">stat</span>(file, &amp;st);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;               <span class="comment">//出错</span></span><br><span class="line"><span class="comment">//文件不存在--回复404</span></span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;fileName, <span class="string">&quot;404.html&quot;</span>);             <span class="comment">//文件名</span></span><br><span class="line">response-&gt;statusCode = NotFound;                    <span class="comment">//状态码</span></span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;statusMsg, <span class="string">&quot;Not Found&quot;</span>);           <span class="comment">//状态描述</span></span><br><span class="line"><span class="comment">//响应头(有许多键值对的，这里只发一个键值对)</span></span><br><span class="line"><span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(<span class="string">&quot;.html&quot;</span>));</span><br><span class="line">response-&gt;sendDataFunc = sendFile;            <span class="comment">//发送数据的函数指针指向发送文件数据函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">//出错了退出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;fileName, file);</span><br><span class="line">response-&gt;statusCode = OK;</span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;statusMsg, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line"><span class="comment">//判断文件类型(看是目录还是文件)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;          <span class="comment">//如果是目录</span></span><br><span class="line"><span class="comment">//响应头(有许多键值对的，这里只法一个键值对)</span></span><br><span class="line"><span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(<span class="string">&quot;.html&quot;</span>));    <span class="comment">//因为是目录，它也是通过html文件显示的</span></span><br><span class="line">response-&gt;sendDataFunc = sendDir;            <span class="comment">//发送数据的函数指针指向发送目录数据函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//响应头</span></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp,<span class="string">&quot;%ld&quot;</span>, st.st_size);</span><br><span class="line"><span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-type&quot;</span>, <span class="built_in">getFileType</span>(file));     <span class="comment">//文件类型</span></span><br><span class="line"><span class="built_in">httpResponseAddHeader</span>(response, <span class="string">&quot;Content-length&quot;</span>, tmp);                 <span class="comment">//文件内容长度</span></span><br><span class="line">response-&gt;sendDataFunc = sendFile;            <span class="comment">//发送数据的函数指针指向发送数据函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符转换为整形数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexToDec</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="comment">// to 存储解码之后的数据, 传出参数, from被解码的数据, 传入参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decodeMsg</span><span class="params">(<span class="type">char</span>* to, <span class="type">char</span>* from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; *from != <span class="string">&#x27;\0&#x27;</span>; ++to, ++from)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// isxdigit -&gt; 判断字符是不是16进制格式, 取值在 0-f</span></span><br><span class="line"><span class="comment">// Linux%E5%86%85%E6%A0%B8.jpg</span></span><br><span class="line"><span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将16进制的数 -&gt; 十进制 将这个数值赋值给了字符 int -&gt; char</span></span><br><span class="line"><span class="comment">// B2 == 178</span></span><br><span class="line"><span class="comment">// 将3个字符, 变成了一个字符, 这个字符就是原始数据</span></span><br><span class="line">*to = <span class="built_in">hexToDec</span>(from[<span class="number">1</span>]) * <span class="number">16</span> + <span class="built_in">hexToDec</span>(from[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过 from[1] 和 from[2] 因此在当前循环中已经处理过了</span></span><br><span class="line">from += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 字符拷贝, 赋值</span></span><br><span class="line">*to = *from;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">*to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应数据类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">getFileType</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// a.jpg a.mp4 a.html</span></span><br><span class="line"><span class="comment">// 自右向左查找‘.’字符, 如不存在返回NULL</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* dot = <span class="built_in">strrchr</span>(name, <span class="string">&#x27;.&#x27;</span>);                        <span class="comment">//从右往左找，找到点，就停止，读后面内容也就是后缀了</span></span><br><span class="line"><span class="keyword">if</span> (dot == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;<span class="comment">// 纯文本</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.html&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.htm&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.jpeg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.gif&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.png&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.css&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.au&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wav&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.avi&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mov&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.qt&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpeg&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mpe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.vrml&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.wrl&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.midi&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mid&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.mp3&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.ogg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(dot, <span class="string">&quot;.pac&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;           <span class="comment">//如果没有找到对应的文件格式，就返回纯文本，符号编码是utf-8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拼好的html数据块添加到readbuf里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendDir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* dirName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">4096</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;&quot;</span>, dirName);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>** namelist;</span><br><span class="line"><span class="comment">//遍历目录，返回值是该目录下文件的数量</span></span><br><span class="line"><span class="comment">//scandir 函数会动态分配内存，将每个目录项的指针存储到一个指针数组namelist中。这个数组中的每个元素都是指向struct dirent结构体的指针，这些结构体包含了文件名等目录项信息。</span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">scandir</span>(dirName, &amp;namelist, <span class="literal">NULL</span>, alphasort);   <span class="comment">//参1：要遍历的目录的名字；参2：传出参数；参3：回调函数(遍历的规则)；参4：排序的方式</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="comment">//取出文件名。namelist指向的是一个指针数组 struct dirent* tmp[] -----&gt;数组tmp里面的元素都是struct dirent*类型的指针</span></span><br><span class="line"><span class="type">char</span>* name = namelist[i]-&gt;d_name;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"><span class="type">char</span> subPath[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(subPath, <span class="string">&quot;%s/%s&quot;</span>, dirName, name);          <span class="comment">//拼接成绝对路径</span></span><br><span class="line"><span class="built_in">stat</span>(subPath, &amp;st);                                <span class="comment">//判断该绝对路径是目录还是文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(st.st_mode)) &#123;</span><br><span class="line"><span class="comment">//注意：如果是%s/有斜线，就代表要跳转到某个目录里面去，如果没有斜线，就代表是访问某个文件</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, name, name, st.st_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(buf + <span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, name, name, st.st_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bufferAppendString</span>(sendBuf, buf);               <span class="comment">//将buf里面的数据写到sendBuf</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO          <span class="comment">//如果定义了该宏(说明使用一起发模式，即将所有数据写到sendbuf里面，最后在写回调函数一起发)，下面代码就无效</span></span></span><br><span class="line"><span class="built_in">bufferSendData</span>(sendBuf, cfd);                       <span class="comment">//sendbuf又有数据了，发送数据(边读边发的模式)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));                    <span class="comment">//然后将容器buf清0</span></span><br><span class="line"><span class="built_in">free</span>(namelist[i]);       <span class="comment">//用完了释放空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);             <span class="comment">//拼接结束标签</span></span><br><span class="line"><span class="built_in">bufferAppendString</span>(sendBuf, buf);                   <span class="comment">//将buf里面的数据写到sendBuf</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO                                  <span class="comment">//如果定义了该宏，下面代码就无效</span></span></span><br><span class="line"><span class="built_in">bufferSendData</span>(sendBuf, cfd);                       <span class="comment">//发送数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">free</span>(namelist);             <span class="comment">//释放二级指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要发送的数据写到readbuf</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> cfd)</span>              <span class="comment">//发送文件函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.打开文件</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(filename, O_RDONLY);                   <span class="comment">//以只读的方式打开文件filename</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//assert(fd &gt; 0);                                      //设置断言(如果fd&lt;=0，就会报错)</span></span><br><span class="line"><span class="comment">//发送文件的两种方式(没有改，这里只能用第一种方法)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="keyword">sizeof</span> buf);             <span class="comment">//从文件中读出数据存到buf</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;                                   <span class="comment">//每次循环后，如果数据还没有读完，len就会大于0</span></span><br><span class="line"><span class="built_in">bufferAppendData</span>(sendBuf, buf, len);         <span class="comment">//将数据buf长度为len的数据写入到sendBuf(buf结尾不是\0，所以得用该函数)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO             <span class="comment">//如果定义了该宏(说明使用一起发模式，即将所有数据写到sendbuf里面，最后在写回调函数一起发)，下面代码就无效</span></span></span><br><span class="line"><span class="built_in">bufferSendData</span>(sendBuf, cfd);                <span class="comment">//sendBuf又有数据了，发送数据(边读边发的模式)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//usleep(10);   //重要,但已经在bufferSendData()函数里面睡眠了(无论是 一起发模式 还是 边写边发模式 都会调用该函数)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;                             <span class="comment">//文件读完了，直接退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                           <span class="comment">//其它情况就是出现问题了，打印错误信息</span></span><br><span class="line"><span class="built_in">close</span>(fd);                                   <span class="comment">//关闭fd</span></span><br><span class="line"><span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//该方法只适用于发送文件的场景</span></span><br><span class="line"><span class="comment">//这种方式是把文件打开，把文件描述符传给sendfile函数，函数内部就会将数据发给客户端(效率更高)---&gt;但如果发送的是目录，该方法还是不行</span></span><br><span class="line"><span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);     <span class="comment">//获取文件的大小(指针被移动到尾部了)</span></span><br><span class="line"><span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_SET);                <span class="comment">//将指针移回头部</span></span><br><span class="line"><span class="keyword">while</span> (offset &lt; size) &#123;         <span class="comment">//当偏移量到达要发送文件大小后(说明发送完了)，就直接退出循环</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">sendfile</span>(cfd, fd, &amp;offset, size - offset);        <span class="comment">//参1是通信描述符；参2的文件描述符；参3是参2的偏移量；参4是open打开文件的大小</span></span><br><span class="line"><span class="comment">//sendfile的第3个参数offset：</span></span><br><span class="line"><span class="comment">// 1.发送数据之前，根据该偏移量开始读文件数据</span></span><br><span class="line"><span class="comment">// 2.发送数据之后，更新该偏移量(不需要我们手动设置，系统自动更新偏移量)</span></span><br><span class="line"><span class="comment">//printf(&quot;ret value: %d\n&quot;, ret);</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;没有数据.....\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组织响应体类HttpResponse"><a href="#组织响应体类HttpResponse" class="headerlink" title="组织响应体类HttpResponse"></a>组织响应体类HttpResponse</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义状态码枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpStatusCode</span> &#123;</span><br><span class="line">Unknown,</span><br><span class="line">OK = <span class="number">200</span>,</span><br><span class="line">MovedPermanently = <span class="number">301</span>,</span><br><span class="line">MovedTemporarily = <span class="number">302</span>,</span><br><span class="line">BadRequest = <span class="number">400</span>,</span><br><span class="line">NotFound = <span class="number">404</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义响应的结构体(一个结构体对应一个key-value)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ResponseHeader</span> &#123;</span><br><span class="line"><span class="type">char</span> key[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span> value[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数指针，用来组织要回复给客户端的数据块</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*responseBody)</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fileName, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span> &#123;</span><br><span class="line"><span class="comment">//状态行：状态码，状态描述</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HttpStatusCode</span> statusCode;     <span class="comment">//状态码</span></span><br><span class="line"><span class="type">char</span> statusMsg[<span class="number">128</span>];                <span class="comment">//状态描述</span></span><br><span class="line"><span class="type">char</span> fileName[<span class="number">128</span>];             <span class="comment">//文件名</span></span><br><span class="line"><span class="comment">//响应头：键值对</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ResponseHeader</span>* headers;       <span class="comment">//通过malloc多开辟几个该结构体空间，即形成一个数组，headers指向数组头</span></span><br><span class="line"><span class="type">int</span> headerNum;                  <span class="comment">//响应头里面有效的元素个数</span></span><br><span class="line">responseBody sendDataFunc;      <span class="comment">//回复给客户端的数据块(函数指针类型),也可以理解为回调函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能实现文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* <span class="built_in">httpResponseInit</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HttpResponse</span>* response = (<span class="keyword">struct</span> HttpResponse*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HttpResponse));</span><br><span class="line">response-&gt;headerNum = <span class="number">0</span>;                 <span class="comment">//初始化响应头的个数为0</span></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ResponseHeader) * ResHeaderSize;</span><br><span class="line">response-&gt;headers = (<span class="keyword">struct</span> ResponseHeader*)<span class="built_in">malloc</span>(size);     <span class="comment">//开辟存放响应头的空间</span></span><br><span class="line">response-&gt;statusCode = Unknown;          <span class="comment">//初始化状态码为未知</span></span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line"><span class="built_in">bzero</span>(response-&gt;headers, size);</span><br><span class="line"><span class="built_in">bzero</span>(response-&gt;statusMsg, <span class="built_in">sizeof</span>(response-&gt;statusMsg));     <span class="comment">//状态描述</span></span><br><span class="line"><span class="built_in">bzero</span>(response-&gt;fileName, <span class="built_in">sizeof</span>(response-&gt;fileName));       <span class="comment">//文件名</span></span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line">response-&gt;sendDataFunc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponseDestroy</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (response != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(response-&gt;headers);      <span class="comment">//释放响应头数组</span></span><br><span class="line"><span class="built_in">free</span>(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponseAddHeader</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response, <span class="type">const</span> <span class="type">char</span>* key, <span class="type">const</span> <span class="type">char</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (response == <span class="literal">NULL</span> || key == <span class="literal">NULL</span> || value == <span class="literal">NULL</span>) &#123;      <span class="comment">//当着三个1其中一个出现空时，都是错误的</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;headers[response-&gt;headerNum].key, key);          <span class="comment">//c语言不能直接赋值，需要进行拷贝</span></span><br><span class="line"><span class="built_in">strcpy</span>(response-&gt;headers[response-&gt;headerNum].value, value);      <span class="comment">//拷贝value</span></span><br><span class="line">response-&gt;headerNum++;                                            <span class="comment">//元素个数++</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组织http响应数据(将之前添加到response里面的数据写入到sendBuf里面)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpResponsePrepareMsg</span><span class="params">(<span class="keyword">struct</span> HttpResponse* response, <span class="keyword">struct</span> Buffer* sendBuf, <span class="type">int</span> socket)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//状态行</span></span><br><span class="line"><span class="type">char</span> tmp[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, response-&gt;statusCode, response-&gt;statusMsg);      <span class="comment">//拼接状态行到tmp</span></span><br><span class="line"><span class="built_in">bufferAppendString</span>(sendBuf, tmp);                                                   <span class="comment">//将数据tmp写到sendBuf</span></span><br><span class="line"><span class="comment">//响应头</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; response-&gt;headerNum; i++) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%s: %s\r\n&quot;</span>, response-&gt;headers[i].key, response-&gt;headers[i].value);</span><br><span class="line"><span class="built_in">bufferAppendString</span>(sendBuf, tmp);               <span class="comment">//将拼接的响应头中的每一行都依次存入到sendBuf</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空行</span></span><br><span class="line"><span class="built_in">bufferAppendString</span>(sendBuf, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//目前，http响应体(状态行、状态头、空行)已经组织好放在了sendbuf(如果采用边发边发送的模式，就可以先发送了)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MSG_SEND_AUTO                                  <span class="comment">//如果定义了该宏(说明使用一起发的模式)，下面代码就无效</span></span></span><br><span class="line"><span class="built_in">bufferSendData</span>(sendBuf, socket);                   <span class="comment">//发送数据(先将sendbuf里面的数据先发送)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//回复的数据(该函数指针指向的是两个目录，一个是发送目录，一个是发送文件)，在processHttpRequest函数里面就让该函数指针指向对应的函数地址</span></span><br><span class="line">response-&gt;<span class="built_in">sendDataFunc</span>(response-&gt;fileName, sendBuf, socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程：</p><p>从main()函数开始，先通过函数tcpServerInit()创建一个服务器的实例，并设置了主线程启动后，它线程池里面的子线程个数为4，这样就得到了一个服务器的实例对象server，随后就可以调用它的一个Run方法了。</p><p>在启动服务器的时候，就是把线程池启动起来，并且把用于监听的套接字用于封装，然后把它放到了当前主线程对应的反应堆模型里面，之后主线程的反应堆模型就运行起来了，那么它底层的pool、epool或select也就运行起来了。它就可以检测监听描述符lfd里面的事件，这里是指读事件。如果有新的客户端连接，读事件就触发了，然后读回调函数acceptConnection就被调用了。</p><p>在读回调函数acceptConnection里，它第一件事就是和客户端建立连接得到了一个通信的文件描述符，然后从主线程里面取出了一个子线程，并且把子线程的反应堆模型evLoop取出来，然后把用于通信的文件描述符放到了evLoop里面。在tcpConnectionInit()函数里面，其实就是把cfd进行了封装，最终得到了一个新的channel，然后把这个channel放到了evLoop子线程的反应堆模型里面。</p><p>总的来说，就是当主线程建立连接之后，它并不会去处理与客户端的通信，和客户端的通信全都是在子线程里面处理的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;该项目的架构是B&amp;#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="linux" scheme="https://lxx93.online/tags/linux/"/>
    
    <category term="Http" scheme="https://lxx93.online/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Qt斗地主项目(下)</title>
    <link href="https://lxx93.online/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/"/>
    <id>https://lxx93.online/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/</id>
    <published>2024-08-08T09:24:35.000Z</published>
    <updated>2024-08-24T15:15:10.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-结束面板窗口类EndingPanel"><a href="#1-结束面板窗口类EndingPanel" class="headerlink" title="1. 结束面板窗口类EndingPanel"></a>1. 结束面板窗口类EndingPanel</h1><p>结束面板窗口类是用于在当一个玩家打完自己手中的牌时，也就意味着游戏结束。当结束的时候，会在主窗口的正中间跳入一个结束面板窗口，上面记录了各个玩家的得分。</p><p>结束分数面板窗口类：新建、c++、c++clase、类名为EndignPanel，基类为QWidget。</p><h2 id="1-1-EndingPanel类头文件"><a href="#1-1-EndingPanel类头文件" class="headerlink" title="1.1 EndingPanel类头文件"></a>1.1 EndingPanel类头文件</h2><p>结束面板窗口类的头文件主要就是定义一些有关结束面板的私有变量，如背景、按钮等。同时也定义一个关于是否继续游戏的信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EndingPanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EndingPanel</span><span class="params">(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取玩家的得分，并显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">continueGame</span><span class="params">()</span></span>;               <span class="comment">//添加一个自定义信号(点击继续按钮时，发出该信号)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_bk;                     <span class="comment">//结束面板的背景</span></span><br><span class="line">    QLabel* m_title;                  <span class="comment">//地主赢或输、农民赢或输的标签</span></span><br><span class="line">    ScorePanel *m_score;              <span class="comment">//之前创建的分数窗口</span></span><br><span class="line">    QPushButton* m_continue;          <span class="comment">//继续游戏按钮</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-EndingPanel类函数实现"><a href="#1-2-EndingPanel类函数实现" class="headerlink" title="1.2 EndingPanel类函数实现"></a>1.2 EndingPanel类函数实现</h2><p>这部分就是对头文件定义的函数实现，通过构造函数，直接初始化完结束面板窗口上的所有内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">EndingPanel::<span class="built_in">EndingPanel</span>(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_bk.<span class="built_in">load</span>(<span class="string">&quot;:/images/gameover.png&quot;</span>);            <span class="comment">//先把结束面板加载出来</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_bk.<span class="built_in">size</span>());                     <span class="comment">//设置大小为图片大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示用户玩家的角色以及游戏状态</span></span><br><span class="line">    m_title = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                    <span class="comment">//创建一个标签</span></span><br><span class="line">    <span class="keyword">if</span>(isLord &amp;&amp; isWin)&#123;                           <span class="comment">//如果用户是地主，且赢了，就在标签上加载对应的图</span></span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLord &amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_fail.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_fail.png&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    m_title-&gt;<span class="built_in">move</span>(<span class="number">125</span>,<span class="number">125</span>);                <span class="comment">//标签显示位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分数面板</span></span><br><span class="line">    m_score = <span class="keyword">new</span> <span class="built_in">ScorePanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">move</span>(<span class="number">75</span>, <span class="number">230</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">setFixedSize</span>(<span class="number">260</span>, <span class="number">160</span>);              <span class="comment">//设置结束面板中，显示分数面板的大小</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontColor</span>(ScorePanel::Red);     <span class="comment">//设置字体颜色为红色</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontSize</span>(<span class="number">18</span>);                   <span class="comment">//设置字体大小为8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续游戏按钮</span></span><br><span class="line">    m_continue = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_continue-&gt;<span class="built_in">move</span>(<span class="number">84</span>, <span class="number">429</span>);</span><br><span class="line">    QString style = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            QPushButton&#123;border-image: url(:/images/button_normal.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:hover&#123;border-image: url(:/images/button_hover.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:pressed&#123;border-image: url(:/images/button_pressed.png)&#125;</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">    m_continue-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    m_continue-&gt;<span class="built_in">setFixedSize</span>(<span class="number">231</span>,<span class="number">48</span>);       <span class="comment">//按钮大小</span></span><br><span class="line">    <span class="built_in">connect</span>(m_continue, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;EndingPanel::continueGame);     <span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score-&gt;<span class="built_in">setScores</span>(left, right, me);           <span class="comment">//直接调用左上角分数面板的设置分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_bk);         <span class="comment">//参1：这个图像要显示到哪个矩形区域里面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-动画效果类AnimationWindow"><a href="#2-动画效果类AnimationWindow" class="headerlink" title="2. 动画效果类AnimationWindow"></a>2. 动画效果类AnimationWindow</h1><p>动画效果类主要就是负责在游戏构成中，在主窗口显示的一些动画。比如说当抢地主阶段，每个玩家的下注分数或不叫。和当有用户打出王炸、顺子、飞机等特殊牌型时，都会有触发一些动画，来提高游戏的体验感。</p><p>动画效果类创建：选择新建、c++、c++clase、类名为AnimationWindow，基类为QWidget。</p><h2 id="2-1-AnimationWindow类头文件"><a href="#2-1-AnimationWindow类头文件" class="headerlink" title="2.1 AnimationWindow类头文件"></a>2.1 AnimationWindow类头文件</h2><p>动画效果类的头文件定义了一些特殊牌型的动画显示函数和下注的分数显示函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnimationWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Sequence, Pair&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AnimationWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示下注分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBetScore</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//显示顺子和连对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showSequence</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="comment">//显示王炸</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showJokerBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示炸弹</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示飞机</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPlane</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_image;                <span class="comment">//加载图片的对象</span></span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-AnimationWindow类函数实现"><a href="#2-2-AnimationWindow类函数实现" class="headerlink" title="2.2 AnimationWindow类函数实现"></a>2.2 AnimationWindow类函数实现</h2><p>这不是是对AnimationWindow类头文件中定义的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">AnimationWindow::<span class="built_in">AnimationWindow</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示分数窗口加载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBetScore</span><span class="params">(<span class="type">int</span> bet)</span>         <span class="comment">//主窗口创建AnimationWindow类对象后，会调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score1.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score2.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score3.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();              <span class="comment">//将加载的图片显示到窗口</span></span><br><span class="line">    <span class="comment">//当抢地主完毕之后，就隐藏该显示分数这个窗口，也就是让被实例化的AnimationWindow对象调用hide方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, &amp;AnimationWindow::hide);        <span class="comment">//定时器只触发一次(一次性信号)，2秒钟后隐藏分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showSequence</span><span class="params">(AnimationWindow::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QString name = type == Pair ? <span class="string">&quot;:/images/liandui.png&quot;</span> : <span class="string">&quot;:/images/shunzi.png&quot;</span>;      <span class="comment">//通过传进来的参数加载对应的图片</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(name);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,&amp;AnimationWindow::hide);               <span class="comment">//2s后隐藏动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showJokerBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">8</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于8了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">8</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/joker_bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">12</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于12了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showPlane</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="built_in">width</span>();                                  <span class="comment">//x轴就默认为动画窗口的宽度</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/plane_1.png&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedHeight</span>(m_image.<span class="built_in">height</span>());               <span class="comment">//y轴就为图片的高度</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="built_in">width</span>() / <span class="number">5</span>;                        <span class="comment">//将宽度分为5份，得到5份取区间</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> dist = <span class="number">0</span>;                       <span class="comment">//飞机移动的距离</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> timers = <span class="number">0</span>;</span><br><span class="line">        dist += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist&gt;=step)&#123;                            <span class="comment">//如果满足，说明某一个区间已经走完了,就进入下一个区间</span></span><br><span class="line">            dist = <span class="number">0</span>;</span><br><span class="line">            timers++;</span><br><span class="line">            QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/plane_%1.png&quot;</span>).<span class="built_in">arg</span>(timers%<span class="number">5</span>+<span class="number">1</span>);      <span class="comment">//图片在1到5之间切换</span></span><br><span class="line">            m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_x &lt;= <span class="number">-110</span>)&#123;                <span class="comment">//当飞机飞出动画窗口，就结束</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">            dist = timers = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">hide</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_x -= <span class="number">5</span>;              <span class="comment">//每次往左走5像素</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">15</span>);             <span class="comment">//每个15毫秒执行一次，画一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//因为对于飞机动画来说，m_x是移动的，而其它动画不移动，所以就把m_x初始化为0</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(m_x,<span class="number">0</span>,m_image.<span class="built_in">width</span>(),m_image.<span class="built_in">height</span>(),m_image);        <span class="comment">//加载的图片在窗口中的位置x和y；宽度和高度；QPixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-闹钟窗口类CountDown"><a href="#3-闹钟窗口类CountDown" class="headerlink" title="3. 闹钟窗口类CountDown"></a>3. 闹钟窗口类CountDown</h1><p>闹钟窗口类主要是在主窗口为用户玩家创建了一个定时闹钟，轮到用户玩家出牌阶段，用户玩家只能在指定的时间内完成出牌或不出，当15秒过后，就默认玩家放弃出牌。当然，闹钟会起作用的前提是玩家必须出牌阶段，比如说当玩家抢完地主后或出牌后，没有前提玩家出牌，又该自己出时，这两种情况闹钟是不会出现的，其他情况，闹钟都会起作用。</p><p>闹钟窗口类：新建、c、c++、类名为<code>CountDown</code>，基类为QWidget</p><h2 id="3-1-CountDown类头文件"><a href="#3-1-CountDown类头文件" class="headerlink" title="3.1 CountDown类头文件"></a>3.1 CountDown类头文件</h2><p>闹钟窗口类CountDown的头文件就是定义了闹钟的图像对象和倒计时数字的图片对象，又定义显示闹钟函数来完成对应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountDown</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CountDown</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCountDown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopCountDown</span><span class="params">()</span></span>; <span class="comment">//终止倒计时的(当闹钟的秒数还没有读到0，但用户玩家已经将牌打出去了，这种情况也需要终止倒计时)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notMuchTime</span><span class="params">()</span></span>;                 <span class="comment">//当闹钟的秒数减到5时，向主界面发送提醒信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">()</span></span>;                     <span class="comment">//当闹钟的秒数减到0时，向主界面发送信号(切换当前玩家为下一个玩家)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_clock;                <span class="comment">//加载闹钟图片对象</span></span><br><span class="line">    QPixmap m_number;               <span class="comment">//加载闹钟上的数字对象</span></span><br><span class="line">    QTimer* m_timer;</span><br><span class="line">    <span class="type">int</span>  m_count;                   <span class="comment">//倒计时的总时长</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-CountDown类函数实现"><a href="#3-2-CountDown类函数实现" class="headerlink" title="3.2 CountDown类函数实现"></a>3.2 CountDown类函数实现</h2><p>这部分就是对CountDown类头文件中定义的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">CountDown::<span class="built_in">CountDown</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">70</span>,<span class="number">70</span>);               <span class="comment">//给当前闹钟窗口显示固定大小(与图片大小一样)</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_count--;                         <span class="comment">//每次-1</span></span><br><span class="line">        <span class="keyword">if</span>(m_count&lt;<span class="number">10</span> &amp;&amp; m_count&gt;<span class="number">0</span>)&#123;       <span class="comment">//当count大于0小于10时，显示闹钟出来</span></span><br><span class="line">            m_clock.<span class="built_in">load</span>(<span class="string">&quot;:/images/clock.png&quot;</span>);</span><br><span class="line">            <span class="comment">//加载数字到闹钟上，数字的宽度是30像素，间隙是10个像素，从后从30*42像素缩放成20*30像素</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/number.png&quot;</span>).<span class="built_in">copy</span>(m_count*(<span class="number">30</span>+<span class="number">10</span>), <span class="number">0</span>, <span class="number">30</span>, <span class="number">42</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">30</span>);   <span class="comment">//x轴上是从远到近</span></span><br><span class="line">            <span class="keyword">if</span>(m_count == <span class="number">5</span>)&#123;</span><br><span class="line">                emit <span class="built_in">notMuchTime</span>();         <span class="comment">//当秒数减为5时，发出信号(播放提示音乐)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">            emit <span class="built_in">timeout</span>();                     <span class="comment">//发出信号(切换当前玩家)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::showCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_count = <span class="number">15</span>;</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);                <span class="comment">//启动定时器(每隔1s切换闹钟里面的数字)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::stopCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">    m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">    m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_clock);                                       <span class="comment">//绘制闹钟</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="number">24</span>,<span class="number">24</span>,m_number.<span class="built_in">width</span>(),m_number.<span class="built_in">height</span>(),m_number);     <span class="comment">//绘制数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-背景音乐类BGMControl"><a href="#4-背景音乐类BGMControl" class="headerlink" title="4. 背景音乐类BGMControl"></a>4. 背景音乐类BGMControl</h1><p>背景音乐类是负责整个游戏的一个配音，有的是循环一直播放，有的是只播放一次。比如说游戏的背景音乐就是一直播放，我们出牌时，男生和女生的声音就是只一次播放，还有一写特殊牌型的声音也是只播放一次，如飞机、炸弹等。</p><p>背景音乐类：新建、c++、c++clase、类名为BGMControl、基类为QObject。</p><h2 id="4-1-BGMControl类头文件"><a href="#4-1-BGMControl类头文件" class="headerlink" title="4.1 BGMControl类头文件"></a>4.1 BGMControl类头文件</h2><p>背景音乐类的头文件定义了一个牌型的枚举类，它与文件中的json文件里面的配音目录顺序一致，这样方便在程序中调用。同时定义了在不同情况下，播放不同的音乐函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BGMControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">RoleSex</span>&#123;Man, Woman&#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardType</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 单张牌</span></span><br><span class="line">            Three,</span><br><span class="line">            Foue,</span><br><span class="line">            Five,</span><br><span class="line">            Six,</span><br><span class="line">            Seven,</span><br><span class="line">            Eight,</span><br><span class="line">            Nine,</span><br><span class="line">            Ten,</span><br><span class="line">            Jack,</span><br><span class="line">            Queen,</span><br><span class="line">            King,</span><br><span class="line">            Ace,</span><br><span class="line">            Tow,</span><br><span class="line">            SmallJoker,</span><br><span class="line">            BigJoker,</span><br><span class="line">            <span class="comment">// 两张牌</span></span><br><span class="line">            Three_Double,</span><br><span class="line">            Foue_Double,</span><br><span class="line">            Five_Double,</span><br><span class="line">            Six_Double,</span><br><span class="line">            Seven_Double,</span><br><span class="line">            Eight_Double,</span><br><span class="line">            Nine_Double,</span><br><span class="line">            Ten_Double,</span><br><span class="line">            Jack_Double,</span><br><span class="line">            Queen_Double,</span><br><span class="line">            King_Double,</span><br><span class="line">            Ace_Double ,</span><br><span class="line">            Tow_Double,</span><br><span class="line">            <span class="comment">// 三张牌</span></span><br><span class="line">            Three_Triple,</span><br><span class="line">            Foue_Triple,</span><br><span class="line">            Five_Triple,</span><br><span class="line">            Six_Triple,</span><br><span class="line">            Seven_Triple,</span><br><span class="line">            Eight_Triple,</span><br><span class="line">            Nine_Triple,</span><br><span class="line">            Ten_Triple,</span><br><span class="line">            Jack_Triple,</span><br><span class="line">            Queen_Triple,</span><br><span class="line">            King_Triple,</span><br><span class="line">            Ace_Triple,</span><br><span class="line">            Tow_Triple,</span><br><span class="line">            <span class="comment">// 其他组合</span></span><br><span class="line">            Plane,          <span class="comment">// 飞机</span></span><br><span class="line">            SequencePair,   <span class="comment">// 连对</span></span><br><span class="line">            ThreeBindOne,   <span class="comment">// 三带一</span></span><br><span class="line">            ThreeBindPair,  <span class="comment">// 三带一对</span></span><br><span class="line">            Sequence,       <span class="comment">// 顺子</span></span><br><span class="line">            FourBindTwo,    <span class="comment">// 四带二(单张)</span></span><br><span class="line">            FourBind2Pair,  <span class="comment">// 四带两对</span></span><br><span class="line">            Bomb,           <span class="comment">// 炸弹</span></span><br><span class="line">            JokerBomb,      <span class="comment">// 王炸</span></span><br><span class="line">            Pass1,          <span class="comment">// 过</span></span><br><span class="line">            Pass2,</span><br><span class="line">            Pass3,</span><br><span class="line">            Pass4,</span><br><span class="line">            MoreBiger1,     <span class="comment">// 大你</span></span><br><span class="line">            MoreBiger2,</span><br><span class="line">            Biggest,        <span class="comment">// 压死</span></span><br><span class="line">            <span class="comment">// 抢地主</span></span><br><span class="line">            NoOrder,        <span class="comment">// 不叫</span></span><br><span class="line">            NoRob,          <span class="comment">// 不抢</span></span><br><span class="line">            Order,          <span class="comment">// 叫地主</span></span><br><span class="line">            Rob1,           <span class="comment">// 抢地主</span></span><br><span class="line">            Rob2,</span><br><span class="line">            Last1,          <span class="comment">// 只剩1张牌</span></span><br><span class="line">            Last2           <span class="comment">// 只剩2张牌</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AssistMusic</span>       <span class="comment">//辅助音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispatch,   <span class="comment">// 发牌</span></span><br><span class="line">        SelectCard, <span class="comment">// 选牌</span></span><br><span class="line">        PlaneVoice, <span class="comment">// 飞机</span></span><br><span class="line">        BombVoice,  <span class="comment">// 炸弹</span></span><br><span class="line">        Alert,      <span class="comment">// 提醒</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BGMControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化播放列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.背景音乐(播放和停止播放)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopBGM</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.播放玩家抢地址音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span>;</span><br><span class="line">    <span class="comment">//3.播放出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span>;           <span class="comment">//播放剩余1张或2张牌的音乐</span></span><br><span class="line">    <span class="comment">//4.播放不出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playPassMusic</span><span class="params">(RoleSex sex)</span></span>;</span><br><span class="line">    <span class="comment">//5.播放辅助音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playAssistMusic</span><span class="params">(AssistMusic type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopAssistMusic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//6.播放结尾音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    QVector&lt;QMediaPlayer*&gt; m_players;</span><br><span class="line">    QVector&lt;QMediaPlaylist* &gt; m_lists;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-BGMControl函数实现"><a href="#4-2-BGMControl函数实现" class="headerlink" title="4.2 BGMControl函数实现"></a>4.2 BGMControl函数实现</h2><p>这部分就是实现了<code>BGMControl</code>类中定义的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">BGMControl::<span class="built_in">BGMControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QMediaPlayer* player = <span class="keyword">new</span> <span class="built_in">QMediaPlayer</span>(<span class="keyword">this</span>);             <span class="comment">//创建多媒体对象</span></span><br><span class="line">        QMediaPlaylist* list = <span class="keyword">new</span> <span class="built_in">QMediaPlaylist</span>(<span class="keyword">this</span>);           <span class="comment">//创建播放列表对象</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span> || i == <span class="number">4</span>)                 <span class="comment">//当是0、1或4时，音乐只播放一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::CurrentItemOnce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)                   <span class="comment">//当是2时，就循环播放音乐</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::Loop);</span><br><span class="line">        &#125;</span><br><span class="line">        player-&gt;<span class="built_in">setPlaylist</span>(list);</span><br><span class="line">        player-&gt;<span class="built_in">setVolume</span>(<span class="number">100</span>);                <span class="comment">//音量</span></span><br><span class="line">        m_players.<span class="built_in">push_back</span>(player);</span><br><span class="line">        m_lists.<span class="built_in">push_back</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">initPlayList</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化播放列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::initPlayList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList list;</span><br><span class="line">    list &lt;&lt; <span class="string">&quot;Man&quot;</span> &lt;&lt; <span class="string">&quot;Woman&quot;</span> &lt;&lt; <span class="string">&quot;BGM&quot;</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="string">&quot;Ending&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读json配置文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/conf/playList.json&quot;</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QByteArray json = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// 解析从文件中读出的json数据</span></span><br><span class="line">    QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(json);</span><br><span class="line">    QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QString prefix = list.<span class="built_in">at</span>(i);</span><br><span class="line">        QJsonArray array = obj.<span class="built_in">value</span>(prefix).<span class="built_in">toArray</span>();</span><br><span class="line">        <span class="comment">// 初始化多媒体播放列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[i]-&gt;<span class="built_in">addMedia</span>(<span class="built_in">QMediaContent</span>(<span class="built_in">QUrl</span>(array.<span class="built_in">at</span>(j).<span class="built_in">toString</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏背景音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2是背景音乐，其音频对应的下标是2</span></span><br><span class="line">    m_lists[<span class="number">2</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">setVolume</span>(volume);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">play</span>();                  <span class="comment">//通过对应的多媒体对象的play播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopBGM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">stop</span>();                  <span class="comment">//停止播放背景音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家下注了没有?</span></span><br><span class="line"><span class="comment">// 玩家的性别?</span></span><br><span class="line"><span class="comment">// 什么时候播放什么样的音频文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(isFirst &amp;&amp; point &gt; <span class="number">0</span>)                 <span class="comment">//如果是第一个叫地主，且下注分数大于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Order);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">0</span>)                      <span class="comment">//下注分数为0，即没有叫地主</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFirst)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoOrder);          <span class="comment">//如果是第一家就播放不叫音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoRob);            <span class="comment">//如果不是第一家就播放不抢音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">2</span>)                        <span class="comment">//下注2分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">3</span>)                        <span class="comment">//下注3分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob2);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();             <span class="comment">//通过多媒体对象播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌的音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到播放列表</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    QMediaPlaylist* list = m_lists[index];           <span class="comment">//通过男生或女生，得到相应的播放列表对象</span></span><br><span class="line"></span><br><span class="line">    Card::CardPoint pt = Card::CardPoint::Card_Begin;</span><br><span class="line">    <span class="comment">// 取出牌型 然后进行判断</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();</span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Single || type == PlayHand::Hand_Pair || type == PlayHand::Hand_Triple)</span><br><span class="line">    &#123;</span><br><span class="line">        pt = cards.<span class="built_in">takeRandomCard</span>().<span class="built_in">point</span>();    <span class="comment">//如果是单牌、双牌或三牌，取出其点数(取出随机一张牌即可)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        number = pt - <span class="number">1</span>;           <span class="comment">//因为pt的枚举类是从begin开始的，需要减1才能和json文件里面的枚举类一一对应</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 对牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span>;      <span class="comment">//对牌在单牌后面，所以需要跳过单牌个数15</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三张点数相同的牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span> + <span class="number">13</span>;         <span class="comment">//跳过对牌个数13</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带一</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        number = ThreeBindOne;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带二</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        number = ThreeBindPair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 飞机</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">    <span class="comment">// 飞机带两个单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">    <span class="comment">// 飞机带两个对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        number = Plane;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 连对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:</span><br><span class="line">        number = SequencePair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 顺子</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:</span><br><span class="line">        number = Sequence;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:</span><br><span class="line">        number = Bomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 王炸</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers:</span><br><span class="line">        number = JokerBomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Pair:</span><br><span class="line">    <span class="comment">// 炸弹带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Two_Single:</span><br><span class="line">    <span class="comment">// 王炸带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Pair:</span><br><span class="line">    <span class="comment">// 王炸带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Two_Single:</span><br><span class="line">        number = FourBindTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isFirst &amp;&amp; (number &gt;= Plane &amp;&amp; number &lt;= FourBindTwo))</span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(MoreBiger1 + QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    <span class="keyword">if</span>(number == Bomb || number == JokerBomb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(BombVoice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number == Plane)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(PlaneVoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="keyword">if</span>(m_players[index]-&gt;<span class="built_in">state</span>() == QMediaPlayer::StoppedState)     <span class="comment">//如果当前对应的多媒体播放是空闲状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">        m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">1500</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">            m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playPassMusic</span><span class="params">(RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">4</span>);    <span class="comment">//随机生成一个数字，0到3</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(Pass1 + random);                  <span class="comment">//随机播放不要音乐</span></span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playAssistMusic</span><span class="params">(AssistMusic type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMediaPlaylist::PlaybackMode mode;                <span class="comment">//定义一个播放模式</span></span><br><span class="line">    <span class="keyword">if</span>(type == Dispatch)                              <span class="comment">//如果是发牌状态，就循环播放音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环播放</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemInLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                       <span class="comment">//其它情况，只播放一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单曲播放一次</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemOnce;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">    list-&gt;<span class="built_in">setPlaybackMode</span>(mode);</span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopAssistMusic</span><span class="params">()</span>           <span class="comment">//停止辅助音乐播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输或赢播放音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isWin)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[<span class="number">4</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-游戏主窗口类GamePanel"><a href="#5-游戏主窗口类GamePanel" class="headerlink" title="5. 游戏主窗口类GamePanel"></a>5. 游戏主窗口类GamePanel</h1><p>游戏主窗口类是游戏的展示界面，玩家玩游戏的整个过程都是在这个窗口中显示的。</p><h2 id="5-1-GamePanel类头文件"><a href="#5-1-GamePanel类头文件" class="headerlink" title="5.1 GamePanel类头文件"></a>5.1 GamePanel类头文件</h2><p>游戏窗口类的头文件需要定义很多初始化的函数，同时也需要接收很多发送过来的信号，然后通过相应的函数(槽函数)来实现对应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePanel</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GamePanel</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">GamePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AnimationType</span>&#123;ShunZi, LianDui, Plane, JokerBomb, Bomb, Bet&#125;;             <span class="comment">//效果动画类要显示的一些动画</span></span><br><span class="line">    <span class="comment">//初始化游戏控制类信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameControlInit</span><span class="params">()</span></span>;       <span class="comment">//该函数也负责信号槽的一些连接</span></span><br><span class="line">    <span class="comment">//更新分数面板的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//切割并存储图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCardMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//裁剪图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cropImage</span><span class="params">(QPixmap&amp; pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span></span>;       <span class="comment">//参数：裁剪图片对象，x位置，y位置，卡牌对象(需要它的花色和点数)</span></span><br><span class="line">    <span class="comment">//初始化游戏按钮组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtonsGroup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化玩家在窗口中的上下文环境(每个玩家的位置信息)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayerContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化游戏场景</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initGameScene</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理游戏的状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span></span>;     <span class="comment">//参数枚举类型游戏状态，有发牌、叫地主和出牌</span></span><br><span class="line">    <span class="comment">//发牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardMoveStep</span><span class="params">(Player* player, <span class="type">int</span> curPos)</span></span>;</span><br><span class="line">    <span class="comment">//处理分发得到的扑克牌(发牌时卡牌区域更新)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disposeCard</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;        <span class="comment">//参数：处理的牌属于哪个玩家，要处理的牌(一张或多张)</span></span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示(把玩家得到的牌更新到该显示的位置上,和打出的牌更新到出牌区域)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerCards</span><span class="params">(Player* player)</span></span>;          <span class="comment">//更新的是哪个玩家的扑克牌窗口</span></span><br><span class="line">    <span class="comment">//加载玩家的头像</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器的处理动作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家状态的变化(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayerStatusChanged</span><span class="params">(Player* player, GameControl::PlayerStatus status)</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家抢地主情况，再在主窗口显示(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;     <span class="comment">//参数：具体哪个玩家，下注分数，是否是第一个叫地主的玩家</span></span><br><span class="line">    <span class="comment">//处理玩家的出牌显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDisposePlayHand</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家鼠标选牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPlayHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理用户放弃出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示特效动画</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showAnimation</span><span class="params">(AnimationType type, <span class="type">int</span> bet=<span class="number">0</span>)</span></span>;  <span class="comment">//因为室友特效动画都是该函数显示，所以直接传入动画枚举类，当是抢地主分数的时候，会用到参2</span></span><br><span class="line">    <span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hidePlayerDropCards</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="comment">// 显示玩家的最终得分(结束面板设置)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showEndingScorePanel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化闹钟倒计时</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCountDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写父类的虚函数---事件处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardAlign</span>&#123;Horizontal, Vertical&#125;;             <span class="comment">//对齐方式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PlayerContext</span>&#123;                   <span class="comment">//每个玩家有一个这样的结构体,是存放玩家对应的位置信息</span></span><br><span class="line">        <span class="comment">//1.玩家扑克牌显示的区域</span></span><br><span class="line">        QRect cardRect;</span><br><span class="line">        <span class="comment">//2.出牌的区域</span></span><br><span class="line">        QRect playHandRect;</span><br><span class="line">        <span class="comment">//3.扑克牌的对齐方式(水平 or 垂直)</span></span><br><span class="line">        CardAlign align;</span><br><span class="line">        <span class="comment">//4.扑克牌显示正面还是背面</span></span><br><span class="line">        <span class="type">bool</span> isFrontSide;</span><br><span class="line">        <span class="comment">//5.游戏过程中的提示信息，比如：不出</span></span><br><span class="line">        QLabel* info;</span><br><span class="line">        <span class="comment">//6.玩家的头像</span></span><br><span class="line">        QLabel* roleImg;</span><br><span class="line">        <span class="comment">//7.玩家刚打出的牌</span></span><br><span class="line">        Cards lastCards;</span><br><span class="line">    &#125;;</span><br><span class="line">    Ui::GamePanel *ui;</span><br><span class="line">    QPixmap m_bkImage;                     <span class="comment">//背景图片的加载对象</span></span><br><span class="line">    GameControl* m_gameCtl;                <span class="comment">//游戏控制类对象</span></span><br><span class="line">    QVector&lt;Player*&gt; m_playerList;         <span class="comment">//存放三个玩家对象的实例</span></span><br><span class="line">    QMap&lt;Card, CardPanel*&gt;m_cardMap;       <span class="comment">//保存卡牌数据和卡牌窗口对象的容器</span></span><br><span class="line">    QSize m_cardSize;                      <span class="comment">//卡牌大小(宽和高)</span></span><br><span class="line">    QPixmap m_cardBackImg;                 <span class="comment">//卡牌背景图加载对象</span></span><br><span class="line">    QMap&lt;Player*, PlayerContext&gt; m_contextMap;      <span class="comment">//将玩家与其对应的位置结构体存到map</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_baseCard;              <span class="comment">//刚开始，发牌区的扑克牌</span></span><br><span class="line">    CardPanel* m_moveCard;              <span class="comment">//移动中的扑克牌</span></span><br><span class="line">    QVector&lt;CardPanel*&gt;m_last3Card;     <span class="comment">//最后三张底牌</span></span><br><span class="line"></span><br><span class="line">    QPoint m_baseCardPos;               <span class="comment">//起始时，牌的初始位置(中心偏上一点)</span></span><br><span class="line">    GameControl::GameStatus m_gameStatus;           <span class="comment">//存放游戏状态</span></span><br><span class="line">    QTimer* m_timer;                    <span class="comment">//定时器</span></span><br><span class="line"></span><br><span class="line">    AnimationWindow* m_animation;            <span class="comment">//动画效果类对象</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_curSelCard;       <span class="comment">//鼠标选择的卡牌窗口对象(只限自己手牌的，因为点击其它机器人玩家的牌，在onCardSelected()函数中已经被排除了)</span></span><br><span class="line">    QSet&lt;CardPanel*&gt; m_selectCards;       <span class="comment">//保存用户鼠标选择的卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//下面两个在updatePlayerCards()里面初始化的</span></span><br><span class="line">    QRect m_cardsRect;                          <span class="comment">//存储用户玩家剩余的牌显示区域</span></span><br><span class="line">    QHash&lt;CardPanel*,QRect&gt; m_userCards;         <span class="comment">//记录用户玩家手中的牌，以及每张牌在窗口中的位置</span></span><br><span class="line"></span><br><span class="line">    CountDown* m_countDown;                <span class="comment">//闹钟类对象指针</span></span><br><span class="line"></span><br><span class="line">    BGMControl* m_bgm;                     <span class="comment">//BGM音乐类对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-2-GamePanel类函数实现"><a href="#5-2-GamePanel类函数实现" class="headerlink" title="5.2 GamePanel类函数实现"></a>5.2 GamePanel类函数实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line">GamePanel::<span class="built_in">GamePanel</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::GamePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 背景图</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>);          <span class="comment">//生成0到9随机数</span></span><br><span class="line">    QString path = <span class="built_in">QString</span>(<span class="string">&quot;:/images/background-%1.png&quot;</span>).<span class="built_in">arg</span>(num+<span class="number">1</span>);     <span class="comment">//拼接背景图路径</span></span><br><span class="line">    m_bkImage.<span class="built_in">load</span>(path);   <span class="comment">//随机加载一张背景图(刚开始时)，通过事件处理器函数painEvent就能将背景图画到窗口上了，当窗口初始化好后，painEvent会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.窗口的标题和大小(固定)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;欢乐斗地主&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1000</span>, <span class="number">650</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实例化游戏控制类对象</span></span><br><span class="line">    <span class="built_in">gameControlInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 玩家得分(更新)</span></span><br><span class="line">    <span class="built_in">updatePlayerScore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 切割游戏图片</span></span><br><span class="line">    <span class="built_in">initCardMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 初始化游戏中的按钮组</span></span><br><span class="line">    <span class="built_in">initButtonsGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 初始化玩家在窗口中的上下文环境</span></span><br><span class="line">    <span class="built_in">initPlayerContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 扑克牌场景初始化</span></span><br><span class="line">    <span class="built_in">initGameScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 倒计时窗口初始化</span></span><br><span class="line">    <span class="built_in">initCountDown</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器实例化</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;GamePanel::onDispatchCard);     <span class="comment">//每触发一次定时器，就会调用槽函数，发牌</span></span><br><span class="line"></span><br><span class="line">    m_animation = <span class="keyword">new</span> <span class="built_in">AnimationWindow</span>(<span class="keyword">this</span>);          <span class="comment">//创建一个动画效果类，指定了父对象，它就显示在父对象窗口上面，而且没有边框</span></span><br><span class="line">    m_bgm = <span class="keyword">new</span> <span class="built_in">BGMControl</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GamePanel::~<span class="built_in">GamePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameControlInit</span><span class="params">()</span>       <span class="comment">//实例化游戏控制类对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_gameCtl = <span class="keyword">new</span> <span class="built_in">GameControl</span>(<span class="keyword">this</span>);       <span class="comment">//指定父对象，窗口析构的时候，就会先自动析构m_gameCtl了</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">playerInit</span>();                 <span class="comment">//三个玩家对象被创建出来了</span></span><br><span class="line">    <span class="comment">//得到三个玩家的实例对象</span></span><br><span class="line">    Robot* leftRobot = m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>();</span><br><span class="line">    Robot* rightRobot = m_gameCtl-&gt;<span class="built_in">getRightRobot</span>();</span><br><span class="line">    UserPlayer* user = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();</span><br><span class="line">    m_playerList &lt;&lt; leftRobot &lt;&lt; rightRobot &lt;&lt; user;        <span class="comment">//存储顺序：左侧机器人，右侧机器人，用户玩家</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家状态变化)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::playerStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::onPlayerStatusChanged);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(抢地主的情况)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyGrabLordBet, <span class="keyword">this</span>, &amp;GamePanel::onGrabLordBet);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(游戏状态变化),主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::gameStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::gameStatusPrecess);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家出牌了),主窗口接收并处理相应的槽函数(处理一些动画效果，更新玩家的牌，并将出的牌显示在出牌区域)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyPlayHand, <span class="keyword">this</span>, &amp;GamePanel::onDisposePlayHand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不管是哪个玩家得到牌后都会发出一个信号，主窗口接收该信号</span></span><br><span class="line">    <span class="built_in">connect</span>(leftRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(rightRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(user, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;scorePanel-&gt;<span class="built_in">setScores</span>(                    <span class="comment">//setScores函数负责将传入的得分显示在窗口上</span></span><br><span class="line">                m_playerList[<span class="number">0</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">1</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">2</span>]-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCardMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.加载大图</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/card.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//2.计算每张图片的大小</span></span><br><span class="line">    m_cardSize.<span class="built_in">setWidth</span>(pixmap.<span class="built_in">width</span>()/<span class="number">13</span>);</span><br><span class="line">    m_cardSize.<span class="built_in">setHeight</span>(pixmap.<span class="built_in">height</span>()/<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//3.背面图加载(裁剪)，需要提供背景图左上角的点，copy(x轴，y轴，要裁剪的宽度，要裁剪的高度)</span></span><br><span class="line">    m_cardBackImg = pixmap.<span class="built_in">copy</span>(<span class="number">2</span>*m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">    <span class="comment">//正常花色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,pt=Card::Card_Begin+<span class="number">1</span>; pt&lt;Card::Card_SJ; pt++,j++)&#123;</span><br><span class="line">            <span class="function">Card <span class="title">card</span><span class="params">((Card::CardPoint)pt, (Card::CardSuit)suit)</span></span>;</span><br><span class="line">            <span class="comment">//裁剪图片(参数：大图对象，裁剪卡牌的x轴，裁剪卡牌的y轴，对应的单张卡牌对象(记录的是对应的花色和点数))</span></span><br><span class="line">            <span class="built_in">cropImage</span>(pixmap, j*m_cardSize.<span class="built_in">width</span>(), i*m_cardSize.<span class="built_in">height</span>(), card);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小王</span></span><br><span class="line">    Card c;</span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_SJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, <span class="number">0</span>, <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">    <span class="comment">//大王</span></span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_BJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cropImage</span><span class="params">(QPixmap &amp;pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span>              <span class="comment">//裁剪图片</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap sub = pix.<span class="built_in">copy</span>(x, y, m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());       <span class="comment">//得到一张扑克牌正面</span></span><br><span class="line">    CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);           <span class="comment">//创建一张卡牌窗口对象</span></span><br><span class="line">    panel-&gt;<span class="built_in">setImage</span>(sub, m_cardBackImg);              <span class="comment">//参数：正面图片对象，背面图片对象 -----&gt;图片显示的已经是对应的花色和点数了</span></span><br><span class="line">    panel-&gt;<span class="built_in">setCard</span>(c);                                <span class="comment">//设置花色和点数   -----&gt;这相当于是记录该图片的花色和点数</span></span><br><span class="line">    panel-&gt;<span class="built_in">hide</span>();                                    <span class="comment">//隐藏</span></span><br><span class="line">    m_cardMap.<span class="built_in">insert</span>(c,panel);                        <span class="comment">//裁剪成功的卡牌存入容器，方便后期管理和处理</span></span><br><span class="line">    <span class="comment">//接收CardPanel类发出的鼠标选择信号---&gt;每张牌的窗口对象只要满足条件，都可以发出信号</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;CardPanel::cardSelected, <span class="keyword">this</span>, &amp;GamePanel::onCardSelected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initButtonsGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">initButtons</span>();                                <span class="comment">//所有的按钮初始化完成</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Start);              <span class="comment">//开始时，显示的是开始游戏页面</span></span><br><span class="line">    <span class="comment">//处理各个按钮发出的信号</span></span><br><span class="line">    <span class="comment">//初始页面的开始按钮，当发出startGame信号，就说明开始游戏的按钮被按下了</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::startGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//界面的初始化</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">clearPlayerScore</span>();          <span class="comment">//将所有玩家的得分清0(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();                    <span class="comment">//更新所有玩家的得分(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="comment">//修改游戏状态 ---&gt; 发牌</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);        <span class="comment">//基于这个参数，里面是通过switcha函数来执行不同游戏状态下的函数</span></span><br><span class="line">        <span class="comment">//播放背景音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);                 <span class="comment">//指定音量为80</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::playHand, <span class="keyword">this</span>, &amp;GamePanel::onUserPlayHand); <span class="comment">//当点击了出牌按钮，会发出playHand信号</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::pass, <span class="keyword">this</span>, &amp;GamePanel::onUserPass);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::betPoint, <span class="keyword">this</span>, [=](<span class="type">int</span> bet)&#123;        <span class="comment">//叫地主几分按钮</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">grabLordBet</span>(bet);</span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//按完下注分数按钮后，就执行选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initPlayerContext</span><span class="params">()</span>              <span class="comment">//为每个玩家设置对应的位置信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.设置玩家扑克牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect cardsRect[]=&#123;</span><br><span class="line">        <span class="comment">//x,y,width,heught</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">90</span>,<span class="number">130</span>,<span class="number">100</span>,<span class="built_in">height</span>()<span class="number">-200</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-190</span>, <span class="number">130</span>, <span class="number">100</span>, <span class="built_in">height</span>()<span class="number">-200</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">250</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-120</span>, <span class="built_in">width</span>()<span class="number">-500</span>,<span class="number">100</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2.玩家出牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect playHandRect[]=&#123;</span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">260</span>,<span class="number">150</span>,<span class="number">100</span>,<span class="number">100</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-360</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">150</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-290</span>, <span class="built_in">width</span>()<span class="number">-300</span>,<span class="number">105</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3.玩家头像显示的位置</span></span><br><span class="line">    <span class="type">const</span> QPoint roleImgPos[]=&#123;</span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">0</span>].<span class="built_in">left</span>()<span class="number">-80</span>,cardsRect[<span class="number">0</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),         <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">1</span>].<span class="built_in">right</span>()+<span class="number">10</span>,cardsRect[<span class="number">1</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">2</span>].<span class="built_in">right</span>()<span class="number">-10</span>,cardsRect[<span class="number">2</span>].<span class="built_in">top</span>()<span class="number">-10</span>)              <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());     <span class="comment">//得到m_playerList存放用户玩家的下标索引(是2,但是不想把代码写死，所以通过这行代码获取)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>();i++)&#123;                          <span class="comment">//变量三个玩家</span></span><br><span class="line">        PlayerContext context;                                <span class="comment">//为每个玩家创建各自的PlayerContext位置结构体</span></span><br><span class="line">        context.align = i==index ? Horizontal:Vertical;             <span class="comment">//对齐方式：机器人玩家和用户玩家是不一样的</span></span><br><span class="line">        context.isFrontSide = i==index ? <span class="literal">true</span>:<span class="literal">false</span>;                  <span class="comment">//扑克牌展示正面还是背面，需要判定，i=index，说明是用户玩家</span></span><br><span class="line">        context.cardRect = cardsRect[i];                              <span class="comment">//卡牌区域(因为m_playerList和cardsRect的顺序是一样的，所以直接赋值即可)</span></span><br><span class="line">        context.playHandRect = playHandRect[i];                       <span class="comment">//出牌区域</span></span><br><span class="line">        <span class="comment">//提示信息(每个玩家的提示信息位置)</span></span><br><span class="line">        context.info = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个标签</span></span><br><span class="line">        context.info-&gt;<span class="built_in">resize</span>(<span class="number">160</span>, <span class="number">98</span>);                  <span class="comment">//指定标签大小</span></span><br><span class="line">        context.info-&gt;<span class="built_in">hide</span>();                           <span class="comment">//初始是隐藏的</span></span><br><span class="line">        <span class="comment">//将提示信息显示到出牌区域的中心位置</span></span><br><span class="line">        QRect rect = playHandRect[i];                   <span class="comment">//每个玩家的出牌区域</span></span><br><span class="line">        <span class="function">QPoint <span class="title">pt</span><span class="params">(rect.left()+(rect.width()-context.info-&gt;width())/<span class="number">2</span>, rect.top()+(rect.height()-context.info-&gt;height())/<span class="number">2</span>)</span></span>;   <span class="comment">//获取出牌区域的中心位置，需要(出牌区域框架-提示信息框架)/2</span></span><br><span class="line">        context.info-&gt;<span class="built_in">move</span>(pt);          <span class="comment">//将提示信息移动到pt位置</span></span><br><span class="line">        <span class="comment">//玩家头像</span></span><br><span class="line">        context.roleImg = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);         <span class="comment">//创建一个放头像的标签</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">resize</span>(<span class="number">84</span>, <span class="number">120</span>);           <span class="comment">//固定大小</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">hide</span>();                    <span class="comment">//隐藏</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">move</span>(roleImgPos[i]);       <span class="comment">//将头像标签移动到指定位置</span></span><br><span class="line">        m_contextMap.<span class="built_in">insert</span>(m_playerList.<span class="built_in">at</span>(i), context);   <span class="comment">//key存玩家对象，value存对应的位置结构体context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initGameScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面三部分，每一部分都对应一张或多张扑克牌，每张扑克牌都是一个卡牌窗口，所以需要创建卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//1.发牌区的扑克牌</span></span><br><span class="line">    m_baseCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_baseCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 2. 发牌过程中移动的扑克牌</span></span><br><span class="line">    m_moveCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_moveCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 3. 最后的三张底牌(用于窗口的显示)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">        panel-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">        m_last3Card.<span class="built_in">push_back</span>(panel);</span><br><span class="line">        panel-&gt;<span class="built_in">hide</span>();              <span class="comment">//初始先隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发牌区和移动过程扑克牌的位置(同一个)</span></span><br><span class="line">    m_baseCardPos = <span class="built_in">QPoint</span>((<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>()) / <span class="number">2</span>, <span class="built_in">height</span>() / <span class="number">2</span> - <span class="number">100</span>);     <span class="comment">//中心位置偏上一点</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">move</span>(m_baseCardPos);         <span class="comment">//设置发牌区的扑克牌位置</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(m_baseCardPos);          <span class="comment">//设置移动过程中扑克牌的位置</span></span><br><span class="line">    <span class="comment">//底牌位置(三种牌的x轴不一样，y轴一样)</span></span><br><span class="line">    <span class="type">int</span> base = (<span class="built_in">width</span>() - <span class="number">3</span> * m_cardSize.<span class="built_in">width</span>() - <span class="number">2</span> * <span class="number">10</span>) / <span class="number">2</span>;   <span class="comment">//width()是当前窗口的总宽度，三张牌有2个空隙(2*10)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_last3Card[i]-&gt;<span class="built_in">move</span>(base + (m_cardSize.<span class="built_in">width</span>() + <span class="number">10</span>) * i, <span class="number">20</span>);      <span class="comment">//分别设置三张底牌的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span>            <span class="comment">//处理游戏的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录游戏状态</span></span><br><span class="line">    m_gameStatus = status;</span><br><span class="line">    <span class="comment">//处理游戏状态</span></span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::DispatchCard:        <span class="comment">//开始发牌状态</span></span><br><span class="line">        <span class="built_in">startDispatchCard</span>();               <span class="comment">//调用发牌函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::CallingLord:         <span class="comment">//叫地主状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出底牌数据</span></span><br><span class="line">        CardList last3Card = m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">toCardList</span>();     <span class="comment">//将存放三张底牌的set容器转为了QVector容器</span></span><br><span class="line">        <span class="comment">//给底牌窗口设置图片</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;last3Card.<span class="built_in">size</span>(); i++)&#123;        <span class="comment">//遍历三张底牌</span></span><br><span class="line">            QPixmap front = m_cardMap[last3Card.<span class="built_in">at</span>(i)]-&gt;<span class="built_in">getImage</span>();         <span class="comment">//获取每张牌它的一个图像</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">setImage</span>(front,m_cardBackImg);            <span class="comment">//设置该卡牌的正面图片和反面图片</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">hide</span>();                                   <span class="comment">//先是隐藏的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始叫地主</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">startLordCard</span>();      <span class="comment">//gamecontrol的一个函数，里面会发出一个信号，主窗口再接收处理槽函数onPlayerStatusChanged</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GameControl::PlayingHand:           <span class="comment">//出牌状态(抢完地主)</span></span><br><span class="line">        <span class="comment">//隐藏发牌区的底牌和移动的牌</span></span><br><span class="line">        m_baseCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="comment">//显示留给地主的三张底牌(顶部)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">show</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            PlayerContext &amp;context = m_contextMap[m_playerList.<span class="built_in">at</span>(i)];       <span class="comment">//获取每个玩家的位置结构体</span></span><br><span class="line">            context.info-&gt;<span class="built_in">hide</span>();                       <span class="comment">//隐藏各个玩家抢地主过程中的提示信息</span></span><br><span class="line">            <span class="comment">//显示各个玩家的头像</span></span><br><span class="line">            Player* player = m_playerList.<span class="built_in">at</span>(i);</span><br><span class="line">            QPixmap pixmap = <span class="built_in">loadRoleImage</span>(player-&gt;<span class="built_in">getSex</span>(),player-&gt;<span class="built_in">getDirection</span>(), player-&gt;<span class="built_in">getRole</span>());   <span class="comment">//得到对应玩家的头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">setPixmap</span>(pixmap);     <span class="comment">//设置头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">show</span>();                <span class="comment">//显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::startDispatchCard</span><span class="params">()</span>            <span class="comment">//发牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重置每张卡牌的属性(不是所有属性)   QMap&lt;Card, CardPanel*&gt;m_cardMap;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cardMap.<span class="built_in">begin</span>(); it!=m_cardMap.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);     <span class="comment">//设置非选中状态</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);     <span class="comment">//显示正面图片</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">hide</span>();                  <span class="comment">//窗口隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//隐藏三张底牌</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置玩家的窗口上下文信息(位置)</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());        <span class="comment">//传入用户玩家对象，得到它在m_playerList的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;                            <span class="comment">//对玩家容器进行遍历</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].lastCards.<span class="built_in">clear</span>();              <span class="comment">//玩家上一次打出的牌进行清空</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].info-&gt;<span class="built_in">hide</span>();                   <span class="comment">//隐藏游戏过程中的提示信息</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].roleImg-&gt;<span class="built_in">hide</span>();                <span class="comment">//玩家的头像隐藏</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].isFrontSide = i==index ? <span class="literal">true</span> : <span class="literal">false</span>;   <span class="comment">//显示正面还是背面(用户玩家显示正面，机器人玩家显示背面)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置所有玩家的卡牌数据</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">resetCardData</span>();        <span class="comment">//该函数里面是做了：洗牌、清空三个玩家的手牌、将出牌玩家对象指向空和出的牌清空</span></span><br><span class="line">    <span class="comment">//显示底牌</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">show</span>();            <span class="comment">//正中间的扑克牌，刚开是背面时(显示出来)</span></span><br><span class="line">    <span class="comment">//隐藏按钮面板</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//传入的是空窗口</span></span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">10</span>);               <span class="comment">//每隔10毫秒，定时器就触发一次</span></span><br><span class="line">    <span class="comment">//播放背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Dispatch);             <span class="comment">//播放发牌的音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cardMoveStep</span><span class="params">(Player *player, <span class="type">int</span> curPos)</span>     <span class="comment">//参数：具体是哪个玩家，移动步长的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到每个玩家的扑克牌展示区域</span></span><br><span class="line">    QRect cardRect = m_contextMap[player].cardRect;</span><br><span class="line">    <span class="comment">//每个玩家的单位步长</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> unit[] = &#123;(m_baseCardPos.<span class="built_in">x</span>() - cardRect.<span class="built_in">right</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">left</span>() - m_baseCardPos.<span class="built_in">x</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">top</span>() - m_baseCardPos.<span class="built_in">y</span>())/<span class="number">100</span> &#125;;   <span class="comment">//左侧玩家:(发牌区域x坐标-左侧玩家区域右变x轴)/长度；右侧玩家</span></span><br><span class="line">    <span class="comment">//每次窗口移动的时候，每个玩家对应的移动牌的实时坐标位置</span></span><br><span class="line">    <span class="type">const</span> QPoint pos[]=&#123; <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() - curPos * unit[<span class="number">0</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() + curPos * unit[<span class="number">1</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>(), m_baseCardPos.<span class="built_in">y</span>() + curPos * unit[<span class="number">2</span>])&#125;;  <span class="comment">//左侧机器人x轴坐标越来越小；右侧机器人x轴坐标越来越大</span></span><br><span class="line">    <span class="comment">//移动扑克牌窗口</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(player);          <span class="comment">//得到对应玩家的下标</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(pos[index]);                      <span class="comment">//卡牌移动到对应玩家 移动路径上 的某一点</span></span><br><span class="line">    <span class="comment">//临界状态处理</span></span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">0</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">show</span>();      <span class="comment">//说明该牌才刚开始移动，想要展示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">100</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();      <span class="comment">//说明该牌已经到了对应玩家的卡牌区域，就需要隐藏了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一张或多张卡牌时，会发出一个信号告诉主窗口，该函数就是接收该信号的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::disposeCard</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span>      <span class="comment">//卡牌区域更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards&amp; myCard = <span class="built_in">const_cast</span>&lt;Cards&amp;&gt;(cards);</span><br><span class="line">    CardList list = myCard.<span class="built_in">toCardList</span>();</span><br><span class="line">    <span class="comment">//CardList list = cards.toCardList();           //CardList是QVector&lt;Card&gt;的一个别名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//通过Card取出对应的窗口对象</span></span><br><span class="line">        panel-&gt;<span class="built_in">setOwner</span>(player);                        <span class="comment">//设置该张卡牌窗口的所有者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerCards</span><span class="params">(Player *player)</span>       <span class="comment">//把玩家得到的牌更新到该显示的位置上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards = player-&gt;<span class="built_in">getCards</span>();             <span class="comment">//取出该玩家得到的牌(手牌)</span></span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将得到的牌存放到QVector，默认是降序排列</span></span><br><span class="line"></span><br><span class="line">    m_cardsRect = <span class="built_in">QRect</span>();             <span class="comment">//先将m_cardsRect初始化</span></span><br><span class="line">    m_userCards.<span class="built_in">clear</span>();               <span class="comment">//每次进来要清空，因为手牌位置发生变化了</span></span><br><span class="line">    <span class="comment">//取出展示扑克牌的区域</span></span><br><span class="line">    <span class="type">int</span> cardSpace = <span class="number">20</span>;               <span class="comment">//卡牌间相隔的像素(也是每张牌能显示出来的宽度)</span></span><br><span class="line">    QRect cardsRect = m_contextMap[player].cardRect;       <span class="comment">//取出该玩家的手牌区域坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;                   <span class="comment">//遍历每一张手牌</span></span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//每一张牌对应一张卡牌窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">show</span>();                       <span class="comment">//显示窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">raise</span>();                      <span class="comment">//让当前的卡牌窗口升起来(就是让当前卡牌窗口是所有之前出现的卡牌子窗口中最上层那个)</span></span><br><span class="line">        panel-&gt;<span class="built_in">setFrontSide</span>(m_contextMap[player].isFrontSide);    <span class="comment">//玩家的卡牌(手牌)显示正面还是反面</span></span><br><span class="line">        <span class="comment">//水平 or 垂直显示 -----&gt;下面是为了让卡牌显示在卡牌区域的正中间(卡牌区域要大一点)</span></span><br><span class="line">        <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;          <span class="comment">//如果是水平(用户玩家)</span></span><br><span class="line">            <span class="comment">//(总宽度-牌占用的宽度)/2：卡牌区域左边距离+(卡牌区域总宽度 - (卡牌总数量-1)*间隔 - 最后一张牌的完整宽度)/2</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>()+(cardsRect.<span class="built_in">width</span>()-(list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - m_cardSize.<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域上面距离+(卡牌区域高度-卡牌高度)/2</span></span><br><span class="line">            <span class="keyword">if</span>(panel-&gt;<span class="built_in">isSelected</span>())&#123;       <span class="comment">//如果这张扑克牌是被选中了，有各向上的弹跳效果</span></span><br><span class="line">                topY -= <span class="number">10</span>;                <span class="comment">//y轴像素-10</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX + cardSpace*i, topY);     <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">            m_cardsRect = <span class="built_in">QRect</span>(leftX, topY, cardSpace*i+m_cardSize.<span class="built_in">width</span>(),m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">            <span class="type">int</span> curWidth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.<span class="built_in">size</span>()<span class="number">-1</span> == i)&#123;                 <span class="comment">//如果是最后一张牌了，则该牌的宽度是一整张</span></span><br><span class="line">                curWidth = m_cardSize.<span class="built_in">width</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curWidth = cardSpace;               <span class="comment">//如果不是最后一张牌，则宽度就是间隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">QRect <span class="title">cardRect</span><span class="params">(leftX + cardSpace*i, topY, curWidth, m_cardSize.height())</span></span>;</span><br><span class="line">            m_userCards.<span class="built_in">insert</span>(panel, cardRect);      <span class="comment">//将每张牌对象和在窗口的位置</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//如果是垂直(机器人玩家)</span></span><br><span class="line">            <span class="comment">//因为不是在窗口的最左测，所以还是需要加上cardsRect.left()</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>() + (cardsRect.<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域左边距离+(卡牌区域宽度-卡牌宽度)/2</span></span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - (list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//m_cardSize和panel都可以表示牌的高度</span></span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX, topY+i*cardSpace);         <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示玩家打出的牌</span></span><br><span class="line">    <span class="comment">//得到当前玩家的出牌区域以及本轮打出的牌</span></span><br><span class="line">    QRect playCardRect = m_contextMap[player].playHandRect;</span><br><span class="line">    Cards lastCards = m_contextMap[player].lastCards;                <span class="comment">//玩家本轮打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!lastCards.<span class="built_in">isEmpty</span>())&#123;                                        <span class="comment">//如果不为空(本轮出牌了)</span></span><br><span class="line">        <span class="type">int</span> playSpacing = <span class="number">24</span>;                      <span class="comment">//出牌区域中牌与牌的间隙</span></span><br><span class="line">        CardList lastCardList = lastCards.<span class="built_in">toCardList</span>();              <span class="comment">//将出的牌存到QVector容器</span></span><br><span class="line">        CardList::ConstIterator itplayed = lastCardList.<span class="built_in">constBegin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; itplayed!=lastCardList.<span class="built_in">constEnd</span>(); itplayed++,i++)&#123;             <span class="comment">//通过常量迭代器遍历本轮出的牌</span></span><br><span class="line">            CardPanel* panel = m_cardMap[*itplayed];          <span class="comment">//得到对应的卡牌窗口对象</span></span><br><span class="line">            panel-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);                        <span class="comment">//显示正面</span></span><br><span class="line">            panel-&gt;<span class="built_in">raise</span>();           <span class="comment">//提升牌(让当前窗口能显示在同以级别窗口的上方)---&gt;当有多张考牌时，为了达到堆叠的效果，2叠1，3叠2，4叠3</span></span><br><span class="line">            <span class="comment">//将打出的牌移动到出牌区域</span></span><br><span class="line">            <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;            <span class="comment">//水平</span></span><br><span class="line">                <span class="type">int</span> leftBase = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-(lastCardList.<span class="built_in">size</span>()<span class="number">-1</span>)*playSpacing-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>() + (playCardRect.<span class="built_in">height</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(leftBase+i*playSpacing, top);      <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> left = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;   <span class="comment">//出牌区域左像素+卡牌x在出牌区域x的中点像素</span></span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>();               <span class="comment">//y轴就是出牌区域的y轴</span></span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(left, top+i*playSpacing);           <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">show</span>();                 <span class="comment">//不确定是隐藏还是显示的，预防是隐藏的，所以就将其显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QPixmap <span class="title">GamePanel::loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span>  <span class="comment">//参2是图像的显示方位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找图片</span></span><br><span class="line">    QVector&lt;QString&gt;lordMan;</span><br><span class="line">    QVector&lt;QString&gt;lordWoman;</span><br><span class="line">    QVector&lt;QString&gt;farmerMan;</span><br><span class="line">    QVector&lt;QString&gt;farmerWoman;</span><br><span class="line">    lordMan &lt;&lt; <span class="string">&quot;:/images/lord_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_man_2.png&quot;</span>;</span><br><span class="line">    lordWoman &lt;&lt; <span class="string">&quot;:/images/lord_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_woman_2.png&quot;</span>;</span><br><span class="line">    farmerMan &lt;&lt; <span class="string">&quot;:/images/farmer_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_man_2.png&quot;</span>;</span><br><span class="line">    farmerWoman &lt;&lt; <span class="string">&quot;:/images/farmer_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_woman_2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过QImage加载图片,因为其提供镜像操作(将朝向左的图片变为朝向右的图片)</span></span><br><span class="line">    QImage image;</span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);          <span class="comment">//随机用一张图片</span></span><br><span class="line">    <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Lord)&#123;                   <span class="comment">//如果是男性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Farmer)&#123;           <span class="comment">//如果是男性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Lord)&#123;           <span class="comment">//如果是女性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Farmer)&#123;         <span class="comment">//如果是女性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    <span class="keyword">if</span>(direct == Player::Left)&#123;        <span class="comment">//如果图片是显示在左侧的，就不需要做镜像</span></span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image);        <span class="comment">//因为返回值是QPixmap，所以还得进行转换</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image.<span class="built_in">mirrored</span>(<span class="literal">true</span>,<span class="literal">false</span>));   <span class="comment">//参1：是否做水平镜像；参2：是否做垂直镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pixmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDispatchCard</span><span class="params">()</span>                 <span class="comment">//每触发一次定时器就会执行该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录扑克牌的位置(各玩家的牌移动距离都分100次步长完成)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> curMovePos = <span class="number">0</span>;     <span class="comment">//主要是记录移动了多少个步长(第一次进该函数执行一次后，以后进该函数，都不执行该句)</span></span><br><span class="line">    <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(curMovePos &gt;= <span class="number">100</span>)&#123;               <span class="comment">//满足条件的话，就说明当前玩家得到了牌，轮到下一个玩家得牌了</span></span><br><span class="line">        <span class="comment">//给当前玩家发一张牌</span></span><br><span class="line">        Card card = m_gameCtl-&gt;<span class="built_in">takeOneCard</span>();            <span class="comment">//随机获取一张牌</span></span><br><span class="line">        curPlayer-&gt;<span class="built_in">storeDispatchCard</span>(card);              <span class="comment">//将该牌存入到当前玩家的手牌中</span></span><br><span class="line">        <span class="comment">//Cards cs(card);                   //带参构造函数</span></span><br><span class="line">        <span class="comment">//disposeCard(curPlayer,cs);   //卡牌区域更新，该函数在上面执行storeDispatchCard()时，里面就发出了信号，并执行disposeCard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换当前玩家</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(curPlayer-&gt;<span class="built_in">getNextPlayer</span>());      <span class="comment">//将下一个玩家改为当前玩家，轮到发牌给他了</span></span><br><span class="line">        curMovePos = <span class="number">0</span>;           <span class="comment">//重新将步长次数置为0</span></span><br><span class="line">        <span class="comment">//发牌动画</span></span><br><span class="line">        <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);</span><br><span class="line">        <span class="comment">//判断牌是否发完了</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">cardCount</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//终止定时器</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            <span class="comment">//切换游戏状态</span></span><br><span class="line">            <span class="built_in">gameStatusPrecess</span>(GameControl::CallingLord);        <span class="comment">//切换为叫地主状态</span></span><br><span class="line">            <span class="comment">//终止发牌音乐的播放(牌发完了)</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">stopAssistMusic</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);        <span class="comment">//参数：当前玩家，移动步长的次数</span></span><br><span class="line">    curMovePos += <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理玩家状态的变化(槽函数)---&gt;gamecontrol类发出的信号(玩家状态变化)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onPlayerStatusChanged</span><span class="params">(Player *player, GameControl::PlayerStatus status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForCallLord:                        <span class="comment">//考虑叫地主</span></span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                 <span class="comment">//只有当前玩家是用户玩家时，才执行下面(机器人玩家没有该按钮组窗口)</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::CallLord, m_gameCtl-&gt;<span class="built_in">getPlayerMaxBet</span>()); <span class="comment">//切换按钮组窗口为抢地主的窗口(修改目前下注最高分)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForPlayHand:                        <span class="comment">//考虑出牌</span></span><br><span class="line">        <span class="comment">//玩家出牌前，隐藏上一轮打出的牌</span></span><br><span class="line">        <span class="built_in">hidePlayerDropCards</span>(player);</span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                       <span class="comment">//先判断玩家是否是用户玩家</span></span><br><span class="line">            <span class="comment">//取出出牌玩家的对象</span></span><br><span class="line">            Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();            <span class="comment">//取出上一次的出牌玩家，如果为空，说明出牌刚开始,</span></span><br><span class="line">            <span class="keyword">if</span>(pendPlayer == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>() || pendPlayer == <span class="literal">nullptr</span>)&#123;              <span class="comment">//如果用户玩家是上一次的出牌玩家(说明上一次出的牌，机器人玩家不要)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PlayCard);           <span class="comment">//显示相应的按钮组窗口(这是用户玩家自由出牌)</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                                       <span class="comment">//不是上一次的出牌玩家(轮到自己了，可以出牌，也可以不出牌)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PassOrPlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                        <span class="comment">//如果玩家是机器人玩家，则就不用显示空即可</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::Winning:</span><br><span class="line">        m_bgm-&gt;<span class="built_in">stopBGM</span>();                    <span class="comment">//结束播放背景音乐</span></span><br><span class="line">        <span class="comment">//如果玩家赢了，就要显示出其它玩家的牌(由背面变为正面)</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()].isFrontSide = <span class="literal">true</span>;        <span class="comment">//先将遍历置为true</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()].isFrontSide = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>());            <span class="comment">//updatePlayerCards会将剩余的牌会显示正面</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getRightRobot</span>());</span><br><span class="line">        <span class="comment">//更新玩家的得分</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();</span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(player);            <span class="comment">//将本局赢的玩家又设为当前玩家(下一局由它先决定要不要地主)</span></span><br><span class="line">        <span class="built_in">showEndingScorePanel</span>();                         <span class="comment">//显示游戏结束面板</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onGrabLordBet</span><span class="params">(Player *player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span>   <span class="comment">//处理抢地主情况的槽函数(显示在主窗口)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//显示抢地主的信息提示</span></span><br><span class="line">    PlayerContext context = m_contextMap[player];</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;                      <span class="comment">//分数为0，说明不叫地主</span></span><br><span class="line">        context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/buqinag.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;         <span class="comment">//如果是第一次叫地主</span></span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/jiaodizhu.png&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/qiangdizhu.png&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示叫地主的分数(如果不叫地主，下注分数是0，就没有必要显示，所以这句代码写在else语句里)</span></span><br><span class="line">        <span class="built_in">showAnimation</span>(Bet,bet);            <span class="comment">//调用动画效果类。参1是动画效果枚举类的分数枚举，参2是具体的分数</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.info-&gt;<span class="built_in">show</span>();              <span class="comment">//显示出提示信息</span></span><br><span class="line">    <span class="comment">//播放分数的背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playerRobLordMusic</span>(bet, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>(),flag);        <span class="comment">//性别需要强制转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDisposePlayHand</span><span class="params">(Player *player, Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//存储玩家当轮打出的牌</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);         <span class="comment">//获取出牌玩家的一些位置信息</span></span><br><span class="line">    it-&gt;lastCards = cards;</span><br><span class="line">    <span class="comment">//2.根据牌型播放游戏特效</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//获得牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Plane || type==PlayHand::Hand_Plane_Two_Pair || type== PlayHand::Hand_Plane_Two_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Plane);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Pair)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(LianDui);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(ShunZi);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Bomb);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(JokerBomb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果玩家打出的是空牌(不出牌)，显示提示信息</span></span><br><span class="line">    <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/pass.png&quot;</span>));</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">show</span>();         <span class="comment">//把info对应的窗口显示出来(之前被隐藏掉了)</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playPassMusic</span>((BGMControl::RoleSex)player-&gt;<span class="built_in">getRole</span>());      <span class="comment">//播放不要音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;            <span class="comment">//如果不为空，就需要判断是不是第一个(自由)出牌的玩家</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==player || m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==<span class="literal">nullptr</span>)&#123;    <span class="comment">//如果是自由出牌</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">true</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());     <span class="comment">//播放音乐，是自由出牌，参2为true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">false</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.更新玩家剩余的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">    <span class="comment">//4. 播放提示音乐</span></span><br><span class="line">    <span class="comment">//判断玩家剩余的牌的数量</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">2</span>)&#123;              <span class="comment">//剩余2张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last2, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">1</span>)&#123;        <span class="comment">//剩余1张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last1, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数是一个槽函数，是接收到control发出的键盘选择信号后，执行的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 判断是不是出牌状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus==GameControl::DispatchCard || m_gameStatus==GameControl::CallingLord)&#123;  <span class="comment">//如果当前是发牌或叫地主状态，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断发出信号的牌的所有者是不是当前用户玩家(有时候我们的鼠标点击了机器人玩家的牌。这样对应的牌窗口也会发出信号，所以需要进行判断)</span></span><br><span class="line">    CardPanel* panel = (CardPanel*)<span class="built_in">sender</span>();       <span class="comment">//sender()返回的是QObject类型的指针()，转换后，得到发出信号的卡牌窗口对象</span></span><br><span class="line">    <span class="keyword">if</span>(panel-&gt;<span class="built_in">getOwner</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;     <span class="comment">//判断发出信号的卡牌窗口的所有者，如果不是用户对象，就直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 保存当前被选中的牌的窗口对象</span></span><br><span class="line">    m_curSelCard = panel;               <span class="comment">//记录在当前手牌中选择的卡牌对象</span></span><br><span class="line">    <span class="comment">//4. 判断参数的鼠标键是左键还是右键</span></span><br><span class="line">    <span class="keyword">if</span>(button == Qt::LeftButton)&#123;                 <span class="comment">//点击的是左键，就设置对应的卡牌窗口加入到准备出牌的容器中</span></span><br><span class="line">        <span class="comment">//设置扑克牌的选中状态</span></span><br><span class="line">        panel-&gt;<span class="built_in">setSeclected</span>(!panel-&gt;<span class="built_in">isSelected</span>());    <span class="comment">//设置选择状态(如果之前没有选中，经过该函数就变为选中，之前选中了，经过该函数就是不选中)</span></span><br><span class="line">        <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(panel-&gt;<span class="built_in">getOwner</span>());</span><br><span class="line">        <span class="comment">//保存或删除扑克牌窗口对象</span></span><br><span class="line">        QSet&lt;CardPanel*&gt;::const_iterator it = m_selectCards.<span class="built_in">find</span>(panel);</span><br><span class="line">        <span class="keyword">if</span>(it == m_selectCards.<span class="built_in">constEnd</span>())&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">insert</span>(panel);       <span class="comment">//没有找到，将该牌添加到容器里面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::SelectCard);          <span class="comment">//播放出牌音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(button == Qt::RightButton)&#123;            <span class="comment">//点击的是右键，就打出牌(如果不满足出牌规则，就不响应)</span></span><br><span class="line">        <span class="comment">//调用出牌按钮对应的槽函数</span></span><br><span class="line">        <span class="built_in">onUserPlayHand</span>();          <span class="comment">//调用处理用户玩家出牌函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断游戏状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus != GameControl::PlayingHand)&#123;     <span class="comment">//当前游戏状态不是出牌状态，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断玩家是不是用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;       <span class="comment">//当前玩家如果不是用户玩家，也直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断要出的牌是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(m_selectCards.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//用户玩家要出的牌容器如果为空，也直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到要打出的牌的牌型(m_selectCards容器不为空)</span></span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        Card card = (*it)-&gt;<span class="built_in">getCard</span>();</span><br><span class="line">        cs.<span class="built_in">add</span>(card);                           <span class="comment">//将用户要打出的牌都放到Cards容器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cs)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();           <span class="comment">//获取要打出牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type==PlayHand::Hand_Unknown)&#123;                       <span class="comment">//如果打出的牌类型是不规则(没有定义)的，也就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前玩家的牌能不能压住上一家的牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;  <span class="comment">//先判断上一次的出牌玩家是不是用户玩家，如果不是，就不能随意出牌(要大过对方)</span></span><br><span class="line">        Cards cards = m_gameCtl-&gt;<span class="built_in">getPendCards</span>();        <span class="comment">//获取上一次的出牌玩家打出的牌</span></span><br><span class="line">        <span class="keyword">if</span>(!hand.<span class="built_in">canBeat</span>(<span class="built_in">PlayHand</span>(cards)))&#123;             <span class="comment">//判断用户玩家准备打出的牌能否击败对方的牌，不能就直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                  <span class="comment">//出完牌了，停止倒计时</span></span><br><span class="line">    <span class="comment">//通过玩家对象出牌(调用出牌函数)</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">playHand</span>(cs);      <span class="comment">//playHand()函数里面会从手牌中移除要打出的牌，并发出信号，通知主窗口接收</span></span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                <span class="comment">//清空用户玩家准备出牌的这个容器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家的放弃出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                     <span class="comment">//用户玩家放弃出牌，终止倒计时</span></span><br><span class="line">    <span class="comment">//判断是不是用户玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();          <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();            <span class="comment">//获取用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(curPlayer != userPlayer)&#123;               <span class="comment">//如果当前玩家不是用户玩家，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前用户玩家是不是上一次出牌的玩家(可以不处理)</span></span><br><span class="line">    Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(pendPlayer==userPlayer || pendPlayer==<span class="literal">nullptr</span>)&#123; <span class="comment">//如果上一次出牌玩家是自己(其它玩家要不起出的牌)或者第一次出牌，这两种清空都直接退出(因为必须要出牌)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打出一个空的Cards是对象</span></span><br><span class="line">    Cards empty;</span><br><span class="line">    userPlayer-&gt;<span class="built_in">playHand</span>(empty);</span><br><span class="line">    <span class="comment">//清空用户选择的牌(玩家可能选择了一些牌，但是没有打出去)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);         <span class="comment">//将选中的牌都设置为非选中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                  <span class="comment">//清空准备出牌容器</span></span><br><span class="line">    <span class="comment">//更新玩家待出牌区域的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(userPlayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特效动画函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showAnimation</span><span class="params">(GamePanel::AnimationType type, <span class="type">int</span> bet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::LianDui:</span><br><span class="line">    <span class="keyword">case</span> AnimationType::ShunZi:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">150</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showSequence</span>((AnimationWindow::Type)type);          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Plane:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>, <span class="number">75</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showPlane</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">180</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::JokerBomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showJokerBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bet:           <span class="comment">//如果是抢地主分数</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">160</span>, <span class="number">98</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-140</span>); <span class="comment">//x和y都先取中间位置，y还需要往上移</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBetScore</span>(bet);          <span class="comment">//调用加载分数的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个主要是考虑到其它动画，因为显示分数是在2s后，会将AnimationType窗口隐藏起来，这样其它动画窗口会看不见，所以在这里调用一下显示</span></span><br><span class="line">    m_animation-&gt;<span class="built_in">show</span>();     <span class="comment">//让隐藏的窗口再显示出来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::hidePlayerDropCards</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);          <span class="comment">//根据当前玩家得到对应的一些信息的位置(如果没有找到传进去的玩家，就返回迭代器end)</span></span><br><span class="line">    <span class="keyword">if</span>(it != m_contextMap.<span class="built_in">end</span>())&#123;                 <span class="comment">//如果it不等于end，说明找到了</span></span><br><span class="line">        <span class="keyword">if</span>(it-&gt;lastCards.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果为空，说明上次没有出牌</span></span><br><span class="line">            it-&gt;info-&gt;<span class="built_in">hide</span>();                     <span class="comment">//先隐藏对应的提示信息</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Cards ---&gt; Card   注：CardList = QVector&lt;Card&gt;</span></span><br><span class="line">            CardList list = it-&gt;lastCards.<span class="built_in">toCardList</span>();             <span class="comment">//将最后打出的牌全部存入到QVector容器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> last=list.<span class="built_in">begin</span>(); last!=list.<span class="built_in">end</span>(); last++)&#123;        <span class="comment">//遍历每一张牌</span></span><br><span class="line">                m_cardMap[*last]-&gt;<span class="built_in">hide</span>();    <span class="comment">//每一张牌都有对应的CardPanel，存到m_cardMap容器的，进行隐藏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it-&gt;lastCards.<span class="built_in">clear</span>();                    <span class="comment">//清空玩家最后一次打出的牌容器(不然会堆叠)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示玩家的最终得分(结束面板设置)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showEndingScorePanel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> islord = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getRole</span>() == Player::Lord?<span class="literal">true</span>:<span class="literal">false</span>;     <span class="comment">//玩家是否是地主</span></span><br><span class="line">    <span class="type">bool</span> isWin = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">isWin</span>();                                   <span class="comment">//玩家是否获胜</span></span><br><span class="line">    EndingPanel* panel = <span class="keyword">new</span> <span class="built_in">EndingPanel</span>(islord, isWin, <span class="keyword">this</span>);       <span class="comment">//创建一个结束面板窗口，参3的this表示在主窗口中显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">show</span>();                                           <span class="comment">//显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, -panel-&gt;<span class="built_in">height</span>());       <span class="comment">//结束面板刚开始显示在主窗口外(看不见)</span></span><br><span class="line">    panel-&gt;<span class="built_in">setPlayerScore</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">    <span class="comment">//根据玩家的输赢来播放对应的音乐</span></span><br><span class="line">    <span class="keyword">if</span>(isWin)&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置结束面板的动画效果</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(panel, <span class="string">&quot;geometry&quot;</span>, <span class="keyword">this</span>);   <span class="comment">//参1：给哪个对象指定动画效果；参3：父对象</span></span><br><span class="line">    <span class="comment">//动画持续时间</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">1500</span>);           <span class="comment">//1.5s</span></span><br><span class="line">    <span class="comment">//设置窗口的起始位置和终止位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(panel-&gt;<span class="built_in">x</span>(), panel-&gt;<span class="built_in">y</span>(), panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>, panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    <span class="comment">//设置窗口的运动曲线</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(<span class="built_in">QEasingCurve</span>(QEasingCurve::OutBounce));</span><br><span class="line">    <span class="comment">//播放动画效果</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//处理窗口信号(当点击继续游戏按钮，就会发出continueGame信号，然后这里也会接收该信号)</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;EndingPanel::continueGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        panel-&gt;<span class="built_in">close</span>();                  <span class="comment">//关闭结束界面窗口，但没有析构(但由于指定了父对象，所以的父对象没有结束，也就不会析构panel)</span></span><br><span class="line">        panel-&gt;<span class="built_in">deleteLater</span>();            <span class="comment">//手动析构panel结束界面窗口</span></span><br><span class="line">        animation-&gt;<span class="built_in">deleteLater</span>();        <span class="comment">//手动析构动画对象</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);               <span class="comment">//按钮组隐藏，显示空按钮的按钮组</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);                <span class="comment">//将游戏状态设置位发牌状态</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);              <span class="comment">//播放背景音乐(开始)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown = <span class="keyword">new</span> <span class="built_in">CountDown</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个闹钟类对象，父对象为主窗口</span></span><br><span class="line">    m_countDown-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_countDown-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_countDown-&gt;<span class="built_in">height</span>())/<span class="number">2</span>+<span class="number">30</span>);    <span class="comment">//显示位置</span></span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::notMuchTime, <span class="keyword">this</span>, [=]()&#123;             <span class="comment">//当闹钟秒数减为5s时,会发出信号</span></span><br><span class="line">        <span class="comment">//播放提示音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Alert);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::timeout, <span class="keyword">this</span>, &amp;GamePanel::onUserPass); <span class="comment">//当秒数减为0s时，会发出信号，执行的槽函数当放弃出牌情况处理</span></span><br><span class="line">    UserPlayer* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();               <span class="comment">//得到用户对象</span></span><br><span class="line">    <span class="built_in">connect</span>(userPlayer, &amp;UserPlayer::startCountDown, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//当用户玩家准备出牌时，会发出信号startCountDown</span></span><br><span class="line">        <span class="comment">//要在主屏幕上显示闹钟，必须是用户玩家可以放弃出牌的情况，比如说上一次出牌玩家不是自己且不是第一次刚开始出牌</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=userPlayer &amp;&amp; m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_countDown-&gt;<span class="built_in">showCountDown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_bkImage);         <span class="comment">//参数：窗口矩形区域、</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span>          <span class="comment">//鼠标移动过程中框选多张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="comment">//ev-&gt;buttons()里面有多种鼠标按住的移动方式(如左键、右键等)</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;                 <span class="comment">//判断一下是否有鼠标左键(大于0说明左键参与了行动)</span></span><br><span class="line">        QPoint pt = ev-&gt;<span class="built_in">pos</span>();                         <span class="comment">//得到鼠标在窗口中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(!m_cardsRect.<span class="built_in">contains</span>(pt))&#123;               <span class="comment">//如果pt不在出牌区域</span></span><br><span class="line">            m_curSelCard = <span class="literal">nullptr</span>;                  <span class="comment">//将鼠标选择的卡牌窗口置为nullptr</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                      <span class="comment">//如果鼠标按住的位置在卡牌区域，就要找到是哪些卡牌</span></span><br><span class="line">            QList&lt;CardPanel*&gt; list = m_userCards.<span class="built_in">keys</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                CardPanel* panel = list.<span class="built_in">at</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(m_userCards[panel].<span class="built_in">contains</span>(pt) &amp;&amp; m_curSelCard!=panel)&#123;  <span class="comment">//如果找到对应卡牌，且如果一直在一张卡牌上面，也只模拟点击一次</span></span><br><span class="line">                    <span class="comment">//点击这张扑克牌(模拟点击效果)</span></span><br><span class="line">                    panel-&gt;<span class="built_in">clicked</span>();       <span class="comment">//该函数会发出一个信号，接收者是GamePanel</span></span><br><span class="line">                    m_curSelCard = panel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6-游戏的启动过程"><a href="#6-游戏的启动过程" class="headerlink" title="6. 游戏的启动过程"></a>6. 游戏的启动过程</h1><blockquote><p> 在这个斗地主的小游戏中，虽然创建了许多类对象，但基本上会在主窗口类中做初始化，并实现各个类的功能，将每个类的功能结合在一起，就实现了单机版的斗地主小游戏。</p></blockquote><p>首先是在主窗口类<code>GamePanel</code>中，设置了主窗口的左上角标题和窗口大小，又往主窗口中加载了背景图，背景图有9张，每次启动游戏随机取1张。</p><p>在<code>initButtonsGroup()</code>函数中先初始化5个页面的按钮组，选择初始界面的按钮组为开始界面，即只有一个开始按钮。然后通过信号槽机制，当点击开始按钮后，就执行匿名函数(发牌操作)。这个匿名函数会切换按钮组窗口，切换成空按钮的窗口，将所有玩家的得分清0，然后又马上更新每个玩家的得分。通过函数<code>gameStatusPrecess()</code>将游戏状态改为发牌状态。在<code>gameStatusPrecess()</code>函数里，因为传进来的参数是发牌状态的参数，通过switch执行对应的状态分支，即开始发牌函数<code>startDispatchCard()</code>。在该开始发牌函数中，它会设置各个玩家和扑克牌在窗口中显示的一些属性，如玩家的头像显示、玩家的手牌是否可见以及正中间的卡牌。同时，在这个函数中，也启动了一个定时器，该定时器每隔10毫秒会发送一次，该定时器是定义在主窗口类GamePanel的构造函数中的，它是每隔固定时间会执行发牌函数<code>onDispatchCard()</code>，这个函数中，是慢慢移动卡牌位置，然后利用定时器实现一个动态的发牌效果，当还剩下3张牌时，停止定时器，通过函数<code>gameStatusPrecess()</code>切换游戏状态为叫地主状态。在该状态下，通过switch执行了对应的分支。在该分支下，先是将3张底牌隐藏起来，然后调用游戏控制类的开始叫地主<code>startLordCard()</code>函数。这个函数里面执行了从父类继承下来的虚函数<code>prepareCallLord()</code>，机器人玩家和用户玩家作为子类，它们实现的操作不一样。首先是用户玩家，用户玩家在这个虚函数里面没有执行任何操作，然后又向主窗口发出了信号<code>playerStatusChanged</code>，主窗口类的<code>gameControlInit()</code>函数里面通过connect来处理该信号，令<code>onPlayerStatusChanged()</code>槽函数执行相应操作。在该函数里，会先判断是否是用户玩家，如果是用户玩家，就切换按钮组窗口，切换叫地主的一些按钮出来。</p><p>用户玩家的叫地主按钮显示出来后，又回到了<code>initButtonsGroup()</code>函数，在该函数，通过信号槽机制connect设置，当点击对应下注按钮时，会携带对应的分数执行匿名函数，在这个匿名函数中，因为用户玩家已经下注了，所以就切换按钮组窗口，切换为空按钮组。同时它会执行Player类的<code>grabLordBet()</code>函数，这个函数会发出信号<code>notifyGrabLordBet</code>，在发出该信号后，在主窗口的构造函数中，游戏控制类初始化函数<code>gameControlInit()</code>里面执行的<code>playerInit()</code>函数，在该函数里面会通过信号槽机制connect来接收信号，并执行槽函数<code>onGrabBet()</code>，在这个函数里面，它会根据用户玩家的下注分数，来判断是否还需要继续执行抢地主的操作，大概有两种情况：</p><p>1.用户玩家按的按钮是不抢地主、下注1分或下注2分，这些情况都说明还需要继续执行抢地主状态，就发送一个信号<code>notifyGrabLordBet</code>，主窗口函数会在构造函数的<code>gameControlInit()</code>函数里面通过信号槽来接收处理，执行槽函数<code>onGrabLordBet()</code>，这个函数里面就是显示提示信息和播放对应的背景音乐。然后回到<code>onGrabBet()</code>函数，它会切换玩家，将下一个玩家更新为当前玩家，并向主窗口发出信号<code>playerStatusChanged</code>，主窗口接收该信号后执行的槽函数中，通过switch执行对应的抢地主分支，而抢地主分支是只有用户玩家时，才会切换出叫地主的按钮组，不是用户玩家，就什么都不执行，退出即可。然后回到onGrabBet()函数，通过当前玩家(机器人玩家)对象调用准备叫地主函数<code>prepareCallLord()</code>。在机器人玩家类中，重写的这个函数里面会创建一个叫地主的子线程，该子线程会先睡眠2s(模拟思考效果)，然后执行考虑叫地主函数<code>thinkCallLord()</code>，在该函数里，会分析对应机器人玩家的手牌情况，看是否满足叫地主的条件，通过最后计算出来的权重来断定下注多数分。然后发送信号<code>notifyGrabLordBet</code>，游戏控制类接受信号并执行槽函数<code>onGrabBet()</code>，在这个函数如果不满足某些条件，就会继续切换下一个玩家叫地主，依次下去。当满足一定条件时，就会确定地主玩家，执行成为地主函数<code>becomeLord()</code>。</p><p>2.用户玩家下注3分，直接成为地主，执行函数<code>becomeLord()</code>。</p><p>在<code>becomeLord()</code>函数中，先是设置各个玩家的身份，将当前地主身份的玩家设置为当前玩家(先出牌)，又将三张底牌添加到地主玩家的手牌中。然后这定义了一个定时器，每隔1s就发送信号<code>gameStatusChanged</code>和<code>playerStatusChanged</code>。其中由主窗口接收信号<code>gameStatusChanged</code>，执行槽函数<code>gameStatusPrecess()</code>，这个槽函数里面就是通过switch语句执行对应的分支，该分支下主要就是将底牌、中间的发牌隐藏、提示信息等，和显示玩家带身份的头像；主窗口也接收<code>playerStatusChanged</code>信号，并执行槽函数<code>onPlayerStatusChanged()</code>，通过执行对应的分支，该分支主要就是判断当前是否是用户玩家，如果是用户玩家，就切换按钮组窗口为出牌情况，不是的话就切换为空按钮主窗口。在处理完两个信号的槽函数后，在定时器中又调用了对应玩家的出牌函数<code>preparePlayHand()</code>，这个出牌函数是用户玩家和机器人玩家执行的程序不一样，用户玩家就执行发出一条信号<code>startCountDown</code>，用于出牌倒计时即可；机器人玩家会创建对应的出牌子线程，在子线程中会执行考虑出牌函数<code>thinkPlayHand()</code>，接下来就是小项目中设定的一些策略了，机器人玩家在什么情况下出什么样的牌。</p><h1 id="7-游戏效果"><a href="#7-游戏效果" class="headerlink" title="7. 游戏效果"></a>7. 游戏效果</h1><p>当点击启动程序时，会先显示一个加载的界面，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_13.png"></p><p>当加载页面完成后，就会出现游戏场景的页面了，在这个页面中右上角显示的是个玩家的分数，因为才启动程序，所以都是0分。场景的正中间是发卡牌的扑克牌，下面是开始按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_14.png"></p><p>当点击开始游戏按钮后，就进入了发牌阶段，只有用户玩家的手牌是显示正面的，其它两个机器人玩家的手牌是显示背面的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_15.png"></p><p>当发牌结束后，就游戏就进入了叫地主状态，当用户玩家直接点击3分按钮后，就可以直接成为地主，结束叫地主状态。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_16.png"></p><p>而当用户玩家点击除3分按钮的其它按钮，就会轮到下一个(机器人)玩家考虑是否叫地主。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_17.png"></p><p>当3个玩家都下注后，最后由下注分数最大的玩家当地主，其它两个玩家作为农民。并且三张底牌显示在正上方。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_18.png"></p><p>叫地主状态结束后，用鼠标选择卡牌，点击出牌即可。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_19.png"></p><p>当出的牌是一些特殊牌型，如炸弹、飞机、顺子等，还会有特效出现。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_20.png"></p><p>当某个玩家出完牌后，表示胜利，然后正中间出现结束面板，显示当前三个玩家的得分，同时右上角也显示当前三个玩家的得分。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_21.png"></p><p>当点击继续游戏按钮时，可以马上又进入下一局游戏，主窗口的右上角依然保存三个玩家的得分。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_22.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-结束面板窗口类EndingPanel&quot;&gt;&lt;a href=&quot;#1-结束面板窗口类EndingPanel&quot; class=&quot;headerlink&quot; title=&quot;1. 结束面板窗口类EndingPanel&quot;&gt;&lt;/a&gt;1. 结束面板窗口类EndingPanel&lt;/h1</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Qt斗地主项目(上)</title>
    <link href="https://lxx93.online/2024/08/04/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8A)/"/>
    <id>https://lxx93.online/2024/08/04/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8A)/</id>
    <published>2024-08-04T10:35:30.000Z</published>
    <updated>2024-08-21T14:14:48.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>这是一个基于Qt开发的单机版的斗地主小游戏。该项目一共涉及到的类有如下：</p><p>1.卡牌类</p><ul><li>单张卡牌：Card</li><li>多张卡牌：Cards</li></ul><p>2.玩家类</p><ul><li><p>玩家类(父类)：Player</p></li><li><p>机器人玩家(子类)：Robot</p></li><li><p>非机器人玩家(子类)：UserPlayer</p></li></ul><p>3.窗口类</p><ul><li><p>游戏开始加载动画窗口：Loading</p></li><li><p>游戏主窗口：GamePanel</p></li><li><p>单张卡牌窗口：CardPanel</p></li><li><p>特效动画窗口：AnimationWindow</p></li><li><p>游戏窗口中的按钮窗口：ButtonGroup</p></li><li><p>游戏结束玩家的成绩窗口：EndingPanel</p></li><li><p>自定义按钮：MyButton</p></li><li><p>游戏分数面板窗口：ScorePanel</p></li></ul><p>4.游戏策略类</p><ul><li><p>出牌类：PlayHand</p></li><li><p>游戏策略类：Strategy</p></li></ul><p>5.游戏控制类</p><ul><li>游戏控制类：GameControl</li></ul><p>6.线程类</p><ul><li><p>机器人玩家抢地主：RobotGrapLord</p></li><li><p>机器人玩家出牌：RobotPlayHand</p></li></ul><p>7.音频类</p><ul><li>控制播放游戏中的所有音频：BGMControl</li></ul><p>首先，创建一个项目，项目名为Landlords，再创建一个游戏主窗口类<code>GamePanel</code>，继承的基类是<code>QMainWindow</code>。该类也将作为斗地主小游戏的一个主窗口。</p><h1 id="2-单张卡牌类Card"><a href="#2-单张卡牌类Card" class="headerlink" title="2. 单张卡牌类Card"></a>2. 单张卡牌类Card</h1><p>单张卡牌类Card主要完成的是扑克牌中花色和点数的定义，以及一些操作符重载，以方便后序的开发中更加简便和高效。</p><p>单张卡牌类Card的创建：通过选择新建、c++、c++class、类名为<code>Card</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p><h2 id="2-1-Card类的头文件"><a href="#2-1-Card类的头文件" class="headerlink" title="2.1 Card类的头文件"></a>2.1 Card类的头文件</h2><p>该头文件主要就是定义了卡牌花色和点数的枚举类，并通过有参构造来定义一张扑克牌。在这里为了后期的开发简便，事先定义了两个card类的排序函数，后期可以通过这两个函数实现对玩家手牌的排序。由于卡牌是存储在QSet容器里面的(定义在Cards类里面的)，Qt中规定该容器里面存储的元素数据必须是可以分配和可以指定的类型，如果要存储一个自定义对象类型，需要提供其比较操作符函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>              <span class="comment">//卡牌类：每张牌的一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//花色枚举类(为了操作方便，给枚举类加上开始和结尾)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardSuit</span>&#123;</span><br><span class="line">        Suit_Begin,</span><br><span class="line">        Diamond,             <span class="comment">//方块</span></span><br><span class="line">        Club,                <span class="comment">//梅花</span></span><br><span class="line">        Heart,               <span class="comment">//红桃</span></span><br><span class="line">        Spade,               <span class="comment">//黑桃</span></span><br><span class="line">        Suit_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//点数枚举类</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardPoint</span>&#123;</span><br><span class="line">        Card_Begin,         <span class="comment">//对应整数0</span></span><br><span class="line">        Card_3,</span><br><span class="line">        Card_4,</span><br><span class="line">        Card_5,</span><br><span class="line">        Card_6,</span><br><span class="line">        Card_7,</span><br><span class="line">        Card_8,</span><br><span class="line">        Card_9,</span><br><span class="line">        Card_10,</span><br><span class="line">        Card_J,</span><br><span class="line">        Card_Q,</span><br><span class="line">        Card_K,</span><br><span class="line">        Card_A,</span><br><span class="line">        Card_2,</span><br><span class="line">        Card_SJ,               <span class="comment">//小王</span></span><br><span class="line">        Card_BJ,               <span class="comment">//大王</span></span><br><span class="line">        Card_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Card</span>();</span><br><span class="line">    <span class="built_in">Card</span>(CardPoint point, CardSuit suit);      <span class="comment">//通过点数和花色创建一张扑克牌</span></span><br><span class="line">    <span class="comment">//设置成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(CardPoint point)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuit</span><span class="params">(CardSuit suit)</span></span>;</span><br><span class="line">    <span class="comment">//返回成员变量</span></span><br><span class="line">    <span class="function">CardPoint <span class="title">point</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">CardSuit <span class="title">suit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CardPoint m_point;           <span class="comment">//成员变量点数</span></span><br><span class="line">    CardSuit m_suit;             <span class="comment">//成员变量花色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象比较</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;         <span class="comment">//升序调用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;      <span class="comment">//降序调用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2);      <span class="comment">//操作符重载(&lt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用QSet容器,里面的使用的数据必须是可以分配和可以指定的类型(常用的基础数据类型)，如果是要存储一个对象的，不能处理的情况，就需要提供一个比较操作符的重载，并且重写</span></span><br><span class="line"><span class="comment">//一个qHash的全局函数，该函数作用是得到某个对象对应的哈希值，计算方式可以自己指定。</span></span><br><span class="line"><span class="comment">//操作符重载(==)</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right);     <span class="comment">//因为QSet容器存储自定义类型Card是有问题的，不能进行比较</span></span><br><span class="line"><span class="comment">//重写全局函数qHash</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line"><span class="comment">//定义类型的别名</span></span><br><span class="line"><span class="keyword">using</span> CardList = QVector&lt;Card&gt;;</span><br></pre></td></tr></table></figure><h2 id="2-2-Card类函数实现"><a href="#2-2-Card类函数实现" class="headerlink" title="2.2 Card类函数实现"></a>2.2 Card类函数实现</h2><p>这部分就是对单张卡牌Card类声明的函数进行实现，即卡牌进行构造，设置卡牌点数、花色，获取卡牌点数、花色等。也完成了一些Card类运算符的重载实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Card::<span class="built_in">Card</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//提供卡牌点数和花色初始化一张牌</span></span><br><span class="line">Card::<span class="built_in">Card</span>(Card::CardPoint point, Card::CardSuit suit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setPoint</span>(point);</span><br><span class="line">    <span class="built_in">setSuit</span>(suit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setPoint</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_point = point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌花色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setSuit</span><span class="params">(Card::CardSuit suit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_suit = suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Card::point</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的花色</span></span><br><span class="line"><span class="function">Card::CardSuit <span class="title">Card::suit</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const对象只能调用带const限定的函数，所以point和suit需要加const限定</span></span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &lt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &lt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &gt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &gt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right)&#123;</span><br><span class="line">    <span class="built_in">return</span> (left.<span class="built_in">point</span>()==right.<span class="built_in">point</span>()&amp;&amp;left.<span class="built_in">suit</span>()==right.<span class="built_in">suit</span>());      <span class="comment">//花色和点数完成相等放回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> card.<span class="built_in">point</span>()*<span class="number">100</span>+card.<span class="built_in">suit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lessSort</span>(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-多张卡牌类Cards"><a href="#3-多张卡牌类Cards" class="headerlink" title="3. 多张卡牌类Cards"></a>3. 多张卡牌类Cards</h1><p>多张卡牌类Cards主要是在Card类的基础上，将对卡牌的一些功能操作进行完善和增添。</p><p>多张卡牌类Cards创建：通过选择新建、c++、c++class、类名为<code>Cards</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p><h2 id="3-1-Cards类的头文件"><a href="#3-1-Cards类的头文件" class="headerlink" title="3.1 Cards类的头文件"></a>3.1 Cards类的头文件</h2><p>该头文件主要定义了一个成员变量<code>m_cards</code>，它是存储多张卡牌的的一个容器对象，以及定义了一系列的成员函数，如对卡牌的添加、删除，和获得<code>m_cards</code>对象的属性，如几张卡牌，是否为空等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cards</span>                  <span class="comment">//多张卡牌类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">SortType</span>&#123;Asc,Desc,NoSort&#125;;          <span class="comment">//枚举类，卡牌排序类型</span></span><br><span class="line">    <span class="built_in">Cards</span>();</span><br><span class="line">    <span class="built_in">Cards</span>(<span class="type">const</span> Card&amp; card);       <span class="comment">//带参的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;                   <span class="comment">//添加单张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;                 <span class="comment">//添加多张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp; cards)</span></span>;        <span class="comment">//添加一个容器的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次性插入多个数据(操作符重载&lt;&lt;)</span></span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card);</span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp;cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cardCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">maxPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//最小点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">minPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//指定点数的牌的数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pointCount</span><span class="params">(Card::CardPoint point)</span></span>;</span><br><span class="line">    <span class="comment">//某张(些)牌是否在集合中(底层是通过是否存在子集来返回)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机取出一张扑克牌(发牌时会用)</span></span><br><span class="line">    <span class="function">Card <span class="title">takeRandomCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将QSet容器转为Qvector容器，实现排序功能</span></span><br><span class="line">    <span class="function">CardList <span class="title">toCardList</span><span class="params">(SortType type = Desc)</span></span>; <span class="comment">//CardList是在card.h里面定义的一种QVector&lt;Card&gt;的一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSet&lt;Card&gt; m_cards;     <span class="comment">//容器里存的是单张卡牌类对象(不重复、无序的)，不能进行排序，要排序就只能转QVector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-Cards类函数实现"><a href="#3-2-Cards类函数实现" class="headerlink" title="3.2 Cards类函数实现"></a>3.2 Cards类函数实现</h2><p>这部分就是对多张卡牌Cards类声明的函数进行实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">Cards::<span class="built_in">Cards</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Cards::<span class="built_in">Cards</span>(<span class="type">const</span> Card &amp;card)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">insert</span>(card);             <span class="comment">//添加单张卡牌就直接往容器m_cards插入即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">unite</span>(cards.m_cards);    <span class="comment">//添加多张卡牌就通过并联添加到容器m_cards里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">count</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写操作符</span></span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card)&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards)&#123;</span><br><span class="line">    <span class="built_in">add</span>(cards);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;            <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">remove</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(card);                 <span class="comment">//从容器中移出卡牌card</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">subtract</span>(cards.m_cards);      <span class="comment">//通过差集将容器m_cards移出多张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::cardCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断手牌是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">isEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除m_cards容器里的卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最大点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::maxPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint max = Card::Card_Begin;             <span class="comment">//Card_Begin对应的枚举类值为0</span></span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &gt; max)&#123;</span><br><span class="line">                max = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;       <span class="comment">//返回容器中最大点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最小点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::minPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint min = Card::Card_End;</span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &lt; min)&#123;</span><br><span class="line">                min = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;       <span class="comment">//返回容器中最小点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到点数为point的卡牌</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::pointCount</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;            <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() == point)&#123;</span><br><span class="line">            count++;          <span class="comment">//如果等于指定点数，数量就+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(card);            <span class="comment">//是否存在该张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(cards.m_cards);    <span class="comment">//是否存在该些卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌，后面发牌操作会用到</span></span><br><span class="line"><span class="function">Card <span class="title">Cards::takeRandomCard</span><span class="params">()</span>          <span class="comment">//随机取出一张卡牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成一个随机数</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(m_cards.<span class="built_in">size</span>());     <span class="comment">//返回一个0到(卡牌数-1)范围的数字，即0到51</span></span><br><span class="line">    QSet&lt;Card&gt;::const_iterator it = m_cards.<span class="built_in">constBegin</span>();              <span class="comment">//const_iterator是只读迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++,it++);</span><br><span class="line">    Card card = *it;         <span class="comment">//记录随机数对应的卡牌</span></span><br><span class="line">    m_cards.<span class="built_in">erase</span>(it);       <span class="comment">//从容器中移出该卡牌</span></span><br><span class="line">    <span class="keyword">return</span> card;             <span class="comment">//返回随机数对应的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对手牌进行升序还是降序</span></span><br><span class="line"><span class="function">CardList <span class="title">Cards::toCardList</span><span class="params">(Cards::SortType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        list &lt;&lt; *it;           <span class="comment">//每遍历一个元素，就将元素存入list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == Asc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),lessSort);            <span class="comment">//升序</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == Desc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),greaterSort);         <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-卡牌窗口类CardPanel"><a href="#4-卡牌窗口类CardPanel" class="headerlink" title="4. 卡牌窗口类CardPanel"></a>4. 卡牌窗口类CardPanel</h1><p>因为每张卡牌在主界面中都是以窗口的形式出现，所以该卡牌窗口类<code>CardPanel</code>相当于是对卡牌对象更充分的完善。</p><p>卡牌窗口类创建：通过选择新建、c++、c++class、类名为<code>CardPanel</code>，基类为QWidget。</p><h2 id="4-1-CardPanel类头文件"><a href="#4-1-CardPanel类头文件" class="headerlink" title="4.1 CardPanel类头文件"></a>4.1 CardPanel类头文件</h2><p>该头文件加载了每张卡牌的的图片，其定义了一系列的成员变量和成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CardPanel</span> : <span class="keyword">public</span> QWidget          <span class="comment">//卡牌窗口类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CardPanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置获取图片函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span>;      <span class="comment">//保存图片信息的，参数1是正面图片；参数2是背面图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">getImage</span><span class="params">()</span></span>;               <span class="comment">//获取正面图片信息(背面都是一样的)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌显示哪一面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFrontSide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录窗口是否被选中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSelected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function">Card <span class="title">getCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的所有者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOwner</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getOwner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;             <span class="comment">//事件处理函数，更新窗口信息的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;        <span class="comment">//重写鼠标按下事件</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;       <span class="comment">//用户玩家的鼠标选择信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_front;</span><br><span class="line">    QPixmap m_back;</span><br><span class="line">    <span class="type">bool</span> m_isfront=<span class="literal">true</span>;                <span class="comment">//是否是正面</span></span><br><span class="line">    <span class="type">bool</span> m_isSelect=<span class="literal">false</span>;              <span class="comment">//是否被选中</span></span><br><span class="line">    Card m_card;                        <span class="comment">//卡牌类对象</span></span><br><span class="line">    Player* m_owner=<span class="literal">nullptr</span>;            <span class="comment">//玩家类对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-CardPanel类函数实现"><a href="#4-2-CardPanel类函数实现" class="headerlink" title="4.2 CardPanel类函数实现"></a>4.2 CardPanel类函数实现</h2><p>这部分就是卡牌窗口类<code>CardPanel</code>里面声明的函数进行实现。可以通过该类成员获得卡牌窗口的一些属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">CardPanel::<span class="built_in">CardPanel</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)&#123;&#125;</span><br><span class="line"><span class="comment">//加载卡牌窗口图片</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_front = front;</span><br><span class="line">    m_back = back;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_front.<span class="built_in">size</span>());        <span class="comment">//设置当前的窗口大小为图片大小</span></span><br><span class="line">    <span class="built_in">update</span>();                           <span class="comment">//刷新窗口，调用的是paintEvent()函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌窗口的正面</span></span><br><span class="line"><span class="function">QPixmap <span class="title">CardPanel::getImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置是正面还是反面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isfront = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isFrontSide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isfront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isSelect = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isSelect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_card = card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Card <span class="title">CardPanel::getCard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setOwner</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_owner = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的所有者</span></span><br><span class="line"><span class="function">Player *<span class="title">CardPanel::getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_owner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(Qt::LeftButton)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口刷新函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::paintEvent</span><span class="params">(QPaintEvent *event)</span>     <span class="comment">//当setImage()函数把图片设置好后，就可以重新绘制窗口了，即调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);               <span class="comment">//处理event参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;             <span class="comment">//定义一个画家类</span></span><br><span class="line">    <span class="keyword">if</span>(m_isfront)&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_front);      <span class="comment">//如果是正面，就画正面，大小和当前窗口一样大rect()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_back);       <span class="comment">//如果是背面，就画背面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新写鼠标划过函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(event-&gt;button())</span></span>;             <span class="comment">//游戏的主窗口接收该信号(鼠标按键的选择)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-玩家类Player"><a href="#5-玩家类Player" class="headerlink" title="5. 玩家类Player"></a>5. 玩家类Player</h1><p>该类是作为游戏里的三个玩家的基类，即两个机器人玩家类和用户玩家类。作为基类，它定义了一些共同的属性，提示为后序的开发提供了一些辅助函数，方便得到需要的属性内容。</p><p>玩家类创建：通过选择新建、c++、c++class、类名为<code>Player</code>，基类为QObject。</p><h2 id="5-1-Player类头文件"><a href="#5-1-Player类头文件" class="headerlink" title="5.1 Player类头文件"></a>5.1 Player类头文件</h2><p>该头文件不仅定义了许多关于玩家的成员变量和成员函数，还定义了四个虚函数，通过多态的方式来实现不同机器人玩家的这个处理逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> QObject               <span class="comment">//玩家类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Role</span>&#123;Lord, Farmer&#125;;             <span class="comment">//角色</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Sex</span>&#123;Man, Woman&#125;;                <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;Left, Right&#125;;         <span class="comment">//头像的显示方位</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Robot, User, UnKnow&#125;;      <span class="comment">//玩家的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QString name, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(QString name)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function">Role <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSex</span><span class="params">(Sex sex)</span></span>;</span><br><span class="line">    <span class="function">Sex <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头像方位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirection</span><span class="params">(Direction direction)</span></span>;</span><br><span class="line">    <span class="function">Direction <span class="title">getDirection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setType</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getScore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//游戏结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供当前对象的上家/下家对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrevPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getPrevPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getNextPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//叫地主、抢地主(传出一个信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">grabLordBet</span><span class="params">(<span class="type">int</span> point)</span></span>;           <span class="comment">//传入的是分数(1，2，3，0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储扑克牌(发牌的时候得到的)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Cards&amp; cards)</span></span>;        <span class="comment">//抢地主得到的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到所有的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空玩家手中所有的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">(Cards&amp; cards)</span></span>;            <span class="comment">//出牌可以出一张也可以出多张</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取待出牌玩家对象以及这个玩家打出的牌(比如说当前玩家出牌后，要记录出牌的玩家和出的牌，下一个出牌玩家会用到)</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storePendingInfo</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚函数 通过多态来实现机器人玩家A和机器人玩家B(有相同的同名函数，但处理逻辑不一样，所以用多态实现)</span></span><br><span class="line">    <span class="comment">//下面4个虚函数在play只需要定义即可，功能实现交给子类，即机器人玩家和用户玩家</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span></span>;           <span class="comment">//准备叫地主(启动 考虑叫地主 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span></span>;           <span class="comment">//准备出牌(启动 考虑出牌 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span></span>;             <span class="comment">//考虑叫地主(计算权重)---&gt;机器人玩家类Robot会重写该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span></span>;             <span class="comment">//考虑出牌---&gt;计算机玩家类Robot会重写该函数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//通知已经叫地主下注</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;         <span class="comment">//参数：叫地主的玩家，下的分数</span></span><br><span class="line">    <span class="comment">//通知已经出牌(playHand()出牌函数会使用，当玩家出完牌后，需要发送的信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;        <span class="comment">//参数：出牌玩家，出的牌</span></span><br><span class="line">    <span class="comment">//向主窗口通知已经得到了卡牌(两种情况，普通得牌和得3张底牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPickCards</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                       <span class="comment">//子类也需要访问这些成员属性遍历，所以得是protected类型</span></span><br><span class="line">    QString m_name;              <span class="comment">//玩家姓名</span></span><br><span class="line">    Role m_role;                 <span class="comment">//玩家角色(枚举类)，地主还是农民</span></span><br><span class="line">    Sex m_sex;                   <span class="comment">//玩家性别(枚举类)，角色性别</span></span><br><span class="line">    Direction m_direction;       <span class="comment">//玩家的头像的显示方位(枚举类)，左或右</span></span><br><span class="line">    Type m_type;                 <span class="comment">//玩家的类型(枚举类)，机器人、用户或未知</span></span><br><span class="line">    <span class="type">int</span> m_score;                 <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="type">bool</span> m_isWin;                <span class="comment">//玩家是否获胜</span></span><br><span class="line"></span><br><span class="line">    Player* m_prev;            <span class="comment">//上家</span></span><br><span class="line">    Player* m_next;            <span class="comment">//下家</span></span><br><span class="line"></span><br><span class="line">    Cards m_cards;             <span class="comment">//存储多张扑克牌(玩家手中的牌)</span></span><br><span class="line"></span><br><span class="line">    Cards m_pendCards;                    <span class="comment">//打出的扑克牌</span></span><br><span class="line">    Player* m_pendPlayer = <span class="literal">nullptr</span>;         <span class="comment">//打出扑克牌的玩家(初始化先置为空)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-2-Player类函数实现"><a href="#5-2-Player类函数实现" class="headerlink" title="5.2 Player类函数实现"></a>5.2 Player类函数实现</h2><p>该玩家类Player实现了两种类的构造函数方法，同时实现了设置和获取玩家的相关属性。而虚函数在这里只需要定义出来即可，不需要实现，留给子类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">Player::<span class="built_in">Player</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)        <span class="comment">//玩家类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    m_score = <span class="number">0</span>;                  <span class="comment">//分数初始化为0</span></span><br><span class="line">    m_isWin = <span class="literal">false</span>;              <span class="comment">//初始化是否赢</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;       <span class="comment">//上次出牌玩家开始指向空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当用的是这个构造函数时，也会初始化父类的构造函数</span></span><br><span class="line">Player::<span class="built_in">Player</span>(QString name, QObject *parent) : <span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的名字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setName</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">Player::getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的角色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setRole</span><span class="params">(Role role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_role = role;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Role <span class="title">Player::getRole</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_role;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家性别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setSex</span><span class="params">(Player::Sex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Sex <span class="title">Player::getSex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的头像方位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setDirection</span><span class="params">(Player::Direction direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_direction = direction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Direction <span class="title">Player::getDirection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的类型(机器人玩家还是用户玩家)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setType</span><span class="params">(Player::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Type <span class="title">Player::getType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Player::getScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家身份获胜</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isWin = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Player::isWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isWin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家的上一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setPrevPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_prev = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置玩家的下一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setNextPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_next = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的上一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPrevPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的下一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getNextPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::grabLordBet</span><span class="params">(<span class="type">int</span> point)</span>      <span class="comment">//抢地主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(<span class="keyword">this</span>, point)</span></span>;  <span class="comment">//发出玩家叫地主的信号，游戏控制类接收该信号，参数：抢地主玩家，下的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入单张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(card);</span><br><span class="line">    Cards cs;</span><br><span class="line">    cs.<span class="built_in">add</span>(card);</span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>, cs)</span></span>;            <span class="comment">//向主窗口通知得到牌了(发牌阶段)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存入多张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(cards);           <span class="comment">//添加底牌</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>,cards)</span></span>;      <span class="comment">//向主窗口通知得到3张底牌了(在游戏控制类中becomelords()中,添加底牌会调用该函数)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::clearCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::playHand</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(cards);                 <span class="comment">//从玩家手中的牌移出要出的牌</span></span><br><span class="line">    <span class="comment">//发出信号，因为该信号可能是机器人玩家发出，也可能是用户玩家发出，所以就通过基类指针this指向子类对象</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(<span class="keyword">this</span>, cards)</span></span>;         <span class="comment">//该信号由游戏控制类接收处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得上一次的出牌玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得上一次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录上一次的出牌玩家和出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storePendingInfo</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pendPlayer = player;</span><br><span class="line">    m_pendCards = cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只定义出四个虚函数即可，留给子类实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::prepareCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::preparePlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkPlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-机器人玩家类Robot"><a href="#6-机器人玩家类Robot" class="headerlink" title="6. 机器人玩家类Robot"></a>6. 机器人玩家类Robot</h1><p>机器人玩家类Robot的基类是玩家类Player，它主要任务就是实现从父类继承下来的虚函数。</p><p>机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>Robot</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将基类改为Player类。</p><h2 id="6-1-Robot类头文件"><a href="#6-1-Robot类头文件" class="headerlink" title="6.1 Robot类头文件"></a>6.1 Robot类头文件</h2><p>机器人玩家类Robot只需要实现从父类继承来的虚函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span> : <span class="keyword">public</span> Player          <span class="comment">//机器人玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Robot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑出牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-2-Robot类函数实现"><a href="#6-2-Robot类函数实现" class="headerlink" title="6.2 Robot类函数实现"></a>6.2 Robot类函数实现</h2><p>这部分主要就是实现了准备叫地主、考虑叫地主、准备出牌和考虑出牌。</p><p>当是机器人玩家时，它会将从父类Player继承下来的虚函数进行重写。首先是在准备叫地主函数<code>prepareCallLord()</code>中，它会创建一个叫地主的子线程类<code>RobotGrapLord</code>(在后面)，然后执行<code>strat()</code>，它会启动子线程类里面的<code>run()</code>函数，而<code>run()</code>函数是睡眠了2s后，调用考虑叫地主函数<code>thinkCallLord()</code>。机器人玩家通过计算手牌的权重来得出是否叫地主的决定。对于准备和考虑出牌过程和这个一模一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Robot::<span class="built_in">Robot</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::Robot;         <span class="comment">//确定玩家类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::prepareCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotGrapLord* subThread = <span class="keyword">new</span> <span class="built_in">RobotGrapLord</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑叫地主的子线程类</span></span><br><span class="line">    <span class="comment">//当子线程里面内容都执行完了，会发出finished信号过后，就调用deleteLater()方法，释放掉该线程占用的内存</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotGrapLord 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();        <span class="comment">//启动考虑叫地主子线程类的run，run函数里面会调用thinkCallLord()来计算权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::preparePlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotPlayHand* subThread = <span class="keyword">new</span> <span class="built_in">RobotPlayHand</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑出牌的子线程类</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotPlayHand 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();             <span class="comment">//启动run函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑叫地主</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  机器人玩家基于手中的牌计算权重，根据权重来考虑是否叫地主</span></span><br><span class="line"><span class="comment">        大小王：6</span></span><br><span class="line"><span class="comment">        顺子/炸弹：5</span></span><br><span class="line"><span class="comment">        三张点数相同的牌：4</span></span><br><span class="line"><span class="comment">        2的权重：3</span></span><br><span class="line"><span class="comment">        对牌：1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;</span><br><span class="line">    weight += st.<span class="built_in">getRangeCards</span>(Card::Card_SJ,Card::Card_BJ).<span class="built_in">cardCount</span>()*<span class="number">6</span>;     <span class="comment">//得到手牌中大小王的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;optSeq = st.<span class="built_in">pickOptimalSeqSingles</span>();   <span class="comment">//pickOptimalSeqSingles函数内部还是再找顺子之前，已经剔除了炸弹、3带1和飞机类型牌</span></span><br><span class="line">    weight += optSeq.<span class="built_in">size</span>()*<span class="number">5</span>;                   <span class="comment">//得到手牌中的顺子的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;bombs = st.<span class="built_in">findCardsByCount</span>(<span class="number">4</span>);</span><br><span class="line">    weight += bombs.<span class="built_in">size</span>()*<span class="number">5</span>;                                 <span class="comment">//得到手牌中炸弹的权重</span></span><br><span class="line"></span><br><span class="line">    weight += m_cards.<span class="built_in">pointCount</span>(Card::Card_2) * <span class="number">3</span>;           <span class="comment">//得到2的权重</span></span><br><span class="line"></span><br><span class="line">    Cards tmp = m_cards;                            <span class="comment">//防止计算权重的牌重复，先复制手牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(optSeq);                             <span class="comment">//剔除顺子</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(bombs);                              <span class="comment">//剔除炸弹</span></span><br><span class="line">    Cards card2 = st.<span class="built_in">getRangeCards</span>(Card::Card_2,Card::Card_2);       <span class="comment">//先取出点数为2的牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(card2);                              <span class="comment">//剔除2</span></span><br><span class="line">    QVector&lt;Cards&gt;triples = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">3</span>);  <span class="comment">//在剔除相应牌型后，再继续找三张相同的牌</span></span><br><span class="line">    weight += triples.<span class="built_in">size</span>()*<span class="number">4</span>;                                      <span class="comment">//得到三张点数相同的牌的权重</span></span><br><span class="line"></span><br><span class="line">    tmp.<span class="built_in">remove</span>(triples);                           <span class="comment">//剔除三张相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;pairs = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">2</span>);   <span class="comment">//在tmp里找对牌</span></span><br><span class="line">    weight += pairs.<span class="built_in">size</span>()*<span class="number">1</span>;                                       <span class="comment">//得到对牌的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(weight &gt;= <span class="number">22</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">22</span> &amp;&amp; weight&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">18</span> &amp;&amp; weight&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;              <span class="comment">//先构造一个Strategy对象，这样就可以使用Strategy类里面的函数了</span></span><br><span class="line">    Cards cs = st.<span class="built_in">makeStrategy</span>();                  <span class="comment">//调用出牌策略函数，可以直接得到机器人玩家要出的牌</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;打出的牌数量：&quot;</span> &lt;&lt;cs.<span class="built_in">cardCount</span>();</span><br><span class="line">    <span class="built_in">playHand</span>(cs);                                  <span class="comment">//出牌，即从手牌中移除要出的牌cs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-用户玩家类UserPlayer"><a href="#7-用户玩家类UserPlayer" class="headerlink" title="7. 用户玩家类UserPlayer"></a>7. 用户玩家类UserPlayer</h1><p>用户玩家类UserPlayer只需要实现从基类Player继承下来的虚函数准备叫地主和准备出牌，且都不需要写太多程序操作，因为这些过程都是用户通过鼠标点击来完成的。</p><p>非机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>UserPlayer</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将其基类改为Player。</p><h2 id="7-1-UserPlayer类头文件"><a href="#7-1-UserPlayer类头文件" class="headerlink" title="7.1 UserPlayer类头文件"></a>7.1 UserPlayer类头文件</h2><p>该类只定义从基类继承下来的虚函数准备叫地主和准备出牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserPlayer</span> : <span class="keyword">public</span> Player              <span class="comment">//非机器人(用户)玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                   <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UserPlayer</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家准备出牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startCountDown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-2-UserPlayer类函数实现"><a href="#7-2-UserPlayer类函数实现" class="headerlink" title="7.2 UserPlayer类函数实现"></a>7.2 UserPlayer类函数实现</h2><p>该部分实现的两个虚函数都不需要做太多操作，因为是用户玩家，这些过程都是通过鼠标完成。但在准备出牌函数中，发出了一个信号<code>startCountDown</code>，表示从轮到用户玩家出牌开始就通知主窗口计时，当秒数从15变为0时，就默认用户玩家放弃出牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UserPlayer::<span class="built_in">UserPlayer</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::User;         <span class="comment">//确定玩家类型(用户)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::prepareCallLord</span><span class="params">()</span>               <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::preparePlayHand</span><span class="params">()</span>               <span class="comment">//用户玩家准备出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">startCountDown</span><span class="params">()</span></span>;                       <span class="comment">//发射一个信号，告知主窗口是用户玩家准备出牌，要开始倒计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-叫地主线程类RobotGrapLord"><a href="#8-叫地主线程类RobotGrapLord" class="headerlink" title="8. 叫地主线程类RobotGrapLord"></a>8. 叫地主线程类RobotGrapLord</h1><p>叫地主线程类<code>RobotGrapLord</code>是专为机器人玩家设计的类，就是负责模拟叫地主这一过程。</p><p>机器人玩家叫地主线程类创建：新建、c、c++、类名为<code>RobotGrapLord</code>，基类为QObject，创建好后修改基类为QThread。</p><h2 id="8-1-RobotGrapLord类头文件"><a href="#8-1-RobotGrapLord类头文件" class="headerlink" title="8.1 RobotGrapLord类头文件"></a>8.1 RobotGrapLord类头文件</h2><p>叫地主线程类RobotGrapLord就定义了一个从基类继承下来的run()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RobotGrapLord</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotGrapLord</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//重写QThread类里面的run方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;                <span class="comment">//执行机器人玩家叫地主</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-2-RobotGrapLor类函数实现"><a href="#8-2-RobotGrapLor类函数实现" class="headerlink" title="8.2 RobotGrapLor类函数实现"></a>8.2 RobotGrapLor类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑叫地主函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RobotGrapLord::<span class="built_in">RobotGrapLord</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player= player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过start()来调用run()函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotGrapLord::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);                      <span class="comment">//睡2秒，模拟机器人玩家一个思考的过程</span></span><br><span class="line">    m_player-&gt;<span class="built_in">thinkCallLord</span>();         <span class="comment">//直接调用Robot类写的考虑叫地主函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-出牌线程类RobotPlayHand"><a href="#9-出牌线程类RobotPlayHand" class="headerlink" title="9. 出牌线程类RobotPlayHand"></a>9. 出牌线程类RobotPlayHand</h1><p>出牌线程类<code>RobotPlayHand</code>是专为机器人玩家设计的类，就是负责模拟出牌这一过程。</p><p>机器人玩家出牌线程类创建：新建、c、c++、类名为<code>RobotPlayHand</code>，基类为QObject，创建好后修改基类为QThread。</p><h2 id="9-1-RobotPlayHand类头文件"><a href="#9-1-RobotPlayHand类头文件" class="headerlink" title="9.1 RobotPlayHand类头文件"></a>9.1 RobotPlayHand类头文件</h2><p>出牌线程类RobotPlayHand就定义了一个从基类继承下来的run()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机器人玩家出牌子线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotPlayHand</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotPlayHand</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;                   <span class="comment">//重写</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-2-RobotPlayHand类函数实现"><a href="#9-2-RobotPlayHand类函数实现" class="headerlink" title="9.2 RobotPlayHand类函数实现"></a>9.2 RobotPlayHand类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑出牌函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RobotPlayHand::<span class="built_in">RobotPlayHand</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player = player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotPlayHand::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);</span><br><span class="line">    m_player-&gt;<span class="built_in">thinkPlayHand</span>();        <span class="comment">//调用考虑出牌函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-玩家分数窗口类ScorePanel"><a href="#10-玩家分数窗口类ScorePanel" class="headerlink" title="10. 玩家分数窗口类ScorePanel"></a>10. 玩家分数窗口类ScorePanel</h1><p>分数窗口类ScorePanel就是负责显示各个玩家的分数，在该小项目中，有两处会使用该分数窗口。一个是主窗口的左上角会显示各个玩家的分数；还有一个是一局游戏结束后，在结束面板上显示各个玩家的分数。</p><h2 id="10-1-制作分数面板窗口"><a href="#10-1-制作分数面板窗口" class="headerlink" title="10.1 制作分数面板窗口"></a>10.1 制作分数面板窗口</h2><p>创建子窗口：</p><p>1.游戏分数面板子窗口：通过选择新建、Qt、Qt设计师界面类、选择Widget类型的窗口(可以内嵌的，以没有边框的形式完美的附着在父窗口上面)，类名为<code>ScorePanel</code>。</p><p>2.将分数窗口添加到主窗口(右上方)</p><p>在主窗口拖入一个Widget子窗口，因为它是一个Widget类型，而不是分数面板的类型，所以就需要进行提升，即就是把父类变为子类。基于这个理论，可以发现分数面板类ScorePanel的基类是Widget类型，所以就可以将该Widget类提升为ScorePanel类型。这样就将Qt中的标准控件变为了自定义控件(把一个基类变成了子类类型)。</p><h2 id="10-2-ScorePanel类头文件"><a href="#10-2-ScorePanel类头文件" class="headerlink" title="10.2 ScorePanel类头文件"></a>10.2 ScorePanel类头文件</h2><p>分数窗口类ScorePanel就定义了一些设置属性的函数，如字体的大小和颜色，这样后期要使用分数窗口的时候，也可以根据环境来设置适合的字体和颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FontColor</span>&#123;Black, White,Red,Blue,Green&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ScorePanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ScorePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置玩家的得分(将得分显示在窗口上)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span>;     <span class="comment">//参数是三个玩家的得分</span></span><br><span class="line">    <span class="comment">//设置字体大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span>;</span><br><span class="line">    <span class="comment">//设置字体的颜色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontColor</span><span class="params">(FontColor color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ScorePanel *ui;</span><br><span class="line">    QVector&lt;QLabel*&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-ScorePanel类函数实现"><a href="#10-3-ScorePanel类函数实现" class="headerlink" title="10.3 ScorePanel类函数实现"></a>10.3 ScorePanel类函数实现</h2><p>该部分就是实现了头文件定义的成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QString MYCOLOR[] = &#123;<span class="string">&quot;black&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line">ScorePanel::<span class="built_in">ScorePanel</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ScorePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将拖到ui上的标签都存入到m_list容器中</span></span><br><span class="line">    m_list &lt;&lt; ui-&gt;meScore &lt;&lt; ui-&gt;leftScore &lt;&lt; ui-&gt;rightScore</span><br><span class="line">           &lt;&lt; ui-&gt;meTitle &lt;&lt; ui-&gt;leftTitle &lt;&lt; ui-&gt;rightTitle</span><br><span class="line">           &lt;&lt; ui-&gt;score1 &lt;&lt; ui-&gt;score2 &lt;&lt; ui-&gt;score3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScorePanel::~<span class="built_in">ScorePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置3个玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要将整形数据转换为字符串类型数据</span></span><br><span class="line">    ui-&gt;leftScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(left));</span><br><span class="line">    ui-&gt;rightScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(right));</span><br><span class="line">    ui-&gt;meScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(user));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置字体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;微软雅黑&quot;</span>, point, QFont::Bold)</span></span>;               <span class="comment">//定义一个字体对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;                     <span class="comment">//遍历分数面板的所有按钮，都设置为该字体</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontColor</span><span class="params">(ScorePanel::FontColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString style = <span class="built_in">QString</span>(<span class="string">&quot;QLabel&#123;color:%1&#125;&quot;</span>).<span class="built_in">arg</span>(MYCOLOR[color]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;              <span class="comment">//遍历分数面板的所有按钮，都设置为该颜色</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-自定义按钮类MyButton"><a href="#11-自定义按钮类MyButton" class="headerlink" title="11. 自定义按钮类MyButton"></a>11. 自定义按钮类MyButton</h1><p>自定义按钮类MyButton主要就是对按钮进行美化，当鼠标经过按钮、按下按钮都加载显示不同的图片，起到一个有点击的效果。</p><h2 id="11-1-自定义按钮类"><a href="#11-1-自定义按钮类" class="headerlink" title="11.1 自定义按钮类"></a>11.1 自定义按钮类</h2><p>创建自定义按钮类：</p><p>通过选择新建、c++、c++class、类名为<code>MyButton</code>，基类设为QWidget。但创建好后，就将MyButton的基类QWidget修改为QPushButton。</p><p>不用带ui，该类只对按钮做美化，按钮上要放什么东西，不在考虑内。从QpushButton派生，然后基于QpushButton在按钮上做美化。</p><h2 id="11-2-MyButton类头文件"><a href="#11-2-MyButton类头文件" class="headerlink" title="11.2 MyButton类头文件"></a>11.2 MyButton类头文件</h2><p>自定义按钮类<code>MyButton</code>主要就是将从基类继承下来的函数进行定义，如鼠标按下、鼠标释放、鼠标进入和鼠标离开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//鼠标按下</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标进入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标离开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//绘图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    </span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//成员变量，对应三张图片的路径</span></span><br><span class="line">    QString m_normal;            <span class="comment">//定义的是正常情况下的图片路径</span></span><br><span class="line">    QString m_hover;             <span class="comment">//定义的是鼠标滑过按钮的图片路径</span></span><br><span class="line">    QString m_pressed;           <span class="comment">//定义的是鼠标按下按钮的图片路径</span></span><br><span class="line"></span><br><span class="line">    QPixmap m_pixmap;           <span class="comment">//得到的路径需要转为QPixmap对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-3-MyButton类函数实现"><a href="#11-3-MyButton类函数实现" class="headerlink" title="11.3 MyButton类函数实现"></a>11.3 MyButton类函数实现</h2><p>这部分就是对自定义按钮类MyButton的头文件定义的函数进行实现，不同情况，加载不同图片，也显示不同图片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MyButton::<span class="built_in">MyButton</span>(QWidget *parent) : <span class="built_in">QPushButton</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_normal = normal;</span><br><span class="line">    m_hover = hover;</span><br><span class="line">    m_pressed = pressed;</span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);           <span class="comment">//默认情况下，就加载m_normal图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span>               <span class="comment">//鼠标按下</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标按下的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_pressed);                             <span class="comment">//加载m_pressed图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mousePressEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span>             <span class="comment">//鼠标释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标释放的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_normal);                              <span class="comment">//加载m_normal图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mouseReleaseEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::enterEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标进入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_hover);                                     <span class="comment">//鼠标经过按钮，加载hover图片</span></span><br><span class="line">    <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::leaveEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标离开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);                                     <span class="comment">//鼠标经过按钮，加载normal图片</span></span><br><span class="line">    <span class="built_in">update</span>();                       <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::paintEvent</span><span class="params">(QPaintEvent *ev)</span>   <span class="comment">//绘图,当窗口刷新的时候被调用重绘，而产生鼠标事件是不会调用该对象的，所以需要手动强制重绘update()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="comment">//对应的事件产生之后，就需要将相关的图片挂到当前的按钮对象上</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;                        <span class="comment">//创建一个画家类，参数是指定绘图设备(当前按钮对象)</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_pixmap);          <span class="comment">//将对应图片完整画到当前对象上。参数：当前按钮所对应的矩形区域、指定m_pixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-按钮组窗口类ButtonGroup"><a href="#12-按钮组窗口类ButtonGroup" class="headerlink" title="12. 按钮组窗口类ButtonGroup"></a>12. 按钮组窗口类ButtonGroup</h1><p>按钮组窗口类主要是为用户玩家服务的，因为开始游戏界面、抢地主界面、必须出牌界面和可放弃出牌界面都需要显示出不同的按钮，所以得在ui中使用Stacked Widget栈窗口，它可以容纳多张不同的窗口，然后通过函数调用切换即可。</p><h2 id="12-1-创建按钮组窗口"><a href="#12-1-创建按钮组窗口" class="headerlink" title="12.1 创建按钮组窗口"></a>12.1 创建按钮组窗口</h2><p>1.窗口创建：</p><p>选择新建、Qt、Qt设计师界面类(是带ui界面的)、选择Widget类型的窗口，类名为<code>ButtonGroup</code>。</p><p>该类是在ui界面上拖入了一个Stacked Widget栈窗口，在该栈窗口中建了5个页面。第1个页面是开始页面；第2个页面是必须出牌页面；第3个为可放弃出牌页面；第4个为叫地主页面；第5个是空白页面。并利用信号槽机制实现了connect操作，即按下按钮，就会触发响应的按钮信号，然后发送自定义信号。该类只负责发送信号即可，不用处理相关的操作。</p><p>2.对每个页面的按钮做美化</p><p>将Stacked Widget栈窗口中的5个窗口的按钮都提升为<code>MyButton</code>类。然后基于<code>MyButton</code>类对窗口所有按钮进行美化。</p><p>3.添加资源文件：选择新建、Qt、Qt Resource File、名称为res。</p><p>4.将按钮组窗口添加到主窗口(中下方)</p><p>在主窗口的下方拖入一个Widget窗口，将其提升为ButtonGroup类。因为主窗口最下方放的是扑克牌，所以得在最下面放一根弹簧将ButtonGroup窗口撑起来一点。然后在主窗口析构函数中，初始化按钮组，并设定刚开的页面为游戏开始页面的按钮组即可。</p><h2 id="12-2-ButtonGroup类头文件"><a href="#12-2-ButtonGroup类头文件" class="headerlink" title="12.2 ButtonGroup类头文件"></a>12.2 ButtonGroup类头文件</h2><p>按钮组窗口类ButtonGroup就是定义了一个Page页的切换函数，通过传入的参数配置页枚举类的不同，会发出信号通知主窗口该显示哪个按钮组窗口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Panel</span>&#123;Start, PlayCard, PassOrPlay,CallLord,Empty&#125;;         <span class="comment">//配置页枚举类</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ButtonGroup</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ButtonGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化按钮</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtons</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Page页的切换(因为第2个参数是只有抢地主页面按钮组时才会用到，其它按钮组页面窗口用不到，所以设置默认参数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectPanel</span><span class="params">(Panel type, <span class="type">int</span> bet = <span class="number">0</span>)</span></span>; <span class="comment">//传入的参数是配置页的枚举类，即窗口,当是叫地主窗口时，要目前下注最高分数(用户玩家需要知道)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//不出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抢地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">betPoint</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ButtonGroup *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-3-ButtonGroup类函数实现"><a href="#12-3-ButtonGroup类函数实现" class="headerlink" title="12.3 ButtonGroup类函数实现"></a>12.3 ButtonGroup类函数实现</h2><p>这部分代码实现了头文件定义的函数，对每个按钮都加载了三种图片，即常规状态下、鼠标滑过状态下和点击按钮状态下。同时也通过信号槽机制，对每个按钮按下后，都会发出信号，触发对应的槽函数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">ButtonGroup::<span class="built_in">ButtonGroup</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ButtonGroup)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ButtonGroup::~<span class="built_in">ButtonGroup</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有按钮的图片初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::initButtons</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    ui-&gt;start-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/start-1.png&quot;</span>, <span class="string">&quot;:/images/start-3.png&quot;</span>, <span class="string">&quot;:/images/start-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    ui-&gt;playCard-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;playCard1-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不要</span></span><br><span class="line">    ui-&gt;pass-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/pass_btn-1.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-3.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不抢</span></span><br><span class="line">    ui-&gt;giveup-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/buqiang-1.png&quot;</span>, <span class="string">&quot;:/images/buqiang-3.png&quot;</span>, <span class="string">&quot;:/images/buqiang-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//1，2，3分</span></span><br><span class="line">    ui-&gt;oneScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/1fen-1.png&quot;</span>, <span class="string">&quot;:/images/1fen-3.png&quot;</span>, <span class="string">&quot;:/images/1fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;twoScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/2fen-1.png&quot;</span>, <span class="string">&quot;:/images/2fen-3.png&quot;</span>, <span class="string">&quot;:/images/2fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;threeScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/3fen-1.png&quot;</span>, <span class="string">&quot;:/images/3fen-3.png&quot;</span>, <span class="string">&quot;:/images/3fen-2.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置按钮的大小</span></span><br><span class="line">    QVector&lt;MyButton*&gt;btns;</span><br><span class="line">    btns &lt;&lt; ui-&gt;start &lt;&lt; ui-&gt;playCard &lt;&lt; ui-&gt;playCard1 &lt;&lt; ui-&gt;pass &lt;&lt; ui-&gt;giveup &lt;&lt; ui-&gt;oneScore &lt;&lt; ui-&gt;twoScore &lt;&lt; ui-&gt;threeScore;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;btns.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        btns[i]-&gt;<span class="built_in">setFixedSize</span>(<span class="number">90</span>,<span class="number">45</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击不同按钮，发出信号后，处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::startGame);     <span class="comment">//按下开始按钮(初始界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);   <span class="comment">//按下出牌按钮(必须出牌界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard1, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);  <span class="comment">//按下出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pass, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::pass);      <span class="comment">//按下放弃出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;giveup, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                  <span class="comment">//按下不抢地主按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">0</span>);       <span class="comment">//当点击的是放弃抢地主，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;oneScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注1分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">1</span>);       <span class="comment">//当点击1分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;twoScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注2分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">2</span>);       <span class="comment">//当点击2分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;threeScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//按下下注3分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">3</span>);       <span class="comment">//当点击3分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示对应的按钮组窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::selectPanel</span><span class="params">(ButtonGroup::Panel type, <span class="type">int</span> bet)</span>   <span class="comment">//传入的是页数,分数(用户玩家才会调用该函数，要知道目前下注的最高分)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(type);           <span class="comment">//设置当前要找展示的按钮页面窗口</span></span><br><span class="line">    <span class="keyword">if</span>(type != CallLord)&#123;             <span class="comment">//如果不是叫地主状态，就直接返回(说明用户玩家不叫地主)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是用户玩家是叫地主状态</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;            <span class="comment">//如果目前最高分是0，说明还可以显示1，2，3分三个按钮</span></span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//2分按钮隐藏</span></span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-游戏控制类GameControl"><a href="#13-游戏控制类GameControl" class="headerlink" title="13. 游戏控制类GameControl"></a>13. 游戏控制类GameControl</h1><p>游戏控制类负责对游戏整个过程进行一个管理和控制，像游戏状态、玩家状态等都想要通过该类来进行一个维护。同时该类也会和主窗口类直接连接，在游戏控制过程中，每个玩家的变化、游戏的变化都需要通过信号的方式通知主窗口。</p><p>游戏控制类添加：通过选择新建、c++、c++class、类名为<code>GameControl</code>，基类为QObject。</p><h2 id="13-1-GameControl类头文件"><a href="#13-1-GameControl类头文件" class="headerlink" title="13.1 GameControl类头文件"></a>13.1 GameControl类头文件</h2><p>游戏控制类<code>GameControl</code>定义了枚举类游戏状态和玩家状态，当它们发送变化时，都会通过信号发送出去。同时，该头文件还定义了许多游戏过程函数，如发牌、叫地主、出牌等。而且有些后面开发会用到的信息都会记录保存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BetRecord</span>&#123;     <span class="comment">//存放三个玩家叫地主情况的结构体(因为c++的结构体类似于类，所以可以有构造函数)</span></span><br><span class="line">    <span class="built_in">BetRecord</span>()&#123;      <span class="comment">//当创建BetRecord时，就自动清空，初始化了</span></span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player = <span class="literal">nullptr</span>;</span><br><span class="line">        bet = <span class="number">0</span>;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Player* player;</span><br><span class="line">    <span class="type">int</span> bet;</span><br><span class="line">    <span class="type">int</span> times;       <span class="comment">//第几次叫地主</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//游戏状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">GameStatus</span>&#123;</span><br><span class="line">        DispatchCard,                 <span class="comment">//发牌状态</span></span><br><span class="line">        CallingLord,                  <span class="comment">//叫地主状态</span></span><br><span class="line">        PlayingHand                   <span class="comment">//出牌状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//玩家状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PlayerStatus</span>&#123;</span><br><span class="line">        ThinkingForCallLord,          <span class="comment">//考虑叫地主</span></span><br><span class="line">        ThinkingForPlayHand,          <span class="comment">//考虑出牌</span></span><br><span class="line">        Winning                       <span class="comment">//玩家赢了</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化玩家,将三个对象创建出来</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到玩家的实例化对象</span></span><br><span class="line">    <span class="function">Robot* <span class="title">getLeftRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Robot* <span class="title">getRightRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UserPlayer* <span class="title">getUserPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和获取当前玩家</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentPlayer</span><span class="params">(Player* player)</span></span>;         <span class="comment">//参数是玩家类型，由于不知道具体玩家类型，传它们的父类</span></span><br><span class="line">    <span class="function">Player *<span class="title">getCurrentPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到出牌玩家和打出的牌</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化扑克牌(所有)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initAllCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//每次发一张牌</span></span><br><span class="line">    <span class="function">Card <span class="title">takeOneCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到最后的三张底牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getSurplusCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//重置卡牌数据(当完成一局游戏就会清空玩家手中的扑克牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetCardData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startLordCard</span><span class="params">()</span></span>;       <span class="comment">//该函数会发出信号，主窗口接收</span></span><br><span class="line">    <span class="comment">//成为地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">becomeLord</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//清空所有玩家的得分</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearPlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到玩家下注的最高得分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPlayerMaxBet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理叫地主(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;        <span class="comment">//参数：具体是哪个玩家，玩家叫地主时下的分数</span></span><br><span class="line">    <span class="comment">//处理出牌(槽函数) ---&gt;当玩家调用了playhand()出牌函数后，会发出出牌信号，由该槽函数接收处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;    <span class="comment">//参数：出牌的玩家，出的牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//向主窗口通知 玩家的状态变化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerStatusChanged</span><span class="params">(Player* player, PlayerStatus status)</span></span>;     <span class="comment">//告诉主窗口是哪个玩家，当前玩家是什么状态(考虑叫地主，考虑出牌，玩家赢了)</span></span><br><span class="line">    <span class="comment">//向主窗口通知是哪个玩家抢了地主以及下注分数(然后轮到其它玩家抢地主下分)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="comment">//游戏状态变化的信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusChanged</span><span class="params">(GameStatus status)</span></span>;         <span class="comment">//参数是游戏的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向主窗口通知玩家出牌了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;       <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line">    <span class="comment">//给玩家传递出牌数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pendingInfo</span><span class="params">(Player* player, Cards&amp; card)</span></span>;          <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Robot* m_robotLeft=<span class="literal">nullptr</span>;</span><br><span class="line">    Robot* m_robotRight=<span class="literal">nullptr</span>;</span><br><span class="line">    UserPlayer* m_user=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Player* m_currPlayer=<span class="literal">nullptr</span>;           <span class="comment">//保存当前玩家对象的指针(实时变化的)</span></span><br><span class="line"></span><br><span class="line">    Player* m_pendPlayer=<span class="literal">nullptr</span>;           <span class="comment">//出牌的玩家</span></span><br><span class="line">    Cards m_pendCards;              <span class="comment">//出牌玩家打出的牌</span></span><br><span class="line"></span><br><span class="line">    Cards m_allCards;               <span class="comment">//一副扑克牌</span></span><br><span class="line"></span><br><span class="line">    BetRecord m_betRecord;          <span class="comment">//存放三个玩家叫地主的情况结构体对象</span></span><br><span class="line">    <span class="type">int</span> m_curBet = <span class="number">0</span>;               <span class="comment">//记录下注底分，方便后期计算</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-2-GameControl类函数实现"><a href="#13-2-GameControl类函数实现" class="headerlink" title="13.2 GameControl类函数实现"></a>13.2 GameControl类函数实现</h2><p>这部分实现了头文件定义的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">GameControl::<span class="built_in">GameControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::playerInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.对象实例化,通过构造函数指定名字，并给该对象指定一个父对象(当释放GameControl时，会自动释放该对象)</span></span><br><span class="line">    m_robotLeft = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人A&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    m_robotRight = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人B&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    m_user = <span class="keyword">new</span> <span class="built_in">UserPlayer</span>(<span class="string">&quot;我自己&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.给各对象设置属性信息</span></span><br><span class="line">    <span class="comment">//头像的显示</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setDirection</span>(Player::Left);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    m_user-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    Player::Sex sex;</span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setSex</span>(sex);                                     <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setSex</span>(sex);                                    <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setSex</span>(sex);                                          <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    <span class="comment">//玩家出牌顺序</span></span><br><span class="line">    <span class="comment">// user</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setPrevPlayer</span>(m_robotLeft);</span><br><span class="line">    m_user-&gt;<span class="built_in">setNextPlayer</span>(m_robotRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left robot</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setPrevPlayer</span>(m_robotRight);</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setNextPlayer</span>(m_user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right robot</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setPrevPlayer</span>(m_user);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setNextPlayer</span>(m_robotLeft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定当前玩家为用户(优先叫地主的权力)</span></span><br><span class="line">    m_currPlayer = m_user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家发射出的抢地主信号(几分)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递出牌玩家对象和玩家打出的牌给其它玩家</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotLeft, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotRight, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_user, &amp;Robot::storePendingInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家出牌</span></span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到左手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getLeftRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotLeft;        <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到右手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getRightRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotRight;      <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到用户玩家对象</span></span><br><span class="line"><span class="function">UserPlayer *<span class="title">GameControl::getUserPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_user;            <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置和获取当前出牌玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::setCurrentPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getCurrentPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_currPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出牌的玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化所有的牌(发牌会用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::initAllCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_allCards.<span class="built_in">clear</span>();             <span class="comment">//先对一副扑克牌做清空操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=Card::Card_Begin+<span class="number">1</span>; p&lt;Card::Card_SJ; p++)&#123;           <span class="comment">//遍历点数，枚举类型不能做算术运算，所以定义p只能是int,不能是Card::CardPoint</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=Card::Suit_Begin+<span class="number">1</span>; s&lt;Card::Suit_End; s++)&#123;      <span class="comment">//遍历花色</span></span><br><span class="line">            <span class="function">Card <span class="title">c</span><span class="params">((Card::CardPoint)p, (Card::CardSuit)s)</span></span>;         <span class="comment">//再将int类型强制转换为枚举类型</span></span><br><span class="line">            m_allCards.<span class="built_in">add</span>(c);         <span class="comment">//创建完一张扑克牌，就插入到m_allCards中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_SJ, Card::Suit_Begin));              <span class="comment">//插入小王</span></span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_BJ, Card::Suit_Begin));              <span class="comment">//插入大王</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌(发牌)</span></span><br><span class="line"><span class="function">Card <span class="title">GameControl::takeOneCard</span><span class="params">()</span>                <span class="comment">//一次发一张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards.<span class="built_in">takeRandomCard</span>();          <span class="comment">//调用Cards类里面定义的函数，随机返回一张扑克牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地主得到3张底牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getSurplusCards</span><span class="params">()</span>           <span class="comment">//获取底牌函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards;                         <span class="comment">//当发完后，做后留下的三张牌就作为底牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发牌前的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::resetCardData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//洗牌</span></span><br><span class="line">    <span class="built_in">initAllCards</span>();</span><br><span class="line">    <span class="comment">//清空所有玩家的牌(就是将玩家对象里的Cards容器清空)</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_user-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    <span class="comment">//初始化出牌玩家和牌(新一局开始之前，是没有出牌玩家的)</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;           <span class="comment">//出牌对象也先默认为空</span></span><br><span class="line">    m_pendCards.<span class="built_in">clear</span>();              <span class="comment">//打出的牌也是空的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::startLordCard</span><span class="params">()</span>        <span class="comment">//准备叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用叫地主函数</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();         <span class="comment">//m_currPlayer可能是用户玩家，也可能是机器人玩家(多态实现)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, ThinkingForCallLord)</span></span>;      <span class="comment">//发出信号，参数：当前玩家，当前玩家状态(准备叫地主)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::becomeLord</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>  <span class="comment">//成为地主，参数传进来的是地主角色，其它两个角色就是农民了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_curBet = bet;             <span class="comment">//保存下注的底分，出牌(炸弹)和打完牌后计算需要用到</span></span><br><span class="line">    player-&gt;<span class="built_in">setRole</span>(Player::Lord);</span><br><span class="line">    player-&gt;<span class="built_in">getPrevPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的上一家是农民</span></span><br><span class="line">    player-&gt;<span class="built_in">getNextPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的下一家是农民</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成为地主的是要先出牌，所以他是当前玩家</span></span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">    player-&gt;<span class="built_in">storeDispatchCard</span>(m_allCards);     <span class="comment">//给该玩家的手牌添加三张底牌(m_allCards是发完牌后，剩下三张)</span></span><br><span class="line"></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">1000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">gameStatusChanged</span>(PlayingHand);                       <span class="comment">//发送游戏的状态信号(出牌状态)</span></span><br><span class="line">        emit <span class="built_in">playerStatusChanged</span>(player, ThinkingForPlayHand);     <span class="comment">//玩家状态(考虑出牌)</span></span><br><span class="line">        <span class="comment">//调用准备出牌函数</span></span><br><span class="line">        m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::clearPlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_user-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GameControl::getPlayerMaxBet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_betRecord.bet;        <span class="comment">//结构体里面存的就是最高分(因为高分信息会覆盖低分信息)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onGrabBet</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>     <span class="comment">//处理叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 通知主界面，该玩家叫地主了(主界面就要更新信息提示)</span></span><br><span class="line">    <span class="keyword">if</span>(bet==<span class="number">0</span> || m_betRecord.bet&gt;=bet)&#123;           <span class="comment">//这种情况说明该玩家放弃抢地主</span></span><br><span class="line">        <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(player, <span class="number">0</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet&gt;<span class="number">0</span> &amp;&amp; m_betRecord.bet==<span class="number">0</span>)&#123; <span class="comment">//如果当前玩家下注的分数大于0，且之前结构体存的是0分(说明之前玩家没有抢地主或现在是第一次下注)</span></span><br><span class="line">        <span class="comment">//第1个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">true</span>);      <span class="comment">//如果是第一个抢地主的玩家，参数3置为true(主窗口需要知道第一个抢地主的玩家)</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//第2或3个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断玩家下注是不是3分，如果是就抢地主成功(抢地主就结束了)</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//该玩家成为地主</span></span><br><span class="line">        <span class="built_in">becomeLord</span>(player,bet);            <span class="comment">//调用成为地主的函数</span></span><br><span class="line">        <span class="comment">//清空抢地主结构体数据</span></span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span>;            <span class="comment">//直接退出了。当某个玩家给出3分时，那么该玩家就是地主了，不用再执行下面内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.下注不够3分，对玩家的分数进行比较，分数高的是地主(低的被覆盖)</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.bet &lt; bet)&#123;  <span class="comment">//m_betRecord结构体是玩家抢地主，就存其信息，当下一个玩家也抢地主，如果分数比之前的高，m_betRecord就进行更新</span></span><br><span class="line">        m_betRecord.bet = bet;             <span class="comment">//重新存储分数</span></span><br><span class="line">        m_betRecord.player = player;       <span class="comment">//重新存储地主玩家</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_betRecord.times++;                   <span class="comment">//下注抢地主的次数++</span></span><br><span class="line">    <span class="comment">//如果每个玩家都抢过一次地主，抢地主结束</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.times == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_betRecord.bet == <span class="number">0</span>)&#123;        <span class="comment">//如果分数还是为0，说明没有玩家叫地主</span></span><br><span class="line">            <span class="function">emit <span class="title">gameStatusChanged</span><span class="params">(DispatchCard)</span></span>;        <span class="comment">//通知此时需要改变为发牌状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;     <span class="comment">//如果不为0，说明有玩家会成为地主</span></span><br><span class="line">            <span class="built_in">becomeLord</span>(m_betRecord.player, m_betRecord.bet);              <span class="comment">//成为地主的玩家是结构体中保存的玩家对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();          <span class="comment">//结构体重置，为下一节游戏清空结构体(因为到了下一句游戏，不会重新创建，还是用这个创建好的结构体)</span></span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">//直接返回，就不用执行下面玩家切换了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.切换玩家，通知下一个玩家继续抢地主</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();      <span class="comment">//改变当前玩家</span></span><br><span class="line">    <span class="comment">//发送信号给主界面，告知当前状态还是为抢地主状态</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer,ThinkingForCallLord)</span></span>;</span><br><span class="line">    <span class="comment">//每个玩家都有一个prepareCallLord()函数，即考虑叫地主，如果是机器人玩家，有专门的线程来处理该操作，如果是用户玩家，该函数就是空的(只需要点击按钮完成操作)</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();      <span class="comment">//告诉新的当前玩家继续抢地主</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onPlayHand</span><span class="params">(Player *player, Cards &amp;card)</span>    <span class="comment">//处理出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 将玩家出牌信号转给主界面(主界面更新出出牌窗口内容)</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(player, card)</span></span>;</span><br><span class="line">    <span class="comment">//2. 如果不是空牌，给其它玩家发送信号，保存出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!card.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_pendCards = card;</span><br><span class="line">        m_pendPlayer = player;</span><br><span class="line">        <span class="function">emit <span class="title">pendingInfo</span><span class="params">(player, card)</span></span>;       <span class="comment">//发出信号给玩家，参数是打出牌的当前玩家和打出的牌(其它玩家需要根据出的牌和玩家，做相应的处理)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有炸弹，底分翻倍</span></span><br><span class="line">    PlayHand::HandType type = <span class="built_in">PlayHand</span>(card).<span class="built_in">getHandType</span>();      <span class="comment">//传入当前玩家出的牌，得到出牌类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Bomb || type == PlayHand::Hand_Bomb_Jokers)&#123;      <span class="comment">//如果出的牌是炸弹和王炸</span></span><br><span class="line">        m_curBet = m_curBet*<span class="number">2</span>;                     <span class="comment">//将底分*2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 如果玩家的牌都出完了，计算本局游戏的总分</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Player* prev = player-&gt;<span class="built_in">getPrevPlayer</span>();                  <span class="comment">//获取当前玩家的上一个玩家</span></span><br><span class="line">        Player* next = player-&gt;<span class="built_in">getNextPlayer</span>();                  <span class="comment">//获取当前玩家的下一个玩家</span></span><br><span class="line">        <span class="keyword">if</span>(player-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;                   <span class="comment">//如果当前玩家为地主</span></span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + <span class="number">2</span>*m_curBet);       <span class="comment">//当前玩家加分(原来得分+当前得分)</span></span><br><span class="line">            prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;             <span class="comment">//当前玩家为农民</span></span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;             <span class="comment">//如果当前玩家的上一个玩家是地主</span></span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                           <span class="comment">//如果当前玩家的上一个玩家是农民</span></span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(player, GameControl::Winning)</span></span>;          <span class="comment">//向主窗口通知 当前玩家的状态变化(赢了)</span></span><br><span class="line">        <span class="keyword">return</span>;         <span class="comment">//赢了就退出了，不然还会执行下面程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 如果牌没有出完，下一个玩家继续出牌</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();                <span class="comment">//将下一个玩家更新为当前玩家</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();         <span class="comment">//更新的当前玩家准备出牌(该函数是一个多态实现，不同类型玩家调用会执行不同的处理)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, GameControl::ThinkingForPlayHand)</span></span>;    <span class="comment">//向主窗口通知 更新的当前玩家的状态变化(考虑出牌)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-出牌类PlayHand"><a href="#14-出牌类PlayHand" class="headerlink" title="14. 出牌类PlayHand"></a>14. 出牌类PlayHand</h1><p>该类主要是对一些牌进行分类和识别，得出调用者传入牌的一个牌型。</p><p>出牌类(策略)：新建、c、c++、类名为PlayHand，基类为Custom。</p><h2 id="14-1-PlayHand类头文件"><a href="#14-1-PlayHand类头文件" class="headerlink" title="14.1 PlayHand类头文件"></a>14.1 PlayHand类头文件</h2><p>出牌类PlayeHand定义了一个牌的类型枚举类，它里面都是斗地主小游戏里面所有的牌型。然后定义了对牌的分类函数和识别函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayHand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 出牌组合或者方式</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">HandType</span></span><br><span class="line">        &#123;</span><br><span class="line">            Hand_Unknown,               <span class="comment">// 未知</span></span><br><span class="line">            Hand_Pass,                  <span class="comment">// 过</span></span><br><span class="line">            Hand_Single,                <span class="comment">// 单</span></span><br><span class="line">            Hand_Pair,                  <span class="comment">// 对</span></span><br><span class="line">            Hand_Triple,                <span class="comment">// 三个</span></span><br><span class="line">            Hand_Triple_Single,         <span class="comment">// 三带一</span></span><br><span class="line">            Hand_Triple_Pair,           <span class="comment">// 三带二</span></span><br><span class="line">            Hand_Plane,                 <span class="comment">// 飞机，555_666</span></span><br><span class="line">            Hand_Plane_Two_Single,      <span class="comment">// 飞机带单，555_666_3_4</span></span><br><span class="line">            Hand_Plane_Two_Pair,        <span class="comment">// 飞机带双，555_666_33_44</span></span><br><span class="line">            Hand_Seq_Pair,              <span class="comment">// 连对，33_44_55(_66...)</span></span><br><span class="line">            Hand_Seq_Single,            <span class="comment">// 顺子，34567(8...)</span></span><br><span class="line">            Hand_Bomb,                  <span class="comment">// 炸弹</span></span><br><span class="line">            Hand_Bomb_Single,           <span class="comment">// 炸弹带一个</span></span><br><span class="line">            Hand_Bomb_Pair,             <span class="comment">// 炸弹带一对</span></span><br><span class="line">            Hand_Bomb_Two_Single,       <span class="comment">// 炸弹带两单</span></span><br><span class="line">            Hand_Bomb_Jokers,           <span class="comment">// 王炸</span></span><br><span class="line">            Hand_Bomb_Jokers_Single,    <span class="comment">// 王炸带一个</span></span><br><span class="line">            Hand_Bomb_Jokers_Pair,      <span class="comment">// 王炸带一对</span></span><br><span class="line">            Hand_Bomb_Jokers_Two_Single<span class="comment">// 王炸带两单</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PlayHand</span>();</span><br><span class="line">        <span class="comment">// 传递给类一组牌, 通过类分析出牌型, 点数, 以及相关的附属信息(比如顺子: 记录牌的数量)</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PlayHand</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="built_in">PlayHand</span>(HandType type, Card::CardPoint pt, <span class="type">int</span> extra);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到牌的属性信息</span></span><br><span class="line">        <span class="function">HandType <span class="title">getHandType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Card::CardPoint <span class="title">getCardPoint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getExtra</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较自己的牌和其他人的牌的大小</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">canBeat</span><span class="params">(<span class="type">const</span> PlayHand&amp; other)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 1. 对扑克牌进行分类: 1张相同的, 2张相同的, 3张相同的, 4张相同的</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">classify</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="comment">// 2. 对牌型进行分类</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">judgeCardType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 判断牌的类型</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPass</span><span class="params">()</span></span>;              <span class="comment">// 放弃出牌</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSingle</span><span class="params">()</span></span>;            <span class="comment">// 单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPair</span><span class="params">()</span></span>;              <span class="comment">// 对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriple</span><span class="params">()</span></span>;            <span class="comment">// 三个(相同)</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTripleSingle</span><span class="params">()</span></span>;      <span class="comment">// 三带一</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriplePair</span><span class="params">()</span></span>;        <span class="comment">// 三带二</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlane</span><span class="params">()</span></span>;             <span class="comment">// 飞机</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoSingle</span><span class="params">()</span></span>;    <span class="comment">// 飞机带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoPair</span><span class="params">()</span></span>;      <span class="comment">// 飞机带2对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqPair</span><span class="params">()</span></span>;           <span class="comment">// 连对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqSingle</span><span class="params">()</span></span>;         <span class="comment">// 顺子</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBomb</span><span class="params">()</span></span>;              <span class="comment">// 炸弹</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombSingle</span><span class="params">()</span></span>;        <span class="comment">// 炸弹带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombPair</span><span class="params">()</span></span>;          <span class="comment">// 炸弹带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombTwoSingle</span><span class="params">()</span></span>;     <span class="comment">// 炸弹带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokers</span><span class="params">()</span></span>;        <span class="comment">// 王炸</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersSingle</span><span class="params">()</span></span>;  <span class="comment">// 王炸带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersPair</span><span class="params">()</span></span>;    <span class="comment">// 王炸带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersTwoSingle</span><span class="params">()</span></span>;   <span class="comment">// 王炸带两单</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        HandType m_type;                          <span class="comment">//牌型</span></span><br><span class="line">        Card::CardPoint m_pt;                     <span class="comment">//点数</span></span><br><span class="line">        <span class="type">int</span> m_extra;                              <span class="comment">//附加类型(如顺子是5张还是6张还是7张，连对是3对还是4对还是5对)</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_oneCard;       <span class="comment">//存储单张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_twoCard;       <span class="comment">//存储两种相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_threeCard;     <span class="comment">//存储三张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_fourCard;      <span class="comment">//存储四张相同点数的牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-2-PlayHand类函数实现"><a href="#14-2-PlayHand类函数实现" class="headerlink" title="14.2 PlayHand类函数实现"></a>14.2 PlayHand类函数实现</h2><p>该部分实现了头文件定义的函数，首先是通过函数classify()对传进来的牌进行分类，用4个容器进行存放，分别为1张相同点数的牌容器、2张相同点数的牌容器、3张相同点数的牌容器和4张相同点数的牌容器。然后通过judgeCardType()函数基于分类的4个容器来对牌进行分析。记录扑克牌的牌型、点数和附加类型(连对的对数和顺子的张数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;playhand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(Cards &amp;cards)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.对扑克牌进行分类：1张的，2张，3张，4张有多少种</span></span><br><span class="line">    <span class="built_in">classify</span>(cards);</span><br><span class="line">    <span class="comment">//2.对牌型进行分类</span></span><br><span class="line">    <span class="built_in">judgeCardType</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(PlayHand::HandType type, Card::CardPoint pt, <span class="type">int</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">    m_pt = pt;</span><br><span class="line">    m_extra = extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的牌型</span></span><br><span class="line"><span class="function">PlayHand::HandType <span class="title">PlayHand::getHandType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">PlayHand::getCardPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取附加类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PlayHand::getExtra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较牌是否大于对方</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::canBeat</span><span class="params">(<span class="type">const</span> PlayHand &amp;other)</span>           <span class="comment">//和对方比较牌型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我的牌型是未知的</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Unknown)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对方放弃出牌</span></span><br><span class="line">    <span class="keyword">if</span>(other.m_type == Hand_Pass)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我是王炸</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己是炸弹，而对方是比炸弹小的牌型(牌类型的枚举类是按照牌型从小到大排列的)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type==Hand_Bomb &amp;&amp; other.m_type&gt;=Hand_Single &amp;&amp; other.m_type&lt;=Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双方的牌型是一致的(比点数)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == other.m_type)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_type == Hand_Seq_Pair || m_type == Hand_Seq_Single)&#123;      <span class="comment">//如果是连对或是顺子</span></span><br><span class="line">            <span class="keyword">return</span> m_pt&gt;other.m_pt &amp;&amp; m_extra == other.m_extra;        <span class="comment">//就要求最小点数要比它大，同时个数要一样，才返回true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_pt &gt; other.m_pt;       <span class="comment">//如果是其它类型，就直接比点数了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//如果都不满足上面，就返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将传进来的牌按张数进行分类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::classify</span><span class="params">(Cards &amp;cards)</span>           <span class="comment">//分析传进来的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将转进来牌存到QVector容器</span></span><br><span class="line">    <span class="type">int</span> cardRecord[Card::Card_End];               <span class="comment">//创建一个数组，大小为不同点数类型大小</span></span><br><span class="line">    <span class="built_in">memset</span>(cardRecord, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*Card::Card_End);     <span class="comment">//数组清0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;             <span class="comment">//遍历每一张牌</span></span><br><span class="line">        Card c = list.<span class="built_in">at</span>(i);                      <span class="comment">//取出扑克牌</span></span><br><span class="line">        cardRecord[c.<span class="built_in">point</span>()]++;                  <span class="comment">//卡牌点数与数组里元素的位置是有对应关系的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先清空四个容器(分别存储相同点数只有1张、2张、3张和4张的牌型)</span></span><br><span class="line">    m_oneCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_twoCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_threeCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_fourCard.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Card::Card_End; i++)&#123;         <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(cardRecord[i] == <span class="number">1</span>)&#123;               <span class="comment">//数组某下标位置元素为1，则说明该点数的牌就为1</span></span><br><span class="line">            m_oneCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到1张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            m_twoCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到2张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">3</span>)&#123;</span><br><span class="line">            m_threeCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到3张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">4</span>)&#123;</span><br><span class="line">            m_fourCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到4张相同牌的容器里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析牌的一个类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::judgeCardType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = Hand_Unknown;               <span class="comment">//牌的类型先初始化为未知</span></span><br><span class="line">    m_pt = Card::Card_Begin;             <span class="comment">//初始化点数</span></span><br><span class="line">    m_extra = <span class="number">0</span>;                         <span class="comment">//这个一般是记录像连队多少对，顺子多少张</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPass</span>())&#123;                      <span class="comment">//放弃出牌</span></span><br><span class="line">        m_type = Hand_Pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isSingle</span>())&#123;                 <span class="comment">//单牌</span></span><br><span class="line">        m_type = Hand_Single;          <span class="comment">//记录类型</span></span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];           <span class="comment">//获取其点数</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPair</span>())&#123;                <span class="comment">//一对</span></span><br><span class="line">        m_type= Hand_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriple</span>())&#123;                        <span class="comment">//3张点数相同</span></span><br><span class="line">        m_type= Hand_Triple;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTripleSingle</span>())&#123;                  <span class="comment">//3带1</span></span><br><span class="line">        m_type= Hand_Triple_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriplePair</span>())&#123;                   <span class="comment">//3带一对</span></span><br><span class="line">        m_type= Hand_Triple_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlane</span>())&#123;                         <span class="comment">//飞机</span></span><br><span class="line">        m_type= Hand_Plane;</span><br><span class="line">        <span class="comment">//记录点数最小的牌</span></span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoSingle</span>())&#123;                <span class="comment">//飞机带两单</span></span><br><span class="line">        m_type= Hand_Plane_Two_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoPair</span>())&#123;                  <span class="comment">//飞机带两对</span></span><br><span class="line">        m_type= Hand_Plane_Two_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqPair</span>())&#123;                       <span class="comment">//连对</span></span><br><span class="line">        m_type= Hand_Seq_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//记录连对的个数</span></span><br><span class="line">        m_extra = m_twoCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqSingle</span>())&#123;                     <span class="comment">//顺子</span></span><br><span class="line">        m_type= Hand_Seq_Single;</span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];</span><br><span class="line">        m_extra = m_oneCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBomb</span>())&#123;                           <span class="comment">//炸弹</span></span><br><span class="line">        m_type= Hand_Bomb;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombSingle</span>())&#123;                    <span class="comment">//炸弹带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombPair</span>())&#123;                       <span class="comment">//炸弹带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Pair;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombTwoSingle</span>())&#123;                  <span class="comment">//炸弹带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Two_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokers</span>())&#123;                     <span class="comment">//王炸</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersSingle</span>())&#123;               <span class="comment">//王炸带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Single;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersPair</span>())&#123;                 <span class="comment">//王炸带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Pair;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersTwoSingle</span>())&#123;            <span class="comment">//王炸带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Two_Single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPass</span><span class="params">()</span>           <span class="comment">//放弃出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//每个容器中都为空，说明是放弃出牌了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSingle</span><span class="params">()</span>            <span class="comment">//判断牌(打出的)是否是单牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果存在1张相同点数容器大小为1，其它2、3、4张相同点数的牌容器为空，说明打出的是单牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//打出的是单牌，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPair</span><span class="params">()</span>                <span class="comment">//判断牌(打出的)是否是一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriple</span><span class="params">()</span>              <span class="comment">//判断牌(打出的)是否是三张一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTripleSingle</span><span class="params">()</span>        <span class="comment">//判断牌(打出的)是否是三带一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriplePair</span><span class="params">()</span>           <span class="comment">//三带二(两张要一样)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlane</span><span class="params">()</span>                <span class="comment">//飞机</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoSingle</span><span class="params">()</span>         <span class="comment">//飞机带两单(不能是大小王)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                  <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2 &amp;&amp; m_oneCard[<span class="number">0</span>]!=Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]!=Card::Card_BJ)&#123;       <span class="comment">//必须是相连且不涉及卡牌2且两单不是大小王</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoPair</span><span class="params">()</span>                <span class="comment">// 飞机带2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqPair</span><span class="params">()</span>                    <span class="comment">//连对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_twoCard.<span class="built_in">begin</span>(),m_twoCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="comment">//如果是三个连续的就满足：(最大数-最小数)=(牌类型总数-1)，如456。还必须满足卡牌是3到2之间(不包括2)</span></span><br><span class="line">        <span class="keyword">if</span>(m_twoCard.<span class="built_in">last</span>()-m_twoCard.<span class="built_in">first</span>()==(m_twoCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_twoCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_twoCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqSingle</span><span class="params">()</span>                 <span class="comment">//顺子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()&gt;=<span class="number">5</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">last</span>()-m_oneCard.<span class="built_in">first</span>()==(m_oneCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_oneCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_oneCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBomb</span><span class="params">()</span>                    <span class="comment">//炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombSingle</span><span class="params">()</span>              <span class="comment">//炸弹带一个单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombPair</span><span class="params">()</span>                 <span class="comment">//炸弹带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombTwoSingle</span><span class="params">()</span>            <span class="comment">//炸弹带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()!=Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()!=Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokers</span><span class="params">()</span>           <span class="comment">//王炸</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()==Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersSingle</span><span class="params">()</span>            <span class="comment">//王炸带一单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">1</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">2</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersPair</span><span class="params">()</span>           <span class="comment">//王炸带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">0</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersTwoSingle</span><span class="params">()</span>            <span class="comment">//王炸带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">4</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">2</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">3</span>]==Card::Card_BJ)&#123;    <span class="comment">//两王比两单大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-游戏策略类Strategy"><a href="#15-游戏策略类Strategy" class="headerlink" title="15. 游戏策略类Strategy"></a>15. 游戏策略类Strategy</h1><p>游戏策略类主要是负责制定斗地主小游戏的规则，和模拟机器人玩家出牌的策略。</p><p>游戏策略类创建：选择新建、c、c++、类名为Strategy，基类为Custom。</p><h2 id="15-1-Strategy类头文件"><a href="#15-1-Strategy类头文件" class="headerlink" title="15.1 Strategy类头文件"></a>15.1 Strategy类头文件</h2><p>游戏策略类Strategy头文件定义的多数是一些游戏的规则，和对机器人玩家的出牌策略，机器人玩家会根据自己的手牌来判断该出什么牌，是否抢地主等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Strategy</span>(Player* player, <span class="type">const</span> Cards&amp; cards);          <span class="comment">//只有机器人玩家才会调用该函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.制定出牌策略</span></span><br><span class="line">    <span class="function">Cards <span class="title">makeStrategy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.第一个出牌firstPlay(没有限制，想出啥出啥)---&gt;机器人玩家使用的函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">firstPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//3.得到比指定牌型大的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getGreaterCards</span><span class="params">(PlayHand type)</span></span>;</span><br><span class="line">    <span class="comment">//4.能大过指定的牌时，判断是出牌还是放行，返回true是出牌。返回false是放行</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">whetherToBeat</span><span class="params">(Cards&amp; cs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.找出指定数量(count)的相同点数的牌(point)，找出count张点数为point的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span></span>;       <span class="comment">//满足指定点数、指定数量的牌</span></span><br><span class="line">    <span class="comment">//6.找出所有点数数量为count的牌 ---&gt; 得到一个多张扑克牌数组</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardsByCount</span>(<span class="type">int</span> count);                        <span class="comment">//满足指定数量的牌</span></span><br><span class="line">    <span class="comment">//7.根据点数范围找牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span></span>;     <span class="comment">//满足指定范围的牌</span></span><br><span class="line">    <span class="comment">//8.按牌型找牌，并且指定要找的牌是否要大过指定的牌型</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardType</span>(PlayHand hand, <span class="type">bool</span> beat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.从指定的Cards对象中挑选出满足条件的顺子(allSeqRecord中每个元素都是一个容器，里面装着满足条件的顺子)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt;&gt;&amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt;&amp;seqSingle, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//10.筛选最优的顺子的集合</span></span><br><span class="line">    <span class="function">QVector&lt;Cards&gt; <span class="title">pickOptimalSeqSingles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> function = <span class="built_in">Cards</span> (Strategy::*)(Card::CardPoint point);      <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CardInfo</span>&#123;</span><br><span class="line">        Card::CardPoint begin;</span><br><span class="line">        Card::CardPoint end;</span><br><span class="line">        <span class="type">int</span> extra;                    <span class="comment">//顺子或连对的数量</span></span><br><span class="line">        <span class="type">bool</span> beat;</span><br><span class="line">        <span class="type">int</span> number;                   <span class="comment">//指定点数的牌的数量(1表示找单排，就是寻找顺子；2表示找对子，就是寻找连对)</span></span><br><span class="line">        <span class="type">int</span> base;                     <span class="comment">//最基础的顺子或者连对的数量(连对是3或顺子是5)</span></span><br><span class="line">        function getSeq;              <span class="comment">//函数指针对象，主要是用来生成基础连对和基础顺子</span></span><br><span class="line">    &#125;;</span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getCards</span>(Card::CardPoint point, <span class="type">int</span> number);     <span class="comment">//从point点数开始查找，找number张---找单、双、三</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getTripleSingleOrPair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//起始点开始找；带1还是带对</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane</span>(Card::CardPoint begin);                <span class="comment">//飞机不带牌</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane2SingleOr2Pair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//飞机带2单还是2对</span></span><br><span class="line">    <span class="comment">//QVector&lt;Cards&gt;getSepPairOrSeqSingle(Card::CardPoint begin, int extra, bool beat);       //连对或顺子</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getSepPairOrSeqSingle</span>(CardInfo &amp;info);       <span class="comment">//连对或顺子</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span></span>;          <span class="comment">//生成基础连对函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span></span>;        <span class="comment">//生成基础顺子函数</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getBomb</span>(Card::CardPoint begin);         <span class="comment">//炸弹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">    Cards m_cards;                 <span class="comment">//存放的是玩家手牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-2-Strategy类函数实现"><a href="#15-2-Strategy类函数实现" class="headerlink" title="15.2 Strategy类函数实现"></a>15.2 Strategy类函数实现</h2><p>这部分是对游戏策略类的头文件中定义的函数进行实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br></pre></td><td class="code"><pre><span class="line">Strategy::<span class="built_in">Strategy</span>(Player *player, <span class="type">const</span> Cards &amp;cards):</span><br><span class="line">    <span class="built_in">m_player</span>(player),</span><br><span class="line">    <span class="built_in">m_cards</span>(cards)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌策略，机器人玩家出牌时直接调用即可，是否出牌和出什么牌都已经处理好了</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::makeStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到出牌玩家对象以及打出的牌</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    Cards pendCards = m_player-&gt;<span class="built_in">getPendCards</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断上次出牌的玩家是不是自己</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer == m_player || pendPlayer == <span class="literal">nullptr</span>)&#123;  <span class="comment">//情况1是上次出牌是我自己，其余玩家没有出牌；情况2是刚开时，上一次出牌玩家就为空</span></span><br><span class="line">        <span class="comment">//直接出牌(没有限制)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">firstPlay</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果不是自己想要，需要找出比出牌玩家点数大的牌</span></span><br><span class="line">        PlayHand <span class="built_in">type</span>(pendCards);               <span class="comment">//构造一个playhand对象，对出的牌进行分析</span></span><br><span class="line">        Cards beatCards = <span class="built_in">getGreaterCards</span>(type);      <span class="comment">//通过分析出类型，得到比上个玩家出队牌更大的牌</span></span><br><span class="line">        <span class="comment">//找到了点数大的牌需要考虑是否出牌</span></span><br><span class="line">        <span class="type">bool</span> shouldBeat = <span class="built_in">whetherToBeat</span>(beatCards);    <span class="comment">//将找到更大的牌作为参数传入</span></span><br><span class="line">        <span class="keyword">if</span>(shouldBeat)&#123;         <span class="comment">//如果出牌，打出要出的牌</span></span><br><span class="line">            <span class="keyword">return</span> beatCards;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//否则返回空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//机器人玩家自由出牌函数</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::firstPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断玩家手中是否只剩下单一的牌型</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(m_cards)</span></span>;           <span class="comment">//传入手牌进行分析</span></span><br><span class="line">    <span class="keyword">if</span>(hand.<span class="built_in">getHandType</span>() != PlayHand::Hand_Unknown)&#123;           <span class="comment">//如果只剩单一牌型</span></span><br><span class="line">        <span class="keyword">return</span> m_cards;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是单一的牌型</span></span><br><span class="line">    <span class="comment">//判断玩家手中是否有顺子</span></span><br><span class="line">    QVector&lt;Cards&gt; optimalSeq = <span class="built_in">pickOptimalSeqSingles</span>();     <span class="comment">//获取顺子(筛选后较大的顺子)---&gt;optimalSeq容器里可能有多个顺子</span></span><br><span class="line">    <span class="keyword">if</span>(!optimalSeq.<span class="built_in">isEmpty</span>())&#123;                    <span class="comment">//如果不为空</span></span><br><span class="line">        <span class="comment">//得到单牌的数量</span></span><br><span class="line">        <span class="type">int</span> baseNum = <span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();            <span class="comment">//没有剔除顺子前的单牌数量</span></span><br><span class="line">        <span class="comment">//把得到的顺子的集合从玩家手中删除</span></span><br><span class="line">        Cards save = m_cards;                  <span class="comment">//复制手牌</span></span><br><span class="line">        save.<span class="built_in">remove</span>(optimalSeq);               <span class="comment">//删除顺子</span></span><br><span class="line">        <span class="type">int</span> lastNum = <span class="built_in">Strategy</span>(m_player,save).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();  <span class="comment">//在去除顺子的手牌中找到单牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(baseNum &gt; lastNum)&#123;           <span class="comment">//这种情况是说明剔除顺子后，单牌数量更少了，是想要的结果</span></span><br><span class="line">            <span class="keyword">return</span> optimalSeq[<span class="number">0</span>];        <span class="comment">//返回其中一个顺子打出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hasPlane, hasTriple, hasPair;</span><br><span class="line">    hasPair = hasTriple = hasPlane = <span class="literal">false</span>;</span><br><span class="line">    Cards backup = m_cards;               <span class="comment">//复制手牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有炸弹</span></span><br><span class="line">    QVector&lt;Cards&gt; bombArray = <span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Bomb, Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    backup.<span class="built_in">remove</span>(bombArray);             <span class="comment">//剔除炸弹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;planeArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Plane,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!planeArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPlane = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(planeArray);        <span class="comment">//剔除飞机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有三张点数相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;seqTripleArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Triple,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqTripleArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasTriple = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqTripleArray);        <span class="comment">//剔除3张点数相同的牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有连对</span></span><br><span class="line">    QVector&lt;Cards&gt;seqPairArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Pair,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqPairArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPair = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqPairArray);        <span class="comment">//剔除连对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPair)&#123;         <span class="comment">//找到了连对不为空，就返回最大连对</span></span><br><span class="line">        Cards maxPair;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqPairArray.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//seqPairArray的元素是类似于34567、345678、3456789....</span></span><br><span class="line">            <span class="keyword">if</span>(seqPairArray[i].<span class="built_in">cardCount</span>() &gt; maxPair.<span class="built_in">cardCount</span>())&#123;        <span class="comment">//比较找出最大连对</span></span><br><span class="line">                maxPair = seqPairArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPlane)&#123;        <span class="comment">//找到了飞机</span></span><br><span class="line">        <span class="comment">//1.飞机带2个对</span></span><br><span class="line">        <span class="type">bool</span> twoPairFond = <span class="literal">false</span>;</span><br><span class="line">        QVector&lt;Cards&gt; pairArray;</span><br><span class="line">        <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">            Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>); <span class="comment">//将搜索的的对子放入pair</span></span><br><span class="line">            <span class="keyword">if</span>(!pair.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                pairArray.<span class="built_in">push_back</span>(pair);             <span class="comment">//添加到pairArray</span></span><br><span class="line">                <span class="keyword">if</span>(pairArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                    twoPairFond = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(twoPairFond)&#123;                       <span class="comment">//如果成功找到2个对</span></span><br><span class="line">            Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">            tmp.<span class="built_in">add</span>(pairArray);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;               <span class="comment">//没有找到2个对，就找2个单牌</span></span><br><span class="line">            <span class="comment">//2.飞机带2个单牌</span></span><br><span class="line">            <span class="type">bool</span> twoSingleFond = <span class="literal">false</span>;</span><br><span class="line">            QVector&lt;Cards&gt; singleArray;</span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;   <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">                <span class="keyword">if</span>(backup.<span class="built_in">pointCount</span>(point) == <span class="number">1</span>)&#123;            <span class="comment">//先查看该点数的牌是否是只有1张，只有1张才进行添加(防止把一些对拆开)</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//将搜索的的单牌放入single</span></span><br><span class="line">                    <span class="keyword">if</span>(!single.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                        singleArray.<span class="built_in">push_back</span>(single);           <span class="comment">//添加到pairArray</span></span><br><span class="line">                        <span class="keyword">if</span>(singleArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                            twoSingleFond = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(twoPairFond)&#123;</span><br><span class="line">                Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">                tmp.<span class="built_in">add</span>(singleArray);</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//如果2对和2单都没有找到满足条件的，就直接打出飞机不带</span></span><br><span class="line">                <span class="comment">//3.直接是飞机</span></span><br><span class="line">                <span class="keyword">return</span> planeArray[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasTriple)&#123;                      <span class="comment">//找到了3张相同的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(seqTripleArray[<span class="number">0</span>]).<span class="built_in">getCardPoint</span>()&lt;Card::Card_A)&#123;         <span class="comment">//如果找到的最小的3张相同牌是小于A的，才执行下面</span></span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_A; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);              <span class="comment">//得到较小点数的牌数</span></span><br><span class="line">                <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;              <span class="comment">//如果是1张，就打出3带1</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//取出点数为point的单牌</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];      <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(single);                          <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount==<span class="number">2</span>)&#123;                      <span class="comment">//如果找到的较小点数的牌数是2</span></span><br><span class="line">                    Cards pair = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);         <span class="comment">//取出点数为point的对子</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];     <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(pair);                     <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到满足条件的单排和对子，就不带副牌</span></span><br><span class="line">        <span class="keyword">return</span> seqTripleArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的牌型都没有得到打出，就考虑打单牌或对牌</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();</span><br><span class="line">    <span class="comment">//如果下一家的手牌数只有1张了，且和下一个玩家不是相同身份</span></span><br><span class="line">    <span class="keyword">if</span>(nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()==<span class="number">1</span> &amp;&amp; m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::<span class="built_in">CardPoint</span>(Card::Card_End<span class="number">-1</span>);</span><br><span class="line">            point&gt;=Card::Card_3; point=Card::<span class="built_in">CardPoint</span>(point<span class="number">-1</span>))&#123;                 <span class="comment">//从大到小遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//如果下一家的手牌数为1且和它是相同身份；如果下一家手牌数大于1且与它不是相同身份；如果下一家手牌数大于1且与它是相同身份</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::Card_3; point&lt;Card::Card_End; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;       <span class="comment">//从小到大遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//上面所有情况呕没有打出牌，就说明牌打完了，直接返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从自己手牌中找到能击败已出牌的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getGreaterCards</span><span class="params">(PlayHand type)</span>         <span class="comment">//参数是要被击败出牌的类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 出牌玩家和当前玩家不是一伙的</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="comment">//上一个出牌玩家出了牌，与它不是一伙，且出牌玩家的手牌已经小于3---&gt;pendPlayer != nullptr是防止第一次出牌的情况(地主自由出)</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer != <span class="literal">nullptr</span> &amp;&amp; pendPlayer-&gt;<span class="built_in">getRole</span>()!=m_player-&gt;<span class="built_in">getRole</span>() &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        QVector&lt;Cards&gt; bombs = <span class="built_in">findCardsByCount</span>(<span class="number">4</span>);      <span class="comment">//通过传入参数4，找出手牌中的所有炸弹，且是从小到大排的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;bombs.<span class="built_in">size</span>(); i++)&#123;               <span class="comment">//从最小开始遍历炸弹比较</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(bombs[i]).<span class="built_in">canBeat</span>(type))&#123;        <span class="comment">//如果我的炸弹类型比出的牌类型大，就会发挥true</span></span><br><span class="line">                <span class="keyword">return</span> bombs[i];                         <span class="comment">//说明找到了击败已出牌的的最小炸弹，就直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有返回，说明没有找到合适的炸弹，就搜索当前玩家有没有王炸</span></span><br><span class="line">        Cards sj = <span class="built_in">findSamePointCards</span>(Card::Card_SJ,<span class="number">1</span>);</span><br><span class="line">        Cards bj = <span class="built_in">findSamePointCards</span>(Card::Card_BJ,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sj.<span class="built_in">isEmpty</span>() &amp;&amp; !bj.<span class="built_in">isEmpty</span>())&#123;        <span class="comment">//如果有王炸，就返回王炸</span></span><br><span class="line">            Cards jokers;</span><br><span class="line">            jokers &lt;&lt; sj &lt;&lt; bj;</span><br><span class="line">            <span class="keyword">return</span> jokers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前玩家和下一个玩家不是一伙的</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();              <span class="comment">//得到下一个玩家对象</span></span><br><span class="line">    <span class="comment">//将玩家手中的顺子剔除出去，万不得已还是不拆除(这里的顺子是指较大的顺子)</span></span><br><span class="line">    Cards remain = m_cards;</span><br><span class="line">    remain.<span class="built_in">remove</span>(<span class="built_in">Strategy</span>(m_player,remain).<span class="built_in">pickOptimalSeqSingles</span>());   <span class="comment">//去除掉手牌中较大的顺子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除冗余的思路：就是将相同的代码放到匿名函数里面，然后通过可调用对象绑定器进行绑定，最后可得到一个可调用对象，要用到的时候，直接使用该可调用对象即可</span></span><br><span class="line">    <span class="keyword">auto</span> beatCard = std::<span class="built_in">bind</span>([=](Cards &amp;cards)&#123;      <span class="comment">//参入的参数是一些牌，返回的还是Cards类型</span></span><br><span class="line">        QVector&lt;Cards&gt;beatCardsArray = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(type, <span class="literal">true</span>);   <span class="comment">//找出已出牌的类型，且要求比它更大一点(true)</span></span><br><span class="line">        <span class="keyword">if</span>(!beatCardsArray.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果找出的不为空，说明找到了比已出牌更大的类型牌</span></span><br><span class="line">            <span class="comment">//如果我与下一个玩家不是相同身份，且下一个玩家的手牌小于等于2了，这时需要出更大的牌，防止下一个玩家能出牌</span></span><br><span class="line">            <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>() &amp;&amp; nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">back</span>();             <span class="comment">//已经找出的牌型是从小到大排的，所以取出最大的牌返回</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//下一个不是相同玩家但牌数小于等于2；下一个是不同玩家，但牌数大于2；下一个是相同玩家，但牌数大于2</span></span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">front</span>();      <span class="comment">//否则的话，就直接返回最小的能压制已出牌的相同牌型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();              <span class="comment">//不满足上面，就返回空对象</span></span><br><span class="line">    &#125;, std::placeholders::_1);</span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(remain)).<span class="built_in">isEmpty</span>())&#123;          <span class="comment">//这是从剔除顺子的手牌中找</span></span><br><span class="line">        <span class="keyword">return</span> cs;                    <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">//如果从剔除顺子的手牌中没有找到，就从所有手牌中找</span></span><br><span class="line">        <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(m_cards)).<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> cs;        <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();               <span class="comment">//没有找到合适出牌类型，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Strategy::whetherToBeat</span><span class="params">(Cards &amp;cs)</span>      <span class="comment">//参数是通过其它函数得到的一个更大的牌，或为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//没有找到能够击败对方的牌,即cs为空</span></span><br><span class="line">    <span class="keyword">if</span>(cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到出牌玩家的对象</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();     <span class="comment">//得到上次出牌的玩家身份</span></span><br><span class="line">    <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>() == pendPlayer-&gt;<span class="built_in">getRole</span>())&#123;   <span class="comment">//如果身份相同，即农民</span></span><br><span class="line">        <span class="comment">//手里的牌所剩无几并且是一个完整的牌型,就可以打</span></span><br><span class="line">        Cards left = m_cards;              <span class="comment">//先复制手牌</span></span><br><span class="line">        left.<span class="built_in">remove</span>(cs);                   <span class="comment">//从手牌移出要打的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(left).<span class="built_in">getHandType</span>()!=PlayHand::Hand_Unknown)&#123;    <span class="comment">//如果手牌剩的类型不是不确定的(即就是可以一下子打完的那中牌类型)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs对象中的牌的最小点数是2，大小王就不出牌</span></span><br><span class="line">        Card::CardPoint basePoint = <span class="built_in">PlayHand</span>(cs).<span class="built_in">getCardPoint</span>();               <span class="comment">//得出要打牌的点数</span></span><br><span class="line">        <span class="keyword">if</span>(basePoint==Card::Card_2 || basePoint==Card::Card_SJ || basePoint==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果过大就不出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//如果与出牌的玩家不是相同身份</span></span><br><span class="line">        PlayHand <span class="built_in">myHand</span>(cs);                       <span class="comment">//先判断要出牌的类型</span></span><br><span class="line">        <span class="comment">//如果是三个2带1，或者带1对，不出牌(保存实力)</span></span><br><span class="line">        <span class="keyword">if</span>((myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Single || myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Pair)</span><br><span class="line">                &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs是对2，并且出牌玩家手中的牌数量大于等于10 &amp;&amp; 自己的牌数量大于等于5，暂时放弃出牌</span></span><br><span class="line">        <span class="keyword">if</span>(myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Pair &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2 &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">10</span> &amp;&amp; m_player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//上面情况都不是，就可以出牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span>     <span class="comment">//指定点数和指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;               <span class="comment">//如果要找的牌的数量小于1或大于4，都是不合法的，返回空对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大小王</span></span><br><span class="line">    <span class="keyword">if</span>(point == Card::Card_SJ || point == Card::Card_BJ)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;              <span class="comment">//非法的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//返回空对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        Card card;</span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);               <span class="comment">//存放点数(大王或小王)</span></span><br><span class="line">        card.<span class="built_in">setSuit</span>(Card::Suit_Begin);     <span class="comment">//存放花色</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;         <span class="comment">//如果该牌在m_cards是真的存在</span></span><br><span class="line">            Cards cards;</span><br><span class="line">            cards.<span class="built_in">add</span>(card);</span><br><span class="line">            <span class="keyword">return</span> cards;                   <span class="comment">//就将该牌添加到cards并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();                    <span class="comment">//没有找到大小王就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是大小王</span></span><br><span class="line">    <span class="type">int</span> findCount = <span class="number">0</span>;                   <span class="comment">//这是用来记录指定点数的牌的数量</span></span><br><span class="line">    Cards findCards;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++)&#123;       <span class="comment">//遍历花色</span></span><br><span class="line">        Card card;                                    <span class="comment">//创建一个card,记录的是指定的点数，和该遍历的花色</span></span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);</span><br><span class="line">        card.<span class="built_in">setSuit</span>((Card::CardSuit)suit);</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;                 <span class="comment">//如果该card在m_cards，说明有该张牌</span></span><br><span class="line">            findCount++;</span><br><span class="line">            findCards.<span class="built_in">add</span>(card);                    <span class="comment">//将该张牌添加到findCards</span></span><br><span class="line">            <span class="keyword">if</span>(findCount == count)&#123;</span><br><span class="line">                <span class="keyword">return</span> findCards;                   <span class="comment">//如果指定点数的牌的数量到达了指定的点数，就返回这些牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();        <span class="comment">//如果遍历完所有的花色，都没有找到指定点数、指定数量的牌，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardsByCount</span><span class="params">(<span class="type">int</span> count)</span>          <span class="comment">//指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();            <span class="comment">//如果指定的数量不合法，就直接返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">    QVector&lt;Cards&gt;cardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(point)==count)&#123;               <span class="comment">//pointCount()函数是指定点数的牌数量</span></span><br><span class="line">            <span class="comment">//如果该点数的牌数量和要求的牌数量相等，就取出该牌(通过上面刚写的函数)</span></span><br><span class="line">            Cards cs;</span><br><span class="line">            cs &lt;&lt; <span class="built_in">findSamePointCards</span>(point,count);       <span class="comment">//取出指定点数、指定数量的牌</span></span><br><span class="line">            cardsArray &lt;&lt; cs;             <span class="comment">//最后返回的容器cardsArray中，一个cards存放的是相同点数的牌</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cardsArray;         <span class="comment">//然后容器，里面存的是指定数量的牌(可能有多中不同点数的牌)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span>      <span class="comment">//指定范围的所有牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards rangeCards;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;   <span class="comment">//遍历这个范围点数的牌</span></span><br><span class="line">        <span class="type">int</span> count = m_cards.<span class="built_in">pointCount</span>(point);                     <span class="comment">//先获得该点数的牌数量</span></span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, count);               <span class="comment">//通过点数、牌数量得到这些牌</span></span><br><span class="line">        rangeCards  &lt;&lt; cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rangeCards;                      <span class="comment">//这里面存的都是在指定范围的牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardType</span><span class="params">(PlayHand hand, <span class="type">bool</span> beat)</span>    <span class="comment">//hand是要求牌的类型，beat是否需要点数更大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//取出要求牌的类型</span></span><br><span class="line">    Card::CardPoint point = hand.<span class="built_in">getCardPoint</span>();         <span class="comment">//取出要求牌的点数</span></span><br><span class="line">    <span class="type">int</span> extra = hand.<span class="built_in">getExtra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定起始点数(如果beat为true，就在原来基础上+1；为false，就直接从最小3开始找)</span></span><br><span class="line">    Card::CardPoint beginPoint = beat?Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>):Card::Card_3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">1</span>);        <span class="comment">//单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">2</span>);        <span class="comment">//对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">3</span>);        <span class="comment">//三个一样</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Single);      <span class="comment">//3带1</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Pair);        <span class="comment">//3带一对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane</span>(beginPoint);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Single);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Pair);</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:                    <span class="comment">//连对</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_Q;          <span class="comment">//最大点数到Q即可</span></span><br><span class="line">        info.number = <span class="number">2</span>;</span><br><span class="line">        info.base = <span class="number">3</span>;                    <span class="comment">//基础连对至少是3对</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqPair;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:               <span class="comment">//顺子</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_10;           <span class="comment">//最大点数到10即可</span></span><br><span class="line">        info.number = <span class="number">1</span>;</span><br><span class="line">        info.base = <span class="number">5</span>;                   <span class="comment">//基础顺子至少是5个</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqSingle;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:                    <span class="comment">//炸弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBomb</span>(beginPoint);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();                <span class="comment">//如果都不是，就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的Cards对象中挑选出顺子(参1和参2都是传出参数，参3是传入参数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Strategy::pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt; &gt; &amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt; &amp;seqSingle, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.得到传入牌cards的所有顺子的组合</span></span><br><span class="line">    QVector&lt;Cards&gt; allSeq = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Single,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(allSeq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//如果为空了，就结束递归，将满足条件的顺子传入allSeqRecord</span></span><br><span class="line">        allSeqRecord &lt;&lt; seqSingle;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;           <span class="comment">//2.对顺子进行筛选</span></span><br><span class="line">        Cards saveCards = cards;      <span class="comment">//先复制手牌，备份使用，马上进入for循环了</span></span><br><span class="line">        <span class="comment">//遍历得到的所有的顺子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;allSeq.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            Cards aScheme = allSeq.<span class="built_in">at</span>(i);             <span class="comment">//将顺子取出</span></span><br><span class="line">            Cards temp = saveCards;</span><br><span class="line">            temp.<span class="built_in">remove</span>(aScheme);                     <span class="comment">//将顺子从用户手中剔除</span></span><br><span class="line"></span><br><span class="line">            QVector&lt;Cards&gt; seqArray = seqSingle;</span><br><span class="line">            seqArray &lt;&lt; aScheme;                      <span class="comment">//将得到的顺子放入seqArray</span></span><br><span class="line">            <span class="comment">//检测还没有其它的顺子</span></span><br><span class="line">            <span class="comment">//seqArray:存储一轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//allSeqRecord:存储多轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//temp:是剔除顺子的手牌</span></span><br><span class="line">            <span class="built_in">pickSeqSingles</span>(allSeqRecord,seqArray,temp);</span><br><span class="line">            <span class="comment">//allSeqRecord里面的存的，比如说第1个元素存的是剔除34567后，手牌中还满足的顺子(包括34567)；第2个元素是剔除345678后还满足的顺子(包括345678)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选最优的顺子</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::pickOptimalSeqSingles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;QVector&lt;Cards&gt;&gt;seqRecord;</span><br><span class="line">    QVector&lt;Cards&gt; seqSingles;</span><br><span class="line">    <span class="comment">//找顺子之前，先把一些更重要的牌型剔除，防止被拆</span></span><br><span class="line">    Cards save = m_cards;                            <span class="comment">//先复制手牌</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">4</span>));                <span class="comment">//剔除炸弹</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">3</span>));                <span class="comment">//剔除一些3带1或飞机类型的牌</span></span><br><span class="line">    <span class="built_in">pickSeqSingles</span>(seqRecord, seqSingles, save);     <span class="comment">//对一些重要的牌进行剔除后，基于剩下的牌save来进行查找顺子</span></span><br><span class="line">    <span class="keyword">if</span>(seqRecord.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果找出的集合为空，说明没有找到顺子，就返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历容器</span></span><br><span class="line">    QMap&lt;<span class="type">int</span>,<span class="type">int</span>&gt;seqMarks;              <span class="comment">//存储对应关系的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqRecord.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Cards backupCards = m_cards;                  <span class="comment">//先复制手牌到backupCards</span></span><br><span class="line">        QVector&lt;Cards&gt;seqArray = seqRecord[i];        <span class="comment">//复制此刻要处理的容器(里面都是顺子)</span></span><br><span class="line">        backupCards.<span class="built_in">remove</span>(seqArray);                 <span class="comment">//从复制的手牌backupCards中移除此刻容器里面的所有顺子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断剩下的单牌数量，数量越少，顺子的组合就越合理</span></span><br><span class="line">        QVector&lt;Cards&gt; singleArray = <span class="built_in">Strategy</span>(m_player, backupCards).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>);     <span class="comment">//将移除顺子容器后的手牌传入</span></span><br><span class="line">        <span class="comment">//因为传入的数量是1,所以返回的singleArray中每个元素cards里面都是存的不同点数的牌，但每个点数的牌数量都为1</span></span><br><span class="line">        CardList cardList;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;singleArray.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cardList &lt;&lt; singleArray[j].<span class="built_in">toCardList</span>();      <span class="comment">//将所有的单牌取出转换后存入到cardList</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里选择点数相对较大一点的顺子，则在两种组合中留下的单牌数量相同的情况下，单牌点数就可能小。所以下面就选择单牌点数小的组合来返回</span></span><br><span class="line">        <span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;cardList.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            mark += cardList[j].<span class="built_in">point</span>() + <span class="number">15</span>;   <span class="comment">//加15的原因，是防止两组组合留下的单牌数不一样情况下，类似3、4和k这两种，应该选择k对应的组合</span></span><br><span class="line">        &#125;</span><br><span class="line">        seqMarks.<span class="built_in">insert</span>(i,mark);          <span class="comment">//将对应的mark值和其最大容器组合下标i的对应关系存到seqMarks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> comMark = <span class="number">1000</span>;                    <span class="comment">//先初始化一个较大值</span></span><br><span class="line">    <span class="keyword">auto</span> it = seqMarks.<span class="built_in">constBegin</span>();       <span class="comment">//常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=seqMarks.<span class="built_in">constEnd</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.<span class="built_in">value</span>() &lt; comMark)&#123;            <span class="comment">//寻找最小的key值对应的value</span></span><br><span class="line">            comMark = it.<span class="built_in">value</span>();</span><br><span class="line">            value = it.<span class="built_in">key</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seqRecord[value];            <span class="comment">//返回最优的顺子(较大的顺子)，是QVector&lt;Cards&gt;类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> number)</span>   <span class="comment">//起点点数point,number张</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint pt=point; pt&lt;Card::Card_End; pt=(Card::CardPoint)(pt+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//目的是尽量不拆分别的牌型</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(pt)==number)&#123;  <span class="comment">//这里是确保找的点数的牌数量与想找的牌数量一样，就执行下面，防止本来有个炸弹，但因为找但牌，就拆开了</span></span><br><span class="line">            Cards cs = <span class="built_in">findSamePointCards</span>(pt, number);</span><br><span class="line">            findCardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getTripleSingleOrPair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到点数相同的三张牌</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getCards</span>(begin,<span class="number">3</span>);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cardsArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//将找到的牌和三张点数相同的牌进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(cardsArray.<span class="built_in">at</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane</span><span class="params">(Card::CardPoint begin)</span>                 <span class="comment">//飞机不带牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;=Card::Card_K; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//根据点数和数量进行搜索</span></span><br><span class="line">        Cards prevCards = <span class="built_in">findSamePointCards</span>(point, <span class="number">3</span>);                      <span class="comment">//找出飞机小</span></span><br><span class="line">        Cards nextCards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">3</span>);  <span class="comment">//找出飞机大</span></span><br><span class="line">        <span class="keyword">if</span>(!prevCards.<span class="built_in">isEmpty</span>() &amp;&amp; !nextCards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            Cards tmp;</span><br><span class="line">            tmp &lt;&lt; prevCards &lt;&lt; nextCards;       <span class="comment">//将飞机小和大存到一个Cards里面，再存入到findCardArray</span></span><br><span class="line">            findCardArray &lt;&lt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane2SingleOr2Pair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span>   <span class="comment">//飞机带2单还是2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getPlane</span>(begin);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type, Card::Card_Begin, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(cardsArray.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//将找到的牌就和飞机进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                Cards tmp;</span><br><span class="line">                tmp &lt;&lt; cardsArray[<span class="number">0</span>] &lt;&lt; cardsArray[<span class="number">1</span>];</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();          <span class="comment">//没有找到，说明不满足这种飞机，就直接清空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者(可能为空)</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连对或顺子(begin是起始点；extra是要找的牌数；beat指是否比原基础上至少大1点)</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getSepPairOrSeqSingle</span><span class="params">(CardInfo &amp;info)</span>    <span class="comment">//连对和顺子提供的数据是不一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt;findCardsArray;</span><br><span class="line">    <span class="keyword">if</span>(info.beat)&#123;       <span class="comment">//为true，表示要找能压制对方的牌</span></span><br><span class="line">        <span class="comment">//最少3个，最大A(连对)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;           <span class="comment">//记录是否查找成功</span></span><br><span class="line">            Cards seqCards;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;info.extra; i++)&#123;</span><br><span class="line">                <span class="comment">//基于点数和数量进行牌的搜索</span></span><br><span class="line">                Cards cards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+i),info.number);     <span class="comment">//连续的2张2张的找连对</span></span><br><span class="line">                <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>() || (point+info.extra&gt;=Card::Card_2))&#123;     <span class="comment">//这种情况就是没有找到</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    seqCards.<span class="built_in">clear</span>();</span><br><span class="line">                    <span class="keyword">break</span>;       <span class="comment">//说明以此刻的point为起点，遍历extra个是找不到的，直接跳出循环，继续下一个point为起点开始查找</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    seqCards &lt;&lt; cards;         <span class="comment">//如果找到了就加入seqCards</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found)&#123;    <span class="comment">//如果以此刻的point为起点找到了满足条件的，就没有必要继续找了，因为压制对方的最小的连对已经找到</span></span><br><span class="line">                findCardsArray &lt;&lt; seqCards;</span><br><span class="line">                <span class="keyword">return</span> findCardsArray;                <span class="comment">//直接返回即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     <span class="comment">//bet为false，意味着要找的连对对点数和数量是没有要求的(不受extra约束)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="comment">//将找到的这个基础连对存储起来</span></span><br><span class="line">            Cards baseSeq = (<span class="keyword">this</span>-&gt;*info.getSeq)(point);       <span class="comment">//使用函数指针，得到一个基础连对或基础顺子</span></span><br><span class="line">            <span class="keyword">if</span>(baseSeq.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果是空，就不执行下面了，重新循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            findCardsArray &lt;&lt; baseSeq;            <span class="comment">//将基础连对存储到最终容器中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> followed = info.base;           <span class="comment">//因为之前已经找到了3对，接下来是再其基础上找连续对子</span></span><br><span class="line">            Cards alreadyFollowedCards;         <span class="comment">//存储后序找到的满足条件的连对</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                Card::CardPoint followedPoint = Card::<span class="built_in">CardPoint</span>(point+followed);      <span class="comment">//新的起始点数</span></span><br><span class="line">                <span class="comment">//判断是否超出了上限</span></span><br><span class="line">                <span class="keyword">if</span>(followedPoint &gt;= Card::Card_2)&#123;              <span class="comment">//如果点数比2大，是不合理的，直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Cards follwedCards = <span class="built_in">findSamePointCards</span>(followedPoint, info.number);     <span class="comment">//如果点数合理，就寻找该点数的对子</span></span><br><span class="line">                <span class="keyword">if</span>(follwedCards.<span class="built_in">isEmpty</span>())&#123;           <span class="comment">//为空表示没有找到，退出循环(说明以此刻的point为起点的后序对子段了或没有了)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//比如说345是基础连对，在此基础上，3456、34567都会作为一个独立的cards存储到最终容器中，当没有8连对时，以345为基础的也结束查找了</span></span><br><span class="line">                    alreadyFollowedCards &lt;&lt; follwedCards;   <span class="comment">//在后面基础每找到一对，就将其存入到alreadyFollowedCards</span></span><br><span class="line">                    Cards newSeq = baseSeq;                 <span class="comment">//通过拷贝赋值得到newSeq，它里面存的是此刻的基础对子</span></span><br><span class="line">                    newSeq &lt;&lt; alreadyFollowedCards;         <span class="comment">//将这一轮找到的对子加入到基础对子，又得到一种新的连对</span></span><br><span class="line">                    findCardsArray &lt;&lt; newSeq;               <span class="comment">//将这一轮得到的新连对存入到最终容器中</span></span><br><span class="line">                    followed++;                             <span class="comment">//++操作，在此刻的基础连对上，继续找下一个对子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;       <span class="comment">//如果遍历完了还没有找到，返回的就是一个空对象，否则里面就有很多连对cards对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span>      <span class="comment">//生成基础连对函数(参数是起始点)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">2</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">2</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">2</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span>    <span class="comment">//生成基础顺子函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">1</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards3 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">3</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards4 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">4</span>),<span class="number">1</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>() &amp;&amp; !cards3.<span class="built_in">isEmpty</span>() &amp;&amp; !cards4.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2 &lt;&lt; cards3 &lt;&lt; cards4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getBomb</span><span class="params">(Card::CardPoint begin)</span>            <span class="comment">//找炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findcardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            findcardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findcardsArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;这是一个基于Qt开发的单机版的斗地主小游戏。该项目一共涉及到的类有如下：&lt;/p&gt;
&lt;p&gt;1.卡牌类&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>QT基础</title>
    <link href="https://lxx93.online/2024/08/03/QT%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/08/03/QT%E5%9F%BA%E7%A1%80/</id>
    <published>2024-08-03T13:48:35.000Z</published>
    <updated>2025-03-26T11:07:12.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展以及一些宏，Qt很容易扩展，并且允许真正的组件编程。</p><p>Qt Creator是一个用于Qt开发的轻量级跨平台集成开发环境。Qt Creator可带来两大关键益处：提供首个专为支持跨平台开发而设计的集成开发环境(IDE)，并确保首次接触Qt框架的开发人员能迅速上手和操作。即使不开发Qt应用程序，Qt Creator也是一个简单易用且功能强大的IDE。</p><p>Qt是一套应用程序开发库，但与MFC不同，Qt是跨平台的开发类库。跨平台意味着只需要编写一次程序，在不同平台上无需改动或只需要少许改动后在编译，就可以形成在不同平台上运行的版本。</p><h2 id="1-2-Qt特征"><a href="#1-2-Qt特征" class="headerlink" title="1.2 Qt特征"></a>1.2 Qt特征</h2><p>1.面向对象</p><p>Qt具有模块设计和控件或元素的可重用性的特点。一个控件不需要找到它的内容和用途，通过Signal和slot与外界通信、交流。而且Qt的控件都可通过继承。</p><p>2.控件间的相互通信</p><p>Qt提供signal和slot概念，这是一种安全可靠的方法，它允许回调，并支持对象之间在彼此不知道对方信息的情况下，进行合作，这使Qt非常合适于真正的控件编程。</p><p>3.友好的联机帮助</p><p>Qt包括大量的联机参考文档，有超文本HTML方式、UNIX帮助页、man手册和补充的指南。对于初学者，指南将一步步地解释Qt编程。</p><p>4.用户自定义</p><p>其它的工具包在应用时都存在一个普遍的问题，就是经常没有真正适合需求的控件，生成的自定义控件对用户来说，也是一个黑匣子。比如，在Motif手册中就讨论了用户自定义的控件问题。而在Qt中，能够创建控件，具有绝对的优越性，生成自定义控件非常简单，并且容易修改控件。</p><p>5.方便性</p><p>由于Qt是一种跨平台的GUI工具包，所以它对编程者隐藏了在处理不同窗口系统时的潜在问题。为了将基于Qt程序更加方便，Qt包含了一系列类。该类能够使程序员避免了在文件处理、时间处理等方面存在依赖操作系统方面的细节问题。</p><h1 id="2-Qt编译过程"><a href="#2-Qt编译过程" class="headerlink" title="2. Qt编译过程"></a>2. Qt编译过程</h1><p>1.编写代码</p><p>通过文本文档写入如下代码，后缀改为cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span>                         <span class="comment">//水平布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span>                         <span class="comment">//垂直布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span>                                <span class="comment">//窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;                            <span class="comment">//程序</span></span><br><span class="line">QLabel *infoLabel = <span class="keyword">new</span> QLabel;                        <span class="comment">//信息标签对象</span></span><br><span class="line">QLabel *openLabel = <span class="keyword">new</span> QLabel;                     <span class="comment">//打开标签对象</span></span><br><span class="line">QLineEdit *cmdLineEdit = <span class="keyword">new</span> QLineEdit;        <span class="comment">//文本行编辑框对象</span></span><br><span class="line">QPushButton *commitButton = <span class="keyword">new</span> QPushButton;          <span class="comment">//确定按钮</span></span><br><span class="line">QPushButton *cancelButton = <span class="keyword">new</span> QPushButton;             <span class="comment">//取消按钮</span></span><br><span class="line">QPushButton *browseButton = <span class="keyword">new</span> QPushButton;           <span class="comment">//浏览按钮</span></span><br><span class="line"></span><br><span class="line">infoLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;input cmd：&quot;</span>);</span><br><span class="line">openLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">commitButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line">cancelButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">browseButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;browse&quot;</span>);</span><br><span class="line"></span><br><span class="line">QHBoxLayout *cmdLayout = <span class="keyword">new</span> QHBoxLayout;                 <span class="comment">//水平布局对象</span></span><br><span class="line">cmdLayout-&gt;<span class="built_in">addWidget</span>(openLabel);</span><br><span class="line">cmdLayout-&gt;<span class="built_in">addWidget</span>(cmdLineEdit);</span><br><span class="line"></span><br><span class="line">QHBoxLayout *buttonLayout = <span class="keyword">new</span> QHBoxLayout;             <span class="comment">//水平布局对象</span></span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(commitButton);</span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(cancelButton);</span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(browseButton);</span><br><span class="line"></span><br><span class="line">QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout;              <span class="comment">//垂直布局对象</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">addWidget</span>(infoLabel);</span><br><span class="line">mainLayout-&gt;<span class="built_in">addLayout</span>(cmdLayout);                              <span class="comment">//将布局添加到布局是用addLayout函数</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">addLayout</span>(buttonLayout);</span><br><span class="line"></span><br><span class="line">QWidget w;                                    <span class="comment">//窗口对象</span></span><br><span class="line">w.<span class="built_in">setLayout</span>(mainLayout);             <span class="comment">//将主布局(所有内容都在这个布局里)嵌入到窗口</span></span><br><span class="line">w.<span class="built_in">show</span>()；</span><br><span class="line"><span class="keyword">return</span> app.<span class="built_in">exec</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.生成工程文件</p><ul><li><p>cmd进入工程目录(最好是QT自带的)</p></li><li><p>在过程目录下的cmd输入：<code>qmake -project</code></p></li><li><p>修改工程文件，在工程目录下会生成一个后缀为pro的文件，在该文件的最后一行添加：<code>QT += widgets gui</code></p></li></ul><p>3.生成makefile，终端输入qmake</p><p>4.输入mingw32-make，执行成功就可以在工程目录下的debug或release目录下生成可执行文件。</p><p>注：以上步骤可能存在环境变量文件，如果出现，想要配置</p><h1 id="3-Qt-Creator"><a href="#3-Qt-Creator" class="headerlink" title="3. Qt Creator"></a>3. Qt Creator</h1><p>在创建一个Qt的项目时，也就是创建一个主窗口，基类的选择有以下三种：</p><ul><li><code>QmainWindow</code>：继承QWidget，带有菜单栏、工具栏、状态栏的界面</li><li><code>QWidget</code>：最基础的窗口类，qt里面能看到的东西的基类，不带菜单栏的界面，类似于QQ、微信的登录框</li><li><code>Qdialog</code>：继承QWidget，对话框界面，完成一些业务时，弹出的对话框</li></ul><p>Qt里面绝大部分的类都是继承自QObject，它是一个顶层类</p><p>下面创建了一个MainWindow窗口类，继承的基类是<code>QWidget</code></p><p>下面是创建窗口后，提供的main()函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个应用程序对象：维护qt应用程序生命的一个对象，每个qt有且只有一个对象</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//窗口类的一个对象</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    <span class="comment">//把窗口显示出来</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//死循环让程序一直运行，生命循环，消息循环</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(1)&#123;</span></span><br><span class="line"><span class="comment">        if(点击x按钮)&#123;</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(点击...)&#123;</span></span><br><span class="line"><span class="comment">            执行相应操作</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        .....</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是窗口类的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//宏，引入t信号槽的一个宏</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//parent窗口制作，父窗口对象的指针</span></span><br><span class="line">    <span class="comment">//如果parent为0或者NULL，表示当前窗口对象是个顶层窗口</span></span><br><span class="line">    <span class="comment">//顶层窗口就是在任务栏可以找到的窗口(可以通过函数设置，所以这个说法不一定正确)</span></span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">newhello</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是窗口类的构造函数以及一些程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//this-&gt;move(100,100);   //主窗口MainWindow窗口也可以移动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnA = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);  <span class="comment">//指定父对象，这个按钮就可以内嵌到MainWindow这个窗口里面</span></span><br><span class="line">    btnA-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                   <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnA-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnB = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnA);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnA这个按钮窗口里面</span></span><br><span class="line">    btnB-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                  <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnB-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);        <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第三个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnC = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnB);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnB这个窗口里面</span></span><br><span class="line">    btnC-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                 <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnC-&gt;<span class="built_in">setFixedSize</span>(<span class="number">50</span>,<span class="number">50</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，<code>ui</code> 是一个指向UI类对象的指针，该对象通常通过UI设计器生成，并包含了所有UI组件的实例和布局信息。而<code>setupUi</code> 是UI类中的一个成员函数，它的作用是将UI组件添加到主窗口上，并设置它们的位置、大小等属性。<code>this</code> 是一个指向当前对象的指针，通常是主窗口的实例。<code>setupUi</code> 函数会使用这个指针来确定UI组件应该添加到哪个窗口上。</p><p>执行后的效果如下：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Qt/8_1.png" style="zoom: 67%;"><h1 id="4-基本知识1"><a href="#4-基本知识1" class="headerlink" title="4. 基本知识1"></a>4. 基本知识1</h1><p><code>QWidget</code>类是所有用户界面对象的基类，它提供了创建和管理窗口部件的功能。另一方面，<code>QObject</code>类是Qt对象模型的基类，它提供了对象树、信号与槽机制、事件处理等基本功能。</p><h2 id="4-1-父子关系"><a href="#4-1-父子关系" class="headerlink" title="4.1 父子关系"></a>4.1 父子关系</h2><p>默认情况下按钮是没有认父亲的，也就是一个顶层窗口，想要按钮显示在窗口中，就要跟窗口构造父子关系，方法如下：</p><ul><li>setParent</li><li>构造函数传参</li></ul><p>创建了一个MainWindow窗口类，继承的基类是<code>QWidget</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种情况没有建立父子关系，而QPushButton的基类是Widget，所以显示的是顶层窗口(重新显示在一个窗口中)</span></span><br><span class="line">    QPushButton btn1;        <span class="comment">//创建按钮对象</span></span><br><span class="line">    btn1.<span class="built_in">setText</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    btn1.<span class="built_in">show</span>();             <span class="comment">//将按钮显示出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立父子关系：建立父子关系后，该按钮就不需要show了，只要父亲显示出来，它就可以显示出来</span></span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    QPushButton btn2;</span><br><span class="line">    btn2.<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    btn2.<span class="built_in">setParent</span>(&amp;w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn3</span><span class="params">(<span class="string">&quot;按钮3&quot;</span>,&amp;w)</span></span>;</span><br><span class="line">    btn3.<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-基础"><a href="#4-2-基础" class="headerlink" title="4.2 基础"></a>4.2 基础</h2><p>1.关于Qt的坐标系是以父窗口的左上角为(0，0)的，以向右的方向为x的正方向，以向下的方向为y的正方向，顶层窗口就是以屏幕左上角为(0，0)的。</p><p>2.常用的API:</p><ul><li>move：移动窗口到父窗口某个位置</li><li>resize：重新设置窗口的大小</li><li>setFixedSize()：设置窗口的固定大小</li><li>setWindowTitle()：设置窗口标题</li><li>setGeometry()：同时设置窗口位置和大小，相当于是move和resize的结合体，参数(x轴，y轴，宽，高)</li></ul><p>3.对象树</p><p>概念：各个窗口对象通过建立父子关系构造的一个关系树</p><p>内存管理：父对象释放的时候会自动释放各个子对象</p><p>Qt中有内存回收机制，即对象树，但不是所有被new出的对象被自动回收，满足下面两个条件才可以自动回收：</p><ol><li>创建的对象必须是<code>QObject</code>类的子类(间接子类也可以)，<code>QObject</code>类是没有父类的，Qt中有很大一部分类都是从这个类派生出去的</li><li>创建出的类对象，必须要指定其父对象是谁，一般情况下有两种操作方式：<ul><li>在构造对象时指定父对象</li><li>通过调用<code>QWidget</code>的API指定父窗口对象，就是setParent()方法</li></ul></li></ol><p>下面创建了一个主窗口MainWindow窗口类，继承的基类是QWidget，又创建了一个MyPushButton窗口类，使它继承的基类是QWidget。</p><p>以下是主窗口MainWindow类的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//局部变量在函数退出的时候就会自动释放(窗口就算没有关闭，它的构造函数也会很快执行结束)，所以这种方式在窗口不能显示按钮</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn</span><span class="params">(<span class="string">&quot;按钮1&quot;</span>,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    btn.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解决办法，让按钮的生命周期长一点：static、类成员变量、new一个，动态内存分配</span></span><br><span class="line">    MyPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-信号槽机制"><a href="#5-信号槽机制" class="headerlink" title="5. 信号槽机制"></a>5. 信号槽机制</h1><p>信号：各种事件；槽：相应信号的动作</p><p>信号和槽本质都是函数</p><p>当某个事件发送后，如某个按钮被点击了一下，它就会发出一个被点击的信号(signal)，当某个对象接到这个信号之后，就会做一些相关的处理动作(slot)。但是Qt对象不会无故收到某个信号，要想让一个对象收到另一个对象发出的信号。这时需要建立连接，即connect()。</p><p><code>connect(信号发送者,信号,信号接收者,槽);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(btn, &amp;QPushButton::clicked, this, &amp;Widget::close);</span><br></pre></td></tr></table></figure><p>使用connect的时候保留<code>&amp;</code>符号的原因：</p><ul><li>提高代码可读性(提示这是一个指针)</li><li>自动提示(会根据前面写的内容来提示你接下来可能输入的内容)</li></ul><p>下面编写了多个类，类与类之间想要在Qt中使用信号槽机制，那么必须要满足如下条件：</p><ol><li>这个类必须从<code>QObject</code>类或者是其子类进行派生</li><li>在定义类的头文件种加入Q_OBJECT宏</li></ol><h2 id="5-1-自定义信号与槽"><a href="#5-1-自定义信号与槽" class="headerlink" title="5.1 自定义信号与槽"></a>5.1 自定义信号与槽</h2><p>1自定义信号要求：</p><ul><li>信号是类的成员函数</li><li>返回值是void类型</li><li>信号的名字可以根据实际情况进行指定</li><li>参数可以随意指定，信号也可以重载</li><li>信号需要使用signals关键字进行声明，类似于public</li><li>信号函数只需要声明，不需要定义(没有函数体实现)</li><li>在程序中发送自定义信号，发送的本质就是调用信号函数</li></ul><p>建议：习惯性在信号函数前加关键字emit；其只是显示的声明信号被发送,没有特殊含义。底层emit &#x3D;&#x3D; #define emit</p><p>2.槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的，要求：</p><ul><li>返回值是void类型</li><li>槽也是函数，因此也支持重载</li><li>Qt中的槽函数的类型有类的成员函数、全局函数、静态函数和lambda表达式(匿名函数)</li><li>槽函数可以使用关键字进行声明：public slots、private slots、protected slots</li></ul><p>3.信号槽使用扩展：</p><ul><li><p>一个信号可以连接多个槽函数，发送一个信号有多个处理函数</p><ul><li>需要写多个connect连接</li><li>槽函数的执行顺序是随机的，和connect函数的调用顺序没有关系</li><li>信号的接收者可以是一个对象，也可以是多个对象</li></ul></li><li><p>一个槽函数可以连接多个信号，多个不同的信号，处理动作是相同的</p><ul><li>写多个connect就可以</li></ul></li><li><p>信号可以连接信号：信号接收者可以接收信号，继续发出新的信号，即传递了数据，并没有进行处理</p></li><li><p>信号槽是可以断开的，通过disconnect()函数，其与connect函数的参数一样</p></li></ul><p>4.参数的二义性问题：当某个类具有两个相同名字的信号，一个带参数，一个不带参数，那么接收该信号的类不知道该执行哪个槽函数，所以会报错，需要通过下面两种方法来解决：</p><ul><li>使用函数指针赋值，让编译器自动挑选符合类型的函数</li><li>使用static_cast强制转换，让编译器自动挑选符合类型的函数</li></ul><p>下面是一个窗口类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tea = <span class="keyword">new</span> <span class="built_in">teacher</span>(<span class="keyword">this</span>);      <span class="comment">//创建teacher类型对象</span></span><br><span class="line">    stu = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="keyword">this</span>);      <span class="comment">//创建Student类型对象</span></span><br><span class="line">    </span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>, <span class="keyword">this</span>);      <span class="comment">//以窗口为父对象，创建一个按钮1</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [&amp;]()&#123;       <span class="comment">//点击按钮触发信号</span></span><br><span class="line">       emit tea-&gt;<span class="built_in">hungry</span>();</span><br><span class="line">       emit tea-&gt;<span class="built_in">hungry</span>(<span class="string">&quot;kfc&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//connect(tea, &amp;teacher::hungry, stu, &amp;Student::treat);      //直接执行会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="built_in">void</span> (teacher::*tq)(QString) = &amp;teacher::hungry;       <span class="comment">//带参的函数指针，指向信号(也可以不带参)</span></span><br><span class="line">    <span class="built_in">void</span> (Student::*sq)(QString) = &amp;Student::treat;        <span class="comment">//带参的函数指针，指向槽函数(也可以不带参)</span></span><br><span class="line"><span class="built_in">connect</span>(tea, tq, stu, sq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：强制类型转换为想要的信号和槽函数(下面是转换为不带参的)</span></span><br><span class="line">    <span class="built_in">connect</span>(tea, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (teacher::*)()&gt;(&amp;teacher::hungry), stu, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (Student::*)()&gt;(&amp;Student::treat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面程序中也可以信号连接信号，如果有同名但参数不同的信号，还需要进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, tea, &amp;teacher::hungry);</span><br></pre></td></tr></table></figure><p>5.Qt4中的信号和槽</p><p>使用两个宏 SIGNAL和SLOT，它们的原理是将后面的参数转换成字符串，使用方式为：</p><p><code>connect(信号发送者, SIGNAL(函数原型), 信号接收者, SLOT(函数原型));</code></p><ul><li>好处：没有重载二义性的问题，有无参数可以直接写在connect里面</li><li>坏处：写错了，编译期间不报错(在项目中就很难排查错误)</li></ul><p>6.QDebug输出QString默认会转义，比如说当给信号传入的参数是<code>emit tea-&gt;hungry(&quot;kfc\r\n&quot;);</code>，控制台输出的也是<code>&quot;kfc\r\n&quot;</code>。</p><p>解决办法：</p><ul><li>将QString转成char*：<code>qDebug()&lt;&lt;&quot;请吃&quot;&lt;&lt;what.toUtf8().data();</code></li><li>使用qDebug().noquote()：<code>qDebug().noquote()&lt;&lt;&quot;请吃&quot;&lt;&lt;what;</code></li></ul><h2 id="5-2-定时器程序"><a href="#5-2-定时器程序" class="headerlink" title="5.2 定时器程序"></a>5.2 定时器程序</h2><p>下面是一个非自定义的信号与槽，所以就需要先手动在ui界面添加两个按钮和两个标签。然后通过系统提供的按钮信号来触发槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器对象</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);  <span class="comment">//new一个定时器对象，给其指定一个父对象(构成对象树，当析构MainWindow时，先析构timer)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改定时器对象的精度(可有可无)---&gt;添加后，显示时间时，1秒会只相差几毫秒，不然会相差有点大</span></span><br><span class="line">    timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);   <span class="comment">//PreciseTimer表示设置了最高精度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击loopBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())&#123;     <span class="comment">//如果定时器正在工作</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();         <span class="comment">//关闭定时器</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//定时器还没有工作</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);    <span class="comment">//启动定时器，1000ms==1s,即1秒发一个timeout信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>,[=]()&#123;        <span class="comment">//发出一个timeout信号处理该动作</span></span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();                <span class="comment">//得到当前的一个时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);    <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">        ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);                    <span class="comment">//在标签上显示时间(动态显示，因为每1秒会发timeout)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击onceBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//获取2s以后的系统时间</span></span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">            QTime tm = QTime::<span class="built_in">currentTime</span>();              <span class="comment">//得到当前的一个时间</span></span><br><span class="line">            QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);  <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">            ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);                 <span class="comment">//在标签上显示时间(静态显示，只有按下按钮才发信息)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-QMainWindow"><a href="#6-QMainWindow" class="headerlink" title="6. QMainWindow"></a>6. QMainWindow</h1><p>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏(menu bar)、多个工具栏(tool bars)、多个停靠部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。具体结果如下：</p><p><img src="/.online//图床数据\Qt\8_3.png"></p><p>1.下面创建了一个窗口类MainWindow，继承的基类是QMainWindow，在该窗口中添加各个部件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏，获取当前窗口的菜单栏，没有的话会自动创建一个</span></span><br><span class="line">    QMenuBar *mb = <span class="keyword">this</span>-&gt;<span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    QMenu *menuFile = mb-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * menuEdit = mb-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">    <span class="comment">//往菜单里面添加菜单项</span></span><br><span class="line">    QAction *actionNew = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    QAction *actionOpen = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加分隔符</span></span><br><span class="line">    menuFile-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"></span><br><span class="line">    QAction *actionRename = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;重命名&quot;</span>);    <span class="comment">//菜单项</span></span><br><span class="line">    <span class="comment">//添加二级菜单</span></span><br><span class="line">    QMenu *menuRecent = menuFile-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;最近打开的文件&quot;</span>);</span><br><span class="line">    menuRecent-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏(可以拖动)，可以有多个</span></span><br><span class="line">    QToolBar *toolBar = <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//工具栏添加工具</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(actionNew);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(actionOpen);</span><br><span class="line">    <span class="comment">//默认停靠在左边</span></span><br><span class="line">    <span class="comment">//this-&gt;addToolBar(Qt::LeftToolBarArea, toolBar);</span></span><br><span class="line">    <span class="comment">//只允许停靠在左边或者右边</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftToolBarArea|Qt::RightToolBarArea);</span><br><span class="line">    <span class="comment">//设置工具栏不可以浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置工具栏不允许拖动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏只有一个，这种就可以不需要添加</span></span><br><span class="line">    QStatusBar *sb = <span class="keyword">this</span>-&gt;<span class="built_in">statusBar</span>();           <span class="comment">//获取窗口的状态栏</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加信息</span></span><br><span class="line">    <span class="comment">//添加左侧信息</span></span><br><span class="line">    QLabel *labelLeft = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;左侧信息&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    sb-&gt;<span class="built_in">addWidget</span>(labelLeft);</span><br><span class="line">    <span class="comment">//添加右侧信息</span></span><br><span class="line">    QLabel *labelRight = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧信息&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    sb-&gt;<span class="built_in">addPermanentWidget</span>(labelRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停靠部件(可以拖动)，可以有多个</span></span><br><span class="line">    QDockWidget *dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;停靠部件&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//默认情况下没有核心部件作为参照物，停靠部件就会占完窗口</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea, dockWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加核心部件</span></span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个编辑框</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.UI文件的使用</p><p>创建项目时保留UI，setupUI函数就是关联UI文件的代码到程序，原理就是qt将ui文件转化成了c++代码。</p><p>3.资源文件使用</p><p>创建资源文件：新建 —–&gt; Qt —–&gt; Qt Resource  File —–&gt; 名称为res</p><h1 id="7-QDialog对话框"><a href="#7-QDialog对话框" class="headerlink" title="7. QDialog对话框"></a>7. QDialog对话框</h1><p>对话框是GUI程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中，比如用于完成一次性任务的功能(如登录功能、现在某个文件打开、保存文件)。对话框通常会是一个顶层窗口，出现在程序最上层，用于实习短期任务或者简洁的用户交互。</p><p>Qt中使用QDialog类实现对话框，但是声明一个QDialog对象的时候，不管这个对话框对象跟哪个窗口建立了父子关系，当它显示出来的时候都还是一个顶层的窗口。</p><p>1.对话框没有最大化、最小化按钮的窗口，其可以分为<code>模态对话框</code>和<code>非模态对话框</code>：</p><ul><li>模态对话框：就是对话框还没有关闭前不能操作同一个进程的其它窗口<ul><li>创建模态：QDialog::exec()函数，是一个阻塞的消息循环函数</li></ul></li><li>非模态对话框：就是对话框没有关闭前也能操作同一个进程的其它窗口<ul><li>使用show()函数来直接显示窗口就可以，非阻塞的情况下要使用new的方式来创建对话框对象，不然容易随着所在区域的释放而释放。</li><li>内存泄漏问题，模态对话框关闭后可能并不会马上释放，所以就得通过设置窗口的属性来让其关闭后自动释放：<ul><li><code>dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);</code></li></ul></li></ul></li></ul><p>下面通过两个按钮的发送信号来触发槽函数，从而实现创建模态和非模态对话框</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_model_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个模态对话框</span></span><br><span class="line">    <span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;hello model dialog&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_nonmodel_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个非模态对话框</span></span><br><span class="line">    <span class="comment">//因为show()是非阻塞的函数，所以当dlg所在的区域释放后，dlg对话框也会释放，得通过new创建</span></span><br><span class="line">    <span class="comment">//QDialog dlg(this);</span></span><br><span class="line">    QDialog *dlg = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//释放问题，只有父对象释放的时候子对象才在释放</span></span><br><span class="line">    dlg-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);       <span class="comment">//通过设置窗口的属性，让它关闭的时候自动释放</span></span><br><span class="line">    dlg-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;hello nonmodel dialog&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.系统标准对话框</p><p>QMessageBox用来提示用户某条信息，分为以下几种：</p><ul><li>错误提示框：<code>QMessageBox::critical();</code></li><li>警告提示框：<code>QMessageBox::warning();</code></li><li>信息提示框：<code>QMessageBox::information();</code></li><li>问题提示框：<code>QMessageBox::question();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数依次是：父对象窗口；提示框标题；提示框提示的信息</span></span><br><span class="line">QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;错误&quot;</span>, <span class="string">&quot;critical&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;警告&quot;</span>, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;信息&quot;</span>, <span class="string">&quot;information&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;ONE PIECE&quot;</span>, <span class="string">&quot;Does it really exist?&quot;</span>, QMessageBox::Ok|QMessageBox::Cancel);</span><br></pre></td></tr></table></figure><p>问题提示框相较于其它几个提示框比较特殊，可以指定对话框的按钮，通过返回值来获取用户点击了哪个按钮。</p><p>3.文件对话框</p><p>使用QFileDialog来打开一个文件对话框，常用的函数是getOpenFileName来选择单一某文件，返回值是用户选择的文件路径。</p><p>在下面程序的中，设置的过滤器表示为将打开的目录种类分为PNG、ICO和all类型，默认先显示的是PNG类别的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认打开的是当前项目所在的文件</span></span><br><span class="line">QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开一个文件&quot;</span>);</span><br><span class="line"><span class="comment">//参数3和参数4是可选的，参3是设置打开的目录，参4是过滤器，将打开目录分为设置的机种类别</span></span><br><span class="line">QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开一个文件&quot;</span>, <span class="string">&quot;C:\\Qt\\Bird&quot;</span>, <span class="string">&quot;PNG (*.png) ;; ICO (*.ico) ;; all (*.*)&quot;</span>);</span><br></pre></td></tr></table></figure><p>4.布局</p><p>有如下两类布局：</p><ul><li>静态：就是位置和大小不会跟着外部窗口变化而变化</li><li>动态：就是位置和大小会跟着外部窗口变化而变化</li></ul><p>常用的动态布局：水平、垂直、栅格、表单布局，推荐使用widget的自带的布局功能</p><p>使用弹簧来调整布局的位置(居中)，栅格布局可以将空间分为几行几列的表格，方便对齐</p><p>大小策略：默认情况下动态布局，子窗口的大小会跟着父窗口的大小变化而变化，调整水平或垂直策略，变为固定</p><p>调整子窗口和父窗口之间的间隙，设置父窗口的margin，调整子窗口之间的间隙就调整spacing</p><p>调整窗口的固定大小，就是将窗口的最大值和最小值都设为同一个值</p><p>5.按钮组</p><ul><li><p>radio button单选按钮：互斥域的问题，如果想将某些单选按钮隔离开，就用容器将它们隔离，一般用Group Box</p></li><li><p>check box多选按钮：有三态(tristate)，每次点击按钮的时候stateChange信号里边传进来</p></li></ul><p>6.QListWidget窗口</p><p>往ListWidget窗口中添加内容有两种方式：</p><ul><li>往ListWidget窗口中，通过addItem添加QListWidgetItem对象(一个一个添加，可以修改item的属性)</li><li>往ListWidget窗口中，通过addItems添加QStringList对象(一次性添加多个，不可以修改item的属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次性添加一个</span></span><br><span class="line">QListWidgetItem *item = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;嘻嘻哈哈&quot;</span>);</span><br><span class="line">item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignHCenter);         <span class="comment">//这是设置了item居中显示</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性添加多个</span></span><br><span class="line">QStringList list;</span><br><span class="line">list&lt;&lt;<span class="string">&quot;嘻嘻哈哈&quot;</span>&lt;&lt;<span class="string">&quot;叽叽喳喳&quot;</span>&lt;&lt;<span class="string">&quot;把卡把卡&quot;</span>;</span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItems</span>(list);</span><br></pre></td></tr></table></figure><p>7.treeWidget窗口</p><ul><li>设置标题，会根据setHeaderLabels函数里面的成员数生成对应的列数</li><li>添加根节点通过addTopLevelItem函数</li><li>根节点下面添加子节点通过addChild函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设置标题</span></span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">setHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;简介&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加跟节点</span></span><br><span class="line">QTreeWidgetItem *liliangItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;力量&quot;</span>);</span><br><span class="line">QTreeWidgetItem *minjieItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;敏捷&quot;</span>);</span><br><span class="line">QTreeWidgetItem *zhiliItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;智力&quot;</span>);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(liliangItem);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(minjieItem);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(zhiliItem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加相应的子节点</span></span><br><span class="line">QStringList heroL1, heroL2, heroM1, heroM2, heroZ1, heroZ2;</span><br><span class="line">heroL1&lt;&lt;<span class="string">&quot;亚瑟&quot;</span>&lt;&lt;<span class="string">&quot;对拼刺刀&quot;</span>;</span><br><span class="line">heroL2&lt;&lt;<span class="string">&quot;坦克&quot;</span>&lt;&lt;<span class="string">&quot;血条厚&quot;</span>;</span><br><span class="line">heroM1&lt;&lt;<span class="string">&quot;李白&quot;</span>&lt;&lt;<span class="string">&quot;花里胡哨&quot;</span>;</span><br><span class="line">heroM2&lt;&lt;<span class="string">&quot;刺客&quot;</span>&lt;&lt;<span class="string">&quot;太秀了&quot;</span>;</span><br><span class="line">heroZ1&lt;&lt;<span class="string">&quot;孙策&quot;</span>&lt;&lt;<span class="string">&quot;无证驾船&quot;</span>;</span><br><span class="line">heroZ2&lt;&lt;<span class="string">&quot;上单&quot;</span>&lt;&lt;<span class="string">&quot;横冲直撞&quot;</span>;</span><br><span class="line">liliangItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL1));</span><br><span class="line">liliangItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL2));</span><br><span class="line">minjieItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroM1));</span><br><span class="line">minjieItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroM2));</span><br><span class="line">zhiliItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroZ1));</span><br><span class="line">zhiliItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroZ2));</span><br></pre></td></tr></table></figure><p>得到的效果图如下</p><p><img src="/.online//图床数据\Qt\8_4.png"></p><p>8.tableWidget窗口</p><ul><li>设置行数通过setRowCount()函数、设置列数通过setColumnCount()函数</li><li>设置水平的标题通过setHorizontalHeaderLabels()函数</li><li>设置表格某行某列的数据setItem(row, col, item)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置行数、列数</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(<span class="number">5</span>);</span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//设置标题</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;性别&quot;</span>&lt;&lt;<span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">QStringList heroNames = <span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;亚瑟&quot;</span>&lt;&lt;<span class="string">&quot;妲己&quot;</span>&lt;&lt;<span class="string">&quot;安其拉&quot;</span>&lt;&lt;<span class="string">&quot;赵云&quot;</span>&lt;&lt;<span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">QStringList herogenders = <span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;男&quot;</span>&lt;&lt;<span class="string">&quot;女&quot;</span>&lt;&lt;<span class="string">&quot;女&quot;</span>&lt;&lt;<span class="string">&quot;男&quot;</span>&lt;&lt;<span class="string">&quot;雄性&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">5</span>; row++)&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(heroNames[row]));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(herogenders[row]));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(row + <span class="number">18</span>)));     <span class="comment">//需要将整数转为string类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果图如下：</p><p><img src="/.online//图床数据\Qt\8_5.png" alt="8_5"></p><p>9.容器</p><p>stacked Widget 页面切换需要我们自己去实现，一般使用按钮点击的时候切换，通过setCurrentIndex()方式切换到第几页，序号从0开始</p><p>10、显示控件</p><ul><li><p>label可以显示静态图，通过pixmap属性即可完成</p></li><li><p>label也可以显示动态图gif，需要先创建movie对象，再通过setMovie()函数设置电影，最后通过start()函数来播放动画</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMovie *movie = new QMovie(&quot;:/Image/mario.gif&quot;, QByteArray(), this);</span><br><span class="line">ui-&gt;label_1-&gt;setMovie(movie);</span><br><span class="line">movie-&gt;start();</span><br></pre></td></tr></table></figure><p>11.自定义控件</p><p>当系统提供的控件不能满足我们生产中的一个功能时，就需要自己创建一些控件。</p><p>比如说一个自定义一个按钮控件，需要先创建一个自定义按钮类MyButton，让它继承QPushButton类，在MyButton类的析构函数中实现一些想要的功能，最后将主窗口中的按钮(QPushButton类)提升为MyButton类，这样就可以实现自定义按钮的一些功能了。</p><h1 id="8-事件"><a href="#8-事件" class="headerlink" title="8. 事件"></a>8. 事件</h1><p>事件(event)是由系统或者Qt应用程序本身在不同的时刻发出的。当用户按下鼠标、敲下键盘、或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>在所有组件的父类QWidget中，定义了很多事件处理的函数，如：</p><ul><li>keyPressEvent()：键盘按键按下事件</li><li>keyReleaseEvent()：键盘按键松开事件</li><li>mouseDoubleClickEvent()：鼠标双击事件</li><li>mouseMoveEvent()：鼠标移动事件</li></ul><p>1.在下面程序中，先创建一个主窗口widget，将一个Label标签拖入其中，再创建一个自定义标签类MyLabel，使它继承QLabel类，然后在该类里面添加对应的事件功能函数，最后将主窗口的Label标签提升为自定义标签类MyLabel。</p><p>自定义标签类的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//重写鼠标按键处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//重写鼠标移动的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//重写event分发函数(事件的分发机制)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写事件过滤器eventFilter</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义标签对应的事件函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">MyLabel::<span class="built_in">MyLabel</span>(QWidget *parent) : <span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，窗口不会主动跟踪鼠标(鼠标进入窗口，先不会触发任何事件)</span></span><br><span class="line">    <span class="comment">//只有当某个鼠标按键按下的情况下才开始跟踪</span></span><br><span class="line">    <span class="comment">//如果想一开始跟踪，就要使用以下函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事件过滤器的使用</span></span><br><span class="line">    <span class="comment">//1.窗口调用installEventFilter来安装一个事件过滤器</span></span><br><span class="line">    <span class="comment">//2.参数是一个事件过滤器对象QObject,该对象的类要重写eventFilter的函数</span></span><br><span class="line">    <span class="comment">//事件过滤的时候，事件会先到达事件过滤器的eventFilter函数</span></span><br><span class="line">    <span class="comment">//返回值：true表示拦截，false表示不拦截，不拦截情况下事件会继续到达窗口</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);       <span class="comment">//将当前窗口安装过滤器，对象可以使用自己作为自己的过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标坐标</span></span><br><span class="line">    <span class="type">int</span> x = ev-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y = ev-&gt;<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标按键</span></span><br><span class="line">    Qt::MouseButton btn = ev-&gt;<span class="built_in">button</span>();       <span class="comment">//单个事件</span></span><br><span class="line">    QString strbutton = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::LeftButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;LeftButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::RightButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;RightButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::MidButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;MidButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;pres[%1,%2][%3]&quot;</span>).<span class="built_in">arg</span>(x).<span class="built_in">arg</span>(y).<span class="built_in">arg</span>(strbutton);            <span class="comment">//label也可以显示html</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标坐标</span></span><br><span class="line">    <span class="type">int</span> x = ev-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y = ev-&gt;<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标按键</span></span><br><span class="line">    Qt::MouseButtons btns = ev-&gt;<span class="built_in">buttons</span>();      <span class="comment">//多个事件</span></span><br><span class="line">    QString strbutton = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::LeftButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;LeftButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::RightButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;RightButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::MidButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;MidButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;move[%1,%2][%3]&quot;</span>).<span class="built_in">arg</span>(x).<span class="built_in">arg</span>(y).<span class="built_in">arg</span>(strbutton);            <span class="comment">//label也可以显示html</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLabel::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回值：true表示该事件得到处理，如果是false，表示没有被处理，事件会继续传递到父窗口</span></span><br><span class="line">    <span class="comment">//QEvent就是所有事件(event类)的父亲</span></span><br><span class="line">    <span class="comment">//判断event的类型</span></span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>() == QEvent::MouseMove)&#123;          <span class="comment">//如果是鼠标移动事件</span></span><br><span class="line">        <span class="comment">//如果注释掉下面这一行，将对鼠标移动事件起到屏蔽作用，因为当我们在主窗口移动鼠标的时候，该事件会先经过我们重写的分发函数，因为我们对该事件没有进行处理，直接就返回了，所以系统啥都不会做，如果是其它事件，因为这里我们没有处理其它事件的函数，所以会调用父类的分发函数去实现处理，一样会生效起作用。</span></span><br><span class="line">        <span class="comment">//this-&gt;mouseMoveEvent(static_cast&lt;QMouseEvent *&gt;(e));    //调用鼠标移动处理函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);      <span class="comment">//其它事件这里没有处理，所以就给父类的分发函数去处理其它事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装了该过滤器的窗口都会执行该函数，所以一个过滤器可能会有多个窗口使用，则参数1(watched)表示目前传过来的窗口对象，参2则是存储触发事件的一些信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLabel::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::MouseMove)&#123;</span><br><span class="line">        <span class="comment">//返回ture表示拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定时器事件timerEvent</p><p>闹钟就是定时器，闹钟响了就是定时器事件</p><p>在头文件中需要重写定时器事件：<code>void timerEvent(QTimerEvent* event);</code>里面实现的功能即为定时器时间到后执行的操作</p><p>在需要的位置通过startTimer来启动一个定时器，返回值就是定时器的id，参数是毫秒，每隔相应的时间就会触发一次定时器事件</p><p>通过函数killtimer()来杀死一个定时器，参数就是要杀死定时器的id</p><p>timerEvent定时器事件处理函数中可以通过event参数获取到当前事件是哪个定时器发出的，如：event-&gt;timerId()</p><p>3.系统封装好的定时器QTimer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);       <span class="comment">//创建定时器对象</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;lcdNumber-&gt;<span class="built_in">display</span>(num++);        <span class="comment">//主窗口的lcd插件显示对应的数字</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_start_clicked</span><span class="params">()</span>         <span class="comment">//start按钮触发的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">10</span>);                   <span class="comment">//启动定时器，10毫秒发出一次信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_end_clicked</span><span class="params">()</span>           <span class="comment">//end按钮触发的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();                      <span class="comment">//停止定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.绘图事件</p><ul><li><p>什么时候画</p><ul><li>绘图事件：窗口需要重新显示的时候(大小发生变化、窗口切换等)，就会收到一个绘图事件paintEvent，收到绘图事件之后，窗口就要将自己画出来。</li></ul></li><li><p>怎么画</p><ul><li>通过定义一个画家QPainter，给出一个画图设备QPaintDevice(窗口)作为参数。</li></ul></li></ul><p>5.创建了一个窗口Widget，在该窗口头文件重写了画图事件，下面为该画图事件函数里面的功能实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个画家，绘图设备为当前窗口</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画家偏移，搬动画家到某个坐标上开始画画</span></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">100</span>,<span class="number">0</span>);      <span class="comment">//现在默认窗口的(100,0)为画家的起点了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一支画笔</span></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));     <span class="comment">//设置颜色</span></span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);                   <span class="comment">//设置笔宽</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DashLine);        <span class="comment">//设置画笔的风格</span></span><br><span class="line">    <span class="comment">//画家设置画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个画刷(用来填充)</span></span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setColor</span>(Qt::cyan);            <span class="comment">//填充的颜色</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::Dense4Pattern);   <span class="comment">//默认情况下，画刷不会填充，还得设置风格</span></span><br><span class="line">    <span class="comment">//画家设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画一条线</span></span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);       <span class="comment">//起点为(0,0)，终点为(100,100)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">50</span>);       <span class="comment">//左上角点为(20,20)，长为50，宽为50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画圆形，使用椭圆(自己调整)</span></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>),<span class="number">50</span>,<span class="number">50</span>);     <span class="comment">//圆心，x轴半径，y轴半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画文字</span></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">200</span>, <span class="number">100</span>, <span class="string">&quot;好好学习，天天向上&quot;</span>);     <span class="comment">//文字坐标，文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.手动触发绘图事件</p><p>在一些应用场景，我们或许希望能手动的触发绘图事件，而不是等到窗口发生变化再触发绘图事件，所以就可以使用下面方法完成。</p><ul><li>可以使用两个函数<ul><li>repaint：会马上触发绘图事件，当某一处函数调用了多次repaint时，会触发多次绘图事件</li><li>update：update做了一些优化，当某一处函数调用了多次update时，只会触发一次绘图事件</li></ul></li></ul><p>注意：不要再绘图事件paintEvent()函数中再触发绘图事件，会导致无线循环</p><p>下面程序实现了将本地存在的图片绘制到窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//painter绘制已经存在到达图片</span></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;C:\\Qt\\素材\\llfcchat-master\\llfcchat-master\\client\\llfcchat\\res\\head_5.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,<span class="number">0</span>,pixmap);</span><br></pre></td></tr></table></figure><p>7.绘图设备</p><p>绘图设备是指继承QPainterDevice的子类，Qt一共提供了4个这样的类，分别是QPixmap、QBitmap、QImage和QPicture，其中：</p><ul><li>QPixmap专本为图像在屏幕上的显示做了优化</li><li>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</li><li>QImage专门为图像的像素级访问做了优化</li><li>QPicture则可以记录和重现QPainter的各条命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是Qt&quot;&gt;&lt;a href=&quot;#1-1-什么是Qt&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Qt" scheme="https://lxx93.online/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>c++并发编程(下)</title>
    <link href="https://lxx93.online/2024/08/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8B)/"/>
    <id>https://lxx93.online/2024/08/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</id>
    <published>2024-08-01T16:22:33.000Z</published>
    <updated>2024-08-06T15:40:28.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引用计数实现无锁并发栈"><a href="#1-引用计数实现无锁并发栈" class="headerlink" title="1. 引用计数实现无锁并发栈"></a>1. 引用计数实现无锁并发栈</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>在C++并发编程中提出了两种计数，一种是外部计数，一种是内部计数，二者加起来就是有效的引用计数，下面提出一种新的方法，利用引用计数实现无锁并发的栈。</p><h2 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h2><p>栈结构函数：栈函数里面实现了栈的默认构造函数、析构函数和创建了一个原子类型的头部节点，同时也定义好了栈的内部节点类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single_ref_stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">single_ref_stack</span>():<span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;        <span class="comment">//默认构造函数</span></span><br><span class="line">    ~<span class="built_in">single_ref_stack</span>() &#123;                      <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">pop</span>());     <span class="comment">//循环出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;                      <span class="comment">//引用节点(栈的内部节点)</span></span><br><span class="line">        std::shared_ptr&lt;T&gt;  _data;         <span class="comment">//1 数据域智能指针</span></span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; _ref_count;       <span class="comment">//2 引用计数</span></span><br><span class="line">        ref_node* _next;                   <span class="comment">//3  下一个节点</span></span><br><span class="line">        <span class="comment">//构造函数，接收外部传来的数据，根据数据构造一个节点</span></span><br><span class="line">        <span class="built_in">ref_node</span>(T <span class="type">const</span>&amp; data_):_data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)), _ref_count(<span class="number">1</span>), _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//头部节点</span></span><br><span class="line">    std::atomic&lt;ref_node*&gt; head;           <span class="comment">//会被多个线程操作，设为原子类型的头部节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>push操作函数：这段程序就是解决两个线程同时push的情况，但同一时刻也只有一个线程会成功，那么另一个线程在while进行比较的时候，就会发现它的new_node的next与head不相等，那么它就会继续循环，而且将新的head值赋值给new_node的next，这样在没有其它线程抢先指向while的话，该线程就会更新head的值，将head指向了它的new_node，并退出循环，这样该线程就完成了节点的push。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;              <span class="comment">//参数是要push的T类型的数据</span></span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">ref_node</span>(data);      <span class="comment">//通过data创建出一个新的ref_node类型节点，并得到其指针</span></span><br><span class="line">    new_node-&gt;next = head.<span class="built_in">load</span>();            <span class="comment">//新节点的next要指向头部节点</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next, new_node));     <span class="comment">//通过重试的方式更新头部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作函数：在下面程序中，是通过引用计数为0或1来判断该节点是否可以直接delete。比如说当线程1进入2处的if，线程2这时候就只能进入7处else，如果线程1在4处，将引用计数-2后，发现还等于1，那么线程1是回收不了该节点的，此时如果线程2发现该节点的引用计数为1，则此时只有它在访问该节点，所以线程2就可以进行回收。但当线程1执行4处时，引用计数为0，说明只有它在访问，这样线程1就可以对该节点进行回收。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node* old_head = head.<span class="built_in">load</span>();             <span class="comment">//先取出头部元素</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!old_head) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();          <span class="comment">//如果为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 只要执行pop就对引用计数+1</span></span><br><span class="line">        ++(old_head-&gt;_ref_count);</span><br><span class="line">        <span class="comment">//2 比较head和old_head想等则交换，更新head,返回true；否则说明head已经被其他线程更新,返回false</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, old_head-&gt;_next)) &#123;</span><br><span class="line">            <span class="comment">//此时head已经为old_head的next了</span></span><br><span class="line">            <span class="keyword">auto</span> cur_count = old_head-&gt;_ref_count.<span class="built_in">load</span>();    <span class="comment">//取出原来头部节点的引用计数</span></span><br><span class="line">            <span class="keyword">auto</span> new_count;</span><br><span class="line">            <span class="comment">//3  循环重试保证引用计数安全更新</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//4 减去本线程增加的1次和初始的1次,如果为0，说明没有其它线程访问该节点</span></span><br><span class="line">                new_count = cur_count - <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!old_head-&gt;_ref_count.<span class="built_in">compare_exchange_weak</span>(cur_count,  new_count));</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;            <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(old_head-&gt;_data);    <span class="comment">//5 交换数据，取出要删除节点old_head的值，此时old_head的值为0了</span></span><br><span class="line">            <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count == <span class="number">0</span>) &#123;    <span class="comment">//继续判断，如果此时old_head的引用计数还为0，就delete掉</span></span><br><span class="line">                <span class="keyword">delete</span> old_head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//7 </span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> old_head;     <span class="comment">//如果判断引用计数等于1的，说明也只有它应该在使用该节点，也可以直接delete</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上pop操作函数的大体流程如下：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_7.png" style="zoom:67%;"><p>从流程上来看，该程序存在着很大的问题，在刚开没有pop前，所有节点的引用计数都为1；如果两个线程进入pop函数后，head的引用计数进行++，变为了3，此时线程1的old_head和线程2的old_head都指向head；当线程1先执行操作2时，它会更新head的指向，并且进入if程序里面，而线程2再来执行操作2时，因为此时的head被更改了，所以它会将它的old_head执行新的head，并执行else里面的程序，这时线程1将引用计数减2后为1，它就负责只将要删除的节点值返回，而没有delete掉要删除的节点(原头节点)，以为线程2会delete掉该节点，而线程2判断当前old_head指向的节点引用计数为1，它以为指向的是原节点，所以就会直接delete，但指向的是要删除节点的下一个节点，这样系统就会崩溃。</p><p>所以为了解决这些问题，可以将引用计数提出来，不放在指针里，和指针解耦。下面程序是将原来的节点结构拆成两个，并且新增<code>_dec_count</code>表示减少的引用计数，放在node结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt;  _data;          <span class="comment">//1 数据域智能指针</span></span><br><span class="line">    ref_node _next;                     <span class="comment">//2  下一个节点</span></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : _data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt;  _dec_count;       <span class="comment">//减少的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;</span><br><span class="line">    <span class="type">int</span> _ref_count;                <span class="comment">// 引用计数</span></span><br><span class="line">    node* _node_ptr;</span><br><span class="line">    <span class="built_in">ref_node</span>( T <span class="type">const</span> &amp; data_):_node_ptr(<span class="keyword">new</span> <span class="built_in">node</span>(data_)), _ref_count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ref_node</span>():_node_ptr(<span class="literal">nullptr</span>),_ref_count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//头部节点</span></span><br><span class="line">std::atomic&lt;ref_node&gt; head;            <span class="comment">//将栈中的head结构变为ref_node类型的原子变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ref_node new_head;               <span class="comment">//1 只要执行pop就对引用计数+1并更新到head中</span></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_head = old_head;</span><br><span class="line">            new_head._ref_count += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, new_head));</span><br><span class="line">        old_head = new_head;</span><br><span class="line">        <span class="keyword">auto</span>* node_ptr = old_head._node_ptr;       <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (node_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  std::<span class="built_in">shared_ptr</span>&lt;T&gt;();        <span class="comment">//为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 比较head和old_head相等则交换否则说明head已经被其他线程更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, node_ptr-&gt;_next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;             <span class="comment">//要返回的值</span></span><br><span class="line">            res.<span class="built_in">swap</span>(node_ptr-&gt;_data);          <span class="comment">//交换智能指针</span></span><br><span class="line">            <span class="type">int</span> increase_count = old_head._ref_count - <span class="number">2</span>;      <span class="comment">//5 增加的数量 </span></span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_add</span>(increase_count) == -increase_count) &#123;  <span class="comment">//6 </span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;    <span class="comment">//7</span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-内存模型回顾"><a href="#2-内存模型回顾" class="headerlink" title="2. 内存模型回顾"></a>2. 内存模型回顾</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>之前实现的那些无锁并发的栈结构，它们对于原子变量的读，写以及读改写操作默认采用的是<code>memory_order_seq_cst</code>，<code>memory_order_seq_cst</code>为全局顺序模型，即所有线程看到的执行顺序是一致的。这种模型对性能消耗较大，所以可以在无锁栈的基础上通过更为宽松的模型提升性能。</p><h2 id="2-2-release-acquire同步"><a href="#2-2-release-acquire同步" class="headerlink" title="2.2 release-acquire同步"></a>2.2 release-acquire同步</h2><p>在之前了解的6中内存顺序，其中可以通过<code>release</code>和<code>acquire</code>的方式实现同步的效果。也就是说，线程A执行store操作，采用<code>memory_order_release</code>顺序模型，线程B执行load操作采用<code>memory_order_acquire</code>顺序模型。如果线程B的load操作读取到线程A的store操作的数值，就可以称线程A的store操作 synchronizes-with(同步) 线程B的load操作。</p><h2 id="2-3-happens-before先行"><a href="#2-3-happens-before先行" class="headerlink" title="2.3 happens-before先行"></a>2.3 happens-before先行</h2><p>如果 a-&gt;store 同步于 b-&gt;load， 则 a-&gt;store 先行于 b-&gt;load。只要同步就能推出先行，所谓先行就是逻辑执行的顺序，一定是a-&gt;store 先于 b-&gt;load。先行还包括一种情况，sequenced-before(顺序执行)， 所谓顺序执行就是单线程中执行的顺序为从上到下的顺序。</p><p>先行具有传递性 操作1 <code>happens-before</code> 操作2，操作2 <code>happens-before</code> 操作3，则操作1 <code>happens-before</code> 操作3</p><p>在下面程序中， 操作2处使用了release内存序，保证操作1会排在操作2之前。 操作3采用了acquire内存序，保证操作4排在操作3之后，且如果操作3能读到操作2的写入值，则保证操作1已经先于操作3执行完。因为while重试的机制，保证操作2同步于操作3，即操作2先于操作3执行，又因为操作1先于操作2执行，而操作3先于操作4执行，所以得出操作1先于操作4执行，那么操作4处断言正确就不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>;                                           <span class="comment">//1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release);            <span class="comment">//2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.load(std::memory_order_acquire));       <span class="comment">//3 </span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>);                                  <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-释放序列的扩展"><a href="#2-4-释放序列的扩展" class="headerlink" title="2.4 释放序列的扩展"></a>2.4 释放序列的扩展</h2><blockquote><p>如果存储操作的标记是memory_order_release、memory_order_acq_rel或memory_order_seq_cst，而载入操作则以memory_order_consume、memory_order_acquire或memory_order_seq_cst标记，这些操作前后相扣成链，每次载入的值都源自前面的存储操作，那么该操作链由一个<strong>释放序列</strong>组成。若最后的载入操作服从内存次序memory_order_acquire或memory_order_seq_cst，则最初的存储操作与它构成同步关系。但如果该载入操作服从的内存次序是memory_order_consume，那么两者构成前序依赖关系。操作链中，每个“读-改-写”操作都可选用任意内存次序，甚至也能选用memory_order_relaxed次序。</p></blockquote><p>release-sequnece：针对一个原子变量M的release操作A完成后, 接下来M上可能还会有一连串的其他操作。如果这一连串操作是由</p><ol><li>同一线程上的写操作</li><li>或者任意线程上的 read-modify-write(可以是任意内存顺序) 操作</li></ol><p>这两种构成的，则称这一连串的操作为以release操作A为首的release sequence。这里的写操作和read-modify-write操作可以使用任意内存顺序。</p><p>同步：一个acquire操作在同一个原子变量上读到了一个release操作写入的值，或者读到了以这个release操作为首的release sequence写入的值，那么这个release操作 “synchronizes-with” 这个 acquire 操作。所以release-sequence不一定构成同步，只有acquire到release的值才算作同步。</p><p>下面程序中，在入队函数的操作1处使用的是<code>memory_order_release</code>内存序来记录入队的数量，这样一方面保证了它之前的代码都执行完了，另一方在出队函数的操作3处有<code>memory_order_acquire</code>的载入操作，这样它们就构成了同步关系。<code>fetch_sub</code>是一个原子操作函数，用于从原子变量 <code>count</code> 的当前值中减去指定的值，即1，并返回操作前的原始值。所以就可以通过该函数来完成队列数据的读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; queue_data;                <span class="comment">//存储数据的队列</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;                     <span class="comment">//记录入队的数量</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; store_finish = <span class="literal">false</span>;     <span class="comment">//表示是否存储完成</span></span><br><span class="line"><span class="comment">//入队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> number_of_items = <span class="number">20</span>;</span><br><span class="line">    queue_data.<span class="built_in">clear</span>();                     <span class="comment">//队列清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_items; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        queue_data.<span class="built_in">push_back</span>(i);       <span class="comment">//从0到20，往队列放入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 最初的存储操作</span></span><br><span class="line">    count.<span class="built_in">store</span>(number_of_items, std::memory_order_release); <span class="comment">//记录入队数量，内存序用的是memory_order_release</span></span><br><span class="line">    store_finish.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);   <span class="comment">//将store_finish置未true，不太关注时效性和同步性，所以就用宽松的内存序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2 循环等待存储完成，使用的是宽松的内存序</span></span><br><span class="line">        <span class="keyword">while</span> (!store_finish.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">        <span class="type">int</span> item_index;</span><br><span class="line">        <span class="comment">//3 读—改—写”操作</span></span><br><span class="line">        <span class="keyword">if</span> ((item_index = count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acquire)) &lt;= <span class="number">0</span>)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">//当count为0的时候，会执行到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 从内部容器queue_data 读取数据项是安全行为</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;queue_data is  &quot;</span> &lt;&lt; queue_data[item_index<span class="number">-1</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_8.png" style="zoom:67%;"><p>从打印结果可以看到消费者线程b和c并没有打印重复的数据，说明他们互斥访问count，每个线程取到的count不一样进而访问queue_data中的不同数据。</p><p>如果单从线程角度考虑，b和c并不能构成同步，但是线程b和c必然有一个线程会先执行执行fetch_sub(原子变量的操作任何顺序模型都能保证操作的原子性)。假设b先执行，和a构成release-sequence关系，b读取到a执行的count.store的结果， b处于以a线程的release为首的释放序列中，则b的store操作会和c的读-改-写(fetch操作，只限这一段代码)构成同步。</p><p>如下图所示：实线表示先行关系，虚线标识释放序列</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_9.jpg" style="zoom:67%;"><p>结论如下：</p><ol><li>a线程和b线程构成release-sequence的释放序列。</li><li>即使b线程和c线程不构成同步，但是b线程的读改写操作处于release-sequence中，且c线程采用acquire方式读改写，则b的读改写和c线程的读改写构成同步，以a线程的release为首的sequence序列和c线程的读改写构成同步。</li><li>这里要强调一点，如果a release-sequence b，a和b不一定构成同步，但是b sychronizes with c，则a synchronizes with c。也就是说处于release序列中的任意读改写操作和其他的线程构成同步，那么我们就能得出release-sequence为首的操作和其他线程同步。</li></ol><h1 id="3-优化无锁栈"><a href="#3-优化无锁栈" class="headerlink" title="3. 优化无锁栈"></a>3. 优化无锁栈</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>对于想要更好的优化无锁栈，可以结合释放序列这一技术来完成。当有数据入栈时，那么pop时要读取最新入栈的数据。所以我们要让push操作同步给pop操作，想到的办法很简单，push对head的修改采用release内存序列，pop对head的读改写采用acquire内存序列。多个线程并发pop，执行读改写操作，这些线程本来是无法同步的，但是最先pop的线程会和push线程构成同步关系，且形成release-sequence。那之后的线程pop就会和第一个pop的线程的写操作形成同步。</p><p>如果没有元素入栈，这时多个线程pop也不会产生问题，可以根据head内部的ptr指向为空判断空栈直接返回空指针。</p><p>总的来说，就是以下两方面含义：</p><ol><li>因为要保证pop操作时节点的数据是有效的。push和pop要构成同步关系，即push采用release内存序修改head；pop采用acquire内存序修改head</li><li>第一个pop的线程的写操作和之后的pop线程读操作要构成同步关系</li></ol><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><p>push操作函数：该函数就是创建一个新节点，将新节点的next指向head，最后操作1处执行比较交换操作，当head等于新节点的next时，使用的是release内存序，并返回true；当head不等于新节点的next时(head被其它线程更新)，使用的是relaxed内存序(因为要重试，所以什么内存序都可以)，并返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_node;               <span class="comment">//定义一个新的节点指针</span></span><br><span class="line">    new_node.ptr = <span class="keyword">new</span> <span class="built_in">count_node</span>(data);     <span class="comment">//通过yao创建的data数据，来构造一个节点</span></span><br><span class="line">    new_node.external_count = <span class="number">1</span>;             <span class="comment">//将该节点的引用计数置1</span></span><br><span class="line">    new_node.ptr-&gt;next = head.<span class="built_in">load</span>();        <span class="comment">//另新节点的next指向head</span></span><br><span class="line">    <span class="comment">//1 比较交换操作</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node.ptr-&gt;next, new_node, memory_order::memory_order_release, memory_order::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作函数：在<code>increase_head_count</code>函数中，操作7的比较交换成功时，使用的是acquire的内存序，这样也是为了与push操作函数中操作1处的比较交换的release内存序构成同步关系。如果考虑两个线程并发执行，有两种情况发生：</p><ol><li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程2先执行完操作5，则内部引用计数就为-1(线程2因为不满足条件，不能进入释放ptr，留给线程1释放ptf)，这时操作2就不会再用ptr了，线程1的操作4就可以进入if释放ptr了。</li><li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程1先执行操作4，那么它会将内部引用计数变为1，并且返回0，不满足条件就不能释放ptr，就退出了。线程2这时执行操作5就能满足条件，从而释放ptr。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();     <span class="comment">//取出head</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);             <span class="comment">//增加引用计数</span></span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;      <span class="comment">//获取old_head的指向</span></span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();           <span class="comment">//如果为空，返回空指针即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始头部更新，如果线程1的old_head与head相等，说明还没有其它线程抢占到head，线程1就负责回收数据和将外部引用计数转为内部引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;              <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);                 <span class="comment">//交换数据</span></span><br><span class="line">            <span class="comment">//3 因为外部引用计数初始化为1，该进行进来时又+1，所以减2，可以统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase) == -count_increase) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;       <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//如果old_head与head不相等，有两种情况：其它线程把head更新了；还有就是该线程先将head引用计数++，后面又被其它线程将head引用计数++了，因为该线程的old_head是局部变量的一个缓存，所以head引用计数更新了，old_head还是旧数据</span></span><br><span class="line">            <span class="comment">//该线程负责减少内部引用计数(该进程进pop的时候，加的是外部引用计数)，最后是判断，外部的引用计数和内部引用计数相加为0，就做回收操作</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;    <span class="comment">//当前线程减少内部引用计数，返回之前值为1说明指针仅被当前线程引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加头部节点引用数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr&amp; old_counter)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_counter;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        new_counter = old_counter;</span><br><span class="line">        ++new_counter.external_count;</span><br><span class="line">    &#125;<span class="comment">//7 循环判断保证head和old_counter相等时做更新,多线程情况保证引用计数原子递增。</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(old_counter,  new_counter, std::memory_order_acquire, std::memory_order_relaxed));</span><br><span class="line">    <span class="comment">//8 走到此处说明head的external_count已经被更新了</span></span><br><span class="line">    old_counter.external_count = new_counter.external_count; <span class="comment">//因为old_counter是引用传进来的，所以external_count更新了想要传给它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于一个原子变量M，其释放序列中的读改写操作无论采用何种模型都能读取M的最新值(原子变量来保证的)。</li><li>为了保证原子变量上下程序的操作能和其它线程同步，可以利用内存顺序模型用来保证数据在多个线程的可见顺序。</li></ul><h2 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h2><p>虽然以上程序优化了无锁栈，但还需要保证ptr的data在被删除之前swap到res里。</p><p>改进后的pop函数：在下面程序中，线程1如果是进入了操作4处执行delete，那么是需要保证swap操作先于fetch_add之后的delete操作，所以fetch_add可以采用release模型；而对于线程2执行操作5，内部delete操作之前，也需要保证其它线程执行的swap操作完成，所以操作5处的fetch_sub要采用acquire内存序，这样它就和操作4构成同步关系，即操作4先于操作5，而操作4完成之前可以保证它上面的程序执行完，所以swap就可以先于操作5了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);</span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;</span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 本线程如果抢先完成head的更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next,  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">//返回头部数据</span></span><br><span class="line">            std::shared_ptr&lt;T&gt; res;</span><br><span class="line">            <span class="comment">//交换数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);</span><br><span class="line">            <span class="comment">//3 减少外部引用计数，先统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase, std::memory_order_release) == -count_increase) &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(<span class="number">-1</span>, std::memory_order_acquire) == <span class="number">1</span>) &#123; <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//ptr-&gt;internal_count.load(std::memory_order_acquire);</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;     <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，操作5处使用内存序relaxed也可以的，只要保证swap操作相较于delete先执行完即可，所以在操作6的delete上面添加内部引用计数的acquire内存序加载，即可和前面的释放序列构成同步关系。</p><h1 id="4-双引用实现无锁队列"><a href="#4-双引用实现无锁队列" class="headerlink" title="4. 双引用实现无锁队列"></a>4. 双引用实现无锁队列</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>队列和栈容器它们的结构是不同的，对于队列结构，push()和pop()分别访问其不同部分，而在栈容器上，这两项操作都访问头节点，所以两种数据结构所需的同步操作相异。如果某线程在队列一端做出改动，而另一线程同时访问队列另一端，程序就要保证前者的改动过程能正确地为后者所见。</p><h2 id="4-2-单线程队列"><a href="#4-2-单线程队列" class="headerlink" title="4.2 单线程队列"></a>4.2 单线程队列</h2><p>下面程序是一个单线程情况下实现的队列操作，在单线程情况下是不会出现问题的，但在多线程情况下，push和pop都会出现问题。</p><p>对于push操作，当两个线程都执行push，如果线程1在操作3先创建了新节点p1，然后数据交换，并让尾指针指向了p1，正准备执行操作7，更新尾指针位置，这时时间片被线程2抢到了，线程2就会覆盖线程1执行的操作，令尾指针指next向p2，并执行了操作7，移动尾指针，让尾指针指向了p2，这时线程1在执行操作7，就令尾指针指向p1。这样就导致数据混乱了，即队列中最后连接的是p2，但尾指针指向p1去了。</p><p>对于pop操作，当两个线程都执行pop时，当线程1通过old_head取出头节点时，正准备执行操作1，这时轮到线程2执行了，线程2也通过old_head取出头节点后，并且先执行了操作1，将head头指针更新为了原头节点的next，这时线程1有执行操作1，由于它的old_head是原头节点，所以它执行完操作7，还是将head头指针更新为原头节点的next。这样就导致，两个进行调用pop，结果head头指针只移动一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePopPush</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>            <span class="comment">//节点的结构类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;     <span class="comment">//节点的数据域</span></span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::atomic&lt;node*&gt; head;            <span class="comment">//头指针</span></span><br><span class="line">    std::atomic&lt;node*&gt; tail;            <span class="comment">//尾指针</span></span><br><span class="line">    <span class="comment">//弹出头部节点</span></span><br><span class="line">    <span class="function">node* <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>();       <span class="comment">//接收头指针</span></span><br><span class="line">        <span class="keyword">if</span> (old_head == tail.<span class="built_in">load</span>())              <span class="comment">//如果头指针和尾指针相等，则是空的，直接返回空指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 没有空，就直接更新头指针，指向删除节点的next</span></span><br><span class="line">        head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;          <span class="comment">//返回要删除的节点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglePopPush</span>():<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">load</span>())&#123;&#125;       <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">SinglePopPush</span>(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePopPush&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SinglePopPush</span>()&#123;</span><br><span class="line">        <span class="keyword">while</span> (node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//循环取出头指针，为空就返回，不为空就delete掉</span></span><br><span class="line">            head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">            <span class="keyword">delete</span> old_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>                <span class="comment">//出队函数(消费者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* old_head = <span class="built_in">pop_head</span>();        <span class="comment">//先取出要删除的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (!old_head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();         <span class="comment">//为空，就返回头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，就取出要删除节点的数据值</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(old_head-&gt;data)</span></span>;</span><br><span class="line">        <span class="keyword">delete</span> old_head;           <span class="comment">//delete要删除的头节点</span></span><br><span class="line">        <span class="keyword">return</span> res;                <span class="comment">//返回数据值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>                 <span class="comment">//入队函数(生产者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(std::make_shared&lt;T&gt;(new_value))</span></span>;     <span class="comment">//先构造好数据</span></span><br><span class="line">        node* p = <span class="keyword">new</span> node;             <span class="comment">//3 创建一个新节点</span></span><br><span class="line">        node* <span class="type">const</span> old_tail = tail.<span class="built_in">load</span>();       <span class="comment">//4 获取尾节点指针</span></span><br><span class="line">        old_tail-&gt;data.<span class="built_in">swap</span>(new_data);      <span class="comment">//5 数据交换(old_tail-&gt;data原来是没有数据的空指针)</span></span><br><span class="line">        old_tail-&gt;next = p;           <span class="comment">//6 令尾节点的next指向p</span></span><br><span class="line">        tail.<span class="built_in">store</span>(p);                <span class="comment">//7 更新尾指针，令尾指针存储新节点p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-3-多线程push"><a href="#4-3-多线程push" class="headerlink" title="4.3 多线程push"></a>4.3 多线程push</h2><p>为了解决多线程push的竞争问题，可以采用以下程序来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> T(new_value))</span></span>;   <span class="comment">//先创建处要push的数据</span></span><br><span class="line">    counted_node_ptr new_next;           <span class="comment">//定义一个可计数的节点指针，有两个参数</span></span><br><span class="line">    new_next.ptr=<span class="keyword">new</span> node;               <span class="comment">//ptr指向新建的一个节点</span></span><br><span class="line">    new_next.external_count=<span class="number">1</span>;           <span class="comment">//外部引用计数为1</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        node* <span class="type">const</span> old_tail=tail.<span class="built_in">load</span>();        <span class="comment">//1 将尾部节点加载出来(它的data和next开始都是空的)</span></span><br><span class="line">        T* old_data=<span class="literal">nullptr</span>;                     <span class="comment">//定义并初始化T类型的old_data为空</span></span><br><span class="line">        <span class="comment">//2 尾节点的data如果还是空的，就更新尾节点的data为new_data的数据data，并返回true</span></span><br><span class="line">        <span class="keyword">if</span>(old_tail-&gt;data.<span class="built_in">compare_exchange_strong</span>(old_data, new_data.<span class="built_in">get</span>()))   </span><br><span class="line">        &#123;</span><br><span class="line">            old_tail-&gt;next=new_next;         <span class="comment">//将尾节点的next指向一个空的可计数的节点</span></span><br><span class="line">            tail.<span class="built_in">store</span>(new_next.ptr);        <span class="comment">//3 更新尾指针为最后连接的一个节点</span></span><br><span class="line">            new_data.<span class="built_in">release</span>();          <span class="comment">//解绑new_data的裸指针，因为该指针已经交给old_tail的data管理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是将data指针原子化，通过比较-交换操作来设置它的值。如果比较-交换操作成功，所操作的节点即为真正的尾节点，我们便可安全地设定next指针，使之指向新节点。若比较-交换操作失败，就表明有另一线程同时存入了数据，我们应该进行循环，重新读取tail指针并从头开始操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-引用计数实现无锁并发栈&quot;&gt;&lt;a href=&quot;#1-引用计数实现无锁并发栈&quot; class=&quot;headerlink&quot; title=&quot;1. 引用计数实现无锁并发栈&quot;&gt;&lt;/a&gt;1. 引用计数实现无锁并发栈&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="并发编程" scheme="https://lxx93.online/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
</feed>
