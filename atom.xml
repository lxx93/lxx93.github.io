<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>-lxxl-</title>
  
  <subtitle>我们一起去偷月亮吧</subtitle>
  <link href="https://lxx93.online/atom.xml" rel="self"/>
  
  <link href="https://lxx93.online/"/>
  <updated>2025-03-29T14:53:33.830Z</updated>
  <id>https://lxx93.online/</id>
  
  <author>
    <name>lxx9339-T</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git学习</title>
    <link href="https://lxx93.online/2025/03/26/git%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lxx93.online/2025/03/26/git%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-03-26T13:25:44.000Z</published>
    <updated>2025-03-29T14:53:33.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1.Git概述"></a>1.Git概述</h1><p>Git是一个免费的、开源的<code>分布式版本控制系统</code>，可以快速高效地处理从小型到大型的各种项目。Git易于学习，占地面积小，性能极快。它具有廉价的本地库、方便的暂存区域和多个工作流分支等特性，其性能优于Subversion、CVS、Perforce和ClearCase等版本工具。</p><p><code>版本控制</code>：是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。其最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p><p><code>集中式版本控制</code>：诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或者提交更新。</p><ul><li>优点：每个人都可以在一定程度上看到项目中的其它人正在做些什么，而管理员也可以轻松掌握每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>缺点：中央服务器的单点故障问题，如果服务器死机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</li></ul><p><code>分布式版本控制</code>：诸如Git、Mercurial等，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)，这样任何一处协同工作用的文件发送故障，事后都可以用其它客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式版本控制系统解决了集中式版本控制系统的缺陷：</p><ul><li>服务器断网的情况下也可以进行开发(因为版本控制是在本地进行的)</li><li>每个客户端保存的也都是整个完整的项目(包含历史记录，更加安全)</li></ul><p>Git工作机制：</p><p><img src="/.online//图床数据\git\1.png"></p><p>代码托管中心：是基于网络服务器的远程代码仓库，一般简单称为<code>远程库</code></p><ul><li>局域网：GitLab</li><li>互联网：GitHub(外网)、Gitee码云(国内网站)</li></ul><h1 id="2-Git操作"><a href="#2-Git操作" class="headerlink" title="2.Git操作"></a>2.Git操作</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name 用户名</td><td align="center">设置用户签名</td></tr><tr><td align="center">git config –global user.email 邮箱</td><td align="center">设置用户签名</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息”文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看历史记录</td></tr><tr><td align="center">git reset –hard 版本号</td><td align="center">版本穿梭</td></tr></tbody></table><h2 id="设置用户签名"><a href="#设置用户签名" class="headerlink" title="设置用户签名"></a>设置用户签名</h2><p>基本语法：</p><ul><li><code>git config --global user.name lxx</code></li><li><code>git config --global user.email 2235221711@qq.com</code></li></ul><p>查看：在<code>C:\Users\PC</code>目录下的文件<code>.gitconfig</code>里面查看</p><p>作用：区分不同操作者身份，用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的(Git首次安装必须设置一下用户签名，否则无法提交代码)。</p><p>注意：这里设置的用户签名和将来登录Github(或其它代码托管中心)的账号没有任何关系。</p><h2 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h2><p>1.初始化本地库</p><p>首先需要选择一个仓库目录，这里使用目录<code>C:\study\git_study\git_demo</code>作为<code>工作区</code>，在该目录下打开git bash。</p><p>基本语法：</p><ul><li><code>git init</code></li></ul><p>结果：在该目录下会生成一个.git文件夹</p><p>2.查看本地库状态</p><p>基本语法：</p><ul><li><code>git status</code></li></ul><p><img src="/.online//图床数据\git\2.png"></p><p>解释：</p><ul><li><code>On branch master</code>：当前本地库在master分支里面</li><li><code>No commits yet</code>：当前没有提交过内容(还是空的git库)</li><li><code>nothing to commit</code>：当前没有什么可以提交(因为当前还没有要提交的文件)</li></ul><p>此时在该git_demo文件夹下添加hello.txt文件：</p><p><img src="/.online//图床数据\git\3.png"></p><p>解释：</p><ul><li><code>Untracked files</code>：表示未被追踪的文件(还没有将文件添加到暂存区)</li><li><code>红色</code>标记：表示文件还没有添加到暂存区</li></ul><p>3.将本地文件添加到<code>暂存区</code>(git追踪文件)</p><p>基本语法：</p><ul><li><code>git add 文件名</code></li></ul><p><img src="/.online//图床数据\git\4.png"></p><p>解释：</p><ul><li>当前git已经追踪到了文件hello.txt，此时该文件只是存在于暂存区(还可以删除，无历史版本)</li><li><code>绿色</code>标识：表示文件已经被添加到暂存区</li></ul><p>补充：将暂存区的文件删除，但该文件在工作区(git_demo目录下)还是存在的</p><ul><li><code>git rm --cached 文件名</code></li></ul><p>4.将暂存区的文件提交到本地库(可以形成一个历史版本)</p><p>基本语法：</p><ul><li><code>git commit -m “日志信息”文件名</code></li></ul><p><img src="/.online//图床数据\git\5.png"></p><p>5.查看历史版本</p><p>基本语法(两种方式)：</p><ul><li><code>git reflog</code></li><li><code>git log</code></li></ul><p><img src="/.online//图床数据\git\6.png" alt="6"></p><p>解释：git reflog查看到的是版本号的前7位，git log查看到的是完整的版本号、谁提交的该版本和提交时间</p><p>6.修改文件</p><p>操作1：修改文件hello.txt后再次查看本地库状态：</p><p><img src="/.online//图床数据\git\7.png"></p><p>解释：会提示文件被修改了，此时是红色标记，说明修改的文件还没有添加到暂存区</p><p>操作2：将修改的hello.txt上传到暂存区，查看状态，并提交到本地库</p><p><img src="/.online//图床数据\git\8.png"></p><p>操作3：查看历史版本</p><p><img src="/.online//图床数据\git\9.png"></p><p>解释：工作区里面永远只会显示一个文件(版本)，git底层是通过指针来控制各个版本的</p><p>7.版本穿梭</p><p>基本语法：</p><ul><li><code>git reset --hard 版本号</code></li></ul><p><img src="/.online//图床数据\git\10.png" alt="10"></p><p>解释：原来有三个版本，且指针是指向第三个版本的(工作区显示)，现在通过第二个版本的版本号，将版本穿梭回了第二个版本，此时工作区显示的就是第二个版本的文件内容了。</p><p>补充：<code>头指针(工作区能看到的内容)指向master分支，master分支指向当前版本号</code></p><ul><li><p>在.git目录下面的HEAD文件里面的内容是：</p><ul><li><code>ref: refs/heads/master</code>：表示指针指向的是master，当前是在master这个分支上</li></ul></li><li><p>在.git\refs\heads目录下的master文件里面的内容是当前master指向的版本号(完整)</p></li></ul><h1 id="3-分支"><a href="#3-分支" class="headerlink" title="3.分支"></a>3.分支</h1><p>在版本控制过程中，同时推进多个任务，为每个任务，可以创建每个任务的单独分支，使用分支意为着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。即当你文件里有内容时，如果这时你创建了一个副分支，那么在副分支下，你主分支里每个文件的内容，在副分支下都存在(相当于拷贝)，但分支底层其实也就是指针的引用。</p><p>优点：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可。</li></ul><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">把指定的分支合并到当前分支上</td></tr></tbody></table><p>1.查看分支</p><p><img src="/.online//图床数据\git\11.png"></p><p>2.创建分支hot-fix</p><p><img src="/.online//图床数据\git\12.png"></p><p>3.切换分支</p><p><img src="/.online//图床数据\git\13.png"></p><p>4.合并操作</p><ul><li>正常合并：master分支没有修改文件，而hot-fix分支对文件进行修改了，所以将hot-fix分支合并到master分支后，文件的内容是hot-fix分支文件的内容(修改的)。</li></ul><p><img src="/.online//图床数据\git\14.png"></p><ul><li>冲突合并：当在主分支对某个文件hello.txt进行修改(如第一行)时，如果提交到了本地库，在副分支下是不会显示f1修改的内容(因为副分支之前已经创建过，相当于另一条分支了，如果是新创建一个分支，则该分支下会显示f1修改的内容)，如果这时你在副分支下，对f1第一行也进行了修改，并且提交到了本地库，当回到主分支进行合并副分支时，就会出现合并冲突，此时只能手动改。</li></ul><p>操作1：主分支和副分支分别修改同一个文件hello.txt，并且修改位置(修改的行)是一样的，又分别提交到本地库，在主分支上将副分支合并</p><p><img src="/.online//图床数据\git\15.png"></p><p>操作2：手动打开hello.txt文件进行修改(不需要哪些内容，删除即可)，修改完后进行保存</p><p><img src="/.online//图床数据\git\16.png"></p><p>操作3：将hello.txt提交到本地库(<code>使用git commit命令时不能带文件名了</code>)</p><p><img src="/.online//图床数据\git\17.png"></p><p>注意：此时master分支下hello.txt文件是手动修改后的内容，而hot-fix副分支下的hello.txt文件还是之前的内容。因为合并只会修改主分支的内容，即只会修改合并的那个分支，被合并的分支不会被修改。</p><p>5.总结</p><p><img src="/.online//图床数据\git\18.png"></p><p>master、hot-fix其实都是指向具体版本记录的指针，当前所在的分支是由HEAD决定的，所以<code>创建分支</code>的本质就是多创建一个指针。</p><ul><li>HEAD如果指向master，那么此时就在master分支上</li><li>HEAD如果指向hot-fix，那么此时就在hot-fix分支上</li><li>所以<code>切换分支</code>的本质就是移动HEAD指针</li></ul><h1 id="4-Git团队协作机制"><a href="#4-Git团队协作机制" class="headerlink" title="4.Git团队协作机制"></a>4.Git团队协作机制</h1><p>1.团队内协作</p><ul><li>电脑A初始化了一个本地库，通过<code>push</code>命令可以将自己本地库下面的代码推送到<code>代码托管中心</code>，即产生一个远程库A</li><li>电脑B可以通过<code>clone</code>命令将远程库A里面的代码克隆到自己的本地库</li><li>电脑B在本地库对克隆的代码进行修改后，通过<code>push</code>命令又推送到远程库A(前提：电脑A将电脑B拉进该项目的团队里面)</li><li>电脑A就可以通过<code>pull</code>命令来拉取远程库A里面电脑B修改的代码，更新到自己的本地库(电脑B、远程库、电脑A的数据同步了)</li></ul><p>2.跨团队协作</p><ul><li>在代码托管中心，远程库B通过<code>fork</code>命令得到远程库A里面的代码</li><li>电脑B通过<code>clone</code>命令将远程库B里面的代码克隆到自己的本地库</li><li>电脑B在本地库对克隆的代码进行修改后，通过<code>push</code>命令推送到远程库B</li><li>远程库B发一个拉取请求<code>Pull request</code>给远程库A</li><li>远程库A收到请求，进行审核</li><li>审核成功，远程库B就通过命令<code>merge</code>命令将远程库A的代码合并过来</li><li>电脑B就可以通过<code>pull</code>命令来拉取合并后的远程库A的代码，更新到自己的本地库</li></ul><h1 id="5-远程库"><a href="#5-远程库" class="headerlink" title="5.远程库"></a>5.远程库</h1><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td align="center">查看当前所有远程地址别名</td></tr><tr><td align="center">git remote add 别名 远程库地址</td><td align="center">给远程库起别名</td></tr><tr><td align="center">git push 别名 分支</td><td align="center">推送本地分支上的内容到远程库</td></tr><tr><td align="center">git clone 远程地址</td><td align="center">将远程库的内容克隆到本地</td></tr><tr><td align="center">git pull 远程库地址别名 远程分支名</td><td align="center">将远程库对于分支最新的内容拉下来后与当前本地分支直接合并</td></tr></tbody></table><h2 id="创建远程库-创建别名"><a href="#创建远程库-创建别名" class="headerlink" title="创建远程库&amp;创建别名"></a>创建远程库&amp;创建别名</h2><p>1.登录github账号，点击右上角的<code>+</code>，点击<code>New repository</code></p><p><img src="/.online//图床数据\git\19.png"></p><p>2.在新建远程库页面设置库名git-demo(在自己账号下不能重名)，选择公开</p><p><img src="/.online//图床数据\git\20.png"></p><p>3.进入远程库git-demo，复制远程库链接</p><p><img src="/.online//图床数据\git\21.png"></p><p>4.创建别名</p><ul><li><code>git remote -v</code>：查看当前所有远程地址别名</li><li><code>git remote add 别名 远程地址</code>：为远程库创建别名，下面通过<code>git-demo</code>为别名</li></ul><p><img src="/.online//图床数据\git\22.png"></p><p>解释：当创建好别名后，再查看当前所有远程库别名就会出现两个git-demo，因为该别名即可用拉取<code>fetch</code>，也可用用来推送<code>push</code>。</p><p>5.推送本地库</p><ul><li><code>git push 别名 分支</code>：如果没有给远程库设置别名，也可以使用链接</li></ul><p><img src="/.online//图床数据\git\23.png"></p><p><img src="/.online//图床数据\git\24.png"></p><p>6.拉取远程库到本地库</p><p>如果自己本地库推送到远程库后，远程库对文件进行了更新，现在将其拉取到本地库。</p><p><img src="/.online//图床数据\git\25.png"></p><p>解释：拉取下来后，查看本地库状态是干净的，说明拉取动作(拉取到本地库的文件)会自动提交到本地库。最后结果就是本地库的代码和远程库的代码已经同步了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Git概述&quot;&gt;&lt;a href=&quot;#1-Git概述&quot; class=&quot;headerlink&quot; title=&quot;1.Git概述&quot;&gt;&lt;/a&gt;1.Git概述&lt;/h1&gt;&lt;p&gt;Git是一个免费的、开源的&lt;code&gt;分布式版本控制系统&lt;/code&gt;，可以快速高效地处理从小型到大</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt操作</title>
    <link href="https://lxx93.online/2025/03/26/Qt%E6%93%8D%E4%BD%9C/"/>
    <id>https://lxx93.online/2025/03/26/Qt%E6%93%8D%E4%BD%9C/</id>
    <published>2025-03-26T04:21:04.000Z</published>
    <updated>2025-03-29T14:53:03.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Qt中多线程的使用"><a href="#一、Qt中多线程的使用" class="headerlink" title="一、Qt中多线程的使用"></a>一、Qt中多线程的使用</h1><p>在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较复杂的逻辑， 如果只有一个线程去处理，就会导致窗口卡顿，无法处理用户的相关操作。这种情况下就需要使用多线程，其中一个线程处理窗口事件，其他线程进行逻辑运算，多个线程各司其职，不仅可以提高用户体验还可以提升程序的执行效率。</p><p>1.在qt中使用了多线程，有些事项是需要额外注意的：</p><ul><li>默认的线程在Qt中称之为窗口线程，也叫主线程，负责窗口事件处理或者窗口控件数据的更新</li><li>子线程负责后台的业务逻辑处理，子线程中不能对窗口对象做任何操作，这些事情需要交给窗口线程处理</li><li>主线程和子线程之间如果要进行数据的传递，需要使用Qt中的信号槽机制(即如果子线程需要对窗口的数据进行修改，只能先通过connect发送给主线程，由主线程对窗口进行修改，而子线程不能直接对窗口进行修改)。</li></ul><h2 id="使用方式1"><a href="#使用方式1" class="headerlink" title="使用方式1"></a>使用方式1</h2><ul><li>创建一个线程类的子类，让其继承QT中的线程类 QThread</li><li>重写父类的 run() 方法，在该函数内部编写子线程要处理的具体的业务流程</li><li>在主线程中创建子线程对象，new 一个就可以了</li><li>启动子线程, 调用 start() 方法</li></ul><p>案例：创建一个子线程文件，里面定义三个子线程类，使其继承QThread，分别重写虚函数run，子线程需要执行的任务都写在该函数里面。而在主线程中，先创建该类的一个对象，调用start函数，则表示启动子线程(run()函数)。</p><p>下面创建了一个MyThread.h文件，在该文件里面创建了三个子线程类，分别是</p><ul><li>Generate类：生成随机数</li><li>BubbleSort类：对生成的随机数进行冒泡排序</li><li>QuickSort类：对生成的随机数进行快速排序</li></ul><p>子线程头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvNum</span><span class="params">(<span class="type">int</span> num)</span></span>;            <span class="comment">//槽函数，复制要生成的随机数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子线程的执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::recvNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;m_num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_list[j]&gt;m_list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j+<span class="number">1</span>];</span><br><span class="line">                m_list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(m_list,<span class="number">0</span>,m_list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程的执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::recvNum); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        gen-&gt;<span class="built_in">start</span>();     <span class="comment">//启动子线程，即执行子线程的run方法(生成随机数)</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::recvArray);     <span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::recvArray);       <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;        <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       bubble-&gt;<span class="built_in">start</span>();        <span class="comment">//启动冒牌排序子线程</span></span><br><span class="line">       quick-&gt;<span class="built_in">start</span>();         <span class="comment">//启动快速排序子线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/.online//图床数据\Qt\8_6.png"></p><h2 id="使用方式2"><a href="#使用方式2" class="headerlink" title="使用方式2"></a>使用方式2</h2><p>Qt提供的第二种线程的创建方式弥补了第一种方式的缺点，用起来更加灵活，但是这种方式写起来会相对复杂一些。</p><ul><li>创建一个新的类(如MyWork)，让这个类从QObject派生</li><li>在这个类中添加一个公共的成员函数，如working()，函数体就是我们要子线程中执行的业务逻辑</li><li>在主线程中创建一个QThread对象, 这就是子线程的对象</li><li>在主线程中创建工作的类对象(千万不要指定给创建的对象指定父对象)</li><li>将MyWork对象移动到创建的子线程对象中, 需要调用QObject类提供的moveToThread()方法</li><li>启动子线程，调用 start(), 这时候线程启动了, 但是移动到线程中的对象(任务)并没有工作</li><li>调用MyWork类对象的工作函数，让这个函数开始执行，这时候是在移动到的那个子线程中运行的</li></ul><p>主窗口的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子类的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主函数执行函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建子线程对象</span></span><br><span class="line">    QThread* t1=<span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* t2=<span class="keyword">new</span> QThread;</span><br><span class="line">    QThread* t3=<span class="keyword">new</span> QThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建任务类对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将任务对象移动到某个子线程中</span></span><br><span class="line">    gen-&gt;<span class="built_in">moveToThread</span>(t1);</span><br><span class="line">    bubble-&gt;<span class="built_in">moveToThread</span>(t2);</span><br><span class="line">    quick-&gt;<span class="built_in">moveToThread</span>(t3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::working); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        t1-&gt;<span class="built_in">start</span>();  <span class="comment">//启动子线程，即执行子线程的working()方法(生成随机数)，没有start，是不会执行working函数的</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::working);  <span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::working);   <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       t2-&gt;<span class="built_in">start</span>();        <span class="comment">//启动冒牌排序子线程</span></span><br><span class="line">       t3-&gt;<span class="built_in">start</span>();         <span class="comment">//启动快速排序子线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的执行函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::working</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[j]&gt;list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = list[j];</span><br><span class="line">                list[j] = list[j+<span class="number">1</span>];</span><br><span class="line">                list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::working</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(list,<span class="number">0</span>,list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h1><p>​        在Qt中使用线程池需要先创建任务，添加到线程池中的每一个任务都需要是一个QRunnable类型，因此在程序中需要创建子类继承QRunnable这个类，然后重写 run() 方法，在这个函数中编写要在线程池中执行的任务，并将这个子类对象传递给线程池，这样任务就可以被线程池中的某个工作的线程处理掉了。</p><p>主线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">starting</span><span class="params">(<span class="type">int</span> num)</span></span>;         <span class="comment">//向子线程发送的信号，参数是要生成的随机数个数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子线程的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generate</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Generate</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvNum</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;)</span></span>;         <span class="comment">//向主线程发送存储随机生成的数的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BubbleSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> : <span class="keyword">public</span> QObject, <span class="keyword">public</span> QRunnable</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">QuickSort</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;list)</span></span>;      <span class="comment">//槽函数接收要排序的数组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;      <span class="comment">//从父类继承的虚函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; num)</span></span>;         <span class="comment">//向主线程发送排序好的容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主线程执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.创建任务对象</span></span><br><span class="line">    Generate* gen = <span class="keyword">new</span> Generate;</span><br><span class="line">    BubbleSort* bubble = <span class="keyword">new</span> BubbleSort;</span><br><span class="line">    QuickSort* quick = <span class="keyword">new</span> QuickSort;</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;MainWindow::starting, gen, &amp;Generate::recvNum); <span class="comment">//连接操作，主线程发送生成随机数个数的信号，子线程接收</span></span><br><span class="line">    <span class="comment">//2.启动子线程</span></span><br><span class="line">    <span class="comment">//生成随机数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">starting</span>(<span class="number">10000</span>);          <span class="comment">//发送信号，参数是生成随机数的个数</span></span><br><span class="line">        QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(gen);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//接收子线程发送的数据</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, bubble, &amp;BubbleSort::recvArray);<span class="comment">//冒泡子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, quick, &amp;QuickSort::recvArray); <span class="comment">//快速子线程接收信号，并执行存储容器操作</span></span><br><span class="line">    <span class="built_in">connect</span>(gen, &amp;Generate::sendArray, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//主线程接收信号，将生成的随机数放到窗口</span></span><br><span class="line">       QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(bubble);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">       QThreadPool::<span class="built_in">globalInstance</span>()-&gt;<span class="built_in">start</span>(quick);   <span class="comment">//把任务对象添加到线程池里面去</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;randList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(bubble, &amp;BubbleSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;  <span class="comment">//冒泡排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;bubbleList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(quick, &amp;QuickSort::finish, <span class="keyword">this</span>, [=](QVector&lt;<span class="type">int</span>&gt; list)&#123;     <span class="comment">//快速排序子线程排序完，将容器发送给主线程</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">           ui-&gt;quickList-&gt;<span class="built_in">addItem</span>(QString::<span class="built_in">number</span>(list.<span class="built_in">at</span>(i)));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子线程执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">Generate::<span class="built_in">Generate</span>(QObject *parent) : <span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置当前类的对象放到线程池中后，工作完毕能自动析构</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::recvNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Generate::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成随机数的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QVector&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_num; i++)&#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(<span class="built_in">qrand</span>()%<span class="number">100000</span>);       <span class="comment">//生成随机数放到容器里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;生成&quot;</span>&lt;&lt;m_num&lt;&lt;<span class="string">&quot;个随机数总共用时：&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">sendArray</span><span class="params">(list)</span></span>;          <span class="comment">//发送容器给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序操作</span></span><br><span class="line">BubbleSort::<span class="built_in">BubbleSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m_list.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_list[j]&gt;m_list[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp = m_list[j];</span><br><span class="line">                m_list[j] = m_list[j+<span class="number">1</span>];</span><br><span class="line">                m_list[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;冒泡排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序操作</span></span><br><span class="line">QuickSort::<span class="built_in">QuickSort</span>(QObject *parent):<span class="built_in">QObject</span>(parent), <span class="built_in">QRunnable</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setAutoDelete</span>(<span class="literal">true</span>);        <span class="comment">//设置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::recvArray</span><span class="params">(QVector&lt;<span class="type">int</span>&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序的线程的线程地址：&quot;</span>&lt;&lt;QThread::<span class="built_in">currentThread</span>();</span><br><span class="line">    QElapsedTimer time;</span><br><span class="line">    time.<span class="built_in">start</span>();             <span class="comment">//开始计时</span></span><br><span class="line">    <span class="built_in">quick</span>(m_list,<span class="number">0</span>,m_list.<span class="built_in">size</span>()<span class="number">-1</span>);      <span class="comment">//执行快速排序</span></span><br><span class="line">    <span class="type">int</span> milsec = time.<span class="built_in">elapsed</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;快速排序花费的时间是&quot;</span>&lt;&lt;milsec&lt;&lt;<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">    <span class="function">emit <span class="title">finish</span><span class="params">(m_list)</span></span>;                <span class="comment">//发送排序好的给主线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort::quick</span><span class="params">(QVector&lt;<span class="type">int</span>&gt;&amp;list, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> i=l, j=r;</span><br><span class="line">        <span class="type">int</span> x = list[i];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[j]&gt;=x) j--;</span><br><span class="line">            list[i]=list[j];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; list[i]&lt;=x) i++;</span><br><span class="line">            list[j]=list[i];</span><br><span class="line">        &#125;</span><br><span class="line">        list[i] = x;</span><br><span class="line">        <span class="built_in">quick</span>(list,l,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quick</span>(list,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、基于TCP的Qt网络通信"><a href="#三、基于TCP的Qt网络通信" class="headerlink" title="三、基于TCP的Qt网络通信"></a>三、基于TCP的Qt网络通信</h1><p>使用Qt提供的类进行基于TCP的套接字通信需要用到两个类：</p><ul><li>QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。</li><li>QTcpSocket：通信的套接字类，客户端、服务器端都需要使用。</li></ul><p>这两个套接字通信类都属于网络模块<code>network</code>。</p><blockquote><p>在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由Qt框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。</p></blockquote><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>通信流程：</p><ul><li>创建套接字服务器QTcpServer对象</li><li>通过QTcpServer对象设置监听，即：QTcpServer::listen()</li><li>基于QTcpServer::newConnection()信号检测是否有新的客户端连接</li><li>如果有新的客户端连接调用QTcpSocket *QTcpServer::nextPendingConnection()得到通信的套接字对象</li><li>使用通信的套接字对象QTcpSocket和客户端进行通信</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li>创建通信的套接字类QTcpSocket对象</li><li>使用服务器端绑定的IP和端口连接服务器QAbstractSocket::connectToHost()</li><li>使用QTcpSocket对象和服务器进行通信</li></ul><p>案例1：通过服务端&#x2F;客户端实现数据发送</p><p>服务端头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_setListen_clicked</span><span class="params">()</span></span>;      <span class="comment">//点击 启动监听服务 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendMsg_clicked</span><span class="params">()</span></span>;        <span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">    QTcpServer* m_s;        <span class="comment">//监听的服务器对象(监听描述符)</span></span><br><span class="line">    QTcpSocket* m_tcp;      <span class="comment">//通信的套接字对象(通信描述符)</span></span><br><span class="line">    QLabel* m_status;       <span class="comment">//状态栏里面的label对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务端执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);     <span class="comment">//端口号默认设置为8899</span></span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;服务器&quot;</span>);       <span class="comment">//给窗口添加标题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建监听的服务器对象</span></span><br><span class="line">    m_s = <span class="keyword">new</span> <span class="built_in">QTcpServer</span>(<span class="keyword">this</span>);       <span class="comment">//指定父对象，窗口关闭自动析构服务器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务端监听的时候，当有客户端连接到达时，就会发出信号newConnection</span></span><br><span class="line">    <span class="built_in">connect</span>(m_s, &amp;QTcpServer::newConnection, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_tcp = m_s-&gt;<span class="built_in">nextPendingConnection</span>();     <span class="comment">//得到一个用于通信的套接字对象(实例化)</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/connect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//改为连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">        <span class="comment">//检测客户点是否发来数据(当接收到readyRead信号的时候，就可以接收数据了)</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();           <span class="comment">//接收所有数据</span></span><br><span class="line">            ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say：&quot;</span> + data);    <span class="comment">//将接收的数据显示在record框</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//当客户端断开连接，m_tcp会发出信号disconnected</span></span><br><span class="line">        <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            m_tcp-&gt;<span class="built_in">close</span>();              <span class="comment">//关闭通信描述符</span></span><br><span class="line">            m_tcp-&gt;<span class="built_in">deleteLater</span>();        <span class="comment">//进行析构</span></span><br><span class="line">            m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));    <span class="comment">//状态栏的连接状态重新设置为为未连接状态</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;       <span class="comment">//创建一个label</span></span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//默认情况下是未连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加label</span></span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态：&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击窗口的 启动监听服务 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_setListen_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>();    <span class="comment">//获取端口号(字符串类型)，转为无符号短整型</span></span><br><span class="line">    m_s-&gt;<span class="built_in">listen</span>(QHostAddress::Any, port);       <span class="comment">//进行监听(绑定了本地的任意一个ip地址，指定端口)</span></span><br><span class="line">    ui-&gt;setListen-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);           <span class="comment">//将该按钮设置为不可用状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMsg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();        <span class="comment">//以纯文本的方式读取要发送的信息</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());        <span class="comment">//将string类型转换为QByteArray类型进行写入发送</span></span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务器say：&quot;</span> + msg);       <span class="comment">//将要发送的msg写入到record框</span></span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();           <span class="comment">//发送完毕后，清空输入框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_sendMsg_clicked</span><span class="params">()</span></span>;       <span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_connect_clicked</span><span class="params">()</span></span>;       <span class="comment">//点击 连接服务器 按钮触发的槽函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">on_disconnect_clicked</span><span class="params">()</span></span>;    <span class="comment">//点击 断开连接 按钮触发的槽函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line"></span><br><span class="line">    QTcpSocket* m_tcp;      <span class="comment">//通信的套接字对象(通信描述符)</span></span><br><span class="line">    QLabel* m_status;       <span class="comment">//状态栏里面的label对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端执行文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    ui-&gt;port-&gt;<span class="built_in">setText</span>(<span class="string">&quot;8899&quot;</span>);     <span class="comment">//端口号默认设置为8899</span></span><br><span class="line">    ui-&gt;ip-&gt;<span class="built_in">setText</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="built_in">setWindowTitle</span>(<span class="string">&quot;客户端&quot;</span>);       <span class="comment">//给窗口添加标题</span></span><br><span class="line">    ui-&gt;disconnect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);        <span class="comment">//刚开始时，断开连接 按钮不能使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建通信的服务器对象</span></span><br><span class="line">    m_tcp = <span class="keyword">new</span> <span class="built_in">QTcpSocket</span>(<span class="keyword">this</span>);       <span class="comment">//实例化通信套接字对象，如果指定父对象this，窗口关闭自动析构服务器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测客户点是否发来数据(当接收到readyRead信号的时候，就可以接收数据了)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::readyRead, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        QByteArray data = m_tcp-&gt;<span class="built_in">readAll</span>();           <span class="comment">//接收所有数据</span></span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务端say：&quot;</span> + data);    <span class="comment">//将接收的数据显示在record框</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当客户端断开连接，m_tcp会发出信号disconnected</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::disconnected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//m_tcp-&gt;deleteLater();  //进行析构(m_tcp创建时没有指定父对象，就在这里手动析构)--&gt;这里如果手动析构，断开后再连接就闪退</span></span><br><span class="line">        m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));<span class="comment">//状态栏的连接状态重新设置为为未连接状态</span></span><br><span class="line">        ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;服务端与客户端断开了连接.....&quot;</span>);</span><br><span class="line">        ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);        <span class="comment">//断开连接后，连接按钮能使用</span></span><br><span class="line">        ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);      <span class="comment">//断开按钮不可以使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当客户端连接成功，就发出connected信号</span></span><br><span class="line">    <span class="built_in">connect</span>(m_tcp, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">       m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/connect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line">       ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;已经成功连接到服务端.....&quot;</span>);</span><br><span class="line">       ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">true</span>);        <span class="comment">//成功连接到服务端后，连接按钮不能使用</span></span><br><span class="line">       ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">true</span>);      <span class="comment">//断开按钮可以使用</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏</span></span><br><span class="line">    m_status = <span class="keyword">new</span> QLabel;       <span class="comment">//创建一个label</span></span><br><span class="line">    m_status-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/disconnect.png&quot;</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">20</span>)); <span class="comment">//默认情况下是未连接状态的图片，固定高度和宽度都是20</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加label</span></span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(<span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;连接状态：&quot;</span>));</span><br><span class="line">    ui-&gt;statusbar-&gt;<span class="built_in">addWidget</span>(m_status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 发送信息 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_sendMsg_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg = ui-&gt;msg-&gt;<span class="built_in">toPlainText</span>();        <span class="comment">//以纯文本的方式读取要发送的信息</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">write</span>(msg.<span class="built_in">toUtf8</span>());        <span class="comment">//将string类型转换为QByteArray类型进行写入发送</span></span><br><span class="line">    ui-&gt;record-&gt;<span class="built_in">append</span>(<span class="string">&quot;客户端say：&quot;</span> + msg);       <span class="comment">//将要发送的msg写入到record框</span></span><br><span class="line">    ui-&gt;msg-&gt;<span class="built_in">clear</span>();           <span class="comment">//发送完毕后，清空输入框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 连接服务器 按钮触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_connect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString ip = ui-&gt;ip-&gt;<span class="built_in">text</span>();                       <span class="comment">//获取ip</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port = ui-&gt;port-&gt;<span class="built_in">text</span>().<span class="built_in">toUShort</span>(); <span class="comment">//获取端口</span></span><br><span class="line">    m_tcp-&gt;<span class="built_in">connectToHost</span>(<span class="built_in">QHostAddress</span>(ip),port);      <span class="comment">//通过ip和端口进行连接服务端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击 断开连接按钮，触发的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_disconnect_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_tcp-&gt;<span class="built_in">close</span>();                         <span class="comment">//关闭通信套接字连接，后续会发出信号disconnected</span></span><br><span class="line">    ui-&gt;connect-&gt;<span class="built_in">setDisabled</span>(<span class="literal">false</span>);        <span class="comment">//断开连接后，连接按钮能使用</span></span><br><span class="line">    ui-&gt;disconnect-&gt;<span class="built_in">setEnabled</span>(<span class="literal">false</span>);      <span class="comment">//断开按钮不可以使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例2：通过服务端&#x2F;客户端实现文件发送(C:\Qt\study\socket_Qt)</p><h1 id="四、Json在Qt中使用"><a href="#四、Json在Qt中使用" class="headerlink" title="四、Json在Qt中使用"></a>四、Json在Qt中使用</h1><p>JSON(JavaScrip Object Notation)是一种轻量级的数据交换格式，它基于ECMAScript(欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON成为理想的数据交换语言，易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>可以理解为Json是一种数据格式，和语言无关，在什么语言中都可以使用Json，基于这种通用的数据格式，一般处理两方面任务：</p><ul><li>组织数据(数据序列化)，用于数据的网络传输</li><li>组数数据(数据序列化)，写磁盘文件实现数据的持久化存储(一般以<code>.json</code>作为文件后缀)</li></ul><p>Json中主要有两种数据格式：Json数组和Json对象，并且这两种格式可以交叉嵌套使用。</p><h2 id="Json数组"><a href="#Json数组" class="headerlink" title="Json数组"></a>Json数组</h2><p>Json数组使用[]表示，[]里面是元素，元素和元素之间使用逗号间隔，最后一个因素后边没有逗号，一个Json数组中支持同时存在多种不同类型的成员，包括：<code>整型</code>、<code>浮点</code>、<code>字符串</code>、<code>布尔类型</code>、<code>json数组</code>、<code>json对象</code>、<code>空值(null)</code>。可见Json数组比起c&#x2F;c++数组要灵活很多</p><h2 id="Json对象"><a href="#Json对象" class="headerlink" title="Json对象"></a>Json对象</h2><p>Json对象使用{}来描述，每个Json对象中可以存储若干个元素，每一个元素对应一个键值对(key：value结构)，元素和元素之间使用逗号间隔，最后一个元素后边没有逗号，对于每个元素中的键值对有以下需要注意：</p><ul><li>键值(key)必须是字符串，位于同一层级的键值不要重复(因为是通过键值取出对应的value值)</li><li>value值的类型是可选的，，可根据实际需求指定，可用类型包括：<code>整型</code>、<code>浮点</code>、<code>字符串</code>、<code>布尔类型</code>、<code>json数组</code>、<code>json对象</code>、<code>空值(null)</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Qt中多线程的使用&quot;&gt;&lt;a href=&quot;#一、Qt中多线程的使用&quot; class=&quot;headerlink&quot; title=&quot;一、Qt中多线程的使用&quot;&gt;&lt;/a&gt;一、Qt中多线程的使用&lt;/h1&gt;&lt;p&gt;在进行桌面应用程序开发的时候， 假设应用程序在某些情况下需要处理比较</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>行测</title>
    <link href="https://lxx93.online/2025/03/15/%E8%A1%8C%E6%B5%8B/"/>
    <id>https://lxx93.online/2025/03/15/%E8%A1%8C%E6%B5%8B/</id>
    <published>2025-03-15T10:02:28.000Z</published>
    <updated>2025-03-29T14:52:46.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-言语理解"><a href="#一-言语理解" class="headerlink" title="一.言语理解"></a>一.言语理解</h1><p>2025年之前，国考题目中，言语理解题目有40道，25年有30道</p><h2 id="1-必考题型"><a href="#1-必考题型" class="headerlink" title="1.必考题型"></a>1.必考题型</h2><p>1.片段阅读</p><ul><li>中心理解题(基础&amp;重要)、细节判断题</li></ul><p>2.语句表达</p><ul><li>语句排序题、语句填空题、接语选择题</li></ul><p>3.逻辑填空(难度高&amp;题量大)</p><ul><li>实词填空、成语填空、混搭填空</li></ul><h2 id="2-中心理解题"><a href="#2-中心理解题" class="headerlink" title="2.中心理解题"></a>2.中心理解题</h2><p>1.提问方式</p><ul><li><p>这段文字<code>主要/旨在/重在/意在/想要</code>说明(论述、强调)的是…… </p></li><li><p>这段文字的<code>主旨/主题/观点</code>是……</p></li><li><p>对这段文字<code>概括最恰当</code>的一项是…… </p></li><li><p>这段文字<code>表达了作者</code>……</p></li><li><p>从这段文字中我们可以<code>看出作者的意图/态度</code>是……</p></li></ul><p> </p><p>2.题解思路</p><ul><li>直接确定重点</li><li>间接确定重点</li></ul><p>(1)直接确定重点</p><p>转折关系：虽然……但是……；尽管……可是……；.…不过……；……然而……；……却……；其实 &#x2F; 事实上 &#x2F; 实际上</p><p>注：<code>转折之后是重点</code></p><p>转折常考结构</p><ul><li>引入 + <code>转折</code>提出观点</li><li>引入 + <code>转折提出观点</code> + 解释说明</li><li>引入 + 转折<code>提出问题 + 问答问题/解决问题</code></li><li>引入 + <code>转折</code>…… + <code>同时/也</code>…..</li></ul><p>阅读策略：引入、解释说明部分可以略读</p><ul><li>背景：近年来、随着、在….的背景下、历史上等</li><li>例子：比如、例如、诸如、譬如、某些地区、不少人等</li><li>原因：因为、由于、：、…等</li></ul><p>[难度提升] 多个转折同时出现，如何判断重点？</p><p>多个转折同时出现，根据结构判断重点。引入&#x2F;解释说明(举例、原因等)中的转折不重要。</p><p>注：文段重点为并列两方面。排除片面选项(只涉及其中一项的选项)。</p><h1 id="二、数量关系"><a href="#二、数量关系" class="headerlink" title="二、数量关系"></a>二、数量关系</h1><p>高频考点问题：和差倍比问题、工程问题、经济利润问题、几何问题、等差数列问题、排列组合问题、概率问题</p><h2 id="1-和差倍比问题"><a href="#1-和差倍比问题" class="headerlink" title="1.和差倍比问题"></a>1.和差倍比问题</h2><h1 id="三、资料分析"><a href="#三、资料分析" class="headerlink" title="三、资料分析"></a>三、资料分析</h1><p>4篇资料，每篇5到题</p><h2 id="1、速算技巧"><a href="#1、速算技巧" class="headerlink" title="1、速算技巧"></a>1、速算技巧</h2><ul><li>截位速算：解决最核心的除法运算</li><li>多数加减：解决多个大数字的加减运算</li><li>分数比较：解决多个分数比大小的问题</li></ul><p>什么是截位？</p><ul><li>就是从左到右保留几位<code>有效数字</code>，看下一位，进行四舍五入(注意：有效数字从第一个非0数字开始)</li></ul><p>截几位？</p><ul><li><p>选项差距大(截2位)</p><ul><li>首位均不同</li><li>首位相同，第二位数字之差大于首位</li></ul></li><li><p>选项差距小(截3位)</p><ul><li>首位相同，第二位数字之差小于等于首位</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-言语理解&quot;&gt;&lt;a href=&quot;#一-言语理解&quot; class=&quot;headerlink&quot; title=&quot;一.言语理解&quot;&gt;&lt;/a&gt;一.言语理解&lt;/h1&gt;&lt;p&gt;2025年之前，国考题目中，言语理解题目有40道，25年有30道&lt;/p&gt;
&lt;h2 id=&quot;1-必考题型&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://lxx93.online/2025/03/04/protobuf/"/>
    <id>https://lxx93.online/2025/03/04/protobuf/</id>
    <published>2025-03-04T05:48:23.000Z</published>
    <updated>2025-03-29T14:52:23.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-ProtoBuf概述"><a href="#1-ProtoBuf概述" class="headerlink" title="1.ProtoBuf概述"></a>1.ProtoBuf概述</h1><p>protobuf也叫protocol buffer，是google的一种数据交换的格式，它独立于语言，独立于平台。google提供了多种语言的实现，如java、c#、c++、go和python等，每一种实现都包含了相应语言的编译器以及库文件。</p><p>1.作用：</p><ul><li><p>数据的持久化存储</p><ul><li>序列化：将数据从内存存储到磁盘</li><li>反序列化：将数据从磁盘加载到内存</li></ul></li><li><p>数据的网络传输：客户端与服务端之间的数据传输</p><ul><li>序列化：对象到字节序列</li><li>反序列化：字节序列到对象</li></ul></li></ul><p>2.特点</p><ul><li>语言无关、平台无关：ProtoBuf支持java、c++、python等多种语言、支持多个平台</li><li>高效：比XML更小、更快、更为简单</li><li>扩展性、兼容性好：可以更新数据结构，而不影响和破坏原有的旧程序</li></ul><p>3.使用特点(c++)：ProtoBuf是需要依赖通过编译生成的头文件和源文件来使用的。</p><p>比如说对于常规发送消息，首先是需要定义一个Class类，在该类里面有：(1)一些列属性字段(要发送的)、(2)处理字段的方法、(3)处理类的方法(序列化、反序列化)。可以发现(2)和(3)是非常耗时，且对于开发者来说比较伤脑筋的，则通过protobuf就可以避免这些问题。</p><h1 id="2-ProtoBuf在window下的使用"><a href="#2-ProtoBuf在window下的使用" class="headerlink" title="2.ProtoBuf在window下的使用"></a>2.ProtoBuf在window下的使用</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>1.下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases"><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers&#x2F;protobuf</a></a></p><p>2.下载对应的压缩包，解压后在bin文件夹下有一个protoc.exe</p><p>3.在该文件夹下打开终端，执行protoc –version，打印对应版本即安装成功</p><p>4.为方便使用，将protoc.exe的目录添加到环境变量中</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>1.定义消息字段</p><p>在message中我们可以定义其属性字段，字段定义格式为：字段类型 字段名&#x3D;字段唯一编号；</p><ul><li>字段名称命名规范：全小写字母，多个字母之间用下划线_连接</li><li>字段类型分为：<strong>标量数据类型</strong> 和 <strong>特殊类型</strong>(包括枚举、其他消息类型等)</li><li>字段唯一编号：用来标识字段，一旦开始使用就不能够再改变</li></ul><p>该表格展示了定义消息体中的<strong>标量数据类型</strong>，以及编译.proto文件之后自动生成的类中与之对应的字段类型。再这里展示了与c++语言对应的类型。</p><table><thead><tr><th align="center">.proto type</th><th align="center">Notes</th><th align="center">c++ Type</th></tr></thead><tbody><tr><td align="center">double</td><td align="center"></td><td align="center">double</td></tr><tr><td align="center">float</td><td align="center"></td><td align="center">float</td></tr><tr><td align="center">int32</td><td align="center">使用变长编码，负数的编码效率较低，若字段可能为负值，应使用sint32代替</td><td align="center">int32</td></tr><tr><td align="center">int64</td><td align="center">使用变长编码，负数的编码效率较低，若字段可能为负值，应使用sint64代替</td><td align="center">int64</td></tr><tr><td align="center">uint32</td><td align="center">使用变长编码</td><td align="center">uint32</td></tr><tr><td align="center">uint64</td><td align="center">使用变长编码</td><td align="center">uint64</td></tr><tr><td align="center">sint32</td><td align="center">使用变长编码，符号整型，负值的编码效率高于常规的int32类型</td><td align="center">int32</td></tr><tr><td align="center">sint64</td><td align="center">使用变长编码，符号整型，负值的编码效率高于常规的int64类型</td><td align="center">int64</td></tr><tr><td align="center">fixed32</td><td align="center">定长4字节，若值常大于2^28，则会比uint32更高效</td><td align="center">uint32</td></tr><tr><td align="center">fixed64</td><td align="center">定长8字节，若值常大于2^56，则会比uint64更高效</td><td align="center">uint64</td></tr><tr><td align="center">sfixed32</td><td align="center">定长4字节</td><td align="center">int32</td></tr><tr><td align="center">sfixed64</td><td align="center">定长8字节</td><td align="center">int64</td></tr><tr><td align="center">bool</td><td align="center"></td><td align="center">bool</td></tr><tr><td align="center">string</td><td align="center">包含UTF-8和ASCII编码的字符串，长度不能超过2^32</td><td align="center">string</td></tr><tr><td align="center">bytes</td><td align="center">可包含任意的字节序列，但长度不能超过2^32</td><td align="center">string</td></tr></tbody></table><p>注意：变长编码是指经过protobuf编码后，原本4字节或8字节的数可能会被变为其他字节数。</p><p>2.字段唯一编号的范围：1-536870911(2^29-1)，其中19000-19999不可用</p><p>19000-19999不可用的原因：在protobuf协议的实现中，对这些数进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警</p><blockquote><p>值得一提的是，范围为1-15的字段编号需要一个字节进行保存编码(只是指编号占的空间，不是指一整条字段)，16-2047内的数字需要两个字节进行保存编码。所以1-15要用来标记出现非常频繁的字段，要为将来有可能添加的、频繁出现的字段预留一些出来。</p></blockquote><p>3.实践</p><p>1.创建一个文件contacts.proto，在该文件内编写以下内容</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首行：语法指定行</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义联系人message</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PeopleInfo</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;       <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int32</span> age = <span class="number">2</span>;         <span class="comment">//年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在该文件的目录下打开终端执行：<code>protoc --cpp_out=. contacts.proto</code></p><p>注意：编译contacts.proto文件后会发生什么？</p><p>编译contacts.proro文件后，会发生所选择语言的代码，如果选择的是c++，那么编译后生成两个文件：contacts.pb.h、contacts.pb.cc。</p><p>对于编译生成的c++代码，包含了以下内容：</p><ul><li>对于每个meaaage，都会生成一个对应的消息类</li><li>在消息类中，编译器为每个字段提供了获取和设置方法，以及一些其它能够操作字段的方法</li><li>编译器会针对于每个.proto文件生成.h和.cc文件，分别用来存放类的声明与类的实现</li></ul><blockquote><p>特别的，对于处理类的方法(序列化、反序列化)并不在PeopleInfo里面，而是在它的父类里面定义的。</p></blockquote><p>序列化的结果为二进制字节序列，而非文本格式(json)。</p><p>3.编写main.cc文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;contacts.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string people_str;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对一个联系人的信息使用PB进行序列化，并将结果打印出来</span></span><br><span class="line">        contacts::PeopleInfo people;               <span class="comment">//通过bao(命名空间)定义一个对象</span></span><br><span class="line">        people.<span class="built_in">set_name</span>(<span class="string">&quot;lxx&quot;</span>);</span><br><span class="line">        people.<span class="built_in">set_age</span>(<span class="string">&quot;25&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!people.<span class="built_in">SerializeToString</span>(&amp;people_str))&#123;         <span class="comment">//序列化</span></span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;序列化联系人失败！&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;序列化成功，结果：&quot;</span>&lt;&lt;people_str&lt;&lt;std::endl;         <span class="comment">//打印出的是乱码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对序列化后的内容使用PB进行反序列化，解析出联系人信息并打印出来</span></span><br><span class="line">        contacts::PeopleInfo people;</span><br><span class="line">        <span class="keyword">if</span>(!people.<span class="built_in">ParseFromString</span>(people_str))&#123;           <span class="comment">//反序列化</span></span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;反序列化联系人失败！&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;反序列化成功，结果：&quot;</span>&lt;&lt;people_str&lt;&lt;std::endl</span><br><span class="line">                 &lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;people.<span class="built_in">name</span>()&lt;&lt;std::endl</span><br><span class="line">                 &lt;&lt;<span class="string">&quot;年龄：&quot;</span>&lt;&lt;people.<span class="built_in">age</span>()&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端输入：<code>g++ -o TestPb main.cc contacts.pb.cc -std=c++11 -lprotobuf</code></p><ul><li>生成TestPb可执行文件</li><li>-lprotobuf：加入要使用的库，不加会有链接错误</li><li>-std&#x3D;c++11：要使用c++11的语法</li></ul><p>总结：相对于XML和JSON来说，因为被编码成二进制，破解成本增大，Protobuf编码是相对安全的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-ProtoBuf概述&quot;&gt;&lt;a href=&quot;#1-ProtoBuf概述&quot; class=&quot;headerlink&quot; title=&quot;1.ProtoBuf概述&quot;&gt;&lt;/a&gt;1.ProtoBuf概述&lt;/h1&gt;&lt;p&gt;protobuf也叫protocol buffer，是goo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库mysql</title>
    <link href="https://lxx93.online/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/"/>
    <id>https://lxx93.online/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93mysql/</id>
    <published>2025-01-10T06:46:50.000Z</published>
    <updated>2025-03-29T14:51:53.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本常识"><a href="#1-基本常识" class="headerlink" title="1. 基本常识"></a>1. 基本常识</h1><p>1.查询该linux系统安装的数据库mysql包：<code>rpm -aq | grep mysql </code></p><p>2.启动mysql服务：<code>systemctl start mysqld</code></p><p>3.查看mysql的服务进程是否启动：<code>ps -ef | grep mysqld</code></p><p>4.Oracle数据库和mysql数据库的区别</p><p><img src="/.online//Users\PC\Desktop\数据库\1.png"></p><ul><li>Oracle只有有一个数据库(安装的时候指定的实例)，数据库名就叫<code>orcl</code>，该数据库下有多个用户，如scott、hr等，每个用户下又有很多表。</li><li>Mysql只有一个用户，用户名就叫root，该用户下有很多数据库，每个库下又有很多表。</li></ul><h1 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h1><h2 id="1-mysql服务"><a href="#1-mysql服务" class="headerlink" title="1. mysql服务"></a>1. mysql服务</h2><ul><li>重启Mysql服务：<code>systemctl restart mysqld</code></li><li>查看Mysql服务状态：<code>systemctl status mysqld</code></li><li>停止Mysql服务：<code>systemctl stop mysqld</code></li><li>启动Mysql服务：<code>systemctl start mysqld</code></li></ul><h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h2><p>1、进入mysql</p><ul><li>启动Mysql服务进程：<code>systemctl start mysqld</code></li><li>进入mysql：<code>mysql -uroot -pLxxwly@93</code></li></ul><p>2、查看有哪些数据库</p><ul><li>查看：<code>show databases;</code></li></ul><p>3、创建删除一个数据库firstdb</p><ul><li><p>创建：<code>create database firstdb;</code></p></li><li><p>删除：<code>drop database blog;</code></p></li></ul><p>4、操作数据库firstdb</p><p>(1)进入数据库firstdb：<code>use firstdb;</code></p><p>(2)查看有多少张表：<code>show tables;</code></p><p>(3)创建一张表：<code>create table t1(表名) (id varchar(20),name varchar(50));</code></p><p>(4)展示创建的表：<code>show create table t1;</code></p><p>(5)查看表的字段：<code>desc t1;</code></p><p>(6)向表中插入数据：<code>insert into t1 values (‘0001’,’lxx’);</code></p><p>(7)查看这张表中的所有数据：<code>select * from t1;</code></p><p>(8)按条件查：<code>select * from t1 where id=’0002’</code> </p><ul><li>还有条件的话，可以加and继续</li></ul><p>(9)按条件查，满足包含l字母的：<code>select * from t1 where name like “%l%”</code> </p><ul><li>默认打印出全部，如果后面加limit 1，表示只打印一行</li></ul><p>(10)机器localhost可以通过用户名first、密码为123进入数据库firstdb，对器所有的表进行操作：<code>grant all on firstdb.* to first@’localhost’ identified by “123”;</code></p><p>(11)在客户端(服务器)192.168.88.93上面可以通过用户名first、密码为123进入数据库firstdb，对器所有的表进行操作：<code>grant all on firstdb.* to first@’192.168.88.93’ identified by “123”;</code></p><p><strong>注意：10和11在mysql8.0版本以上就不可以了，需要先创建用户</strong></p><p>(12)先创建用户，在赋予权限：</p><ul><li><p>create user first@’lxx’ identified by ‘Lxxwly@93’;</p></li><li><p>grant all on firstdb.* to first@’lxx’;  ——&gt;all改为select就表示只赋予查找的权限</p></li><li><p>mysql -hlxx -ufirst -pLxxwly@93 -P3306  ——–退出后，从linux终端进入</p></li></ul><p>注意：flush privileges;    —–&gt;刷新权限，每次更改后，需要刷新权限</p><p>(13)删除数据库：<code>drop database test_db;</code></p><p>(14)删除表：<code>drop table test01;</code></p><p>(15)清空表内容：<code>delete from test01;</code></p><p>(16)查看数据库字符集：<code>show variables like &#39;%char%&#39;;</code></p><p>(17)修改密码：<code>mysqladmin -uroot -p password</code></p><h2 id="3-综合案例"><a href="#3-综合案例" class="headerlink" title="3. 综合案例"></a>3. 综合案例</h2><p>1.创建一个学生表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table student(id int, name varchar(20), chinese int, english int, math int);</span><br></pre></td></tr></table></figure><p>2.插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insert into student(id,name,chinese,english,math) values(1,&#x27;路飞&#x27;,80,85,90);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(2,&#x27;索隆&#x27;,90,95,95);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(3,&#x27;山治&#x27;,80,96,96);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(4,&#x27;娜美&#x27;,81,97,85);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(5,&#x27;乌索普&#x27;,85,84,90);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(6,&#x27;罗宾&#x27;,92,85,87);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(7,&#x27;乔巴&#x27;,75,81,80);</span><br><span class="line">insert into student(id,name,chinese,english,math) values(8,&#x27;甚平&#x27;,77,80,79);</span><br></pre></td></tr></table></figure><p>3.基础SQL</p><ul><li>查询表中所有学生的信息：<code>select * from student;</code></li><li>查询表中所有学生的姓名和对应的英语成绩：<code>select name,english from student;</code></li><li>过滤表中英语成绩重复的数据：<code>select distinct english from student;</code></li><li>计算每个人三科的总成绩，并使用别名：<code>select english+chinese+math as 总分 from student;</code></li><li>在所有学生英语分数上加10分：<code>select name,english+10 from student;</code></li><li>查询姓名为索隆的学生成绩：<code>select * from student where name = &#39;索隆&#39;;</code></li><li>查询英语成绩大于90分的同学：<code>select * from student where english &gt; 90;</code></li><li>查询总分大于250分的所有同学：<code>select * from student where english+chinese+math&gt; 250;</code></li><li>查询英语分数在85-95之间的同学：<ul><li><code>select * from student where english&gt;=85 and english&lt;=95;</code></li><li><code>select * from student where english between 85 and 95;</code></li></ul></li><li>查询数学分数为84，90，91的同学：<ul><li><code>select * from student where math=84 or math=90 or math=91;</code></li><li><code>select * from student where math in(84,90,91);</code></li></ul></li><li>查询所有姓索的学生成绩：<code>select * from student where name like &#39;索%&#39;;</code></li><li>对数学成绩排序后输出(升序)：<code>select * from student order by math;</code></li><li>对总分进行排序输出(降序)：<code>select * from student order by math+chinese+english desc;</code></li><li>对姓索的同学按总成绩排序输出(降序)：<code>select * from student where name like &#39;索%&#39; order by math+chinese+english desc;</code></li><li>统计一个班级共有多少学生：<code>select count(*) from student;</code></li><li>统计数学成绩大于90分的学生个数：<code>select count(*) from student where math&gt;90;</code></li><li>统计一个班级数学总成绩：<code>select sum(math) from student;</code></li><li>统计一个班级语文、英语、数学各科的总成绩：<code>select sum(math),sum(chinese),sum(english) from student;</code></li><li>统计一个班级语文、英语、数学的成绩总和：<ul><li><code>select sum(math+chinese+english) from student;</code></li><li><code>select sum(math)+sum(chinese)+sum(english) from student;</code></li></ul></li><li>一个班级的数学平均分：<code>select avg(math) from student;</code></li><li>班级的最高分的最低分：<code>select max(math+chinese+english),min(math+chinese+english) from student;</code></li></ul><h2 id="4-日期时间函数"><a href="#4-日期时间函数" class="headerlink" title="4. 日期时间函数"></a>4. 日期时间函数</h2><p>mysql里面时间分为三类：时间、日期、时间戳(含有时分秒的sysdate)</p><ul><li><p>查看当前时间、当前年、当前月、当前日和当前天：<code>select now(), year(now()), month(now()), day(now()), date(now());</code></p><p><img src="/.online//Users\PC\Desktop\数据库\2.png"></p></li><li><p>查看当前天，当前时间，当前时间戳：<code>select current_date(), current_time(), current_timestamp() from dual;</code></p></li></ul><h2 id="5-相关函数"><a href="#5-相关函数" class="headerlink" title="5. 相关函数"></a>5. 相关函数</h2><ul><li><p>对多个字符串进行拼接：<code>select concat(&#39;aaa&#39;,&#39;bbb&#39;, &#39;ccc&#39;) from dual;</code></p></li><li><p>将字符串转换为大写：<code>select ucase(&#39;abc&#39;) from dual;</code></p></li><li><p>将字符串转换为小写：<code>select lcase(&#39;ABC&#39;) from dual;</code></p></li><li><p>返回第二个参数字符串在第一个参数字符串中出现的位置：<code>select instr(&#39;abc&#39;,&#39;bc&#39;) from dual;</code></p></li><li><p>从字符串abc中的左边起取2个字符：<code>select left(&#39;abc&#39;,2) from dual;</code></p></li><li><p>返回字符串的长度：<code>select length(&#39;abc&#39;) from dual;</code></p></li><li><p>将字符串abcdefg中的abc转换为lxx：<code>select replace(&#39;abcdefg&#39;,&#39;abc&#39;,&#39;lxx&#39;) from dual;</code></p></li><li><p>按字符比较两个字符串的大小：<code>select strcmp(&#39;abcdefg&#39;,&#39;abc&#39;) from dual;</code></p></li><li><p>日期转换为字符串显示：<code>select date_format(now(), &#39;%Y-%m-%d %h:%i:%s&#39;) from dual;</code></p></li></ul><p>1.数字相关函数</p><table><thead><tr><th align="center">函数</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">abs(number)</td><td align="center">绝对值</td></tr><tr><td align="center">bin(number)</td><td align="center">十进制转二进制</td></tr><tr><td align="center">ceiling(number)</td><td align="center">向上取整</td></tr><tr><td align="center">conv(number,from,to)</td><td align="center">进制转换</td></tr><tr><td align="center">floor(number)</td><td align="center">向下取整</td></tr><tr><td align="center">format(number,decimal_places)</td><td align="center">保留小数位数</td></tr><tr><td align="center">hex(number)</td><td align="center">转十六进制</td></tr><tr><td align="center">least(number1,number2,…..)</td><td align="center">求最小值</td></tr><tr><td align="center">mod(numerator,denominator)</td><td align="center">求余</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基本常识&quot;&gt;&lt;a href=&quot;#1-基本常识&quot; class=&quot;headerlink&quot; title=&quot;1. 基本常识&quot;&gt;&lt;/a&gt;1. 基本常识&lt;/h1&gt;&lt;p&gt;1.查询该linux系统安装的数据库mysql包：&lt;code&gt;rpm -aq | grep mysql </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="https://lxx93.online/2024/11/18/redis%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/11/18/redis%E5%9F%BA%E7%A1%80/</id>
    <published>2024-11-18T01:48:53.000Z</published>
    <updated>2025-01-04T05:46:51.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis 也称为远程字典服务，是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库，提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等等。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布&#x2F;订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis Cluster集群架构方案。</p><p>1.主流功能与应用</p><ul><li>分布式缓存，挡在mysql数据库之前的带刀护卫<ul><li>所有查询先去找redis，查得到就直接返回，找不到就去访问MySQL，mysql返回数据以后，就把该数据写到redis，下次客户端在查询该数据，就可用直接在redis上查到了。</li></ul></li><li>内存存储和持久化(RDB+AOF)，redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务<ul><li>redis活着的时候，所有数据都是在内存(memory)的，但断电后，redis里面的数据就会丢失，那又要把mysql的数据重新加载进redis？这样的工作会比较烦躁，所以redis自己也带有数据持久化功能，当redis关机了，在内存中的redis数据可以写进硬盘，那么当redis恢复使用后，就可以把硬盘上的东西重新读回到redis，依旧不麻烦mysql。</li></ul></li><li>高可用架构搭配<ul><li>单机、主场、哨兵、集群</li></ul></li><li>缓存穿透、击穿、雪崩<ul><li>避免一台redis挂了，所有查询都找mysql</li></ul></li><li>分布式锁</li><li>队列</li></ul><p>2.redis与传统数据库(mysql)的关系</p><ul><li>Redis是Key-Value数据库(NoSQL一种)，mysql是关系数据库</li><li>Redis数据操作主要在内存，而mysql主要存储在磁盘</li><li>Redis在某一些场景使用中要明显优于mysql，比如计数器、排行榜等方面</li><li>Redis通常用于一些特定场景，需要与Mysql一起配合使用</li><li>两者并不是相互替换和竞争关系，而是共用和配合使用</li></ul><p>3.redis优势</p><ul><li>性能极高，Redis能读的速度是110000次&#x2F;秒，写的速度是81000次&#x2F;秒</li><li>Redis数据类型丰富，不仅仅支持简单的Key-Value类型的数据，同时还提供list、set、zset、hash等数据结构的存储</li><li>Redis支持数据持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</li><li>Redis支持数据的备份，即master-slave模式的数据备份</li></ul><p>4.总结图</p><p><img src="/.online//图床数据\必备技能skills\3.png"></p><p>5.官网地址</p><p>英文：<a href="https://redis.io/">https://redis.io</a></p><p>中文：</p><ul><li><a href="https://redis.cn/">http://redis.cn</a></li><li><a href="https://www.redis.com.cn/documentation.html">https://www.redis.com.cn/documentation.html</a></li></ul><p>6.Redis源码地址：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><p>7.Redis在线测试：<a href="https://try.redis.io/">https://try.redis.io</a></p><p>8.Redis命令参考：<a href="http://doc.redisfans.com/">http://doc.redisfans.com</a></p><h1 id="2-安装使用"><a href="#2-安装使用" class="headerlink" title="2. 安装使用"></a>2. 安装使用</h1><p>1.下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a>。</p><p>2.下载完后，解压文件，在该文件目录下<code>redis.windows.conf</code>文件中可以修改端口和密码。</p><p>3.启动服务器：在该目录下的终端执行<code>redis-server.exe redis.windows.conf</code>。</p><h2 id="2-1-Redis客户端"><a href="#2-1-Redis客户端" class="headerlink" title="2.1 Redis客户端"></a>2.1 Redis客户端</h2><p>安装完成Redis，我们就可以操作Reids，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编辑客户端</li></ul><p>1.命令行客户端</p><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [option] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的ip地址，默认是127.0.0.1</li><li><code>-p 6279</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123456</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回pong</li></ul><p>不指定commond时，会进入redis-cli的交互控制台。</p><p>注意：如果在文件目录下的控制台直接输入<code>redis-cli.exe -h 127.0.0.1 -p 6380 -a 123456</code>会出现提醒，提醒这样输入密码会有风险，所以可以通过如下命令完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6380</span><br><span class="line">AUTH 123456</span><br></pre></td></tr></table></figure><h1 id="3-常见命令"><a href="#3-常见命令" class="headerlink" title="3. 常见命令"></a>3. 常见命令</h1><h2 id="3-1-Redis数据结构介绍"><a href="#3-1-Redis数据结构介绍" class="headerlink" title="3.1 Redis数据结构介绍"></a>3.1 Redis数据结构介绍</h2><p>Redis是一个Key-Value的数据库，Key一般是String类型，不过value的类型多种多样：</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">hello world</td></tr><tr><td align="center">Hash</td><td align="center">{name: “jack”, age: 21}</td></tr><tr><td align="center">List</td><td align="center">[A -&gt; B -&gt; C -&gt; C]</td></tr><tr><td align="center">Set</td><td align="center">{A, B, C}</td></tr><tr><td align="center">SortedSet</td><td align="center">{A: 1, B: 2, C: 3}</td></tr><tr><td align="center">GEO</td><td align="center">{A: (120.3, 30.5)}</td></tr><tr><td align="center">BitMap</td><td align="center">0110110101110101011</td></tr><tr><td align="center">HyperLog</td><td align="center">0110110101110101011</td></tr></tbody></table><p>其中，前面5种是基本类型，后面3种是特殊类型。</p><p>Redis为了方便我们学习，将操作不同的数据类型的命令也做了分组，在官网<a href="https://redis.io/commands">https://redis.io/commands</a>可以查看到不同的命令。</p><h2 id="3-2-Redis通用命令"><a href="#3-2-Redis通用命令" class="headerlink" title="3.2 Redis通用命令"></a>3.2 Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><p>help：查看一个命令的具体用法，例如：help keys</p></li><li><p>keys：查看符合模板的所有Key，不建议在生产环境设备上使用(底层是模糊查询的机制，当数据量过大时，会给cpu很大的负担，会搜索很长的时间，而redis是单线程的，那么搜索这段时间就不会执行其它程序)</p><ul><li>查询所有匹配的keys：<code>keys *</code></li><li>查询以a开头的所有的keys：<code>keys a*</code></li></ul></li><li><p>del：删除一个指定的key</p><ul><li>删除name这个key：<code>del name</code></li></ul></li><li><p>exists：判断key是否存在，存在返回1，不存在就返回0</p><ul><li>判断name这个key是否存在：<code>exists name</code></li></ul></li><li><p>expire：给一个key设置有效期，有效期到期时，该key会被自动删除</p><ul><li>给age这个key设置20秒的有效期：<code>expire age 20</code></li></ul></li><li><p>ttl：查看一个key的剩余有效期，当返回-2时，说明该key已经不存在了</p><ul><li>查看age这个key的剩余有效期：<code>ttl age</code></li><li>当创建的key没有指定有效期时，通过ttl查询会返回-1，表示该key会永久有效。</li></ul></li></ul><h2 id="3-3-String类型"><a href="#3-3-String类型" class="headerlink" title="3.3 String类型"></a>3.3 String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">msg</td><td align="center">hello world</td></tr><tr><td align="center">num</td><td align="center">10</td></tr><tr><td align="center">score</td><td align="center">92.5</td></tr></tbody></table><p>1.String类型的常见命令：</p><ul><li>set：添加或者修改已经存在的一个String类型的键值对</li><li>get：根据key获取String类型的value</li><li>mset：批量添加多个String类型的键值对</li><li>mget：根据多个key获取多个String类型的value</li><li>incr：让一个整型的key自增1</li><li>incrby：让一个整型的key自增并指定步长，例如：incrby num 2 让num的值自增2</li><li>incrbyfloat：让一个浮点类型的数字自增(必须指定步长)</li><li>setnx：添加一个String类型的键值对，前提是这个key不存在，否则不执行(修改不成功)</li><li>setex：添加一个String类型的键值对，并且指定有效期<ul><li>添加一个key为name，value为jack，有效期为10s的数据：<code>setex name 10 jack</code></li></ul></li></ul><p>Redis没有类似Mysql中Table的概念，那该如何区分不同类型的key？</p><p>2.key的结构</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><p><code>项目名：业务名：类型：id</code></p><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条</p><p>例如项目名称叫heima，有user和product两种不同类型的数据，可以这样定义key：</p><ul><li>user相关的key：heima:user:1</li><li>product相关的key：heima:product:1</li></ul><p>如果value是一个java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th align="center">KEY</th><th align="center">VALUE</th></tr></thead><tbody><tr><td align="center">heima:user:1</td><td align="center">{“id”: 1, “name”: “jack”, “age”: 21 }</td></tr><tr><td align="center">heima:product:1</td><td align="center">{“id”: 1, “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>例子：</p><p><img src="/.online//图床数据\必备技能skills\4.png"></p><h2 id="3-4-Hash类型"><a href="#3-4-Hash类型" class="headerlink" title="3.4 Hash类型"></a>3.4 Hash类型</h2><p>Hash类型，也叫散列，其中value是一个无序字典，类似于java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/.online//图床数据\必备技能skills\5.png"></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/.online//图床数据\必备技能skills\6.png"></p><p>1.Hash类型的常见命令：</p><ul><li><p>hset key field value：添加或者修改hash类型key的field的值</p><ul><li>向heima:user:3里面的name添加值lucy：<code>hset heima:user:3 name lucy</code></li><li>向heima:user:3里面的age添加值21：<code>hset heima:user:3 age 21</code></li></ul></li><li><p>hget key field：获取一个hash类型key的field的值</p></li><li><p>hmset：批量添加多个hash类型key的field的值</p><ul><li>使用：<code>hmset heima:user:4 name lilei age 20 sex man</code></li></ul></li><li><p>hmget：批量获取多个hash类型key的field的值</p><ul><li>使用：<code>hmget heima:user:4 name age sex</code></li></ul></li><li><p>hgetall：获取一个hash类型的key中的所有的field和value</p></li><li><p>hkeys：获取一个hash类型的key中的所有的field</p></li><li><p>hvals：获取一个hash类型的key中的所有的value</p></li><li><p>hincrby：让一个hash类型key的字段值自增并指定步长</p><p>使用(自增2)：<code>hincrby heima:user:3 age 2</code></p></li><li><p>hsetnx：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行(修改不成功)</p></li></ul><h2 id="3-4-List类型"><a href="#3-4-List类型" class="headerlink" title="3.4 List类型"></a>3.4 List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，如朋友圈点赞列表、评论列表等。</p><p>List类型的常见命令</p><ul><li>lpush key element … ：向列表左侧插入一个或多个元素<ul><li>向users的列表左侧依次插入1、2、3：<code>Lpush users 1 2 3</code></li></ul></li><li>lpop key ：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>rpush key element … ：向列表右侧插入一个或多个元素</li><li>rpop key ：移除并返回列表右侧的第一个元素，没有则返回nil</li><li>lrange key start end ：返回一段角标范围内的所有元素<ul><li>向users的列表左侧依次取出下标1到3的元素（）：<code>lrange users 1 3</code></li></ul></li><li>blpop和brpop ：与lpop和rpop类似，只不过在没有元素时等待指定时间，而不是直接返回nil<ul><li>向users2中从左边移除元素，且等待时间为39秒：<code>blpop users2 39</code></li></ul></li></ul><h2 id="3-5-Set类型"><a href="#3-5-Set类型" class="headerlink" title="3.5 Set类型"></a>3.5 Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个Hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p>Set类型的常见命令</p><ul><li>sadd key member … ：向set中添加一个或多个元素</li><li>srem key member … ：移除set中的指定元素</li><li>scard key ：返回set中元素的个数</li><li>sismember key member ：判断一个元素是否存在于set中</li><li>smembers：获取set中的所有元素</li><li>sinter key1 key2 … ：求key1和key2的交集</li><li>sdiff key1 key2 … ：求key1和key2的差集(key1中有，而key2中没有的元素)</li><li>sunion key1 key2 … ：求key1和key2的并集</li></ul><h2 id="3-6-SortedSet类型"><a href="#3-6-SortedSet类型" class="headerlink" title="3.6 SortedSet类型"></a>3.6 SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别较大，SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表(SkipList)加hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因此SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet类型的常见命令</p><ul><li>zadd key score member：添加一个或多个元素到sortedset，如果已经存在则更新其score值<ul><li>使用：<code>zadd students 85 jack 83 kucy 95 tom</code></li></ul></li><li>zrem key member：删除sortedset中的一个指定元素<ul><li>使用：<code>zrem students tom</code></li></ul></li><li>zscore key member：获取sortedset中的指定元素的score值</li><li>zrank key member：获取sortedset中的指定元素的排名<ul><li>使用：<code>zrank students rose</code></li></ul></li><li>zcard key：获取sortedset中的元素个数<ul><li>使用：<code>zcard students</code></li></ul></li><li>zcount key min max：统计score值在给定范围内的所有元素的个数<ul><li>使用：<code>zcount students 0 80</code></li></ul></li><li>zincrby key increment member：让sortedset中的指定元素自增，步长为指定的increment值<ul><li>使用：<code>zincrby students 2 rose</code></li></ul></li><li>zrange key min max：按照score排序后，获取指定排名范围内的元素<ul><li>如果是前三名：<code>zrevrange students 0 2</code></li></ul></li><li>zrangebyscore key min max：按照score排序后，获取指定score范围内的元素</li><li>zdiff、zinter、zunion：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序的，如果要降序则在命令的Z后面添加rev即可</p><p>Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis 也称为远程字典服务，是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++基础</title>
    <link href="https://lxx93.online/2024/11/03/c++%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/11/03/c++%E5%9F%BA%E7%A1%80/</id>
    <published>2024-11-03T06:15:26.000Z</published>
    <updated>2025-01-04T05:46:34.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-c-简介"><a href="#1-c-简介" class="headerlink" title="1. c++简介"></a>1. c++简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<em><strong>中级</strong></em>语言，它综合了高级语言和低级语言的特点。</p><p><strong>注意：</strong>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</li><li>继承：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</li><li>多态：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</li><li>抽象：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</li></ul><h1 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h1><h2 id="1-变量和数据类型"><a href="#1-变量和数据类型" class="headerlink" title="1. 变量和数据类型"></a>1. 变量和数据类型</h2><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。</p><p>c++中七种基本的 C++ 数据类型及其扩展：</p><table><thead><tr><th align="center">类型</th><th align="center">位</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">-128到127 或者 0到255</td></tr><tr><td align="center">unsigned char</td><td align="center">1</td><td align="center">0到255</td></tr><tr><td align="center">signed char</td><td align="center">1</td><td align="center">-128到127</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">-2147483648 到 2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">4</td><td align="center">0 到 4294967295</td></tr><tr><td align="center">signed int</td><td align="center">4</td><td align="center">-2147483648 到 2147483647</td></tr><tr><td align="center">short int</td><td align="center">2</td><td align="center">-32768 到 32767</td></tr><tr><td align="center">unsigned short int</td><td align="center">2</td><td align="center">0 到 65,535</td></tr><tr><td align="center">signed short int</td><td align="center">2</td><td align="center">-32768 到 32767</td></tr><tr><td align="center">long int</td><td align="center">8</td><td align="center">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">signed long int</td><td align="center">8</td><td align="center">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="center">unsigned long</td><td align="center">8</td><td align="center">0 到 18,446,744,073,709,551,615</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">单精度型浮点型</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">双精度型浮点型</td></tr><tr><td align="center">long long</td><td align="center">8</td><td align="center"></td></tr><tr><td align="center">long double</td><td align="center">16</td><td align="center"></td></tr><tr><td align="center">wchar_t</td><td align="center">2或4</td><td align="center">1个宽字符</td></tr></tbody></table><p>类型转换</p><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p><ul><li><p>静态转换</p><ul><li><p>静态转换是将一种数据类型的值强制转换为另一种数据类型的值。</p></li><li><p>静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。</p></li><li><p>静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;                    <span class="comment">//其他类型指针-&gt;void*指针-&gt;其他类型指针</span></span><br><span class="line"><span class="type">double</span>* pp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(ptr);     <span class="comment">//将指针类型转换的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">long</span> b = a;                           <span class="comment">//安全，可以隐式转换，不会出现警告</span></span><br><span class="line"><span class="type">double</span> c = <span class="number">1.23</span>;</span><br><span class="line"><span class="type">long</span> d = (<span class="type">long</span>)c;                     <span class="comment">//C风格：显式转换</span></span><br><span class="line"><span class="type">long</span> d1 = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(c);      <span class="comment">//c++风格：显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//double* pd1 = &amp;a;                    //错误，不能隐式转换</span></span><br><span class="line"><span class="type">double</span>* pd2 = (<span class="type">double</span>*)&amp;a;             <span class="comment">//c风格，强制类型转换</span></span><br><span class="line"><span class="comment">//double* pd3 = static_cast&lt;double*&gt;(&amp;a);     //错误，static_cast不支持不同类型指针的转换，但可以通过void*指针中转</span></span><br><span class="line"><span class="type">void</span>* pv = &amp;a;                         <span class="comment">//任何类型的指针都可以隐式的转换为void*(无符号型指针)</span></span><br><span class="line"><span class="type">double</span>* pd3 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(pv);      <span class="comment">//然后通过static_cast将void*转换为其他类型的指针</span></span><br><span class="line">cout &lt;&lt; pd3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态转换</p><ul><li><p>动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 将基类指针转换为派生类指针</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>常量转换</p><ul><li><p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。</p></li><li><p>常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 常量转换，将const int转换为int</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>重新解释转换</p><ul><li><p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。</p></li><li><p>重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p></li><li><pre><code class="c++">int i = 10;float f = reinterpret_cast&lt;float&amp;&gt;(i); // 重新解释将int类型转换为float类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;    //使用std这个命名空间</span><br><span class="line">int number;   //全局变量可以不用赋值，默认为0</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int number = 1;    //局部变量</span><br><span class="line">cout &lt;&lt; &quot;number=&quot; &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;::number=&quot; &lt;&lt; ::number &lt;&lt; endl;     //访问全局变量前要加::</span><br><span class="line"></span><br><span class="line">//定义常量</span><br><span class="line">const float Pi = 3.14;</span><br><span class="line">cout &lt;&lt; &quot;Pi=&quot; &lt;&lt; Pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//特殊字符</span><br><span class="line">cout &lt;&lt; &quot;hello world\t\&quot;hello world\&quot;\n \?&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>c++中有两种类型的表达式：</p><ul><li>左值：指向内存位置的表达式被称为左值表达式。左值可以出现在赋值号的左边或右边。</li><li>右值：术语右值指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul><p>c++中的变量作用域：</p><ul><li>局部作用域：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。</li><li>全局作用域：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。</li><li>块作用域：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。</li><li>类作用域：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。</li></ul><h2 id="2-修饰符类型"><a href="#2-修饰符类型" class="headerlink" title="2. 修饰符类型"></a>2. 修饰符类型</h2><p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p><table><thead><tr><th align="center">限定符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">const</td><td align="center">const定义常量，表示该变量的值不能被修改</td></tr><tr><td align="center">volatile</td><td align="center">修饰符volatile告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程</td></tr><tr><td align="center">restrict</td><td align="center">由restrict修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict</td></tr><tr><td align="center">mutable</td><td align="center">表示类中的成员变量可以在 const 成员函数中被修改</td></tr><tr><td align="center">static</td><td align="center">用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问</td></tr><tr><td align="center">register</td><td align="center">用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// 定义常量 NUM，其值不可修改</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// 定义变量 num，其值可能会在未知的时间被改变</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_; <span class="comment">// const 关键字表示该成员函数不会修改对象中的数据成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// mutable 关键字允许在 const 成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// register 关键字建议编译器将变量 num 存储在寄存器中</span></span><br><span class="line">    <span class="comment">// 以提高程序执行速度</span></span><br><span class="line">    <span class="comment">// 但是实际上是否会存储在寄存器中由编译器决定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//短路求值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span> || ++i;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位运算符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0xb5</span>;    <span class="comment">// 1011 0101</span></span><br><span class="line">cout &lt;&lt; hex;      <span class="comment">//十六进制表示(设置cout的输出格式为十六进制表示)</span></span><br><span class="line"><span class="comment">//算术操作符会导致 整型提升(bits原来是8位，经过移动操作后，c++会将其提升为int类型32位)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bits左移2位：&quot;</span> &lt;&lt; (bits &lt;&lt; <span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 0000 0000 0000 0000 0000 0010 1101 0100</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bits右移2位：&quot;</span> &lt;&lt; (bits &gt;&gt; <span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// 0000 0000 0000 0000 0000 0000 0010 1101</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dec;     <span class="comment">//十进制表示</span></span><br><span class="line">cout &lt;&lt; (<span class="number">200</span> &lt;&lt; <span class="number">3</span>) &lt;&lt; endl;        <span class="comment">//扩大8倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//位逻辑运算符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc1 = <span class="number">5</span>;      <span class="comment">// 0000 0101</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc2 = <span class="number">12</span>;     <span class="comment">// 0000 1100</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~uc1) &lt;&lt; endl;   <span class="comment">//按位取反    1111 1010  最高位是1，是负数(负数是以补码形式表示的)，原码：0000 0110</span></span><br><span class="line">cout &lt;&lt; (uc1 &amp; uc2) &lt;&lt; endl;     <span class="comment">//按位取与    0000 0100</span></span><br><span class="line">cout &lt;&lt; (uc1 | uc2) &lt;&lt; endl;     <span class="comment">//按位取或    0000 1101</span></span><br><span class="line">cout &lt;&lt; (uc1 ^ uc2) &lt;&lt; endl;     <span class="comment">//按位异或    0000 1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：从一组数里找出只出现一次的那个数</span></span><br><span class="line"><span class="type">int</span> i1 = <span class="number">5</span>, i2 = <span class="number">12</span>, i3 = <span class="number">12</span>, i4 = <span class="number">9</span>, i5 = <span class="number">5</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;只出现一次的那个数：&quot;</span> &lt;&lt; (i1 ^ i2 ^ i3 ^ i4 ^ i5) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line"><span class="type">int</span> total = <span class="number">20</span>, num = <span class="number">6</span>;</span><br><span class="line"><span class="type">double</span> avg = total / num;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; avg &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; (<span class="type">double</span>)total / num &lt;&lt; endl;   <span class="comment">//c语言风格</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; <span class="built_in">double</span>(total) / num &lt;&lt; endl;   <span class="comment">//c++函数调用风格</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;avg=&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total) / num &lt;&lt; endl;   <span class="comment">//c++强制类型转换运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span></span><br><span class="line">bits左移<span class="number">2</span>位：<span class="number">2</span>d4</span><br><span class="line">bits右移<span class="number">2</span>位：<span class="number">2</span>d</span><br><span class="line"><span class="number">1600</span></span><br><span class="line"><span class="literal">-6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">只出现一次的那个数：<span class="number">9</span></span><br><span class="line">avg=<span class="number">3</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br><span class="line">avg=<span class="number">3.33333</span></span><br></pre></td></tr></table></figure><h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h2><p>1.范围for循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;现在的数字是：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.99乘法表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">cout &lt;&lt; j &lt;&lt; <span class="string">&quot;X&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; i * j &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.绘制爱心曲线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//爱心曲线方程：(x^2+y^2-a)^3-x^2 * y^3 = 0</span></span><br><span class="line"><span class="type">double</span> a = <span class="number">0.8</span>;</span><br><span class="line"><span class="type">double</span> bound = <span class="number">1.3</span> * <span class="built_in">sqrt</span>(a);</span><br><span class="line"><span class="comment">//x,y坐标变换步长</span></span><br><span class="line"><span class="type">double</span> step = <span class="number">0.1</span>;</span><br><span class="line"><span class="comment">//二维码扫描所有点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> y = bound; y &gt;= -bound; y -= step) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> x = -bound; x &lt;= bound; x += <span class="number">0.5</span>*step) &#123;</span><br><span class="line"><span class="comment">//代入曲线方程，计算每个点是否在曲线内</span></span><br><span class="line"><span class="type">double</span> result = <span class="built_in">pow</span>((<span class="built_in">pow</span>(x,<span class="number">2</span>) + <span class="built_in">pow</span>(y, <span class="number">2</span>) - a), <span class="number">3</span>) - <span class="built_in">pow</span>(x, <span class="number">2</span>) * <span class="built_in">pow</span>(y, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-指针与常量"><a href="#5-指针与常量" class="headerlink" title="5. 指针与常量"></a>5. 指针与常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义指针</span></span><br><span class="line"><span class="type">int</span>* p1;</span><br><span class="line"><span class="type">long</span>* p2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>* p3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p3) &lt;&lt; endl;      <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的使用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line"><span class="type">long</span> c = <span class="number">93</span>;</span><br><span class="line">p1 = &amp;a;</span><br><span class="line">p2 = &amp;c;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的地址为：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;          <span class="comment">//0000007A6770FB94</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b的地址为：&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;          <span class="comment">//0000007A6770FBB4</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c的地址为：&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;          <span class="comment">//0000007A6770FBD4</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1 &lt;&lt; endl;                <span class="comment">//0000007A6770FB94</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; endl;                <span class="comment">//0000007A6770FBD4</span></span><br><span class="line"></span><br><span class="line">*p1 = <span class="number">12</span>;     <span class="comment">//修改p1指针指向的变量值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//12</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//将p1指向的变量改为b的地址</span></span><br><span class="line">*p1 = <span class="number">25</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//12</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;                 <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指向常量的指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1 = <span class="number">10</span>, c2 = <span class="number">25</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pc = &amp;c1;     <span class="comment">//pc指向int类型常量的指针，   int* pc = &amp;c1;会报错</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pc=&quot;</span> &lt;&lt; *pc &lt;&lt; endl;            <span class="comment">//10</span></span><br><span class="line">pc = &amp;c2;       <span class="comment">//指向的常量不能修改，但可以修改指针的指向</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*pc=&quot;</span> &lt;&lt; *pc &lt;&lt; endl;            <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指针常量(const指针)：指针的指向不能改</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> cp = &amp;a;     <span class="comment">//只能指向int型变量，不能是常量</span></span><br><span class="line">*cp = <span class="number">93</span>;    <span class="comment">//指向的地址不能变，但里面的值可以变</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;                 <span class="comment">//93</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//指针数组和数组指针</span></span><br><span class="line"><span class="type">int</span>* pa[<span class="number">5</span>];       <span class="comment">//指针数组：数组里面存的是指针</span></span><br><span class="line"><span class="built_in">int</span>(*ap)[<span class="number">5</span>];      <span class="comment">//数组指针：指向数组的指针</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pa在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(pa) &lt;&lt; endl;      <span class="comment">//5*8 = 40</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ap在内存中的长度为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ap) &lt;&lt; endl;      <span class="comment">//是一个指针，所以长度是8</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, &#125;;</span><br><span class="line">ap = &amp;arr;        <span class="comment">//ap指向的是整个arr数组，不能是ap=arr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-引用与常量"><a href="#6-引用与常量" class="headerlink" title="6. 引用与常量"></a>6. 引用与常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//引用：地址是同一个地址，而且引用一个变量过后，不能再绑定其他变量，地址就定了，但里面的值可以改</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;     <span class="comment">//   int&amp; ref =90;  将会报错</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref=&quot;</span> &lt;&lt; ref &lt;&lt; endl;             <span class="comment">//10</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a的地址为：&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;        <span class="comment">//0000001CE5EFF964</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref的地址为：&quot;</span> &lt;&lt; &amp;ref &lt;&lt; endl;    <span class="comment">//0000001CE5EFF964</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对常量的引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref = zero;</span><br><span class="line"><span class="comment">//cref = 10;   cref是zero的一个常量引用了，因此不能修改所引用的值</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref2 = i;     <span class="comment">//可以用一个变量做初始值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cref3 = <span class="number">10</span>;   <span class="comment">//可以用字面值常量做初始化值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针常量</span></span><br><span class="line"><span class="type">int</span> t = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span>&amp; ref6 = t;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;t;</span><br><span class="line">ref6 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; endl;        <span class="comment">//20</span></span><br><span class="line">*p = <span class="number">15</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t=&quot;</span> &lt;&lt; t &lt;&lt; endl;        <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定指针的引用</span></span><br><span class="line"><span class="type">int</span>* ptr = &amp;a;</span><br><span class="line"><span class="type">int</span>*&amp; prep = ptr;</span><br><span class="line"><span class="comment">//没有指向引用的指针，因为引用不是一种数据类型，它也是绑定其他数据类型的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量引用</strong>：通过使用 <code>const int&amp;</code>，你可以创建一个引用，该引用可以引用常量(const int)、变量(int)或字面值(10)，但你不能通过这个引用修改其引用的值。</p><p><strong>引用与指针常量的区别</strong></p><p>引用：</p><ul><li>绑定后不可变，始终指向同一个变量</li><li>可以通过引用来修改其所绑定变量的值</li></ul><p>指针常量：</p><ul><li>绑定后不可变，指向的对象不能改变</li><li>可以通过指针来修改其所指向变量的值</li></ul><p>结论：引用和指针常量在绑定后都是不能再绑定到其他变量，但它们的用法和语义上有明显的区别。引用更像是一个别名，而指针常量则是一个变量，其值是一个内存地址。</p><h2 id="7-对象特性"><a href="#7-对象特性" class="headerlink" title="7. 对象特性"></a>7. 对象特性</h2><p>1.构造函数和析构函数</p><p>构造函数和析构函数都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</p><ul><li><p>构造函数</p><ul><li>没有返回值，不用写void</li><li>函数名与类名相同</li><li>构造函数可以有参数，可以发生重载</li><li>创建对象的时候，构造函数会自动调用，而且只调用一次</li></ul></li><li><p>析构函数(进行清理的操作)</p><ul><li>没有返回值，不写void</li><li>函数名和类名相同，在名称前加~</li><li>析构函数不可以有参数的，不可以发生重载</li><li>对象在销毁前，会自动调用析构函数，而且只调用一次</li></ul></li></ul><p>2.成员变量和成员函数分开存储</p><p>空对象占用内存空间为1，c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置。</p><p>下面这个程序中，当Person类中有<code>int num</code>的时候，程序输出为4，当没有<code>int num</code>的时候，输出的结果为1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> num;               <span class="comment">//非静态成员变量，属于类的对象上</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sum;        <span class="comment">//静态成员变量，不属于类对象上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;         <span class="comment">//非静态成员函数，不属于类对象上</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">//静态成员函数，不属于类对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类的大小：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.this指针和指针常量</p><p>this指针的本质是指针常量，指针的指向是不可以修改的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//在成员函数后面加const，修饰的是this指向，让指针指向的值也不能修改，相当于const Person * const this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;           <span class="comment">//常函数</span></span><br><span class="line"><span class="comment">//this-&gt;a = 100;    </span></span><br><span class="line"><span class="keyword">this</span>-&gt;b = <span class="number">100</span>;    <span class="comment">//不会报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> b;   <span class="comment">//特殊变量，即使在常函数中，也可以修改这个值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"><span class="type">const</span> Person p1;  <span class="comment">//在对象前面加const，变为常对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-运算符重载"><a href="#8-运算符重载" class="headerlink" title="8. 运算符重载"></a>8. 运算符重载</h2><p>1.赋值运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在普通赋值运算符情况下，当有些属性创建在堆区，此时就会出现浅拷贝的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person&amp; p) &#123;</span><br><span class="line"><span class="comment">//编译器提供的是浅拷贝</span></span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">p3 = p2 = p1;</span><br><span class="line">cout &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.关系运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 ==  号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载 !=  号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;lxx&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;lxx&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.加号运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运算符重载：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1、成员函数来重载+运算符</span></span><br><span class="line"><span class="comment">//下面调用的本质：Person p3 =p1.operator+(p2);</span></span><br><span class="line"><span class="comment">/*Person operator+(Person&amp; p) &#123;</span></span><br><span class="line"><span class="comment">Person temp;</span></span><br><span class="line"><span class="comment">temp.ma = this-&gt;ma + p.ma;</span></span><br><span class="line"><span class="comment">temp.mb = this-&gt;mb + p.mb;</span></span><br><span class="line"><span class="comment">return temp;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数重载</span></span><br><span class="line"><span class="comment">//下面调用的本质：Person p3 = operator+(p1, p2);</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.ma = p1.ma + p2.ma;</span><br><span class="line">temp.mb = p1.mb + p2.mb;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、运算符重载也可以发生函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, <span class="type">int</span> num) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.ma = p1.ma + num;</span><br><span class="line">temp.mb = p1.mb + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p1.ma = <span class="number">10</span>;</span><br><span class="line">p1.mb = <span class="number">10</span>;</span><br><span class="line">Person p2;</span><br><span class="line">p2.ma = <span class="number">10</span>;</span><br><span class="line">p2.mb = <span class="number">10</span>;</span><br><span class="line">Person p3 = p1 + p2;</span><br><span class="line"><span class="comment">// Person p3 = p1.operator+(p2);      //第一种重载也可以使用这种方式来使用</span></span><br><span class="line">Person p4 = p1 + <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; p3.ma &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p3.mb &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.ma &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p4.mb &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.左移运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//利用成员函数重载 左移运算符 p.operator&lt;&lt;(cout)  简化版本是p&lt;&lt;cout</span></span><br><span class="line"><span class="comment">//不能利用成员函数进行重载&lt;&lt;运算符，因为无法实现 cout在左侧</span></span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;p) &#123;      <span class="comment">//operator&lt;&lt;(cout,p)的本质是cout&lt;&lt;p</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ma=&quot;</span> &lt;&lt; p.ma &lt;&lt; <span class="string">&quot; mb=&quot;</span> &lt;&lt; p.mb;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">Person p;</span><br><span class="line">p.ma = <span class="number">10</span>; p.mb = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-继承"><a href="#9-继承" class="headerlink" title="9. 继承"></a>9. 继承</h2><p>1.以public方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中依然是公共权限</li><li>父类中的保护权限成员 到 子类中依然是保护权限</li><li>父类中的私有权限成员 在 子类中访问不到</li></ul><p>2.以protected方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中是保护权限</li><li>父类中的保护权限成员 到 子类中是保护权限</li><li>父类中的私有权限成员 在 子类访问不到</li></ul><p>3.以private方式继承父类</p><ul><li>父类中的公共权限成员 到 子类中是私有权限</li><li>父类中的保护权限成员 到 子类中是私有权限</li><li>父类中的私有权限成员 在 子类访问不到</li></ul><p>注意：继承中的构造函数和析构函数的顺序：先构造父类，再构造子类，析构函数顺序与构造函数顺序相反</p><p>如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数。如果想访问到父类中被隐藏的同名成员函数，需要加作用域</p><p>菱形继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承，解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前，加上关键字virtual变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yyy</span> :<span class="keyword">public</span> sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">yyy s;</span><br><span class="line">s.sheep::ma = <span class="number">18</span>;</span><br><span class="line">s.Tuo::ma = <span class="number">24</span>;</span><br><span class="line"><span class="comment">//加上虚继承后，访问的就是同一个地址下的值了，解决了资源浪费的问题</span></span><br><span class="line">cout &lt;&lt; s.sheep::ma &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Tuo::ma &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.ma &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-多态"><a href="#10-多态" class="headerlink" title="10. 多态"></a>10. 多态</h2><p>1.多态满足的条件</p><ul><li>有继承关系</li><li>子类重写父类的虚函数(重写：函数返回值类型、函数名、参数列表 完成相同)</li></ul><p>多态使用：父类的指针或者引用 指向子类对象</p><p>2.纯虚函数：只要有一个纯虚函数，这个类就是抽象类<br>抽象类的特定：</p><ul><li>无法实例化</li><li>抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子类中func的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Base b;     //无法实例化抽象类</span></span><br><span class="line">Base* p = <span class="keyword">new</span> son;</span><br><span class="line">p-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.虚析构函数和纯虚析构函数共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>区别：如果是纯虚析构函数，该类是抽象类，无法实例化对象。</p><p>虚析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;            <span class="comment">// 虚析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;                <span class="comment">// 派生类的析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();      <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;                     <span class="comment">// 删除时调用派生类和基类的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>纯虚析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="number">0</span>;  <span class="comment">// 纯虚析构函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Base::~<span class="built_in">Base</span>() &#123;  <span class="comment">// 纯虚析构函数的定义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Base destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;  <span class="comment">// 派生类的析构函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;  <span class="comment">// 删除时调用派生类和基类的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-模板"><a href="#11-模板" class="headerlink" title="11. 模板"></a>11. 模板</h2><p>1.函数模板的应用：建立一个通用函数，其函数反回值类型和形参可以不具体制定，用一个虚拟的类型来表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//声明一个模板，告诉编译器后面代码种紧跟这的T不要报错，T是一个通用数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line"><span class="comment">//1、自动类型推到</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line"><span class="comment">//mySwap(a, c);   //错误，T推到不出一致的类型，一个是int，一个是char</span></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="comment">//mySwap&lt;int&gt;(a, b);</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="comment">//func();      //报错，模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.调用规则</p><ul><li>如果函数模板和普通函数都可以调用，优先调用普通函数</li><li>可以通过空模板参数列表 强制调用 函数模板</li><li>函数模板可以发生函数重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;普通函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;模板函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;模板函数重载调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myprint</span>(a,b); <span class="comment">//调用的是普通函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过空模板参数列表，强制调用函数模板</span></span><br><span class="line">myprint&lt;&gt;(a, b);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板也可以重载</span></span><br><span class="line"><span class="built_in">myprint</span>(a, b, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数模板可以产生更好的匹配，优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myprint</span>(c1, c2);    <span class="comment">//虽然普通函数可以隐式的转换类型，但调用的是模板函数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.函数模板的全特化</p><p>模板的调用不是万能的，当对自定义类型数据等进行比较时，会有问题。利用全特化的模板，可以解决自定义类型的通用性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;      <span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">if</span> (a == b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;    <span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> ma;</span><br><span class="line"><span class="type">int</span> mb;</span><br><span class="line"><span class="built_in">person</span>(<span class="type">int</span> a,<span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ma = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;mb = b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用具体化person的版本实现代码，具体化优先调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">bool</span> <span class="title">mycompare</span><span class="params">(person&amp; p1, person&amp; p2)</span> </span>&#123;    <span class="comment">//template&lt;&gt;是模板全特化</span></span><br><span class="line"><span class="keyword">if</span> (p1.ma == p2.ma &amp;&amp; p1.mb == p2.mb) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">bool</span> ref = <span class="built_in">mycompare</span>(a, b);     <span class="comment">//是int类型，调用原始模板即可</span></span><br><span class="line"><span class="keyword">if</span> (ref) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">bool</span> ref1 = <span class="built_in">mycompare</span>(p1, p2);      <span class="comment">//是person类型，调用自己写的全特化的模板</span></span><br><span class="line"><span class="keyword">if</span> (ref1) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板全特化 :</p><ul><li><code>template&lt;&gt;</code> 表示这是一个模板的完全特化版本。也就是说，这个 <code>mycompare</code> 函数专门用于 <code>person</code> 类型的对象比较。</li><li>全特化意味着 <code>mycompare</code> 函数模板的原型存在，但这里的版本仅适用于 <code>person</code> 类型。</li></ul><p>4.类模板</p><p>类模板与函数模板的区别</p><ul><li>类模板没有自动类型推导的使用方法</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mname = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mage = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mname &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; mage &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">NameType mname;</span><br><span class="line">AgeType mage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">39</span>)</span></span>;</span><br><span class="line">p1.<span class="built_in">showperson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板中的成员函数并不是一开始就创建的，在调用时才去创建的。</p><h1 id="2-STL教程"><a href="#2-STL教程" class="headerlink" title="2. STL教程"></a>2. STL教程</h1><p>C++ 标准模板库是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p><p>STL 分为多个组件，包括容器、迭代器、算法、函数对象和适配器等。</p><h2 id="1-array容器"><a href="#1-array容器" class="headerlink" title="1. array容器"></a>1. array容器</h2><p><code>std::array</code> 是 C++ 标准库中的一个模板类，它定义在 <code>&lt;array&gt;</code> 头文件中。<code>std::array</code> 模板类提供了一个固定大小的数组，其大小在编译时确定，并且不允许动态改变。与 C 语言中的数组相比，具有更好的类型安全和内存管理特性。</p><p>1.std::array的基本语法：</p><p><code>std::array&lt;T, N&gt; array_name;</code></p><ul><li><code>T</code> 是数组中元素的类型。</li><li><code>N</code> 是数组的大小，必须是一个非负整数。</li></ul><p>声明与初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明一个定长为5的int数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.特点</p><ul><li><strong>类型安全</strong>：<code>std::array</code> 强制类型检查，避免了 C 语言数组的类型不安全问题。</li><li><strong>固定大小</strong>：数组的大小在编译时确定，不能在运行时改变。</li><li><strong>内存连续</strong>：<code>std::array</code> 的元素在内存中是连续存储的，这使得它可以高效地访问元素。</li><li><strong>标准容器</strong>：<code>std::array</code> 提供了与 <code>std::vector</code> 类似的接口，如 <code>size()</code>, <code>at()</code>, <code>front()</code>, <code>back()</code> 等。</li></ul><p>3.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>at(size_t pos)</code></td><td align="left">返回指定位置的元素，带边界检查</td></tr><tr><td align="left"><code>operator[]</code></td><td align="left">返回指定位置的元素，不带边界检查</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回数组的第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回数组的最后一个元素</td></tr><tr><td align="left"><code>data()</code></td><td align="left">返回指向数组数据的指针</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回数组大小（固定不变）</td></tr><tr><td align="left"><code>fill(const T&amp; value)</code></td><td align="left">将数组所有元素设置为指定值</td></tr><tr><td align="left"><code>swap(array&amp; other)</code></td><td align="left">交换两个数组的内容</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回数组的起始&#x2F;结束迭代器</td></tr></tbody></table><p>4.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::array</code></th></tr></thead><tbody><tr><td align="center"><strong>大小</strong></td><td align="center">编译时固定</td></tr><tr><td align="center"><strong>边界检查</strong></td><td align="center"><code>at()</code> 提供边界检查</td></tr><tr><td align="center"><strong>内存管理</strong></td><td align="center">栈上分配</td></tr><tr><td align="center"><strong>性能</strong></td><td align="center">高效</td></tr><tr><td align="center"><strong>接口</strong></td><td align="center">支持 STL 标准接口</td></tr></tbody></table><h2 id="2-vector容器"><a href="#2-vector容器" class="headerlink" title="2. vector容器"></a>2. vector容器</h2><p><code>vector</code>是 STL 中的一个容器类，用于存储动态大小的数组。<code>vector</code>是一个序列容器，它允许用户在容器的末尾快速地添加或删除元素。与数组相比，<code>&lt;vector&gt;</code> 提供了更多的功能，如自动调整大小、随机访问等。</p><p>1.声明与初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1;                  <span class="comment">// 空的vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 长度为5的vector，元素默认初始化</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 长度为5的vector，元素值为10</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>push_back(const T&amp; val)</code></td><td align="left">在末尾添加元素</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">删除末尾元素</td></tr><tr><td align="left"><code>at(size_t pos)</code></td><td align="left">返回指定位置的元素，带边界检查</td></tr><tr><td align="left"><code>operator[]</code></td><td align="left">返回指定位置的元素，不带边界检查</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回最后一个元素</td></tr><tr><td align="left"><code>data()</code></td><td align="left">返回指向底层数组的指针</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回当前元素数量</td></tr><tr><td align="left"><code>capacity()</code></td><td align="left">返回当前分配的容量</td></tr><tr><td align="left"><code>reserve(size_t n)</code></td><td align="left">预留至少 <code>n</code> 个元素的存储空间</td></tr><tr><td align="left"><code>resize(size_t n)</code></td><td align="left">将元素数量调整为 <code>n</code></td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清空所有元素</td></tr><tr><td align="left"><code>insert(iterator pos, val)</code></td><td align="left">在指定位置插入元素</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">删除指定位置的元素</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回起始&#x2F;结束迭代器</td></tr></tbody></table><p>3.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::vector</code></th></tr></thead><tbody><tr><td align="center"><strong>大小</strong></td><td align="center">动态可变</td></tr><tr><td align="center"><strong>存储位置</strong></td><td align="center">连续内存</td></tr><tr><td align="center"><strong>访问性能</strong></td><td align="center">随机访问快速</td></tr><tr><td align="center"><strong>插入和删除性能</strong></td><td align="center">末尾操作性能高，其他位置较慢</td></tr><tr><td align="center"><strong>内存增长方式</strong></td><td align="center">容量不足时成倍增长</td></tr></tbody></table><h2 id="3-list容器"><a href="#3-list容器" class="headerlink" title="3. list容器"></a>3. list容器</h2><p><code>&lt;list&gt;</code> 是 C++ 标准模板库中的一个序列容器，它允许在容器的任意位置快速插入和删除元素。与数组或向量<code>&lt;vector&gt;</code>不同，<code>list</code> 不需要在创建时指定大小，并且可以在任何位置添加或删除元素，而不需要重新分配内存。</p><p>1.声明和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst1;                  <span class="comment">// 空的list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 包含5个默认初始化元素的list</span></span><br><span class="line">    <span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 包含5个元素，每个元素为10</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; lst4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.特点</p><ul><li><strong>双向迭代</strong>：<code>&lt;list&gt;</code> 提供了双向迭代器，可以向前和向后遍历元素。</li><li><strong>动态大小</strong>：与数组不同，<code>&lt;list&gt;</code> 的大小可以动态变化，不需要预先分配固定大小的内存。</li><li><strong>快速插入和删除</strong>：可以在列表的任何位置快速插入或删除元素，而不需要像向量那样移动大量元素。</li></ul><p>3.常用的一些函数</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>push_back(const T&amp; val)</code></td><td align="left">在链表末尾添加元素</td></tr><tr><td align="left"><code>push_front(const T&amp; val)</code></td><td align="left">在链表头部添加元素</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">删除链表末尾的元素</td></tr><tr><td align="left"><code>pop_front()</code></td><td align="left">删除链表头部的元素</td></tr><tr><td align="left"><code>insert(iterator pos, val)</code></td><td align="left">在指定位置插入元素</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">删除指定位置的元素</td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清空所有元素</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回链表中的元素数量</td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查链表是否为空</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回链表第一个元素</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回链表最后一个元素</td></tr><tr><td align="left"><code>remove(const T&amp; val)</code></td><td align="left">删除所有等于指定值的元素</td></tr><tr><td align="left"><code>sort()</code></td><td align="left">对链表中的元素进行排序</td></tr><tr><td align="left"><code>merge(list&amp; other)</code></td><td align="left">合并另一个已排序的链表</td></tr><tr><td align="left"><code>reverse()</code></td><td align="left">反转链表</td></tr><tr><td align="left"><code>begin()</code> &#x2F; <code>end()</code></td><td align="left">返回链表的起始&#x2F;结束迭代器</td></tr></tbody></table><p>4.特性</p><table><thead><tr><th align="center">特性</th><th align="center"><code>std::list</code></th></tr></thead><tbody><tr><td align="center"><strong>内存结构</strong></td><td align="center">非连续内存，双向链表</td></tr><tr><td align="center"><strong>访问性能</strong></td><td align="center">顺序访问较快，随机访问慢</td></tr><tr><td align="center"><strong>插入&#x2F;删除性能</strong></td><td align="center">任意位置插入、删除快</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">频繁在中间插入&#x2F;删除</td></tr><tr><td align="center"><strong>迭代器稳定性</strong></td><td align="center">稳定，元素插入或删除不会失效</td></tr></tbody></table><p>5.注意事项</p><ul><li><code>&lt;list&gt;</code> 的元素是按插入顺序存储的，而不是按元素值排序。</li><li>由于 <code>&lt;list&gt;</code> 的元素存储在不同的内存位置，所以它不适合需要随机访问的场景。</li><li>与向量相比，<code>&lt;list&gt;</code> 的内存使用效率较低，因为每个元素都需要额外的空间来存储指向前后元素的指针。</li></ul><h2 id="4-deque容器"><a href="#4-deque容器" class="headerlink" title="4. deque容器"></a>4. deque容器</h2><p><code>&lt;deque&gt;</code> 提供了双端队列的实现，它在C++中以模板类的形式存在，允许存储任意类型的数据。</p><p><code>&lt;deque&gt;</code> 是一个动态数组，它提供了快速的随机访问能力，同时允许在两端进行高效的插入和删除操作。这使得 <code>&lt;deque&gt;</code> 成为处理需要频繁插入和删除元素的场景的理想选择。</p><p>1.声明和初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d;                  <span class="comment">// 空的deque</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;               <span class="comment">// 包含5个默认初始化元素的d</span></span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;           <span class="comment">// 包含5个元素，每个元素为10</span></span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;   <span class="comment">// 使用初始化列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.常用的一些函数</p><table><thead><tr><th align="left">函数名称</th><th align="left">功能描述</th></tr></thead><tbody><tr><td align="left"><code>operator=</code></td><td align="left">赋值操作符，赋值给 <code>deque</code> 容器。</td></tr><tr><td align="left"><code>assign()</code></td><td align="left">用新值替换 <code>deque</code> 容器中的所有元素。</td></tr><tr><td align="left"><code>at(size_type pos)</code></td><td align="left">返回 <code>pos</code> 位置的元素，并进行范围检查。</td></tr><tr><td align="left"><code>operator[](size_type pos)</code></td><td align="left">返回 <code>pos</code> 位置的元素，不进行范围检查。</td></tr><tr><td align="left"><code>front()</code></td><td align="left">返回第一个元素的引用。</td></tr><tr><td align="left"><code>back()</code></td><td align="left">返回最后一个元素的引用。</td></tr><tr><td align="left"><code>begin()</code></td><td align="left">返回指向第一个元素的迭代器。</td></tr><tr><td align="left"><code>end()</code></td><td align="left">返回指向末尾元素后一位置的迭代器。</td></tr><tr><td align="left"><code>rbegin()</code></td><td align="left">返回指向最后一个元素的逆向迭代器。</td></tr><tr><td align="left"><code>rend()</code></td><td align="left">返回指向第一个元素之前位置的逆向迭代器。</td></tr><tr><td align="left"><code>empty()</code></td><td align="left">检查容器是否为空。</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回容器中的元素个数。</td></tr><tr><td align="left"><code>max_size()</code></td><td align="left">返回容器可容纳的最大元素个数。</td></tr><tr><td align="left"><code>clear()</code></td><td align="left">清除容器中的所有元素。</td></tr><tr><td align="left"><code>insert(iterator pos, const T&amp; value)</code></td><td align="left">在 <code>pos</code> 位置插入 <code>value</code> 元素。</td></tr><tr><td align="left"><code>erase(iterator pos)</code></td><td align="left">移除 <code>pos</code> 位置的元素。</td></tr><tr><td align="left"><code>push_back(const T&amp; value)</code></td><td align="left">在容器末尾添加 <code>value</code> 元素。</td></tr><tr><td align="left"><code>pop_back()</code></td><td align="left">移除容器末尾的元素。</td></tr><tr><td align="left"><code>push_front(const T&amp; value)</code></td><td align="left">在容器前端添加 <code>value</code> 元素。</td></tr><tr><td align="left"><code>pop_front()</code></td><td align="left">移除容器前端的元素。</td></tr><tr><td align="left"><code>resize(size_type count)</code></td><td align="left">调整容器大小为 <code>count</code>，多出部分用默认值填充。</td></tr><tr><td align="left"><code>swap(deque&amp; other)</code></td><td align="left">交换两个 <code>deque</code> 容器的内容。</td></tr><tr><td align="left"><code>get_allocator()</code></td><td align="left">返回一个用于构造双端队列的分配器对象的副本。</td></tr></tbody></table><p><strong>注意：</strong>在使用 front() 或 back() 之前，确保双端队列不为空，否则会引发未定义的行为。如果需要检查双端队列是否为空，可以使用 empty() 成员函数。</p><h2 id="5-stack容器"><a href="#5-stack容器" class="headerlink" title="5. stack容器"></a>5. stack容器</h2><p><code>&lt;stack&gt;</code> 是 C++ 标准模板库的一部分，它实现了一个后进先出的数据结构。这种数据结构非常适合于需要”最后添加的元素最先被移除”的场景。</p><p><code>&lt;stack&gt;</code> 容器适配器提供了一个栈的接口，它基于其他容器(如 <code>deque</code> 或 <code>vector</code>)来实现。栈的元素是线性排列的，但只允许在一端(栈顶)进行添加和移除操作。</p><p>1.常用的操作</p><ul><li><code>push()</code>: 在栈顶添加一个元素。</li><li><code>pop()</code>: 移除栈顶元素。</li><li><code>top()</code>: 返回栈顶元素的引用，但不移除它。</li><li><code>empty()</code>: 检查栈是否为空。</li><li><code>size()</code>: 返回栈中元素的数量。</li></ul><p>2.注意事项</p><ul><li><code>&lt;stack&gt;</code> 不提供直接访问栈中元素的方法，只能通过 <code>top()</code> 访问栈顶元素。</li><li>尝试在空栈上调用 <code>top()</code> 或 <code>pop()</code> 将导致未定义行为。</li><li><code>&lt;stack&gt;</code> 的底层容器可以是任何支持随机访问迭代器的序列容器，如 <code>vector</code> 或 <code>deque</code>。</li></ul><h2 id="6-queue容器"><a href="#6-queue容器" class="headerlink" title="6. queue容器"></a>6. queue容器</h2><p>C++ 标准库中的 <code>&lt;queue&gt;</code> 头文件提供了队列数据结构的实现。队列是一种先进先出的数据结构，它允许在一端添加元素(称为队尾)，并在另一端移除元素(称为队首)。</p><p>1.常用的操作</p><ul><li><code>empty()</code>: 检查队列是否为空。</li><li><code>size()</code>: 返回队列中的元素数量。</li><li><code>front()</code>: 返回队首元素的引用。</li><li><code>back()</code>: 返回队尾元素的引用。</li><li><code>push()</code>: 在队尾添加一个元素。</li><li><code>pop()</code>: 移除队首元素。</li></ul><p>2.注意事项</p><ul><li>队列不允许随机访问元素，即不能直接通过索引访问队列中的元素。</li><li>队列的实现通常使用链表或动态数组，这取决于具体的实现。</li></ul><h2 id="7-priority-queue容器"><a href="#7-priority-queue容器" class="headerlink" title="7. priority_queue容器"></a>7. priority_queue容器</h2><p>在 C++ 中，<code>&lt;priority_queue&gt;</code> 是标准模板库的一部分，用于实现优先队列。优先队列是一种特殊的队列，它允许我们快速访问队列中具有最高(或最低)优先级的元素。</p><p>在 C++ 中，<code>priority_queue</code> 默认是一个大顶堆，这意味着队列的顶部元素总是具有最大的值。</p><p><code>priority_queue</code> 是一个容器适配器，它提供了对底层容器的堆操作。它不提供迭代器，也不支持随机访问。</p><p>1.常用的操作</p><ul><li><code>empty()</code>: 检查队列是否为空。</li><li><code>size()</code>: 返回队列中的元素数量。</li><li><code>top()</code>: 返回队列顶部的元素(不删除它)。</li><li><code>push()</code>: 向队列添加一个元素。</li><li><code>pop()</code>: 移除队列顶部的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类型，使用优先队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person1</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="comment">//bool operator&lt;(const person1&amp; p) const &#123;</span></span><br><span class="line"><span class="comment">//return this-&gt;a &gt; p.a;       //小于符号是大顶堆，大于符号是小顶堆</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> person1&amp; p1, <span class="type">const</span> person1&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> p1.b &lt; p2.b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置que为小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; que;   <span class="comment">//参3为less&lt;int&gt;，则是大顶堆</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义类型的优先队列</span></span><br><span class="line">    <span class="comment">//priority_queue&lt;person1&gt;q;    //方法1的调用</span></span><br><span class="line">    priority_queue&lt;person1, vector&lt;person1&gt;, cmp&gt;q;    <span class="comment">//方法2的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-set容器"><a href="#8-set容器" class="headerlink" title="8. set容器"></a>8. set容器</h2><p>C++ 标准库中的 <code>&lt;set&gt;</code> 是一个关联容器，它存储了一组唯一的元素，并按照一定的顺序进行排序。</p><p><code>&lt;set&gt;</code> 提供了高效的元素查找、插入和删除操作。它是基于红黑树实现的，因此具有对数时间复杂度的查找、插入和删除性能。</p><p><code>&lt;set&gt;</code> 容器中存储的元素类型必须满足以下条件：</p><ul><li>元素类型必须可以比较大小。</li><li>元素类型必须可以被复制和赋值。</li></ul><p>1.常用的操作</p><ul><li><code>insert(元素)</code>: 插入一个元素。</li><li><code>erase(元素)</code>: 删除一个元素。</li><li><code>find(元素)</code>: 查找一个元素。</li><li><code>size()</code>: 返回容器中元素的数量。</li><li><code>empty()</code>: 检查容器是否为空。</li></ul><p>2.set容器的特点：</p><ul><li>所有元素插入时会自动排序</li><li>set容器不存在重复的值</li></ul><p>3.unordered_set容器</p><p>提供了一种基于哈希表的容器，用于存储唯一的元素集合。与 <code>set</code> 不同，<code>unordered_set</code> 不保证元素的自动排序，但通常提供更快的查找、插入和删除操作。常用的操作和set容器大致一样。</p><h2 id="9-map容器"><a href="#9-map容器" class="headerlink" title="9.map容器"></a>9.map容器</h2><p><code>&lt;map&gt;</code> 是标准模板库的一部分，它提供了一种关联容器，用于存储键值对。</p><p><code>map</code> 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景。</p><p>1.定义和特性</p><ul><li><strong>键值对</strong>：<code>map</code> 存储的是键值对，其中每个键都是唯一的。</li><li><strong>排序</strong>：<code>map</code> 中的元素按照键的顺序自动排序，通常是升序。</li><li><strong>唯一性</strong>：每个键在 <code>map</code> 中只能出现一次。</li><li><strong>双向迭代器</strong>：<code>map</code> 提供了双向迭代器，可以向前和向后遍历元素。</li></ul><p>2.常用的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种(不建议，但可以用来访问)</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());  <span class="comment">//删除第一个元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">//按照key删除一个元素</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过key设置排序方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;     <span class="comment">//小于是升序，大于的降序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, mycompare&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, mycompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-algorithm算法库"><a href="#3-algorithm算法库" class="headerlink" title="3.  algorithm算法库"></a>3.  algorithm算法库</h1><p>C++ 标准库中的 <code>&lt;algorithm&gt;</code> 头文件提供了一组用于操作容器(如数组、向量、列表等)的算法。这些算法包括排序、搜索、复制、比较等，它们是编写高效、可重用代码的重要工具。</p><p><code>&lt;algorithm&gt;</code> 头文件定义了一组模板函数，这些函数可以应用于任何类型的容器，只要容器支持迭代器。这些算法通常接受两个或更多的迭代器作为参数，表示操作的起始和结束位置。 </p><h2 id="1-排序算法sort"><a href="#1-排序算法sort" class="headerlink" title="1. 排序算法sort"></a>1. 排序算法sort</h2><p>定义：对容器中的元素进行排序。</p><p>语法：<code>sort(container.begin(), container.end(), compare_function);</code></p><p>其中 compare_function 是一个可选的比较函数，用于自定义排序方式。</p><p>其它算法：</p><ul><li><strong>std::partial_sort</strong>: 对部分区间排序</li><li><strong>std::stable_sort</strong>: 稳定排序，保留相等元素的相对顺序。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());         <span class="comment">//普通排序(默认升序)</span></span><br><span class="line">    std::<span class="built_in">partial_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">3</span>, numbers.<span class="built_in">end</span>()); <span class="comment">//前3个是有序，后续的无序(获取最小的3个数)  </span></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());  <span class="comment">//普通排序(相等元素的相对位置不变)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-搜索算法find"><a href="#2-搜索算法find" class="headerlink" title="2. 搜索算法find"></a>2. 搜索算法find</h2><p>定义：在容器中查找与给定值匹配的第一个元素。</p><p>语法：<code>auto it = find(container.begin(), container.end(), value);</code></p><p>如果找到，it 将指向匹配的元素；如果没有找到，it 将等于 container.end()。</p><p>其它算法：</p><ul><li><strong>std::binary_search</strong>: 对有序区间进行二分查找。</li><li><strong>std::find_if</strong>: 查找第一个满足特定条件的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());  <span class="comment">// 先排序</span></span><br><span class="line">    <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">4</span>);      <span class="comment">//找4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-复制算法copy"><a href="#3-复制算法copy" class="headerlink" title="3. 复制算法copy"></a>3. 复制算法copy</h2><p>定义：将一个范围内的元素复制到另一个容器或数组。</p><p>语法：<code>copy(source_begin, source_end, destination_begin);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> destination[<span class="number">5</span>];</span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), destination);   <span class="comment">//将source中的元素复制到数组destination</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-比较算法equal"><a href="#4-比较算法equal" class="headerlink" title="4. 比较算法equal"></a>4. 比较算法equal</h2><p>定义：比较两个容器或两个范围内的元素是否相等。</p><p>语法：<code>bool result = equal(first1, last1, first2, compare_function);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">bool</span> are_equal = std::<span class="built_in">equal</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-修改算法"><a href="#5-修改算法" class="headerlink" title="5. 修改算法"></a>5. 修改算法</h2><p>常用的语法：</p><ul><li><strong>std::reverse</strong>: 反转区间内的元素顺序。<ul><li><code>std::reverse(vec.begin(), vec.end());</code></li></ul></li><li><strong>std::fill</strong>: 将指定区间内的所有元素赋值为某个值。<ul><li><code>std::fill(vec.begin(), vec.end(), 0);  // 所有元素设为 0</code></li></ul></li><li><strong>std::replace</strong>: 将区间内的某个值替换为另一个值。<ul><li><code>std::replace(vec.begin(), vec.end(), 1, 99);  // 将所有 1 替换为 99</code></li></ul></li><li><strong>std::copy</strong>: 将区间内的元素复制到另一个区间。<ul><li><code>std::copy(vec.begin(), vec.end(), vec2.begin());</code></li></ul></li></ul><h2 id="6-归并算法merge"><a href="#6-归并算法merge" class="headerlink" title="6. 归并算法merge"></a>6. 归并算法merge</h2><p>定义：将两个有序区间合并到一个有序区间。</p><p>语法：<code>std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></p><p>其它算法：</p><ul><li><strong>std::inplace_merge</strong>: 在单个区间中合并两个有序子区间。<ul><li><code>std::inplace_merge(vec.begin(), middle, vec.end());</code></li></ul></li></ul><h2 id="7-集合算法"><a href="#7-集合算法" class="headerlink" title="7.  集合算法"></a>7.  集合算法</h2><p>常用的语法：</p><ul><li><p><strong>std::set_union</strong>: 计算两个有序集合的并集。</p><ul><li><code>auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li><li>其中返回的it是result中得到的并集元素中最后一个的下一个位置</li></ul></li><li><p><strong>std::set_intersection</strong>: 计算两个有序集合的交集。</p><ul><li><code>auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li></ul></li><li><p><strong>std::set_difference</strong>: 计算集合的差集。</p><ul><li><code>auto it = std::set_difference(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());</code></li></ul></li></ul><h2 id="8-其它有用算法"><a href="#8-其它有用算法" class="headerlink" title="8. 其它有用算法"></a>8. 其它有用算法</h2><p>常用的语法：</p><ul><li><p><strong>std::accumulate（需要 <numeric> 库）</numeric></strong>：计算范围内元素的累计和。</p><ul><li><code>int sum = std::accumulate(vec.begin(), vec.end(), 0);</code></li></ul></li><li><p><strong>std::for_each</strong>: 对区间内的每个元素执行相应操作。</p><ul><li><code>std::for_each(vec.begin(), vec.end(), [](int&amp; x) &#123; x += 1; &#125;);</code></li></ul></li><li><p><strong>std::min_element</strong> 和 <strong>std::max_element</strong>: 查找区间内的最小值和最大值。</p><ul><li><code>auto min_it = std::min_element(vec.begin(), vec.end());</code></li><li><code>auto max_it = std::max_element(vec.begin(), vec.end());</code></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-c-简介&quot;&gt;&lt;a href=&quot;#1-c-简介&quot; class=&quot;headerlink&quot; title=&quot;1. c++简介&quot;&gt;&lt;/a&gt;1. c++简介&lt;/h1&gt;&lt;p&gt;C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="https://lxx93.online/2024/09/26/docker%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/09/26/docker%E5%9F%BA%E7%A1%80/</id>
    <published>2024-09-26T01:04:01.000Z</published>
    <updated>2024-10-07T15:46:26.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-docker概述"><a href="#1-docker概述" class="headerlink" title="1. docker概述"></a>1. docker概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是：<code>Build, Ship and Run Any App, Anywhere</code>，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP及其运行环境能做到<code>一次镜像，处处运行</code>。</p><p>Linux容器技术的出现就解决了这样一个问题，而Docker就是再它的基础上发展过来的。将应用打成镜像，通过镜像成为运行在Docker容器上面的实例，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</p><p>docker理念：解决了<code>运行环境和配置问题</code>的<code>软件容器</code>，方便做持续集成并有助于整体发布的容器虚拟化技术。</p><h2 id="1-2-传统虚拟机和容器"><a href="#1-2-传统虚拟机和容器" class="headerlink" title="1.2 传统虚拟机和容器"></a>1.2 传统虚拟机和容器</h2><p>1.传统虚拟机(virtual machine)：</p><p>传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统(如VirtualBox、VMware等)，创建虚拟机(虚拟出各种硬件)，在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。</p><p>缺点：资源占用多、冗余步骤多、启动慢。</p><p>2.Linux容器(Linux Container，简称LXC)：</p><p>Linux容器是与系统其他部分分隔开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一的运行。</p><p>3.两者对比</p><table><thead><tr><th align="center">特性</th><th align="center">Docker容器</th><th align="center">虚拟机(VM)</th></tr></thead><tbody><tr><td align="center">操作系统</td><td align="center">与宿主机共享OS</td><td align="center">宿主机OS上运行虚拟机OS</td></tr><tr><td align="center">存储大小</td><td align="center">镜像小，便于存储与传输</td><td align="center">镜像庞大(vmdk、vdi等)</td></tr><tr><td align="center">运行性能</td><td align="center">几乎无额外性能损失</td><td align="center">操作系统额外的CPU、内存消耗</td></tr><tr><td align="center">移植性</td><td align="center">轻便、灵活，适用于Linux</td><td align="center">笨重，与虚拟化技术耦合度高</td></tr><tr><td align="center">硬件亲和性</td><td align="center">面向软件开发者</td><td align="center">面向硬件运维者</td></tr><tr><td align="center">部署速度</td><td align="center">快速，秒级</td><td align="center">较慢，10s以上</td></tr></tbody></table><h2 id="1-3-Docker运行速度快的原因"><a href="#1-3-Docker运行速度快的原因" class="headerlink" title="1.3 Docker运行速度快的原因"></a>1.3 Docker运行速度快的原因</h2><ul><li><p>Docker有比虚拟机更少的抽象层：</p><ul><li>由于Docker不需要Hypervisor（虚拟机）实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上docker有明显优势。</li></ul></li><li><p>Docker利用的是宿主机的内核，而不需要加载操作系统OS内核：</p><ul><li>当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较耗时耗资源的过程。当新建一个虚拟机时，虚拟机软件需要加载OS，返回新建过程是分钟级别的。而Docker由于直接利用宿主机的操作系统，则省略了返回过程，因此新建一个docker容器只需要几秒钟。</li></ul></li><li><p>Docker容器的本质就是一个进程。</p></li></ul><h2 id="1-4-Docker软件"><a href="#1-4-Docker软件" class="headerlink" title="1.4 Docker软件"></a>1.4 Docker软件</h2><p>Docker并非一个通用的容器工具，它依赖于已经存在并运行的Linux内核环境。在Windows上安装Docker时需要依赖WLS，即Windows下的Linux子系统。</p><p>Docker实质上是在已经运行的Linux下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的Linux主机。</p><p>Docker的基本组成部分(三要素)：</p><ul><li><p>镜像(image)：就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建多个容器。</p></li><li><p>容器(container)：Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是用镜像创建的运行实例。</p></li><li><p>仓库(repository)：是集中存放镜像文件的场所。</p></li></ul><h2 id="1-5-Docker架构"><a href="#1-5-Docker架构" class="headerlink" title="1.5 Docker架构"></a>1.5 Docker架构</h2><p>Docker是一个 C&#x2F;S(Client-Server) 结构的系统，后端是一个松耦合架构，众多模块各司其职。</p><p>Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从容器接收命令并管理运行在主机上的容器。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/1.png"></p><p>Docker运行的基本流程为：</p><ul><li><p>用户是使用Docker Client 与 Docker Daemon 建立通信，并发送请求给后者</p></li><li><p>Docker Daemon 作为 Docker 架构的主体部分，首先提供 Docker Server 的功能使其可以接收 Docker Client 的请求</p></li><li><p>Docker Engine 执行 Docker 内部的一系列工作，每一项工作都是以一个 Job 的形式存在</p></li><li><p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registry 中下载镜像，并通过镜像管理驱动 Graph Driver 将下载镜像以 Graph 的形式存储</p></li><li><p>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境</p></li><li><p>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成</p></li><li><p>Libcontainer 是一项独立的容器管理包，Network driver 以及 Exec driver 都是通过 Libcontainer 来实现具体对容器进行的操作</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/2.png"></p><h1 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2. 安装docker"></a>2. 安装docker</h1><h2 id="2-1-linux系统"><a href="#2-1-linux系统" class="headerlink" title="2.1 linux系统"></a>2.1 linux系统</h2><p>1.安装gcc：<code>yum -y install gcc</code></p><p>2.安装g++：<code>yum -y install gcc-c++</code></p><p>3.# yum-util提供yum-config-manager功能：<code>yum install -y yum-utils</code></p><p>4.配置docker的资源库(阿里云镜像地址)：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>5.更新yum软件包索引(可选)：<code>yum makecache fast</code></p><p>6.安装Docker引擎：<code>yum install docker-ce docker-ce-cli containerd.io</code></p><p>7.启动docker：<code>systemctl start docker</code></p><ul><li><p>通过<code>ps -ef | grep docker</code>查看启动的docker</p></li><li><p>此时查看docker版本，可以看到Server: Docker Engine(Docker引擎)版本号：<code>docker version</code></p></li></ul><p>8.测试：<code>docker run hello-world</code></p><p>其它命令：</p><p>使用yum删除docker引擎 ：<code>yum remove docker-ce docker-ce-cli containerd.io</code></p><p>删除镜像、容器、卷、自定义配置等文件 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br><span class="line">rm -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="2-2-配置加速器"><a href="#2-2-配置加速器" class="headerlink" title="2.2 配置加速器"></a>2.2 配置加速器</h2><p>往<code>daemon.json</code>中写入内容，终端执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://u7fgx15j.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后刷新配置、重启docker即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>注意：但是发现这样配置加速器后，当执行<code>docker run hello-world</code>时，依然会拉取不成功，出现以下问题：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/3.png"></p><p>解决方案1(推荐)：</p><p>1.在<code>/etc/docker/daemon.json</code>文件中改写为以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://do.nark.eu.org&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dc.j8.work&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后刷新配置、重启docker</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon<span class="literal">-reload</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>3.检查registry mirror刚刚配置的加速地址是否成功，执行<code>docker info</code></p><p>当最下面能看到如下内容，表示配置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/4.png"></p><p>4.执行<code>docker run hello-world</code>就可以发现成功了</p><blockquote><p>run的作用：开始时，Docker在本机中寻找该镜像，如果本机有该镜像，就以该镜像为模板生产容器实例运行；如果本机没有该镜像，就去Docker Hub上查找该镜像，Hub如果能找到，就下载该镜像到本地，以该镜像为模板生产容器实例运行；如果Hub不能找到，就返回失败错误，查不到该镜像。</p></blockquote><p>解决方案2：由于目前国内的许多镜像都被停用了，所以想要拉取镜像，得用一些不常规的方法，如下所示：</p><p>先在<code>/etc/docker/daemon.json</code>里面添加如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://register.liberx.info&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker后，如果想要<code>docker search</code>，在终端执行是不管用的，得在网址<a href="https://register.liberx.info/">https://register.liberx.info/</a>提供的页面里输入相应的镜像查看，该页面所提供的镜像版本都可以在linux终端通过<code>docker pull</code>；来拉取获得。</p><h1 id="3-Docker常用命令"><a href="#3-Docker常用命令" class="headerlink" title="3 .Docker常用命令"></a>3 .Docker常用命令</h1><h2 id="3-1-帮助启动类命令"><a href="#3-1-帮助启动类命令" class="headerlink" title="3.1 帮助启动类命令"></a>3.1 帮助启动类命令</h2><p>1.启动docker：<code>systemctl start docker</code></p><p>2.停止docker：<code>systemctl stop docker</code></p><p>3.重启docker：<code>systemctl restart docker</code></p><p>4.查看docker状态：<code>systemctl status docker</code></p><p>5.开机自启动：<code>systemctl enable docker</code></p><p>6.查看docker概要信息：<code>docker info</code></p><p>7.查看docker总体帮助文档：<code>docker --help</code></p><p>8.查看docker命令帮助文档：<code>docker 具体命令 --help</code></p><h2 id="3-2-镜像命令"><a href="#3-2-镜像命令" class="headerlink" title="3.2 镜像命令"></a>3.2 镜像命令</h2><p>1.列出本地主机上的镜像：<code>docker images</code></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/5.png"></p><p>REPOSITORY：表示镜像的仓库源</p><p>TAG：镜像的标签版本号</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像创建时间</p><p>SIZE：镜像大小</p><blockquote><p>同一仓库源可以有多个TAG版本，代表这个仓库源的不同个版本，我们使用REPOSITORY:TAG来定义不同的镜像。如果不指定一个镜像的版本标签。例如只使用ubuntu，docker将默认使用ubuntu:latest镜像</p></blockquote><p>OPTIONS说明：</p><ul><li>-a：列出本地所有的镜像(含历史映像层)</li><li>-q：只显示镜像ID</li></ul><p>2.查镜像：<code>docker search 某个xxx镜像名字</code></p><p>含义：通过相应的镜像加速器去Hub(远程仓库)上面去查找有无需要的镜像</p><p>属性解释：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NAME</td><td align="center">镜像名称</td></tr><tr><td align="center">DESCRIPTION</td><td align="center">镜像说明</td></tr><tr><td align="center">STARS</td><td align="center">点赞数量</td></tr><tr><td align="center">OFFICIAL</td><td align="center">是否是官方的</td></tr><tr><td align="center">AUTOMATED</td><td align="center">是否是自动构建的</td></tr></tbody></table><p>OPTIONS说明：</p><ul><li>–limit：只列出N个镜像，默认是25个</li><li>docker search –limit 5 redis：表示只列出5个redis镜像</li></ul><p>3.拉取镜像：<code>docker pull 某个xxx镜像名字</code></p><ul><li>pull镜像名字的时候，如果没有加对应的版本号，就默认下载最新的版本:latest，如<code>docker pull redis:6.0.8</code>是下载redis的6.0.8版本</li></ul><p>4.查看镜像&#x2F;容器&#x2F;数据卷所占的空间：<code>docker system df</code></p><p>5.删除镜像：<code>docker rmi 某个xxx镜像名字ID</code></p><ul><li><p>有些情况下，因为某种原因，不能直接删除对应的镜像，这时就需要通过<code>docker rmi -f 镜像名字ID</code>强制删除</p></li><li><p>如果需要删除多个镜像，后面进行追加即可，如果需要删除全部镜像，可以通过<code>docker rmi -f $(docker images -qa)</code>实现</p></li></ul><blockquote><p>面试题：谈谈docker虚悬镜像是什么？</p><p>仓库名、标签都是<none>的镜像，就俗称虚悬镜像dangling image。这种镜像建议删除，没什么用，有时候docker构建的时候，会出现一些问题。</none></p></blockquote><h2 id="3-3-容器命令"><a href="#3-3-容器命令" class="headerlink" title="3.3 容器命令"></a>3.3 容器命令</h2><p>有镜像才能创建容器，这是根本前提。镜像是模板，容器是实例</p><p>1.新建+启动容器 ——-&gt;启动交互式容器(前台命令行)</p><p>指令：docker run [OPTIONS] image [COMMAND] [ARG…] </p><p>OPTIONS说明(常用)：有些是一个减号，有些是两个减号</p><ul><li><p>–name&#x3D;”容器新名字”：为容器指定一个名称(没有取的话，系统会随机取一个名字)；</p></li><li><p>-d：后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；</p></li><li><p>-i：以交互模式运行容器，通常与-t同时使用；</p></li><li><p>-t：为容器重新分配一个伪输入终端，通过与-i同时使用。也即启动交互式容器(前台有伪终端，等待交互)</p></li><li><p>-P：随机端口映射，大写P</p></li><li><p>-p：指定端口映射，小写p</p></li></ul><p>如：<code>docker run -it ubuntu /bin/bash</code></p><ul><li>ubuntu：ubuntu镜像</li><li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里希望有个交互式Shell，因此用的是&#x2F;bin&#x2F;bash</li><li>退出终端，直接输入exit</li></ul><p>2.列出当前所有正在运行的容器</p><p>指令：docker ps [OPTIONS]</p><p>OPTIONS说明：</p><ul><li>-a：列出当前所有正在运行的容器+历史上运行过的</li><li>-l：显示最近创建的容器</li><li>-n 数字：显示最近(数字)个创建的容器</li><li>-q：静默模式，只显示容器编号</li></ul><p>例子：再通过ubuntu镜像创建一个容器实例，然后查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=myu1 ubuntu bash</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/6.png"></p><p>3.退出容器</p><ul><li>exit：run进行容器，exit退出，容器停止</li><li>ctrl+p+q：run进去容器，ctrl+p+q退出，容器不停止</li></ul><p>4.启动已停止运行的容器：docker start 容器ID或者容器名</p><p>5.重启容器：docker restart 容器ID或者容器名</p><p>6.停止容器：docker stop 容器ID或者容器名</p><p>7.强制停止容器：docker kill 容器ID或者容器名</p><p>8.删除已停止的容器：docker rm 容器ID</p><ul><li><p>加-f可以强制删除活着的容器</p></li><li><p>一次性删除多个容器实例：</p><ul><li>docker rm -f $(docker ps -a -q)</li><li>docker ps -a -q | xargs docker rm</li></ul></li></ul><p>9.启动守护式容器(后台服务器)</p><p>在大部分的场景下，我们希望docker的服务是在后台运行的，这样就可以通过-d指定容器的后台运行模式。</p><p>问题：使用镜像ubuntu:latest以后台模式启动一个容器，终端执行docker run -d ubuntu后，用docker ps -a进行查看，会发现容器已经退出。所以非常重要的一点是，docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令(比如运行top、tail)，就是会自动退出的。所以有些镜像-d是不可以的，doekcr机制必须要用-it。</p><p>对应像mysql和redis等应用，使用前台交互式启动<code>docker run -it redis:6.0.8</code>是不怎么合理的，因为不小心关掉窗口或ctrl+c都容易导致服务停止，容易误伤。所以以后台守护式启动更加合理。</p><p>10.查看容器的日志：<code>docker logs 容器ID</code></p><p>11.查看容器内运行的进程：<code>docker top 容器ID</code></p><p>12.查看容器内部细节：docker inspect 容器ID</p><p>13.进入正在运行的容器并以命令行交互</p><ul><li>docker exec -it 容器ID bin&#x2F;bash</li><li>docker attach 容器ID</li></ul><p>应用：当是通过ctrl+p+q退出的容器，但其容器还在运行，或者像进入一些通过后台守护式启动的容器，可以通过上面两种方法重新进入容器。</p><p>两者之间的区别：</p><ul><li>attach直接进入容器启动命令的终端，不会启动新的进程，用exit退出后，会导致容器停止</li><li>exec是在容器中打开新的终端，并且可以启动新的进程，用exec退出后，不会导致容器停止(建议使用)</li></ul><p>14.从容器内拷贝文件到主机上：<code>docker cp 容器ID:容器内路径 目的主机路径</code></p><p>例子：将容器ID为ddb1ae909a66容器里面目录文件&#x2F;tmp&#x2F;a.txt拷贝到主机的&#x2F;test目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ddb1ae909a66:/tmp/a.txt /test</span><br></pre></td></tr></table></figure><p>15.导入和导出容器</p><ul><li>export导出容器的内容留作为一个tar归档文件<ul><li>指令：docker export 容器ID &gt; 文件名.tar</li></ul></li><li>import从tar包中的内容创建一个新的文件系统再导入为镜像<ul><li>指令：cat 文件名.tar | docker import - 镜像用户&#x2F;镜像名:镜像版本号</li></ul></li></ul><h1 id="4-Docker镜像"><a href="#4-Docker镜像" class="headerlink" title="4. Docker镜像"></a>4. Docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好行程一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>只有通过这个镜像文件才能生成Docker容器实例。</p><h2 id="4-1-联合文件系统"><a href="#4-1-联合文件系统" class="headerlink" title="4.1 联合文件系统"></a>4.1 联合文件系统</h2><p>联合文件系统(UnionFS)：Union文件系统，是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像可以制作具体的应用镜像。</p><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><h2 id="4-2-Docker镜像加载原理"><a href="#4-2-Docker镜像加载原理" class="headerlink" title="4.2 Docker镜像加载原理"></a>4.2 Docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就叫联合文件系统。</p><p>bootfs(boot file system)主要包含 bootloader 和 kernel，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统。在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已经由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>rootfs（root file system，在bootfs之上，包含的就是典型Linux系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code>等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu、CentOS等。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/7.png"></p><p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接使用Host的Kernel，自己只需要提供rootfs就可以。所以，对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，不同的发行版可以共用bootfs。</p><blockquote><p>Docker镜像要采用这种分层结构的原因：镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。</p><p>比如说有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p></blockquote><h2 id="4-3-容器层"><a href="#4-3-容器层" class="headerlink" title="4.3 容器层"></a>4.3 容器层</h2><p>Docker镜像层都是只读的，容器层是可写的</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动，即添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/8.png"></p><h2 id="4-4-Docker镜像commit操作"><a href="#4-4-Docker镜像commit操作" class="headerlink" title="4.4 Docker镜像commit操作"></a>4.4 Docker镜像commit操作</h2><p>docker commit提交容器副本使之成为一个新的镜像</p><ul><li>docker commit -m&#x3D;”提交的描述信息” -a&#x3D;”作者” 容器ID 要创建的目标镜像名:[标签名]</li></ul><p>案例：演示ubuntu安装vim</p><ol><li><p>从Hub上下载ubuntu镜像到本地并成功运行，原始的默认ubuntu镜像是不带着vim命令的</p><ul><li>下载镜像：<code>docker pull ubuntu</code></li><li>运行：<code>docker run -it ubuntu /bin/bash</code></li></ul></li><li><p>外网连通的情况下，安装vim</p><ul><li>先更新包管理工具：<code>apt-get update</code></li><li>然后安装需要的vim：<code>apt-get install vim</code></li></ul></li><li><p>安装完成后，commit一个新镜像(与之前镜像不一样的)</p><ul><li><p><code>docker commit -m=&quot;vim cmd add ok&quot; -a=&quot;lxx&quot; 734e289931b0 lxxmake/myubuntu:1.0</code></p></li><li><p>查看本地镜像：<code>docker images</code></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/9.png"></p></li></ul></li><li><p>启动新镜像后，可以使用vim编辑</p><ul><li><code>docker run -it lxxmake/myubuntu:1.0 /bin/bash</code></li></ul></li></ol><p>总结：Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/10.png"></p><h2 id="4-5-本地镜像发布到阿里云"><a href="#4-5-本地镜像发布到阿里云" class="headerlink" title="4.5 本地镜像发布到阿里云"></a>4.5 本地镜像发布到阿里云</h2><p>1.进入阿里云官网，先点击左上角的列表，点击容器里面的容器镜像服务。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/11.png"></p><p>2.在弹出的如下页面，先完成个人实例的创建</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/12.png"></p><p>3.点击创建命名空间，随便取一个名字即可</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/13.png"></p><p>4.为刚刚创建的命名空间创建一个镜像仓库</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/14.png"></p><p>5.填写完相关信息，进入下一步，选择本地仓库。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/15.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/16.png"></p><p>6.完成以上操作后，就会有该界面了，点击管理进入仓库管理</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/17.png"></p><p>7.点击管理后，就会进入该页面，这里有从我们本地将镜像推送到阿里云的步骤，也有从阿里云拉取镜像会本地的方法。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/18.png"></p><p>下面是我在linux系统上操作的情况：首先是将本地自己写的镜像拉取到阿里云(操作1、操作2、操作3)，然后删除本地的这个镜像(操作4)，在确保本地没有该镜像后，再从阿里云上拉取回刚刚推送的镜像(操作5)。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/19.png"></p><h2 id="4-6-本地镜像发布到私有库"><a href="#4-6-本地镜像发布到私有库" class="headerlink" title="4.6 本地镜像发布到私有库"></a>4.6 本地镜像发布到私有库</h2><p>官方Docker Hub地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>，中国大陆访问太慢了且准备被阿里云取代的趋势，不太主流。Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。</p><p>操作步骤：省略</p><h1 id="5-容器卷"><a href="#5-容器卷" class="headerlink" title="5. 容器卷"></a>5. 容器卷</h1><p>容器卷有点类似于Redis里面的rdb和aof文件，将docker容器内的数据保存进宿主机的磁盘中，以达到数据的持久化和敏感重要数据的备份(通过映射目录实现)。</p><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性。卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><blockquote><p>作用：众所周知，将运用与运行的环境打包镜像，run后形成容器实例运行，但是我们是希望数据能够持久化的。Docker容器产生的数据，如果不进行备份，那么当容器实例删除后，容器内的数据自然也就没有了。为了能够保存数据在docker中，所以就需要使用卷了。</p></blockquote><p>特点：</p><ul><li>数据卷可在容器之间共享或重用数据</li><li>卷中的更改可以直接实时生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ul><p>1.运行一个带有容器卷存储功能的容器实例：<code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</code></p><p>案例1：宿主和容器之间映射添加容器卷</p><p>首先是通过带有容器卷存储功能的方式进入容器，这里指明了本地的映射目录是&#x2F;docker&#x2F;host_data，容器里面对应的映射目录是&#x2F;docker&#x2F;docker_data。</p><p>下面是完成映射绑定之后，对应的容器端，在这容器里面的映射目录下创建的文件，会同步到本地映射目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/20.png"></p><p>下面是本地映射目录端，在这里面创建的文件，也会同步映射到容器对应的映射目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/21.png"></p><p>注意：当把容器停掉之后，在本地映射目录下继续添加、修改文件等操作，都还是会同步到容器对应的映射目录下。</p><p>2.读写规则映射添加说明</p><p>上面的操作是默认支持读写规则的，但有些情况下，只是像将本地的内容映射到容器，而不想容器能进行修改，即容器自己只能读取不能写，就需要通过ro来进行指明。</p><p>指令：<code>docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</code></p><p>3.卷的继承和共享</p><p>指令：通过<code>--volumes-from 父类名</code>来完成</p><p>案例2：以ubuntu镜像为例，实现继承操作</p><p>容器1先完成和宿主机的映射：docker run -it –privileged&#x3D;true -v &#x2F;tmp&#x2F;host_data:&#x2F;tmp&#x2F;docker_data –name&#x3D;u1 ubuntu</p><p>容器2继承容器1的卷规则：docker run -it –privileged&#x3D;true –volumes-from u1 –name&#x3D;u2 ubuntu</p><blockquote><p>需要了解的是，在完成上面两个指令后，之前容器u1和宿主机映射目录的文件，在容器u2中也具备了，u2在继承下来的映射目录下进行添加或修改文件等操作也会同步到u1和宿主机中。</p></blockquote><h1 id="6-docker常规软件安装"><a href="#6-docker常规软件安装" class="headerlink" title="6. docker常规软件安装"></a>6. docker常规软件安装</h1><p>总体步骤：</p><ol><li><p>搜索镜像</p></li><li><p>拉取镜像</p></li><li><p>查看镜像</p></li><li><p>启动镜像(服务端口映射)</p></li><li><p>停止容器</p></li><li><p>移除容器</p></li></ol><h2 id="6-1-tomcat安装"><a href="#6-1-tomcat安装" class="headerlink" title="6.1 tomcat安装"></a>6.1 tomcat安装</h2><p>1.在docker hub官网<a href="https://hub.docker.com/">https://hub.docker.com/</a>上面查找tomcat镜像，如果有对应的镜像，才能拉取下载到本地。</p><p>2.从docker hub上拉取tomcat镜像到本地：<code>docker pull tomcat</code></p><p>3.查看是否有拉取到的tomcat：<code>docker images</code></p><p>4.使用tomcat镜像创建容器实例(运行镜像)</p><ul><li>指令：<code>docker run -it -p 8080:8080 tomcat</code><ul><li>-p：小写，主机端口:docker容器端口</li><li>-P：大写，随机分配端口</li><li>-i：交互</li><li>-t：终端</li><li>-d：后台</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/22.png"></p><p>5.访问猫主页</p><ul><li>问题：当进入tomcat后，在虚拟机的火狐上通过<code>localhost:8080</code>访问时，不会弹出一只猫的页面，这是不正常的。</li><li>原因：这是因为在新版的tomcat中做了改变，在通过<code>docker exec -it 9aada4d3af80 /bin/bash</code>进入tomcat后，它的<code>webapps</code>目录下的内容为空。真正有内容的已经被改为了webapps.dist文件夹</li><li>解决方法：<ul><li>通过<code>rm -r webapps</code>删除该文件夹</li><li>通过<code>mv webapps.dist webapps</code>将文件夹webapps.dist重新命名为webapps</li><li>这样就完成了，在虚拟机上搜索localhost:8080就可以看到了一只猫的页面了</li></ul></li></ul><p>补充：所有的docker容器实例其本质而言均是一个迷你版的、精简版的内核版的linux</p><p>6.免费改版说明</p><p>可以通过下载非最新版来避免上面一系列的繁琐操作，运行后直接通过<code>localhost:8080</code>访问得到一只猫的页面了</p><ul><li>下载镜像：<code>docker pull billygoo/tomcat8-jdk8</code></li><li>后台运行：<code>docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8</code></li></ul><h2 id="6-2-安装mysql"><a href="#6-2-安装mysql" class="headerlink" title="6.2 安装mysql"></a>6.2 安装mysql</h2><p>1.在docker hub上面查找mysql镜像</p><p>2.从docker hub上拉取mysql镜像到本地标签为5.7(这里以5.7版本为例)</p><ul><li>下载拉取：<code>docker pull mysql:5.7</code></li></ul><p>3.使用mysql15.7镜像创建容器(运行镜像)</p><ul><li>指令：<code>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code><ul><li>注意：当linux服务器上本身装了mysql，且是启动的，所以在使用docker之前，端口3306就已经被占用了，所以在执行该命令之前，需要先将linux系统本身的mysql停掉</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/docker/23.png"></p><p>4.进入容器中的mysql</p><ul><li>进入装有mysql容器：<code>docker exec -it 555d7763267c /bin/bash</code></li><li>进入mysql：<code>mysql -uroot -p</code></li><li>输入密码123456，进入后所有操作和在linux上操作mysql一模一样</li><li>查看使用的字符集：<code>SHOW VARIABLES LIKE &#39;character%&#39;;</code> —–&gt;发现使用的基本上都不是utf-8</li></ul><p>5.完善</p><ul><li><p>问题：1.插入中文数据会出现报错乱码；2删除容器后，里面的mysql数据全没了</p></li><li><p>解决方法：对容器里面mysql的日志、数据和配置进行挂载，即挂载3个容器卷。</p><ul><li><p>执行指令：docker run -d -p 3306:3306 –privileged&#x3D;true -v &#x2F;database&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;database&#x2F;mysql&#x2F;ldata:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;database&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name mysql1 mysql:5.7</p></li><li><p>在主机的&#x2F;database&#x2F;mysql&#x2F;conf&#x2F;文件夹下新建my.cnf，添加内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure></li><li><p>重新启动mysql容器实例，再重新进入：<code>docker restart mysql1</code>  —–&gt;注意：mysql1是之前创建时取的容器名字</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-docker概述&quot;&gt;&lt;a href=&quot;#1-docker概述&quot; class=&quot;headerlink&quot; title=&quot;1. docker概述&quot;&gt;&lt;/a&gt;1. docker概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="https://lxx93.online/2024/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB/"/>
    <id>https://lxx93.online/2024/09/15/%E6%95%B0%E6%8D%AE%E5%BA%93MongoDB/</id>
    <published>2024-09-15T01:35:50.000Z</published>
    <updated>2024-09-16T15:48:39.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MongoDB是一个基于分布式文件存储的数据库，操作语法与JavaScript类似，容易上手。它与mysql不一样，mysql操作的是表格，即结构化数据，而mongodb操作的是json非结构化数据。下载地址<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>数据库是按照数据结构来组织、存储和管理数据的<code>应用程序</code>，主要作用就是<code>管理数据</code>，对数据进行增删改查。</p><p>Mongodb数据库在使用前，需要在终端执行<code>mongod</code>来打开数据库服务端，在终端执行<code>mongo</code>打开客户端，通过相关命令来完成数据库的增删改查。当然也可以下载<code>Mongoose</code>包来通过代码完成对<code>Mongodb</code>数据库的增删改查。</p><p>相比纯文件管理数据，数据库管理数据有如下特点：</p><ul><li>速度更快</li><li>扩展性更高</li><li>安全性更高</li></ul><p>Mongodb中有三个重要概念：</p><ul><li><p>数据库(database)：是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合</p></li><li><p>集合(collection)：集合类似于 JS 中的数组，在集合中可以存放很多文档</p></li><li><p>文档(document)：档是数据库中的最小单位，类似于 JS 中的对象</p></li></ul><p>理解：</p><ul><li>一个JSON文件好比是一个<code>数据库</code>，一个Mongodb服务下可以有N个数据库</li><li>JSON文件中的一级属性的数组值好比是<code>集合</code></li><li>数组中的对象好比是<code>文档</code></li><li>对象中的属性也可以称为<code>字段</code></li></ul><blockquote><p>一般情况下：</p><ul><li><p>一个项目使用一个数据库</p></li><li><p>一个集合会存储同一种类型的数据</p></li></ul></blockquote><h1 id="2-操作命令"><a href="#2-操作命令" class="headerlink" title="2. 操作命令"></a>2. 操作命令</h1><p>1.显示所有的数据块：<code>show dbs</code></p><p>2.切换到指定的数据库，如果数据库不存在会自动创建数据库：<code>use 数据库名</code></p><p>3.显示当前数据库：<code>db</code></p><p>4.删除当前数据库：先<code>use 库名</code>，再<code>db.dropDatabase()</code></p><p>5.创建集合：db.createCollection(‘集合名称’)</p><p>6.显示当前数据库中的所有集合：show collections</p><p>7.删除某个集合：db.集合名.drop()</p><p>8.重命名集合：db.集合名.renameCollection(‘newName’)</p><p>9.插入文档：db.集合名.insert(文档对象)</p><p>10.查询文档：db.集合名.find(查询条件)</p><ul><li>_id是mongodb自动生成的唯一编号，用来唯一标识文档</li></ul><p>11.更新文档：</p><ul><li>db.集合名.update(查询条件,新的文档)</li><li>db.集合名.update({name:’张三’},{$set:{age:19}})</li></ul><p>12.删除文档：db.集合名.remove(查询条件)</p><h1 id="3-Mongoose"><a href="#3-Mongoose" class="headerlink" title="3. Mongoose"></a>3. Mongoose</h1><p><code>Mongoose</code>是一个对象文档模型库，主要作用就是方便使用代码操作<code>mongodb</code>数据库。</p><p>因为它有事一个工具包，所以在通过<code>npm init</code>创建一个包后，就可以在该文件夹下使用<code>npm i mongoose</code>来下载该包。</p><h2 id="3-1-通过mongoose连接上Mongodb数据库"><a href="#3-1-通过mongoose连接上Mongodb数据库" class="headerlink" title="3.1 通过mongoose连接上Mongodb数据库"></a>3.1 通过mongoose连接上Mongodb数据库</h2><p>在下载Mongoose工具包后，在该文件夹下创建一个js文件，添加以下程序即可完成连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入mongoose</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接mongodb服务</span></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://127.0.0.1:27017/bilibili&#x27;</span>);      <span class="comment">//协议-ip-端口-路径(要操作数据库的名称，不存在会自动创建)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123; <span class="comment">//设置连接成功的回调，这里on和once都可以，区别在于once只会连接1次(当服务端关了又开了后，once不会去连接了)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">()=&gt;</span>&#123;           <span class="comment">//设置连接错误的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接失败&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">()=&gt;</span>&#123;           <span class="comment">//设置连接关闭的回调</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接关闭&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭mongodb的连接</span></span><br><span class="line"><span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">&#125;, <span class="number">2000</span>);          <span class="comment">//2s钟后关闭</span></span><br></pre></td></tr></table></figure><h2 id="3-2-Mongoose插入文档"><a href="#3-2-Mongoose插入文档" class="headerlink" title="3.2 Mongoose插入文档"></a>3.2 Mongoose插入文档</h2><p>对于文档的插入操作，是在连接成功的回调函数中执行。在下面程序中，需要注意的是：在旧版本中 <code>Model.create()</code> 的<code>第二个参数是一个回调函数</code>用来捕获成功或异常。但是最新版本中，<code>Model.create()</code> 中<code>就没有第二个参数了</code>，而是返回了一个 <code>Promise</code> 对象，我们将采用 <code>then</code> 方法 和 <code>catch</code> 方法来捕获状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123; <span class="comment">//设置连接成功的回调，这里on和once都可以，区别在于once只会连接1次(当服务端关了又开了后，once不会去连接了)</span></span><br><span class="line">    <span class="comment">//创建文档的结构对象</span></span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    <span class="comment">//新增(下面这种方式在高版本是不支持的，会报错)</span></span><br><span class="line">    <span class="comment">// BookModel.create(&#123;</span></span><br><span class="line">    <span class="comment">//     name: &#x27;西游记&#x27;,</span></span><br><span class="line">    <span class="comment">//     author: &#x27;吴承恩&#x27;,</span></span><br><span class="line">    <span class="comment">//     price: 19.9</span></span><br><span class="line">    <span class="comment">// &#125;, (err, data) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     //如果出现错误</span></span><br><span class="line">    <span class="comment">//     if(err)&#123;</span></span><br><span class="line">    <span class="comment">//         console.log(err);</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //如果没有出错，则输出插入后的文档对象</span></span><br><span class="line">    <span class="comment">//     console.log(data);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//较高的版本使用这种方式插入</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">19.9</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//关闭数据块连接</span></span><br><span class="line">    mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-3-字段类型"><a href="#3-3-字段类型" class="headerlink" title="3.3 字段类型"></a>3.3 字段类型</h2><p>文档结构可选的常用字段类型列表：</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">字符串</td></tr><tr><td align="center">Number</td><td align="center">数字</td></tr><tr><td align="center">Boolean</td><td align="center">布尔值</td></tr><tr><td align="center">Array</td><td align="center">数组，也可以使用[]来标识</td></tr><tr><td align="center">Date</td><td align="center">日期</td></tr><tr><td align="center">Buffer</td><td align="center">Buffer对象</td></tr><tr><td align="center">Mixed</td><td align="center">任意类型，需要使用mongoose.Schema.Types.Mixed指定</td></tr><tr><td align="center">Objectld</td><td align="center">对象ID，需要使用mongoose.Schema.Types.ObjectId指定</td></tr><tr><td align="center">Decimal128</td><td align="center">高精度数字，需要使用mongoose.Schema.Types.Decimal128指定</td></tr></tbody></table><p>测试程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//创建文档的结构对象</span></span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">        <span class="attr">tags</span>: <span class="title class_">Array</span>,</span><br><span class="line">        <span class="attr">pub_time</span>: <span class="title class_">Date</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="number">19.9</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">tags</span>: [<span class="string">&#x27;鬼怪&#x27;</span>, <span class="string">&#x27;励志&#x27;</span>, <span class="string">&#x27;社会&#x27;</span>],</span><br><span class="line">        <span class="attr">pub_time</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()              <span class="comment">//当前时间为发布时间</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();         <span class="comment">//关闭数据库</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();         <span class="comment">//关闭数据库</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-4-字段值验证"><a href="#3-4-字段值验证" class="headerlink" title="3.4 字段值验证"></a>3.4 字段值验证</h2><p>Mongoose有一些内建验证器，可以对字段值进行验证</p><p>1.必填项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>         <span class="comment">//表明该属性必须不为空</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">author</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">default</span>: <span class="string">&#x27;匿名&#x27;</span>        <span class="comment">//设置默认值，如果没有选择这一属性，会默认为`匿名`</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3.枚举值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gender</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">enum</span>: [<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>]         <span class="comment">//设置的值必须是数组中的</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>4.唯一值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">username</span>: &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line"><span class="attr">unique</span>: <span class="literal">true</span>            <span class="comment">//设置这个属性为唯一性，不能有重复的该字段名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>unique 需要 重建集合 才能有效果</p></li><li><p>永远不要相信用户的输入，需要检查后再插入数据库</p></li></ul><p>测试程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,         <span class="comment">//表明该属性必须不为空</span></span><br><span class="line">            <span class="attr">unique</span>: <span class="literal">true</span>            <span class="comment">//设置为独一无二的，不能重复的属性名</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">author</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">default</span>: <span class="string">&#x27;匿名&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">            <span class="attr">enum</span>: [<span class="string">&#x27;言情&#x27;</span>, <span class="string">&#x27;城市&#x27;</span>, <span class="string">&#x27;志怪&#x27;</span>, <span class="string">&#x27;恐怖&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;books&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;西游记&#x27;</span>,           <span class="comment">//为空了会报错</span></span><br><span class="line">        <span class="attr">author</span>: <span class="string">&#x27;吴承恩&#x27;</span>,         <span class="comment">//没有这一项，会默认作者是&#x27;匿名&#x27;</span></span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;言情&#x27;</span>             <span class="comment">//类型只能选择上面定义好的枚举类里面的内容</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);             <span class="comment">//如果插入成功，则输出插入后的文档对象</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);              <span class="comment">//插入失败</span></span><br><span class="line">        mongoose.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-5-Mongoose删除和更新文档"><a href="#3-5-Mongoose删除和更新文档" class="headerlink" title="3.5 Mongoose删除和更新文档"></a>3.5 Mongoose删除和更新文档</h2><p>下面程序需要注意的是，由于版本的问题，现在高版本已经不支持<code>BookModel.deleteMany(&#123;&#125;, (err, data) =&gt; &#123;&#125;);</code>这种回调的写法了。</p><p>1.通过以下方式来完成删除操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除1条，因为版本问题，不同通过回调函数的形式来写了</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">deleteOne</span>(&#123;<span class="attr">_id</span>: <span class="string">&#x27;66e65604f92fdec9fa0a7f53&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//批量删除，删除is_hot为false的文档</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">deleteMany</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">false</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.通过以下方式来完成更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新数据1条(参数：条件；更新的情况)</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">updateOne</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">13.9</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//批量更新</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">updateMany</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">true</span>&#125;, &#123;<span class="attr">price</span>: <span class="number">19.9</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-6-读取文档"><a href="#3-6-读取文档" class="headerlink" title="3.6 读取文档"></a>3.6 读取文档</h2><p>1.普通读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mongoose.<span class="property">connection</span>.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置集合中文档的属性以及属性值的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookSchema</span> = <span class="keyword">new</span> mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">author</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">price</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="attr">is_hot</span>: <span class="title class_">Boolean</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//创建模型对象， 对文档操作的封装对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BookModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;novels&#x27;</span>, <span class="title class_">BookSchema</span>);        <span class="comment">//参1：集合名称；参2：结构对象</span></span><br><span class="line">    <span class="comment">//1.读取单条</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">findOne</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//2.通过id获取</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">findById</span>(<span class="string">&#x27;66e65688565eb1640b878f88&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">    <span class="comment">//3.批量获取(如果find里面没有写任何内容，就是获取全部)</span></span><br><span class="line">    <span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;<span class="attr">is_hot</span>: <span class="literal">true</span>&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);<span class="keyword">return</span>;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.运算符</p><p>在mongodb不能直接使用<code>&gt;、&lt;、&gt;=、&lt;=、!==</code>等运算符，需要使用替代符号：</p><ul><li><code>&gt;</code>使用<code>$gt</code></li><li><code>&lt;</code>使用<code>$lt</code></li><li><code>&gt;=</code>使用<code>$gte</code></li><li><code>&lt;=</code>使用<code>$lte</code></li><li><code>!==</code>使用<code>$ne</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找价格小于30的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">price</span>: &#123;<span class="attr">$lt</span>: <span class="number">30</span>&#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>3.逻辑运算</p><ul><li><code>$or</code>表示逻辑或</li><li><code>$and</code>表示逻辑与</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找名字为名侦探柯南或海贼王的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">$or</span>: [&#123;<span class="attr">name</span>: <span class="string">&#x27;名侦探柯南&#x27;</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">&#x27;海贼王&#x27;</span>&#125;]</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//价格大于15，下于30的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">$and</span>: [&#123;<span class="attr">price</span>: &#123;<span class="attr">$gt</span>: <span class="number">15</span>&#125;&#125;, &#123;<span class="attr">price</span>: &#123;<span class="attr">$lt</span>:<span class="number">30</span>&#125;&#125;]</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>4.正则匹配</p><p>条件中可以直接使用JS的正则语法，通过正则可以进行模糊查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找名字带柯的书籍</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="regexp">/柯/</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>5.个性化读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取全部数据，但每条数据只显示name和author</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>        <span class="comment">//如果不添加_id: 0，默认会有id的</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//对数据的价格进行升序排序</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>&#125;)</span><br><span class="line">    .<span class="title function_">sort</span>(&#123;<span class="attr">price</span>: <span class="number">1</span>&#125;)                  <span class="comment">//1是升序；-1是倒序</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//按照价格降序排序，又跳过了3个，所以选择查看第4和第5贵的书籍信息</span></span><br><span class="line"><span class="title class_">BookModel</span>.<span class="title function_">find</span>().<span class="title function_">select</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">author</span>: <span class="number">1</span>, <span class="attr">_id</span>: <span class="number">0</span>&#125;)</span><br><span class="line">      .<span class="title function_">sort</span>(&#123;<span class="attr">price</span>: -<span class="number">1</span>&#125;)            <span class="comment">//降序</span></span><br><span class="line">      .<span class="title function_">skip</span>(<span class="number">3</span>)                      <span class="comment">//跳过前面3个</span></span><br><span class="line">      .<span class="title function_">limit</span>(<span class="number">2</span>)                     <span class="comment">//限定，选择前2个</span></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~~&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>最后如果想要操作更加的简单，可以使用Mongodb的图形化工具，比如说Navicat等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;MongoDB是一个基于分布式文件存储的数据库，操作语法与JavaScript类似，容易上手。它与mysql不一样，my</summary>
      
    
    
    
    <category term="数据库" scheme="https://lxx93.online/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>nodejs基础</title>
    <link href="https://lxx93.online/2024/09/10/nodejs%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/09/10/nodejs%E5%9F%BA%E7%A1%80/</id>
    <published>2024-09-10T13:22:55.000Z</published>
    <updated>2024-10-07T15:09:27.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Node.js是一个开源的，跨平台的JavaScript运行环境。通俗来讲，node.js就是一款应用程序，是一款软件，它可以运行JavaScript。</p><h2 id="1-1-Node-js的作用"><a href="#1-1-Node-js的作用" class="headerlink" title="1.1 Node.js的作用"></a>1.1 Node.js的作用</h2><p>1.开发服务器应用</p><p>众所周知，网页的构建是通过HTML、CSS、JavaScript来完成的，其中HTML负责控制结构、CSS负责控制样式、JS负责控制交互和效果。当在本机双击HTML文件后，页面就能够打开，但是这个网页只能在本机看到。如果想要该网页能够让每个人都能够访问，就需要使用服务器了。因为服务器能够保存我们写好的HTML、CSS、JavaScript，其他用户能够在自己的电脑上通过url来向我们的服务器发送请求，发送请求后，服务器能够将这些资源返回给用户的浏览器，然后浏览器就可以对这些资源做解析，页面就能够呈现了(所有的用户都能够通过url来访问服务器)。在这个过程中，node.js就运行在服务器端，它会对用户的请求做处理，并且把这些资源返回给浏览器。</p><p>2.开发工具类应用</p><p>目前前端开发中非常重要的三款工具Webpack、vite、Babel，它们可以提高前端项目的开发效率和质量，但都是借助于Node.js开发能力而实现的。所以可以借助node.js来创建一些属于自己的工具，来提高开发效率。</p><p>3.开发桌面端应用</p><p>对于代码编辑工具VSCode、设计工具Figma、接口测试工具Postman这三款软件都是借助electron框架，而这个框架又是借助node.js开发出来的，所以在学习了node.js后还可以去开发一些桌面端应用程序。</p><h2 id="1-2-node-js编码注意事项"><a href="#1-2-node-js编码注意事项" class="headerlink" title="1.2 node.js编码注意事项"></a>1.2 node.js编码注意事项</h2><p>1.Node.js中不能使用BOM和DOM的API，可以使用console和定时器API。</p><ul><li><p>BOM(Browser Object Model，浏览器对象模型)是与浏览器窗口进行互动的对象结构。它提供了一组可以操作浏览器窗口、历史记录、定时器等浏览器相关信息的API</p></li><li><p>DOM(Document Object Model，文档对象模型)则是一个与平台和语言无关的接口，它将网页的结构化文档表示为一个树形结构，允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p></li></ul><p>简而言之，BOM API 允许开发者与浏览器窗口和浏览器本身进行交互，而 DOM API 则允许开发者访问和操作网页的内容和结构。两者都是 JavaScript 编程中的重要组成部分，使得开发者能够创建动态和交互式的网页应用。</p><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它允许 JavaScript 运行在服务器端。由于 Node.js 运行在服务器端，而不是在浏览器环境中，因此它不提供浏览器特有的 API，比如 BOM 和部分 DOM API。</p><p>2.Node.js中的顶级对象为global，也可以用globalThis访问顶级对象。</p><ul><li><p>在 Node.js 环境中，全局对象被称为 <code>global</code>。这意味着在 Node.js 中定义的全局变量和函数会自动成为 <code>global</code> 对象的属性和方法。例如，如果你在 Node.js 脚本中定义了一个全局变量 <code>var myGlobalVar = &#39;Hello, world!&#39;;</code>，那么你可以通过 <code>global.myGlobalVar</code> 来访问这个变量。</p></li><li><p><code>globalThis</code> 是一个相对较新的全局属性，它在所有环境中(包括浏览器和 Node.js)都指向全局对象。这意味着无论在哪个环境中，你都可以使用 <code>globalThis</code> 来访问全局作用域下的变量和函数。在 Node.js 中，<code>globalThis</code> 指向的就是 <code>global</code> 对象。</p></li></ul><h1 id="2-Buffer-缓冲器"><a href="#2-Buffer-缓冲器" class="headerlink" title="2. Buffer(缓冲器)"></a>2. Buffer(缓冲器)</h1><p>Buffer中文译为缓冲区，是一个类似于Array的对象，用于表示固定长度的字节序列。换句话说，Buffer就是一段固定长度的内存空间，用于处理二进制数据。</p><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>1.概念：Buffer是一个类似于数值的<code>对象</code>，用于表示固定长度的字节序列。Buffer本质是一段内存空间，专门用来处理<code>二进制数据</code>。</p><p>2.特点</p><ul><li>Buffer大小固定且无法调整</li><li>Buffer性能较好，可以直接对计算机内存进行操作</li><li>每个元素的大小为1字节(byte)</li></ul><h2 id="2-2Buffer的使用"><a href="#2-2Buffer的使用" class="headerlink" title="2.2Buffer的使用"></a>2.2Buffer的使用</h2><p>1.buffer的创建有三种方法，分别是alloc、allocUnsafe和from。如下程序所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. alloc</span></span><br><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);   <span class="comment">//创建一个10字节的buffey，Buffer是nodejs的内置模块，在启动时已经被加载进来，不需要手动导入就可以使用，它可以理解为全局变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);             <span class="comment">//用alloc创建的方法，每个二进制位都会归0(清0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.allocUnsafe</span></span><br><span class="line"><span class="keyword">let</span> buf_2 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">1000</span>);     <span class="comment">//这种方法创建的buffer，可能包含旧的内存数据(之前用完但没有清0的)，但速度比alloc方法快</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.from</span></span><br><span class="line"><span class="keyword">let</span> buf_3 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);        <span class="comment">//这种方法可以将一个字符串或数组转为buffer</span></span><br><span class="line"><span class="keyword">let</span> buf_4 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_4);</span><br></pre></td></tr></table></figure><p>2.Buffer与字符串的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buffer与字符串的转换</span></span><br><span class="line"><span class="keyword">let</span> buf_1 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>([<span class="number">105</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">121</span>,<span class="number">111</span>,<span class="number">117</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf_1.<span class="title function_">toString</span>());         <span class="comment">//默认采用的是utf-8的方式进行转换</span></span><br></pre></td></tr></table></figure><p>3.Buffer的读写：可以直接通过[]的方式对数据进行处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf[<span class="number">0</span>]);                   <span class="comment">//将h通过utf-8进行转换为十进制数  结果：104</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf[<span class="number">0</span>].<span class="title function_">toString</span>(<span class="number">2</span>));       <span class="comment">//将h转换为2进制数              结果：1101000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);                      <span class="comment">//先打印buf内容                结果&lt;Buffer 68 65 6c 6c 6f&gt;</span></span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">95</span>;                           <span class="comment">//对第一位h进行修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="title function_">toString</span>());           <span class="comment">//打印修改的结果(转换成字符串了)  结果：_ello</span></span><br></pre></td></tr></table></figure><p>4.注意事项</p><p>如果数值超过255，则超过8位，数据会被舍弃：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">buf[<span class="number">0</span>] = <span class="number">361</span>;          <span class="comment">//舍弃高位数字(超过8位的，大于255的) 361=000101101001 =&gt; 0110 1001，即69</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);      <span class="comment">//打印结果为 &lt;Buffer 69 65 6c 6c 6f&gt;</span></span><br></pre></td></tr></table></figure><p>中文是utf-8的中文，一个中文一般占3个字节：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;你好&#x27;</span>);     <span class="comment">//是6个字节</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf);       <span class="comment">//结果：&lt;Buffer e4 bd a0 e5 a5 bd&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-计算机基础"><a href="#3-计算机基础" class="headerlink" title="3. 计算机基础"></a>3. 计算机基础</h1><h2 id="3-1-计算机基本组成"><a href="#3-1-计算机基本组成" class="headerlink" title="3.1 计算机基本组成"></a>3.1 计算机基本组成</h2><p>1.CPU：中央处理器，是整个计算机运算和控制的中心</p><p>2.内存：是存储数据的一个介质，可以在里面存放大量的0和1这样的数据</p><ul><li>特点：读写速度较快，断电丢失数据。程序在运行时都会载入到内存当中，让CPU高速的对这个数据进行执行和处理</li></ul><p>3.硬盘：也可以存储很多0和1这样的数据，</p><ul><li>特点：读写速度较慢，断电不丢失数据。平时下载的程序，如英雄联盟、浏览器、QQ等这些程序下载安装完后都是放到了硬盘里面。</li></ul><p>4.显卡：负责处理视频信号的，当有信息需要呈现，需要在显示器中显示时，就会将信号传递给显卡，显卡处理完毕后，再将信号传递给显示器，然后显示器最终显示。</p><p>5.主板：是一块大的集成电路板，上面有很多插槽，很多元器件就是插在插槽里面，通过主板联系在一起的。</p><p>除了上面器件，再通过一些外设，如显示器、键盘、鼠标和音响等，整个电脑就算组装完毕了。</p><h2 id="3-2-程序运行的基本流程"><a href="#3-2-程序运行的基本流程" class="headerlink" title="3.2 程序运行的基本流程"></a>3.2 程序运行的基本流程</h2><p>当所有器件都组装完毕之后，计算机也不能正常去运行。因为还缺少一个操作系统，常见的操作系统有Windows、Linux和MacOS。操作系统也是一种应用程序(010101..)，用来管理和调度硬件资源。可以理解为，操作系统能够让cpu去执行哪个程序。</p><p>装系统：就是将操作系统这个程序安装在硬盘的这样一个过程。当把这个操作系统程序装到硬盘之后，电脑就可以开机运行了。</p><p>运行流程：首先会先将Windows相关的一些程序文件载入到内存里面，载入内存之后，CPU就可以运行了。CPU执行的时候，如果发现有视频信号需要在显示器上去呈现，就会交给显卡去处理，显卡处理完之后，再交由显示器去呈现。再处理过程当中，如果遇到了声音信号，这时候会交给声卡，声卡再将信号传递给外部的播放设备(如耳机、音响等)。它们一结合，就会呈现出视频和声音一起播放的效果</p><blockquote><p>程序一般保存在硬盘中(还有一些是存在软盘这样一些介质里面的)，软件安装的过程就是将程序写入硬盘的过程。程序在运行时会加载进入内存，然后由CPU读取并执行程序。</p></blockquote><h1 id="4-fs模块"><a href="#4-fs模块" class="headerlink" title="4. fs模块"></a>4. fs模块</h1><p>fs模块可以实现与硬盘的交互。例如文件的创建、删除、重命名、移动，还有文件内容的写入、读取，以及文件夹的相关操作。</p><p>文件写入的应用场景：当需要持久化保存数据的时候，应该想到文件写入。</p><ul><li>下载文件</li><li>安装软件</li><li>保存程序日志，如Git</li><li>编辑器保存文件</li><li>视频录制</li></ul><p>文件读取应用场景</p><ul><li>电脑开机</li><li>程序运行</li><li>编辑器打开文件</li><li>查看图片</li><li>播放视频</li><li>播放音乐</li><li>Git查看日志</li><li>上传文件</li><li>查看聊天记录</li></ul><h2 id="4-1-读写操作"><a href="#4-1-读写操作" class="headerlink" title="4.1 读写操作"></a>4.1 读写操作</h2><p>1.writeFile异步写入</p><p>语法：<code>fs.writeFile(file, data[, options], callback)</code></p><p>参数说明：</p><ul><li>file：文件名(不存在会自动创建)</li><li>data：待写入的数据</li><li>options：选项设置(可选)</li><li>callback：写入回调(当写入完成之后，会自动调用该回调函数)</li></ul><p>测试程序：在下面程序中，代码先自上而下运行，当运行到writeFile时，会进行磁盘的写入，它会将这个磁盘写入交给另一个线程(IO线程)去完成，而主线程会继续向下执行。当IO线程写入完毕之后，会将回调函数压入到队列当中，等js的主线程给初始化的代码执行完毕之后，就会从任务队列中将这个回调函数取出来执行。如下面程序的结果是先打印12，再打印写入成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需求：新建一个文件夹，座右铭.txt，写入的内容：三人行，必有我师焉</span></span><br><span class="line"><span class="comment">//1. 导入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 写入文件</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;三人行，必有我师焉&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;  <span class="comment">//当写入完成之后，会自动调用该回调函数,并将错误传递给这个函数</span></span><br><span class="line">    <span class="comment">//err写入失败：错误对象；写入成功：null</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>+<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>2.writeFileSync同步写入</p><p>语法：<code>fs.writeFileSync(file, data)</code></p><p>参数说明：</p><ul><li>file：文件名(不存在会自动创建)</li><li>data：待写入的数据</li></ul><p>测试程序：创建了一个data.txt文件，向里面写入了test</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">`test`</span>);</span><br></pre></td></tr></table></figure><p>3.appendFile异步追加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;择其善者而从之，择其不善者而改之&#x27;</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.appendFileSync同步追加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.<span class="title function_">appendFileSync</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;\r\n温故而知新，可以为师矣&#x27;</span>);      <span class="comment">// \r\n表示换行</span></span><br></pre></td></tr></table></figure><p>5.writeFile实现追加写入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;love love love&#x27;</span>,&#123;<span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span>&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//a是追加；w是写入(覆盖)；r是读；默认是w</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>6.createWriteStream流式写入</p><p>createWriteStream会根据传入的参数路径，与它建立一个通道，啥时候想写，就通过write往通道里面传入内容即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);     <span class="comment">//引入写入流对象(接收一个文件路径的参数)</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;半亩方糖一签开\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;天光云影共徘徊\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;问渠那得清如许\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;有源头活水来\r\n&#x27;</span>);</span><br><span class="line">ws.<span class="title function_">close</span>();                 <span class="comment">//关闭通道</span></span><br></pre></td></tr></table></figure><blockquote><p>特点：程序打开一个文件是需要消耗资源的，流式写入可以减少打开关闭文件的次数。</p><p>流式写入方式适用于<code>大文件写入或者频繁写入的场景</code>，writeFile适用于<code>写入频率较低的场景</code>。</p></blockquote><p>7.readFile异步读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//err接收错误的信息；data用来接收读取的文件内容</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        cconsole.<span class="title function_">log</span>(<span class="string">&#x27;读取失败~~&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>8.readFileSync同步读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./观书有感.txt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><p>9.createReadStream流式读取</p><p>在绑定事件中，当从文件当中读取出来一块数据之后，就会执行一次回调，并把读取到的内容传递给形参chunk。这种方法相比其他读取方法，效率会更高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建读取流对象</span></span><br><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./video.mp4&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定data事件(参数：事件的名字；带参数chunk的回调函数)</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="property">length</span>);       <span class="comment">//65536字节 =&gt; 64KB(每次读取的大小)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//当文件读取完毕之后，会触发该事件(可选事件)</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>10.文件移动和重命名</p><p>可以使用<code>rename</code>或<code>renameSync</code>来移动或重命名文件或文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行重命名，将座右铭.txt改为论语.txt</span></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./座右铭.txt&#x27;</span>, <span class="string">&#x27;./论语.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行移动</span></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="string">&#x27;../资料/data.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>11.删除文件</p><p><code>unlink</code>方法对应的同步方法是<code>unlinkSync</code>；<code>rm</code>方法对应的同步方法是<code>reSync</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./论语.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./data.txt&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作成功~&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-2-文件夹操作"><a href="#4-2-文件夹操作" class="headerlink" title="4.2 文件夹操作"></a>4.2 文件夹操作</h2><p>通过node,js可以对文件夹进行创建、读取、删除等操作</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">mkdir&#x2F;mkdirSync</td><td align="center">创建文件夹</td></tr><tr><td align="center">readdir&#x2F;readdirSync</td><td align="center">读取文件夹</td></tr><tr><td align="center">rmdir&#x2F;rmdirSync</td><td align="center">删除文件夹</td></tr></tbody></table><p>1.创建文件夹mkdir</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建单个文件夹html</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归创建多层文件夹</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a/b/c&#x27;</span>,&#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.读取文件夹readdir</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.删除文件夹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除单层文件夹</span></span><br><span class="line">fs.<span class="title function_">rmdir</span>(<span class="string">&#x27;./html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归删除多层文件夹</span></span><br><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./a&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;      <span class="comment">//如果用rmdir也可以，但有警告</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除成功&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.查看资源的状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;./video.mp4&#x27;</span>, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);                  <span class="comment">//打印出指定文件的状态数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isFile</span>());         <span class="comment">//是否是文件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isDirectory</span>());    <span class="comment">//是否是文件夹</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>5.’全局变量’__dirname</p><p>相对路径参照物是命令行的工作目录，所以有时候在代码中写相对路径时，会因为命令行的工作目录而导致编写出错。</p><p><code>__dirname</code>：保存的是所在文件的所有目录的绝对路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFileSync</span>(__dirname + <span class="string">&#x27;/index.txt&#x27;</span>, <span class="string">&#x27;love&#x27;</span>);      <span class="comment">//在当前文件下的index.txt文件中写入love</span></span><br></pre></td></tr></table></figure><h1 id="5-path模块"><a href="#5-path模块" class="headerlink" title="5. path模块"></a>5. path模块</h1><p>path模块提供了操作路径的功能，下面是几个常用的API：</p><table><thead><tr><th align="center">API</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">path.resolve</td><td align="center">拼接规范的绝对路径</td></tr><tr><td align="center">path.sep</td><td align="center">获取操作系统的路径分隔符</td></tr><tr><td align="center">path.parse</td><td align="center">解析路径并返回对象</td></tr><tr><td align="center">path.basename</td><td align="center">获取路径的基础名称</td></tr><tr><td align="center">path.dirname</td><td align="center">获取路径的目录名</td></tr><tr><td align="center">path.extname</td><td align="center">获取路径的扩展名</td></tr></tbody></table><h1 id="6-http模块"><a href="#6-http模块" class="headerlink" title="6. http模块"></a>6. http模块</h1><p>1.想要获取请求的数据，需要通过request对象</p><table><thead><tr><th align="center">含义</th><th align="center">语法</th></tr></thead><tbody><tr><td align="center">请求方法</td><td align="center">request.method</td></tr><tr><td align="center">请求版本</td><td align="center">request.httpVersion</td></tr><tr><td align="center">请求路径</td><td align="center">request.url</td></tr><tr><td align="center">URL路径</td><td align="center">require(‘url’).parse(request.url).pathname</td></tr><tr><td align="center">URL查询字符串</td><td align="center">require(‘url’).parse(request.url,true).query</td></tr><tr><td align="center">请求头</td><td align="center">request.headers</td></tr><tr><td align="center">请求体</td><td align="center">request.on(‘data’,function(chunk{}))</td></tr></tbody></table><h2 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h2><p>1.用nodejs创建了一个HTTP服务端，在浏览器输入<a href="http://127.0.0.1:9000](http://127.0.0.1:9000/)后，回车，网页上会显示`Hello">http://127.0.0.1:9000](http://127.0.0.1:9000/)后，回车，网页上会显示`Hello</a> HTTP Server&#96;。如果监听的端口为80的话，浏览器输入127.0.0.1即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建服务对象(当收到请求，就会调用回调函数)</span></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server  =http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="comment">//console.log(request.method);</span></span><br><span class="line">    <span class="comment">//获取请求的url</span></span><br><span class="line">    <span class="comment">//console.log(request.url);       //只包含url中的路径与查询字符串(不包含协议、ip和端口)</span></span><br><span class="line">    <span class="comment">//获取请求头</span></span><br><span class="line">    <span class="comment">//console.log(request.headers);</span></span><br><span class="line">    <span class="comment">//response.end(&#x27;Hello HTTP Server&#x27;);                     //设置响应体，并结束响应</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;你好，世界&#x27;</span>);        <span class="comment">//设置响应体(是中文的话会出现乱码，需要设置响应的字符集)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>HTTP协议默认端口是80，HTTPS协议的默认端口是443，HTTP服务开发常用端口有3000、8080、8090和9000等</p><blockquote><p>如果端口被其他程序占用，可以使用<code>资源监视器</code>找到占用端口的程序，然后使用<code>任务管理器</code>关闭对应的程序。</p></blockquote><p>2.获取请求体的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//1.声明一个变量(接收响应体的结果)</span></span><br><span class="line">    <span class="keyword">let</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">//2.给request绑定事件data</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="params">chunk</span> =&gt;</span> &#123;      <span class="comment">//参数：给request绑定的一个data事件，回调函数</span></span><br><span class="line">        body += chunk;       <span class="comment">//将取出的数据放到body中</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//3.绑定end事件(把可读流里面的数据都读完了，会触发end事件)</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(body);             <span class="comment">//打印请求体的内容</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;Hello HTTP&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.获取请求路径与查询字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);     <span class="comment">//导入url模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//request是对请求报文的一个封装对象，可以获取到请求报文里面的相关内容；response是对响应报文的一个封装，可以设置响应给对端的结果</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//解析request.url</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>);              <span class="comment">//这是包含了路径和查询字符串</span></span><br><span class="line">    <span class="comment">//通过url的parse解析request.url的结果</span></span><br><span class="line">    <span class="keyword">let</span> res = url.<span class="title function_">parse</span>(request.<span class="property">url</span>, <span class="literal">true</span>);   <span class="comment">//参数2为true,可以使得结构体中的query属性(存放字符串的)变为一个对象,方便获得value值</span></span><br><span class="line">    <span class="comment">//console.log(res);                      //可以得到请求的一个结构体(key：value)</span></span><br><span class="line">    <span class="keyword">let</span> pathname = res.<span class="property">pathname</span>;           <span class="comment">//获取路径</span></span><br><span class="line">    <span class="comment">//console.log(pathname);</span></span><br><span class="line">    <span class="keyword">let</span> keyword = res.<span class="property">query</span>.<span class="property">keyword</span>;      <span class="comment">//获得keyword对应的value值(因为解析时，参2为true，所以可以这样调用)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(keyword);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例：实现一个http的服务端，当url的路径是login时，访问的是登录界面；当url的路径是reg时，访问的是注册界面；当路径是其他时，访问的是Not Found界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//获取请求方法</span></span><br><span class="line">    <span class="keyword">let</span> &#123;method&#125; = request;</span><br><span class="line">    <span class="comment">//获取请求的url路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>,<span class="string">&#x27;http://127.0.0.1&#x27;</span>);           <span class="comment">//参1：路径和key-value值</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="keyword">if</span>(method === <span class="string">&#x27;GET&#x27;</span> &amp;&amp; pathname === <span class="string">&#x27;/login&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//登录的情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;登录界面&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method === <span class="string">&#x27;GET&#x27;</span> &amp;&amp; pathname === <span class="string">&#x27;/reg&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//注册的情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;注册界面&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//情况情形</span></span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;Not Found&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4.设置响应报文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;   <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//1.设置响应状态码</span></span><br><span class="line">    response.<span class="property">statusCode</span> = <span class="number">203</span>;</span><br><span class="line">    <span class="comment">//2.设置状态描述</span></span><br><span class="line">    response.<span class="property">statusMessage</span> = <span class="string">&#x27;lxxl&#x27;</span>;</span><br><span class="line">    <span class="comment">//3.响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);          <span class="comment">//响应内容的类型和编码字符</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Server&#x27;</span>, <span class="string">&#x27;Node.js&#x27;</span>);                   <span class="comment">//标识服务端的名字的</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;myheader&#x27;</span>, <span class="string">&#x27;test test test&#x27;</span>);          <span class="comment">//也可以设置自己想加的</span></span><br><span class="line">    <span class="comment">//4.响应头设置</span></span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;lxxl&#x27;</span>);            <span class="comment">//设置响应体，可以有多个write</span></span><br><span class="line">    response.<span class="title function_">end</span>();                    <span class="comment">//一般使用了write，就不用end写(为空即可)，end只能有一个</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>案例：创建一个HTTP服务端，返回给浏览器一个注册界面(用html写好的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node.js部分的程序</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//读取文件内容</span></span><br><span class="line">    <span class="keyword">let</span> html = fs.<span class="title function_">readFileSync</span>(__dirname + <span class="string">&#x27;/reg.html&#x27;</span>);        <span class="comment">//拼接文件名，并读取</span></span><br><span class="line">    response.<span class="title function_">end</span>(html);                <span class="comment">//设置响应体</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html部分的程序 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin: 0 auto; border: 1px solid #ccc; padding: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1998<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1999<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>7<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>8<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>9<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>10<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第三行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;中国上海&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>未婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;three&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第五行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第六行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢的类型：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 妩媚的 </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 可爱的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 性感的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 开朗的</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第七行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第八行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第九行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span> 我同意注册条款和会员加入标准</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我是会员，立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚的寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/skills/1.png"></p><p>补充：HTTP服务在哪个文件夹中寻找静态资源，哪个文件夹就是<code>静态资源目录</code>，也称为<code>网站根目录</code>。</p><p>5.设置资源类型(mime类型)</p><p>媒体类型是一种标准，用来表示文档、文件或字节流的性质和格式。</p><p>HTTP服务可以设置响应头Content-Type来表示响应体的MIME类型，浏览器会根据该类型决定如何处理资源。下面是常见文件对应的mime类型：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">html: &#x27;text/html&#x27;</span></span><br><span class="line"><span class="section">css: &#x27;text/css&#x27;</span></span><br><span class="line"><span class="section">js: &#x27;text/javascript&#x27;</span></span><br><span class="line"><span class="section">png: &#x27;image/png&#x27;</span></span><br><span class="line"><span class="section">jpg: &#x27;image/jpeg&#x27;</span></span><br><span class="line"><span class="section">gif: &#x27;image/gif&#x27;</span></span><br><span class="line"><span class="section">mp4: &#x27;video/mp4&#x27;</span></span><br><span class="line"><span class="section">mp3: &#x27;audio/mpeg&#x27;</span></span><br><span class="line"><span class="section">json: &#x27;application/json&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于未知的资源类型，可以选择<code>application/octet-stream</code>类型，浏览器在遇到该类型的响应时，会对响应体内容进行独立存储，也就是常见的<code>下载</code>效果。</p></blockquote><p>下面程序是设置响应体的MIME类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个变量</span></span><br><span class="line"><span class="keyword">let</span> mimes = &#123;</span><br><span class="line">    <span class="attr">html</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">    <span class="attr">css</span>: <span class="string">&#x27;text/css&#x27;</span>,</span><br><span class="line">    <span class="attr">js</span>: <span class="string">&#x27;text/javascript&#x27;</span>,</span><br><span class="line">    <span class="attr">png</span>: <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line">    <span class="attr">jpg</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">    <span class="attr">gif</span>: <span class="string">&#x27;image/gif&#x27;</span>,</span><br><span class="line">    <span class="attr">mp4</span>: <span class="string">&#x27;video/mp4&#x27;</span>,</span><br><span class="line">    <span class="attr">mp3</span>: <span class="string">&#x27;audio/mpeg&#x27;</span>,</span><br><span class="line">    <span class="attr">json</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务对象</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request,response</span>) =&gt;</span> &#123;         <span class="comment">//当服务接收到http请求的时候，该函数就会执行</span></span><br><span class="line">    <span class="comment">//读取请求url的路径</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname&#125; = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>, <span class="string">&#x27;http://127.0.0.1&#x27;</span>);       <span class="comment">//获得路径</span></span><br><span class="line">    <span class="comment">//声明一个变量</span></span><br><span class="line">    <span class="keyword">let</span> root = __dirname + <span class="string">&#x27;/page&#x27;</span>;             <span class="comment">//这是拼接资源目录</span></span><br><span class="line">    <span class="comment">//拼接文件路径</span></span><br><span class="line">    <span class="keyword">let</span> filePath = root + pathname;            <span class="comment">//得到对应资源目录下，对端要得到的文件的路径</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(filePath, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>);</span><br><span class="line">            response.<span class="property">statusCode</span> = <span class="number">500</span>;</span><br><span class="line">            response.<span class="title function_">end</span>(<span class="string">&#x27;文件读取失败&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取文件的后缀名</span></span><br><span class="line">        <span class="comment">//let ext = path.extname(filePath);             //如果url输入的路径是3.png，这里得到的就是.png</span></span><br><span class="line">        <span class="keyword">let</span> ext = path.<span class="title function_">extname</span>(filePath).<span class="title function_">slice</span>(<span class="number">1</span>);      <span class="comment">//从下标1开始截取，这里得到的是png</span></span><br><span class="line">        <span class="comment">//获取对应的类型</span></span><br><span class="line">        <span class="keyword">let</span> type = mimes[ext];</span><br><span class="line">        <span class="keyword">if</span>(type)&#123;</span><br><span class="line">            <span class="comment">//匹配到了</span></span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, type);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.<span class="title function_">setHeader</span>(<span class="string">&#x27;content-type&#x27;</span>, <span class="string">&#x27;application/octet-stream&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        response.<span class="title function_">end</span>(data);                <span class="comment">//设置响应体</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听端口，启动服务</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">()=&gt;</span>&#123;                    <span class="comment">//参数：端口号9000；回调函数(当这个服务启动成功后会执行)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动.....&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-GET和POST请求"><a href="#6-2-GET和POST请求" class="headerlink" title="6.2 GET和POST请求"></a>6.2 GET和POST请求</h2><p>1.使用情况</p><ul><li>GET请求的情况：<ul><li>在地址栏直接输入url访问</li><li>点击a链接</li><li>link标签引入css</li><li>script标签引入css</li><li>video与audio引入多媒体</li><li>img标签引入图片</li><li>form标签中的method为get(不区分大小写)</li><li>ajax中的get请求</li></ul></li><li>POST请求的情况：<ul><li>form标签中的method为post(不区分大小写)</li><li>ajax的post请求</li></ul></li></ul><p>2.GET和POST请求的区别</p><ul><li>作用：GET主要用来获取数据，POST主要用来提交数据</li><li>参数位置：GET带参数请求一般是将参数缀到URL之后，POST带参数请求一般是将参数放到请求体中</li><li>安全性：POST请求相对GET安全一些，因为在浏览器中参数会暴露在地址栏</li><li>GET请求大小有限制，一般为2K，而POST请求则没有大小限制</li></ul><h1 id="7-Node-js模块化"><a href="#7-Node-js模块化" class="headerlink" title="7. Node.js模块化"></a>7. Node.js模块化</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>模块化的概念：将一个复杂的程序文件依据一定规则(规范)拆分成多个文件的过程称之为<code>模块化</code>。</p><p>模块的概念：对拆分出的每个文件就是一个模块，模块的内部数据是私有的，不过模块可以暴露内部数据以便其它模块使用。</p><p>模块化的好处：</p><ul><li>防止命名冲突</li><li>高复用性</li><li>高维护性</li></ul><h2 id="7-2-操作"><a href="#7-2-操作" class="headerlink" title="7.2 操作"></a>7.2 操作</h2><p>模块暴露数据的方式有两种：</p><ul><li>module.exports &#x3D; value</li><li>exports.name &#x3D; value</li></ul><blockquote><p>注意：</p><ul><li>module.exports可以暴露<code>任意</code>数据</li><li>不能使用<code>exports = value</code>的形式暴露数据，模块内部module与exports的隐式关系是<code>exports = module.exports = &#123;&#125;</code></li></ul></blockquote><p>1.创建一个需要暴露的程序me.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tiemo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;贴膜.....&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//捏脚</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">niejiao</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捏脚.....&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露数据1</span></span><br><span class="line"><span class="comment">//module.exports = tiemo;               //这里是只暴露了iemo函数</span></span><br><span class="line"><span class="comment">// module.exports = &#123;</span></span><br><span class="line"><span class="comment">//     tiemo,</span></span><br><span class="line"><span class="comment">//     niejiao</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露数据2</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">niejiao</span> = niejiao;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">tiemo</span> = tiemo;</span><br></pre></td></tr></table></figure><p>引用的程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="built_in">require</span>(<span class="string">&#x27;./me.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line">me.<span class="title function_">tiemo</span>();</span><br><span class="line">me.<span class="title function_">niejiao</span>();</span><br></pre></td></tr></table></figure><p>2.导入模块</p><p>在模块中使用require传入文件路径即可引入文件：<code>const test = require(&#39;./me.js&#39;);</code></p><p>require使用的一些注意事项：</p><ul><li>对于自己创建的模块，导入时路径建议写<code>相对路径</code>，且不能省略<code>./</code>和<code>../</code></li><li>js和json文件导入时可以不用写后缀，c&#x2F;c++编写的node扩展文件也可以不用写后缀，但是一般用不到</li><li>如果导入其它类型的文件，会以js文件进行处理</li><li>如果导入的路径是个文件夹，则会首先检测该文件夹下package.json文件中的main属性对应的文件，如果存在则导入，反之如果文件不存在会报错。如果main属性不存在，或者package.json不存在，则会尝试导入文件夹下的index.js和index.json，如果还是没有找到，就会报错。</li><li>导入node.js内置模块时，直接require模块的名字即可，无需加<code>./</code>和<code>../</code>。</li></ul><h1 id="8-包管理工具"><a href="#8-包管理工具" class="headerlink" title="8. 包管理工具"></a>8. 包管理工具</h1><h2 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1 简介"></a>8.1 简介</h2><p>包英文单词是package，代表了一组特定功能的源码集合</p><p>包管理工具：是管理包的应用软件，可以对包进行下载安装、更新、删除和上传等操作。借助包管理工具，可以快速开发项目，提升开发效率。包管理工具是一个通用的概念，很多编程语言都有包管理工具。</p><p>常用的包管理工具有：npm、yarm、cnpm</p><h2 id="8-2-npm"><a href="#8-2-npm" class="headerlink" title="8.2 npm"></a>8.2 npm</h2><p>npm是node.js官方内置的包管理工具，是必须要掌握的工具</p><p>初始化：创建一个空目录，然后以此目录作为工作目录启动命令行工具，执行<code>npm init</code>。</p><p><code>npm init</code>命令的作用是将文件夹初始化为一个包，交互式创建<code>package.json</code>文件，它是包的配置文件，每个包都必须要有<code>package.json</code>。</p><p>1.属性解释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm&quot;</span><span class="punctuation">,</span>                <span class="comment">//包的名字</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span>           <span class="comment">//包的版本</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span>           <span class="comment">//包的入口文件</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>                  <span class="comment">//脚本配置</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>                 <span class="comment">//作者</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span>             <span class="comment">//开源证书</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span>             <span class="comment">//包的描述</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>初始化过程中注意事项：</p><ul><li><code>package name</code>不能使用中文、大写，默认值是文件夹的名称，所以文件夹名称也不能使用中文和大写</li><li><code>version</code>要求<code>x.x.x</code>的形式定义，x必须是数字，默认值是<code>1.0.0</code></li><li><code>package.json</code>开源手动创建与修改</li><li>使用<code>npm init -y</code>或者<code>npm init --yes</code>极速创建<code>package.json</code></li></ul></blockquote><p>2.生产环境与开发环境</p><p>开发环境是程序员专门用来写代码的环境，一般是指程序员的电脑，开发环境的项目一般<code>只能程序员自己自己访问</code></p><p>生产环境是项目代码正式运行的环境，一般是指正式的服务器电脑，生产环境的项目一般<code>每个客户都可以访问</code></p><p>3.生产依赖与开发依赖</p><p>可以在安装时设置选项来区分<code>依赖的类型</code>，如：</p><table><thead><tr><th align="center">类型</th><th align="center">命令</th><th align="center">补充</th></tr></thead><tbody><tr><td align="center">生产依赖</td><td align="center">npm i -S uniq</td><td align="center">-S等效于–save，-S是默认选项</td></tr><tr><td align="center">开发依赖</td><td align="center">npm i -D less</td><td align="center">-D等效于–save-dev</td></tr></tbody></table><p>其中生产依赖的包信息保存在package.json中<code>dependencies</code>属性，开发依赖保存的包信息保存在package.json中的<code>devDependencies</code>属性</p><p>生产依赖是指这个依赖即在开发阶段使用，也在最终的运行当中使用</p><p>开发依赖是指这个依赖只在开发阶段使用，过了开发阶段就没有用了</p><p>4.全局安装</p><p>上面介绍的是局部安装，即只能在打开终端的那个文件夹下使用。可以执行安装选项<code>-g</code>进行全局安装，如<code>npm i -g nodemon</code>，全局安装完成之后就可以在命令行的任何位置运行nodemon命令了。这个命令的作用是<code>自动重启node应用程序</code></p><p>说明：</p><ul><li>可以通过<code>npm root -g</code>查看全局安装包的位置</li><li>不是所有的包都适合全局安装，只有全局类的工具才适合，可以通过查看包的官方文档来确定安装方式。</li></ul><p>5.安装包依赖</p><p>在项目协作中有一个常用的命令就是<code>npm i</code>，通过该命令可以依据<code>package.json</code>和<code>package-lock.json</code>的依赖声明安装项目依赖</p><blockquote><p><code>node_modules</code>文件夹大多数情况都不会存入版本库，因为当一个项目很大时，会用到很多的依赖包，而项目的依赖包都存在<code>node_modules</code>文件夹中，如果将该项目上传到Git，其他人下载时就会很麻烦。所以就可以下载除了<code>node_modules</code>文件夹的其它所有文件，然后通过<code>npm i</code>来下载项目所需要的依赖。</p></blockquote><p>6.安装指定的包和删除依赖</p><p>如果当前包的版本不匹配，或要安装指定版本的包，可以通过<code>npm i &lt;包名@版本号&gt;</code>，如<code>npm i jquery@1.11.2</code></p><p>删除依赖包可以使用：</p><ul><li>局部删除：npm remove 包名或者npm r 包名</li><li>全局删除：npm remove -g 包名</li></ul><p>7.配置命名别名</p><p>通过配置命名别名可以更简单的执行命令，如在package.json中的scripts属性中有如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node server.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">.....</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>配置完之后，可以使用别名执行命令，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run server           <span class="comment">//执行的是node server.js</span></span><br><span class="line">npm run start            <span class="comment">//执行的是node index.js</span></span><br></pre></td></tr></table></figure><p>不过<code>start</code>别名比较特别，使用时可以省略，如<code>npm start</code></p><h2 id="8-3-npm配置淘宝镜像"><a href="#8-3-npm配置淘宝镜像" class="headerlink" title="8.3 npm配置淘宝镜像"></a>8.3 npm配置淘宝镜像</h2><p>用npm也可以使用淘宝镜像，配置的方式有两种</p><ul><li>直接配置</li><li>工具配置</li></ul><p>1.直接配置</p><p>执行如下命令即可完成配置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><p>2.工具配置(建议使用)</p><p>使用nrm配置npm的镜像地址<code>npm registry manager</code></p><ul><li>安装nrm：<code>npm i -g nrm</code></li><li>修改镜像：<code>nrm use taobao</code></li><li>检查是否配置成功(可选)，如果是<code>https://registry.npmmirror.com/</code>，则表名成功：<code>npm config list</code></li></ul><p>补充：查看支持的镜像地址：<code>nrm ls</code></p><p>然后就可以通过<code>nrm use 要使用的镜像</code>来切换镜像地址了，如切换为官方地址<code>nrm use npm</code></p><p>注意：淘宝镜像是只读的，只能下载，不能上传。比如说写好一个工具包，想要上传到npm去给其他人用，就需要切换为npm的官方地址才可以上传。</p><h2 id="8-4-管理发布包"><a href="#8-4-管理发布包" class="headerlink" title="8.4 管理发布包"></a>8.4 管理发布包</h2><p>1.创建与发布</p><p>可以将自己开发的工具包发布到npm服务上，方便自己和其他开发者使用，操作步骤如下：</p><ul><li>创建文件夹，并创建文件index.js，在文件中声明函数，使用module.exports暴露</li><li>npm初始化工具包，package.json填写包的信息(包的名字是唯一的)</li><li>注册账号<a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></li><li>激活账号(必须)—–&gt;填写验证码</li><li>修改为官方的官方镜像(命令行中运行nrm use npm)</li><li>命令行<code>npm login</code>填写相关用户信息</li><li>命令行下<code>npm publish</code>提交包</li></ul><p>2.更新包</p><p>后续可以对自己发布的包进行更新，操作如下：</p><ul><li>更新包中的代码</li><li>测试代码是否可用</li><li>修改package.json中的版本号(在原来基础上做++操作，相当于自己修改一次，也修改一次版本号)</li><li>发布更新<code>npm publish</code></li></ul><p>3.删除包</p><p>执行命令<code>npm unpublish --force</code>即可</p><blockquote><p>删除包需要满足的条件：</p><ul><li>要是包的作者</li><li>发布小于24小时</li><li>大于24小时后，没有其他包依赖，并且每周小于300下载量，并且只有一个维护者</li></ul></blockquote><p>4.nvm使用</p><p>下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases">Releases · coreybutler&#x2F;nvm-windows (github.com)</a>，选择<code>nvm-setup.exe</code>下载即可</p><p>常用的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>nvm list available</td><td>显示所有可以下载的Node.js版本</td></tr><tr><td>nvm list</td><td>显示已安装的版本</td></tr><tr><td>nvm install 18.12.1</td><td>安装18.12.1版本的Node.js</td></tr><tr><td>nvm install latest</td><td>安装最新版本的Node.js</td></tr><tr><td>nvm uninstall 18.12.1</td><td>删除某个版本的Node.js</td></tr><tr><td>nvm use 18.12.1</td><td>切换18.12.1版本的Node.js</td></tr></tbody></table><h1 id="9-express框架"><a href="#9-express框架" class="headerlink" title="9. express框架"></a>9. express框架</h1><p>express是一个基于Node.js平台的极简、灵活的WEB应用开发框架，官方网址：<a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></p><p>简单来说，express是一个封装好的工具包，本身是一个npm包，所以可以通过npm安装。express封装了很多功能，便于开发WEB应用(HTTP服务)。</p><h2 id="9-1-操作"><a href="#9-1-操作" class="headerlink" title="9.1 操作"></a>9.1 操作</h2><p>首先是先创建一个文件夹，在该文件夹下的终端执行&#96;npm init’，先生成一个包，然后执行npm i express，在该目录下下载express工具包，这样在该目录下就可以使用该工具包了。如下是程序程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//当浏览器把请求发送过来之后，如果请求的方法是get，并且请求url的路径是/home，就会执行后面的回调函数，用它来对浏览器响应结果</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1.express路由</p><p>路由确定了应用程序如何响应客户端对特定端点的请求。</p><p>一个路由的组成有<code>请求方法</code>、<code>路径</code>和<code>回调函数</code>组成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.get方法，路径为/home</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;网址首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//2.post方法，路径为/login</span></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;注册页面&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//3.匹配所有方法,路径为/test</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;test test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//4.404响应(当没有匹配成功路由时，执行该路由)</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;404 not Found&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.获取请求报文参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//原生操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">method</span>);               <span class="comment">//获取请求方式</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">url</span>);                  <span class="comment">//获取请求路径和key-value</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">httpVersion</span>);          <span class="comment">//获取http版本</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">headers</span>);              <span class="comment">//获取请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//express操作</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">path</span>);            <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);           <span class="comment">//获取key和value值，是用&#123;&#125;封装的</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">ip</span>);              <span class="comment">//获取ip</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="title function_">get</span>(<span class="string">&#x27;host&#x27;</span>));     <span class="comment">//获取ip和端口</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时，为了更加的灵活运用，也可以通过占位符的方式来作为路径。在如下程序中，浏览器的路径只要是<code>任意字符.html</code>都可以匹配成功路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/:id.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;    <span class="comment">//通过:id占位符来完成，浏览器只要是</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>.<span class="property">id</span>);         <span class="comment">//获取路径(这里的id要与上面的占位符名字一样)</span></span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3.响应设置</p><p>express框架封装了一些API来方便给客户端响应数据，并且兼容原生HTTP模块的获取方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/singer/:id.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//req是对请求报文的一个封装对象；res是响应报文的一个封装对象</span></span><br><span class="line">    <span class="comment">//原生响应</span></span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">404</span>;                <span class="comment">//状态码</span></span><br><span class="line">    res.<span class="property">statusMessage</span> = <span class="string">&#x27;love&#x27;</span>;          <span class="comment">//状态描述</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;yyy&#x27;</span>);         <span class="comment">//响应头</span></span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&#x27;hello express &#x27;</span>);         <span class="comment">//响应体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//express响应</span></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>);                     <span class="comment">//状态码</span></span><br><span class="line">    res.<span class="title function_">set</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>);               <span class="comment">//响应头</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;您好 express&#x27;</span>);             <span class="comment">//响应体</span></span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">500</span>).<span class="title function_">set</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>).<span class="title function_">send</span>(<span class="string">&#x27;这都是OK的&#x27;</span>);    <span class="comment">//也可以直接这样操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//express其他的响应方法</span></span><br><span class="line">    <span class="comment">//跳转响应</span></span><br><span class="line">    res.<span class="title function_">redirect</span>(<span class="string">&#x27;http://atguigu.com&#x27;</span>);          <span class="comment">//页面会跳转到http://atguigu.com网址去</span></span><br><span class="line">    <span class="comment">//下载响应</span></span><br><span class="line">    res.<span class="title function_">download</span>(__dirname + <span class="string">&#x27;/package.json&#x27;</span>);   <span class="comment">//会下载指定目录下的文件</span></span><br><span class="line">    <span class="comment">//JSON响应</span></span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;lxx&#x27;</span>,</span><br><span class="line">        <span class="attr">slogon</span>: <span class="string">&#x27;让天下没有难学的技术&#x27;</span></span><br><span class="line">    &#125;);       <span class="comment">//显示json内容</span></span><br><span class="line">    <span class="comment">//响应文件内容</span></span><br><span class="line">    res.<span class="title function_">sendFile</span>(__dirname + <span class="string">&#x27;/test.html&#x27;</span>);      <span class="comment">//会显示test.html的这个页面</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="9-2-express中间件"><a href="#9-2-express中间件" class="headerlink" title="9.2 express中间件"></a>9.2 express中间件</h2><p>中间件本质是一个回调函数，中间件函数可以像路由回调一样访问请求对象(request)，响应对象(response)。</p><p>中间件的作用：就是使用函数封装公共操作，简化代码</p><p>中间件的类型：</p><ul><li>全局中间件：就是指一个请求发过来后，这个全局中间件就会执行，执行完毕后才去执行路由回调。(每一个请求过来，全局中间件一定会执行)</li><li>路由中间件：就是指一个请求发过来后，路由中间件是和路由放在一起的，只有满足了某一个路由规则，它所对应的中间件才会去执行。</li></ul><p>1.全局中间件实现：当客户端通过浏览器访问该服务器时，会对应的记录它的url和ip，然后保保存到一个文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明一个中间件函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recoremiddleware</span>(<span class="params">req, res, next</span>)&#123; <span class="comment">//参数：请求报文对象；响应报文对象；内部函数，执行之后会指向后续的路由回调或者是中间件函数回调</span></span><br><span class="line">    <span class="comment">//获取url和ip</span></span><br><span class="line">    <span class="keyword">let</span> &#123;url, ip&#125; = req;</span><br><span class="line">    <span class="comment">//将信息保存再文件中access.log(通过追加的方式写入)</span></span><br><span class="line">    fs.<span class="title function_">appendFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./access.log&#x27;</span>), <span class="string">`<span class="subst">$&#123;url&#125;</span> <span class="subst">$&#123;ip&#125;</span>\r\n`</span>);  <span class="comment">//文件的路径；写入的内容。注意$要与反引号结合使用</span></span><br><span class="line">    <span class="comment">//调用next，它会去执行后续的回调函数，如路由回调</span></span><br><span class="line">    <span class="title function_">next</span>();              <span class="comment">//如果不执行这行，那么就只记录了，没有回应给客户端</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.使用中间件函数</span></span><br><span class="line">app.<span class="title function_">use</span>(recoremiddleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;后台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.路由中间件实现：当客户端通过浏览器发送请求后，先通过url来匹配执行哪个路由，当匹配完后，要执行中间件里面的代码，即判断有无携带<code>code=520</code>，如果有，就执行对应的路由回调；如果没有携带，就回应一个暗号错误。(防盗链可以用类似的方法实现)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3声明一个中间件函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recoremiddleware</span>(<span class="params">req, res, next</span>)&#123;</span><br><span class="line">   <span class="comment">//判断URL中是否code参数等于520</span></span><br><span class="line">   <span class="keyword">if</span>(req.<span class="property">query</span>.<span class="property">code</span> === <span class="string">&#x27;520&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;暗号错误&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/home&#x27;</span>,recoremiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;       <span class="comment">//对该路由设置了中间件</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin&#x27;</span>,recoremiddleware, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;      <span class="comment">//对该路由设置了中间件</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;后台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;*&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;404 Not Found&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9-3-处理静态资源的中间件"><a href="#9-3-处理静态资源的中间件" class="headerlink" title="9.3 处理静态资源的中间件"></a>9.3 处理静态资源的中间件</h2><blockquote><p>使用注意事项：</p><ul><li>index.html文件为默认打开的资源</li><li>如果静态资源与路由规则同时都匹配，谁先匹配，谁就响应</li><li>路由响应动态资源，静态资源中间件响应静态资源</li></ul></blockquote><p>当添加了静态资源中间件设置，再浏览器发送请求时，如果路径声明没有写(即&#x2F;)，服务端这边会先找index.html页面，即到public这个静态目录里面去找，找到了就读取内容，响应给浏览器。但如果路由规则也设置了&#x2F;，那么谁先匹配上，就执行谁(执行顺序从上到下)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态资源中间件设置，将当前文件夹下的public目录作为网站的根目录</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(__dirname + <span class="string">&#x27;/public&#x27;</span>));        <span class="comment">//当前这个目录中都是一些静态资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;前台首页&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.监听端口，启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务已经启动，端口3000正在监听中......&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比如说对应的public下有一个index.html文件，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#ADD8E6</span>; <span class="comment">/* 浅蓝色 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span>青春不常在，抓紧谈恋爱<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin: 0 auto; border: 1px solid #ccc; padding: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>生日：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择年份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1998<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1999<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2001<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择月份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>7<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>8<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>9<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>10<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择日--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第三行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>所在地区：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;中国上海&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第四行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>婚姻状况：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>未婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>已婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;marry&quot;</span> <span class="attr">id</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;three&quot;</span>&gt;</span>离婚<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第五行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>学历：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第六行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>喜欢的类型：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 妩媚的 </span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 可爱的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 性感的</span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;love&quot;</span>&gt;</span> 开朗的</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第七行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>个人介绍：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第八行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;免费注册&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第九行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span> 我同意注册条款和会员加入标准</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>我是会员，立即登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 第十一行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我承诺<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>年满18岁<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>抱着严肃的态度<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>真诚的寻找另一半<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/skills/2.png"></p><h2 id="9-4-EJS模板引擎"><a href="#9-4-EJS模板引擎" class="headerlink" title="9.4 EJS模板引擎"></a>9.4 EJS模板引擎</h2><p>模板引擎是分离<code>用户界面和业务数据</code>的一种技术，是一个高效的Javascript的模板引擎。</p><p>1.ejs普通渲染</p><p>创建一个文件夹，在文件夹的终端下执行<code>npm i ejs</code>，这样在该目录下就可以使用ejs工具包了。</p><p>先创建一个2-lxx.html文件，这里只是简单写了一行代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我爱你 &lt;%= china %&gt;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再创建一个js文件，来完成跨文件渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> china = <span class="string">&#x27;中国&#x27;</span>;</span><br><span class="line"><span class="comment">//声明变量(读取其它文件的内容)</span></span><br><span class="line"><span class="keyword">let</span> str = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./2-lxx.html&#x27;</span>).<span class="title function_">toString</span>(); <span class="comment">//读取2-lxx.html文件里面的内容,想要toString，不然是buffer类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ejs渲染</span></span><br><span class="line"><span class="keyword">let</span> result = ejs.<span class="title function_">render</span>(str, &#123;<span class="attr">china</span>:china&#125;);    <span class="comment">//对str进行一个解析，找到&lt;%=这些标识，然后把里面的内容替换为参2里面对应属性的value值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);            <span class="comment">//输出的是&lt;h2&gt;我爱你 中国&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure><p>2.ejs条件渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isLogin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用ejs渲染(这里也可以放到其它文件里，再调用)</span></span><br><span class="line"><span class="keyword">let</span> result = ejs.<span class="title function_">render</span>(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;% if(isLogin)&#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;欢迎回来&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125;else&#123; %&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;登录&lt;/button&gt; &lt;button&gt;登录&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="string">    `</span>, &#123;<span class="attr">isLogin</span>: isLogin&#125;);      <span class="comment">//对str进行一个解析，找到&lt;%=这些标识，然后把里面的内容替换为参2里面对应属性的value值</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);            <span class="comment">//输出的是&lt;h2&gt;我爱你 中国&lt;/h2&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-5-Express应用程序生成器"><a href="#9-5-Express应用程序生成器" class="headerlink" title="9.5 Express应用程序生成器"></a>9.5 Express应用程序生成器</h2><p>通过应用生成器工具express-generator可以快速创建一个应用的骨架。可以通过npx命令来运行Express应用程序生成器。</p><p>全局安装这个包：<code>npm install -g express-generator</code>。</p><p>创建骨架：<code>express -e generator</code>，-e表示添加ejs模板引擎的支持，generator表示文件夹的名称(将代码装到哪个文件夹下)。</p><p>在生成骨架的文件夹下，安装依赖：<code>npm i</code></p><p>启动服务端：<code>npm start</code></p><h2 id="9-6-案例实践-记账本"><a href="#9-6-案例实践-记账本" class="headerlink" title="9.6 案例实践-记账本"></a>9.6 案例实践-记账本</h2><p>首先是创建一个文件夹，在该文件夹下创建一个应用裤架：<code>express -e accounts</code></p><p>在accounts文件夹下安装依赖：<code>npm i</code></p><p>需要用到一个小型的数据库lowdb：<code>npm i lowdb@1.0.0</code></p><p>对每一个订单进行编号id，安装shortid：<code>npm i shortid</code></p><h1 id="10-API接口"><a href="#10-API接口" class="headerlink" title="10. API接口"></a>10. API接口</h1><h2 id="10-1-简介"><a href="#10-1-简介" class="headerlink" title="10.1 简介"></a>10.1 简介</h2><p>接口是前后端通信的桥梁，可以理解为一个接口就是服务中的一个路由规则，根据请求响应结果。这里所指的接口是<code>数据接口</code>，与编程语言(java、go等)中的接口语法不同。</p><p>接口的作用：实现前后端通信</p><p>接口的组成：请求方法、接口地址(URL)、请求参数、响应结果</p><h2 id="10-2-RESTful-API接口"><a href="#10-2-RESTful-API接口" class="headerlink" title="10.2 RESTful API接口"></a>10.2 RESTful API接口</h2><p><code>RESTful API</code>是一种特殊风格的接口，主要特点有如下几个：</p><ul><li><p>URL 中的路径表示 资源 ，路径中不能有动词 ，例如<code>create</code> , <code>delete</code> , <code>update</code>等这些都不能有</p></li><li><p>操作资源要与 <code>HTTP请求方法</code> 对应</p></li><li><p>操作结果要与<code>HTTP响应状态码</code>对应</p></li></ul><table><thead><tr><th align="center">操作</th><th align="center">请求类型</th><th align="center">URL</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">新增歌曲</td><td align="center">POST</td><td align="center">&#x2F;song</td><td align="center">返回新生成的歌曲信息</td></tr><tr><td align="center">删除歌曲</td><td align="center">DELETE</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回一个空文档</td></tr><tr><td align="center">修改歌曲</td><td align="center">PUT</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回更新后的歌曲信息</td></tr><tr><td align="center">修改歌曲</td><td align="center">PATCH</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回更新后的歌曲信息</td></tr><tr><td align="center">获取所有歌曲</td><td align="center">GET</td><td align="center">&#x2F;song</td><td align="center">返回歌曲列表数组</td></tr><tr><td align="center">获取单个歌曲</td><td align="center">GET</td><td align="center">&#x2F;song&#x2F;10</td><td align="center">返回单个歌曲信息</td></tr></tbody></table><h2 id="10-3-json-server"><a href="#10-3-json-server" class="headerlink" title="10.3 json-server"></a>10.3 json-server</h2><p>json-server本身是一个JS编写的工具包，可以快速搭建RESTful API服务</p><p>搭建临时的接口服务操作步骤：</p><p>1.全局安装<code>json-server</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="literal">-g</span> json<span class="literal">-server</span></span><br></pre></td></tr></table></figure><p>2.创建JSON文件(db.json)，编写基本结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;活着&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;余华&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;西游记&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;吴承恩&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;平凡的世界&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;路遥&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;songs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;知足&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;五月天&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;不能说的秘密&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;singer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;周杰伦&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3.以<code>JSON</code>文件所在文件夹作为工作目录，执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json<span class="literal">-server</span> <span class="literal">--watch</span> db.json</span><br></pre></td></tr></table></figure><p>完成过后，客户端(浏览器)就可以通过<code>http://127.0.0.1:3000/</code>后面加上路径来访问对应的数据了。</p><h1 id="11-会话控制"><a href="#11-会话控制" class="headerlink" title="11. 会话控制"></a>11. 会话控制</h1><h2 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介"></a>11.1 简介</h2><p>所谓会话控制就是对会话进行控制。HTTP是一种无状态的协议，它没有办法区分多次的请求是否来自于同一个客户端，无法区分用户，所以可以通过<code>会话控制</code>来解决该问题。</p><p>常见的会话控制技术有三种：</p><ul><li>cookie</li><li>session</li><li>token</li></ul><h2 id="11-2-cookie"><a href="#11-2-cookie" class="headerlink" title="11.2 cookie"></a>11.2 cookie</h2><p>cookie是HTTP服务器发送到用户浏览器并保存在本地的一小块数据，简单来说：</p><ul><li>cookie是保存在浏览器端的一小块数据</li><li>cookie是按照域名划分保存的</li></ul><p>示例：</p><table><thead><tr><th align="center">域名</th><th align="center">cookie</th></tr></thead><tbody><tr><td align="center"><a href="http://www.baidu.com/">www.baidu.com</a></td><td align="center">a&#x3D;100;b&#x3D;200</td></tr><tr><td align="center"><a href="http://www.bilibili.com/">www.bilibili.com</a></td><td align="center">xid&#x3D;1020abce121;hm&#x3D;112411213</td></tr><tr><td align="center">jd.com</td><td align="center">x&#x3D;100;ocw&#x3D;12414cce</td></tr></tbody></table><p>1.特点</p><p>浏览器向服务器发送请求时，会自动将<code>当前域名</code>下可用的cookie设置在请求头中，然后传递给服务器。这个请求头的名字也叫cookie，所以将cookie理解为一个HTTP的请求头也是可以的。</p><p>2.cookie运行流程</p><ul><li><p>浏览器这边会先把我们的账号密码等信息传递给服务器，服务器就会返回一个属于我们的cookie。注意的是，服务器是通过响应报文里面响应头为set-cookie传递给我们的。</p></li><li><p>当服务器返回一个我们的cookie后，浏览器就会将set-cookie后面的内容进行一个存储，于是就将cookie信息保存在我们当前这个域名的cookie下面。</p></li><li><p>当保存完毕之后，浏览器下次再向该服务器发送请求时，就会自动携带这个域名下面的cookie，然后传递给服务器。此时服务器就可以通过对这个信息的解析来得知请求的一个发送者，所以在返回结果时，就可以通过对应的发送者来响应对应的内容，这样就实现了用户的识别，实现了会话控制。</p></li></ul><h2 id="11-3-express框架使用cookie"><a href="#11-3-express框架使用cookie" class="headerlink" title="11.3 express框架使用cookie"></a>11.3 express框架使用cookie</h2><p>在一个文件夹下的终端通过<code>npm init</code>创建一个包的配置文件，再在该目录下通过<code>npm i express</code>安装express工具包。</p><p>1.设置和删除cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/set-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//res.cookie(&#x27;name&#x27;, &#x27;zhangsan&#x27;);            //会在浏览器关闭的时候销毁</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span>*<span class="number">1000</span>&#125;);     <span class="comment">//参3是设置生命周期，这里设置了存活1分钟(期间关闭浏览器也可以的)</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);                   <span class="comment">//这里又设置一个cookie</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/remove-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">clearCookie</span>(<span class="string">&#x27;name&#x27;</span>);                       <span class="comment">//删除cookie name</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;删除成功~~~&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>2.获取cookie</p><p>如果要在express框架中获取cookie，还需要通过<code>npm i cookie-parser</code>来下载工具包cookie-parser。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/set-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, &#123;<span class="attr">maxAge</span>: <span class="number">60</span>*<span class="number">1000</span>&#125;);        <span class="comment">//参3是设置生命周期，这里设置了存活1分钟(期间关闭浏览器也可以的)</span></span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;theme&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);                   <span class="comment">//这里又设置一个cookie</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/get-cookie&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">cookies</span>);                      <span class="comment">//获取cookie name</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`欢迎您 <span class="subst">$&#123;req.cookies.name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="11-4-session"><a href="#11-4-session" class="headerlink" title="11.4 session"></a>11.4 session</h2><p>session是保存在<code>服务器端的一块数据</code>，保存当前访问用户的相关消息。它的作用是实现会话控制，可以识别用户的身份，快速获取当前用户的相关消息。</p><p>1.session的运行流程</p><ul><li>用户提供自己的账号和密码传递给服务器，服务器接收到后会对其进行校验，检查填写的内容是否正确、与数据库里面的填写的内容是否匹配。如果填写没有问题，服务器会为当前的访问者创建一个对象，可以理解为是session对象。在这个对象里面会保存当前用户的一些基本信息，如用户名、用户id、用户邮箱等。除此之外，服务器端还会在这个对象当中生成一个独一无二的id标识，即session_id。</li><li>有了这个session对象之后，一方面服务器会将该对象存到session对象池里面(每个用户有了session对象之后都会被存到服务器那边的session对象池里面)，一方面会将这个id以响应cookie的形式返回给浏览器，浏览器接收到后就会将这个cookie信息保存起来。</li><li>有了cookie之后，以后再向服务器发送请求时，它就会带着cookie向服务器发送请求。服务器接收到该请求后，服务器就会从cookie里面把这个session_id取出来，取出来后就可以到session对象池里面去匹配寻找，即在存放session对象的容器里面去找，如果找到了跟这个session_id匹配的数据，就知道当前的用户是谁了。</li></ul><h2 id="11-5-express框架使用session"><a href="#11-5-express框架使用session" class="headerlink" title="11.5 express框架使用session"></a>11.5 express框架使用session</h2><p>在一个文件夹下的终端通过<code>npm init</code>创建一个包的配置文件，再在该目录下通过<code>npm i express</code>安装express工具包。</p><p>然后还需要安装两个工具包，终端执行命令：<code>npm i express-session connect-mongo</code>。</p><p>下面程序是session在express框架下的使用，同时结合了mongodb数据库来辅助观察存储的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">//引入模块 express-session connect-mongo</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&#x27;connect-mongo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 session 的中间件</span></span><br><span class="line"><span class="comment">//解释：app.use是设置中间件的，session是一个函数，接收一个对象类型的参数，返回一个函数</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;sid&#x27;</span>,       <span class="comment">//设置cookie的name，默认值是：connect.sid</span></span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;atguigu&#x27;</span>, <span class="comment">//参与加密的字符串（又称签名）</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">false</span>, <span class="comment">//是否为每次请求都设置一个cookie用来存储session的id</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">true</span>, <span class="comment">//是否在每次请求时重新保存session</span></span><br><span class="line">    <span class="attr">store</span>: <span class="title class_">MongoStore</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">mongoUrl</span>: <span class="string">&#x27;mongodb://127.0.0.1:27017/bilibili&#x27;</span> <span class="comment">//数据库的连接配置，将当前信息存储在mongodb里面的bilibili下面</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">cookie</span>: &#123;</span><br><span class="line">        <span class="attr">httpOnly</span>: <span class="literal">true</span>,      <span class="comment">// 开启后前端无法通过 JS 操作来访问cookie</span></span><br><span class="line">        <span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">60</span> <span class="comment">// 是控制后端sessionID和发送给浏览器的cookie的过期时间的，这里设置了1分钟</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">//首页，打开后即可完成在mongodb数据库中的bilibili下创建一个session数据库</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;home&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加cookie，在url输入username=admin&amp;password=admin即可完成得到session_id，它会存储在数据库中</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//username=admin&amp;password=admin</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">query</span>.<span class="property">username</span> === <span class="string">&#x27;admin&#x27;</span> &amp;&amp; req.<span class="property">query</span>.<span class="property">password</span> === <span class="string">&#x27;admin&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//设置session信息</span></span><br><span class="line">        req.<span class="property">session</span>.<span class="property">username</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">        req.<span class="property">session</span>.<span class="property">uid</span> = <span class="string">&#x27;258aefccc&#x27;</span>;</span><br><span class="line">        <span class="comment">//成功响应</span></span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;登录失败~~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//session读取</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/cart&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//检测session是否存在用户数据</span></span><br><span class="line">    <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">username</span>)&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">`购物车页面，欢迎您 <span class="subst">$&#123;req.session.username&#125;</span>`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;您还没有登录~~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//session销毁,从数据库中也销毁了该信息</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    req.<span class="property">session</span>.<span class="title function_">destroy</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;退出成功~~~&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="11-6-session和cookie的区别"><a href="#11-6-session和cookie的区别" class="headerlink" title="11.6 session和cookie的区别"></a>11.6 session和cookie的区别</h2><p>cookie和session的区别主要在于如下几点：</p><ol><li><p>所在的位置</p><ul><li>cookie：浏览器端</li><li>session：服务端</li></ul></li><li><p>安全性</p><ul><li>cookie是以明文的方式存放在客户端的，安全性相对较低</li><li>session存放于服务器中，所以安全性<code>相对</code>较好</li></ul></li><li><p>网络传输量</p><ul><li>cookie设置的内容过多会增大报文体积，会影响传输效率</li><li>session数据存储在服务器，只是通过cookie传递id，所以不影响传输效率</li></ul></li><li><p>存储限制</p><ul><li>浏览器限制单个cookie保存的数据不能超过4k，且单个域名下的存储数量也有限制</li><li>session数据存储在服务器中，所以没有这些限制</li></ul></li></ol><h2 id="11-7-token"><a href="#11-7-token" class="headerlink" title="11.7 token"></a>11.7 token</h2><p><code>token</code>是服务端生成并返回给HTTP客户端的一串加密字符串，<code>token</code>中保存着用户信息。它的作用是实现会话控制，可以识别用户的身份，主要用于移动端APP。</p><p>1.token的工作流程</p><ul><li>客户端将账号和密码通过请求发送给服务器，服务端检测了所提交的信息之后，如果没有问题，就会创建出token。创建好后，就会将该信息返回给客户端。</li><li>客户端收到服务器返回的token信息后，下次再发送请求时，客户端就会带着token传递给服务器，服务器就会对传来的token做校验，并且从token里面提取出用户的信息，继而识别用户的身份。</li></ul><blockquote><p>可以发现，token和cookie很像，cookie也是服务端校验用户的信息以后，将cookie返回给客户端，下次客户端发送请求时，再带着cookie给服务器。但它们之间也还是有一些区别的，cookie是自动携带的，而token是手动携带，比如说客户端给服务器发请求了，它得自己将token放在请求报文里面，然后再向服务器发请求。但cookie不是，当客户端要发送请求给服务器时，浏览器就会自动的将信息放在请求报文里面传递给服务器。</p></blockquote><p>2.token的特点</p><ul><li><p>服务端压力更小</p><ul><li>数据存储在客户端</li></ul></li><li><p>相对更安全</p><ul><li>数据加密</li><li>可以避免CSRF(跨站请求伪造)</li></ul></li><li><p>扩展性更强</p><ul><li>服务间可以共享</li><li>增加服务节点更简单</li></ul></li></ul><p>3.JWT</p><p>JWT是目前最流行的跨域认证解决方案，可用于基于token的身份验证。JWT是token的生成于校验更规范。</p><p>使用：在文件夹的终端通过<code>npm init</code>创建一个包的配置文件，再通过<code>npm i jsonwebtoken</code>下载jsonwebtoken工具包。</p><p>创建出一个token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入模块</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生成token -----&gt; let token = jwt.sign(用户数据，加密字符串，配置对象)</span></span><br><span class="line"><span class="keyword">let</span> token = jwt.<span class="title function_">sign</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;lixx&#x27;</span></span><br><span class="line">&#125;, <span class="string">&#x27;atguigu&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">60</span>,          <span class="comment">//token的声明周期，单位是秒</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(token);</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpeHgiLCJpYXQiOjE3MjY0NzMzNzcsImV4cCI6MTcyNjQ3MzQzN30.mrmErdIPfWz7lLEdZRXSQdV7F9HrtYJVEuEwFSzmad0</span><br></pre></td></tr></table></figure><p>验证token：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="string">&#x27;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpeHgiLCJpYXQiOjE3MjY0NzMzNzcsImV4cCI6MTcyNjQ3MzQzN30.mrmErdIPfWz7lLEdZRXSQdV7F9HrtYJVEuEwFSzmad0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证生成的token</span></span><br><span class="line">jwt.<span class="title function_">verify</span>(t, <span class="string">&#x27;atguigu&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;校验失败~~~&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果在指定的token生命周期里面执行上面的验证代码，都会出现如下信息：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; username: <span class="string">&#x27;lixx&#x27;</span>, iat: <span class="number">1726473377</span>, exp: <span class="number">1726473437</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Node.js是一个开源的，跨平台的JavaScript运行环境。通俗来讲，node.js就是一款应用程序，是一款软件，</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>c++全栈聊天项目</title>
    <link href="https://lxx93.online/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/"/>
    <id>https://lxx93.online/2024/09/03/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-09-03T07:34:24.000Z</published>
    <updated>2025-03-15T08:34:42.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本项目为c++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nodejs搭建验证服务，各服务间用grpc通信，server和client用asio通信等，也包括用户信息的录入等，实现跨平台设计，先设计windows的server，之后再考虑移植到linux中，较为全面的展示c++在实际项目中的应用。</p><p>1.在QT创建一个主界面：</p><p>新建—&gt;Application—&gt;Qt Widgets Application—&gt;项目名称为lxxchat—&gt;类名为MainWindow—&gt;基类为QMainWindow</p><p>2.创建一个登录的对话框：</p><p>新建—&gt;Qt—&gt;Qt设计师界面类—&gt;选择界面模板：Dialog without Buttons—&gt;类名为：LoginDialog</p><p>3.创建一个资源文件：</p><p>新建—&gt;Qt—&gt;Qt Resource File—&gt;名称为rc</p><p>4.创建一个注册的对话框</p><p>新建—&gt;Qt—&gt;Qt设计师界面类—&gt;选择界面模板：Dialog without Buttons—&gt;类名为：RegisterDialog</p><p>5.创建一个全局的文件</p><p>新建—&gt;c++—&gt;c++ Header File—&gt;名称为global.h</p><p>新建—&gt;c++—&gt;c++ Source File—&gt;名称为global.cpp</p><p>6.单例类的创建</p><p>新建—&gt;c++—&gt;c++ Header File—&gt;名称为singleton.h</p><p>7.创建一个Qt的Http发送的管理者类</p><p>新建—&gt;c++—&gt;c++class—&gt;类名为HttpMgr</p><p>8.定时按钮类</p><p>新建—&gt;c++,c++clase—&gt;类名为TimerBtn，基类为Custom</p><p>创建好后，令其继承QPushButton按钮类</p><p>将注册界面的获取按钮提升为TimerBtn，当点击该按钮后，就会触发TimerBtn重写的一些功能。</p><p>9.创建可点击的标签类ClickedLabel，用于密码和确认密码的隐藏和显示</p><p>新建—&gt;c++，c++clase—&gt;类名为ClickedLabel，基类为Custom(创建好后，继承基类QLabel)</p><p>将注册页面的两个label标签提升为ClickedLabel类</p><p>将登录界面的忘记密码按钮提升为ClickedLabel类</p><p>将ChatPage界面里面的emo_lb和file_lb两个label提升为可点击的ClickedLabel类</p><p>10.创建应该TCP管理者类</p><p>新建—&gt;c++，c++clase—&gt;类名为TcpMgr，基类为Custom(先不写，默认的)</p><p>11.创建聊天对话框</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为Dialog without Buttons—&gt;类名为ChatDialog</p><p>12.创建可点击的按钮类</p><p>新建—&gt;c++，c++clase—&gt;类名为ClickedBtn，基类为Custom(创建好后，继承基类QPushButton)</p><p>将聊天界面里面的add_btn按钮提升为ClickedBtn类</p><p>将ChatPage界面的receive_btn和send_btn提升为ClickedBtn类</p><p>13.创建自定义的输入框类</p><p>新建—&gt;c++，c++clase—&gt;类名为CustomizeEdit，基类为Custom(创建好后，继承基类QLineEdit)</p><p>将聊天界面里面的search_edit输入框提升为CustomizeEdit类</p><p>14.创建自定义的listwidget类</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatUserList，基类为Custom(创建好后，继承基类QListWidget)</p><p>将聊天界面里面的char_user_list框提升为ChatUserList类</p><p>15.创建用户窗口</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为widget—&gt;类名为ChatUserWid</p><p>创建好好继承ListItemBase类(自己写的)</p><p>16.创建控制item的基类ListItemBase</p><p>新建—&gt;c++，c++clase—&gt;类名为ListItemBase，基类为Custom(创建好后，继承基类QWidget)</p><p>17.创建加载内容的对话框</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为Dialog without Buttons—&gt;类名为LoadingDlg</p><p>18.创建聊天页类ChatPage</p><p>新建—&gt;Qt，Qt设计师界面类—&gt;界面模板为widget—&gt;类名为ChatPage</p><p>将聊天界面中QstackedWidget模块里面的chat_page提升为ChatPage类</p><p>19.创建聊天界面（主）</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatView，基类为Custom(创建好后，继承基类QWidget)</p><p>将聊天界面中的chat_data_list提升为ChatView</p><p>20.创建聊天界面框架(副)</p><p>新建—&gt;c++，c++clase—&gt;类名为ChatItemBase，基类为Custom(创建好后，继承基类QWidget)</p><p>21.创建聊天界面的气泡</p><p>新建—&gt;c++，c++clase—&gt;类名为BubbleFrame，基类为Custom(创建好后，继承基类QFrame)</p><p>22.创建气泡里面的文本</p><p>新建—&gt;c++，c++clase—&gt;类名为TextBubble，基类为Custom(创建好后，继承基类BubbleFrame)</p><p>23.常见气泡里面的图片</p><p>新建—&gt;c++，c++clase—&gt;类名为PictureBubble，基类为Custom(创建好后，继承基类BubbleFrame)</p><ol start="24"><li></li></ol><p>新建—&gt;c++，c++clase—&gt;类名为MessageTextEdit，基类为Custom(创建好后，继承基类QTextEdit)</p><p>将chatpage.ui里面的chatEdit提升为MessageTextEdit</p><p>25.创建StateWidget类</p><p>新建—&gt;c++，c++clase—&gt;类名为StateWidget，基类为Custom</p><hr><h1 id="2-网关服务器GateServer"><a href="#2-网关服务器GateServer" class="headerlink" title="2. 网关服务器GateServer"></a>2. 网关服务器GateServer</h1><p>网关服务器主要应答客户端基本的连接请求，包括根据服务器负载情况选择合适服务器给客户端登录、注册、获取验证服务等，接收http请求并应答。</p><p>1.绑定和监听连接(服务端)</p><p>利用visual studio创建一个空项目，项目名字为GateServer，然后按照之前的方法配置boost库和jsoncpp配置好后，我们添加一个新的类，名字叫CServer。添加成功后生成的CServer.h和CServer.cpp也会自动加入到项目中。</p><p>在<code>GateServer</code>项目中的逻辑：先是CServer启动，其启动后，就会监听连接。当对端有连接请求来之后，就交给<code>HttpConnection</code>类去管理，在这个类里面，它会先监听读事件，当对端有数据发来之后会触发读回调函数，在这个函数里面会处理读的请求<code>HandleReq()</code>，并且启动超时检测<code>CheckDeadline()</code>(检测发送是否超时)。其中在处理读请求<code>HandleReq()</code>函数中，会调用底层的<code>LogicSystem</code>逻辑层去处理请求，同时这里会把请求的<code>url</code>和<code>HttpConnection</code>对象的智能指针作为参数传过去。而在LogicSystem逻辑层类的<code>HandleGet</code>函数中，就是在map容器里面去找对应的url，如果之前没有注册过这个url，就会返回false，底层就会返回404错误；如果注册过，就会调用对应的回调(处理器)。</p><p>对应写回包就是写好响应头，然后准备对端请求的数据发送过去即可，如果在规定时间内写完发送给对端，在触发的写回调中就会把定时器取消，否则定时器会进行检测，超时的话它就会把socket强制关闭。</p><p>2.在Qt中添加客户端的配置文件config.ini</p><p>在QT的pro文件中需要添加如下程序：这段程序主要用于在<strong>Windows平台</strong>的调试模式(<code>debug</code>配置)下，将配置文件(如<code>config.ini</code>)从工程目录拷贝到输出目录。可以这样理解，你的Qt程序需要使用<code>config.ini</code>配置文件来读取网络设置、数据库连接信息等。当你在调试时，程序从<code>debug</code>目录运行，而这个目录默认情况下并不包含<code>config.ini</code>。该脚本自动将配置文件从项目的根目录拷贝到<code>debug</code>目录，确保程序运行时可以正确找到配置文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">win32:<span class="built_in">CONFIG</span>(debug, debug | release)</span><br><span class="line">&#123;</span><br><span class="line">    #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\QT\Test</span><br><span class="line">    #PWD就为D:/QT/Test，DllFile = D:/QT/Test/release<span class="comment">/*.dll</span></span><br><span class="line"><span class="comment">    TargetConfig = $$&#123;PWD&#125;/config.ini</span></span><br><span class="line"><span class="comment">    #将输入目录中的&quot;/&quot;替换为&quot;\&quot;</span></span><br><span class="line"><span class="comment">    TargetConfig = $$replace(TargetConfig, /, \\)</span></span><br><span class="line"><span class="comment">    #将输出目录中的&quot;/&quot;替换为&quot;\&quot;</span></span><br><span class="line"><span class="comment">    OutputDir =  $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125;</span></span><br><span class="line"><span class="comment">    OutputDir = $$replace(OutputDir, /, \\)</span></span><br><span class="line"><span class="comment">    //执行copy命令</span></span><br><span class="line"><span class="comment">    QMAKE_POST_LINK += copy /Y \&quot;$$TargetConfig\&quot; \&quot;$$OutputDir\&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>3.创建一个获取验证码的grpc客户端VerifyGrpcClient：</p><p>先定义一个message.proto文件，这是一种用于定义结构化数据的序列化协议，常用于远程过程调用(RPC)系统或者消息格式的定义。代码定义了一个服务和两个消息，用于实现一个获取验证码的接口。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;        <span class="comment">//定义了Protobuf的语法版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> message;   <span class="comment">//定义了包名为message。包名在Protobuf中用于组织代码，避免命名冲突。不同的包中的服务和消息不会互相冲突。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务定义，这个服务叫做VarifyService，代表一个远程服务，用于提供某种功能。在这个服务中定义了一个RPC(远程过程调用)方法。</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">VarifyService</span> &#123;</span><br><span class="line"><span class="comment">//d定义一个rpc方法，方法名是GetVarifyCode， 输入是GetVarifyReq，输出是GetVarifyRsp，</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> GetVarifyCode (GetVarifyReq) <span class="keyword">returns</span> (GetVarifyRsp) </span>&#123;&#125;  <span class="comment">//当客户端调用GetVarifyCode时，会发送GetVarifyReq请求，服务端将返回GetVarifyRsp响应</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了消息结构体GetVarifyReq(发送请求时提供的参数)</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetVarifyReq</span> &#123;</span><br><span class="line"><span class="comment">//email是一个字符串字段，表示请求中用户提供的邮件。1是这个字段的标识符，用于在序列化和反序列化时识别字段，其在整个消息定义中是唯一的。</span></span><br><span class="line"><span class="type">string</span> email = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了响应消息体GetVarifyRsp(需要回复的参数)</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetVarifyRsp</span> &#123;</span><br><span class="line"><span class="type">int32</span> error = <span class="number">1</span>;      <span class="comment">//32位的整数字段，表示错误代码</span></span><br><span class="line"><span class="type">string</span> email = <span class="number">2</span>;     <span class="comment">//字符串字段，表示服务器返回的邮件</span></span><br><span class="line"><span class="type">string</span> code = <span class="number">3</span>;      <span class="comment">//字符串字段，表示服务器生成的验证码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是在message.proto所在文件夹的powershell上执行如下命令，利用grpc编译后生成的proc.exe来生成proto的grpc的头文件和源文件。即会生成message.grpc.pb.cc和message.grpc.pb.h文件，这两个文件里面保存了grpc通信的接口。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe  <span class="literal">-I</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--grpc_out</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--plugin</span>=protoc<span class="literal">-gen-grpc</span>=<span class="string">&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</span> <span class="string">&quot;message.proto&quot;</span></span><br></pre></td></tr></table></figure><p>对于通信的接口所使用的参数需要通过以下命令来生成，即会得到message.pb.cc和message.pb.h文件，这两个文件保存了通信使用的参数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe <span class="literal">--cpp_out</span>=. <span class="string">&quot;message.proto&quot;</span></span><br></pre></td></tr></table></figure><p>4.添加一个查询状态的grpc客户端StatusGrpcClient</p><h1 id="3-认证服务"><a href="#3-认证服务" class="headerlink" title="3. 认证服务"></a>3. 认证服务</h1><p>认证服务要给邮箱发送验证码，所以用nodejs较为合适，nodejs是一门IO效率很高而且生态完善的语言，用到发送邮件的库也方便。</p><p>1.初始化node.js项目的一个配置文件：在VarifyServer文件夹下打开PowerShell终端执行<code>npm init</code>，然后一路点击回车即可。</p><p>2.安装grpc-js包，也可以安装grpc，grpc是C++版本，grpc-js是js版本，C++版本停止维护了。所以用grpc-js版本。</p><p>在VarifyServer文件夹的PowerShell终端下执行<code>npm install @grpc/grpc-js</code>。</p><p>3.安装proto-loader用来动态解析proto文件，在PowerShell终端下继续执行<code>npm install @grpc/proto-loader</code>。</p><p>4.安装email处理的库，在PowerShell终端下继续执行<code>npm install nodemailer</code>。</p><p>5.启动程序：npm run serve</p><p>81.68.86.146</p><p>流程：</p><p>用Qt编写了一个client，它会把请求(获取验证码)给到visual Studio编写的服务端GateServer，而GateServer会调用grpc，把请求投递给验证服务Varify，验证服务就会调用邮箱服务，该邮箱是各个平台提供的邮箱接口API，调用该API，发送到指定的邮箱里。如果发送成功了，邮箱接口API还会把成功的请求告诉验证服务Varify，验证服务也就会通过grpc服务把这个发送成功的请求回复给GateServer。当然不管成功还是失败，GateServer得到结果后都会发送给Qt那边的客户端。</p><h1 id="4-设置验证码过期"><a href="#4-设置验证码过期" class="headerlink" title="4. 设置验证码过期"></a>4. 设置验证码过期</h1><p>验证码是要设置过期的，可以用redis管理过期的验证码自动删除，key为邮箱，value为验证码，过期时间为3min。</p><h2 id="4-1-redis服务搭建"><a href="#4-1-redis服务搭建" class="headerlink" title="4.1 redis服务搭建"></a>4.1 redis服务搭建</h2><p>1.在Redis-x64-5.0.14.1文件夹下的redis.windows.conf文件中处理如下：</p><p>修改端口：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br></pre></td></tr></table></figure><p>添加requirepass</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure><p>2.启动redis服务器(在Redis-x64-5.0.14.1目录下)：<code>.\redis-server.exe .\redis.windows.conf</code></p><p><img src="/.online//Users\PC\Desktop\聊天项目\1.png"></p><p>3.启动客户端并输入密码：</p><p><img src="/.online//Users\PC\Desktop\聊天项目\2.png"></p><p>4.widows编译和配置redis(很麻烦，省略)</p><h2 id="4-2-VerifyServer增加redis"><a href="#4-2-VerifyServer增加redis" class="headerlink" title="4.2 VerifyServer增加redis"></a>4.2 VerifyServer增加redis</h2><h2 id="4-3-mysql"><a href="#4-3-mysql" class="headerlink" title="4.3 mysql"></a>4.3 mysql</h2><p>1.在C:\cppsoft\mysql\mysql\bin目录下打开cmd输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装mysql,安装完成后Mysql会有一个随机密码</span><br><span class="line">.\mysqld.exe <span class="literal">--initialize</span> <span class="literal">--console</span></span><br></pre></td></tr></table></figure><p>得到如下图，随机密码要记住，以后我们改密码会用到</p><p><img src="/.online//Users\PC\Desktop\聊天项目\3.png"></p><p>2.在C:\cppsoft\mysql\mysql\bin目录下以管理员身份打开cmd输入以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//安装mysql服务并启动   </span><br><span class="line">.\mysqld.exe <span class="literal">--install</span> mysql</span><br></pre></td></tr></table></figure><p>3.修改mysql密码</p><p>首先是在本机启动mysql服务：电脑搜索服务，找到mysql，启动它。</p><p>然后在C:\cppsoft\mysql\mysql\bin目录下打开终端，执行命令：<code>.\mysql -uroot -p</code>，进入后先填写原始密码，上面保留那个</p><p>然后执行改命令，进行修改密码：<code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></p><p>4.配置环境变量</p><p>新建系统变量：</p><ul><li><p>变量名：MYSQL_HOME</p></li><li><p>变量值：自己的msql目录(C:\cppsoft\mysql)</p></li></ul><p>修改系统的path变量：点击编辑path，进去后添加 %MYSQL_HOME%\bin</p><h1 id="5-状态服务器StatusServer"><a href="#5-状态服务器StatusServer" class="headerlink" title="5.状态服务器StatusServer"></a>5.状态服务器StatusServer</h1><h1 id="6-ChatServer类"><a href="#6-ChatServer类" class="headerlink" title="6.ChatServer类"></a>6.ChatServer类</h1><p>长连接的流程：客户端想要登录，首先需要将登录请求发给GataServer服务器，GataServer就去StatusServer服务器上去查询，如果校验没有任何问题的话，它就会分配一个ip和token，给到GataServer服务器，GataServer就会把这个消息给到客户端。客户端就会利用这个ip和token来登录，ChatServer服务器会验证这个ip和token(去StatusServer服务器上查询)，以及该用户的一些信息，如果都没有问题，它就会让其登录，返回一个rsp回包，这样客户端就和ChatServer服务器建立了连接，后续客户端需要发的信息内容，就可以发给ChatServer服务器。</p><p><img src="/.online//Users\PC\Desktop\聊天项目\4.png"></p><h1 id="7-usermgr类"><a href="#7-usermgr类" class="headerlink" title="7. usermgr类"></a>7. usermgr类</h1><h1 id="8-流程"><a href="#8-流程" class="headerlink" title="8.流程"></a>8.流程</h1><p>1.主窗口<code>mainwindow</code>(创建登录界面对象)展示登录界面<code>logindialog</code>。  mainwindow —–&gt; logindialog</p><p>2.登录界面<code>logindialog</code>点击注册按钮，发出信号switchRegister，主窗口<code>mainwindow</code>接收。 loginwindow —–&gt; mainwindow                     </p><p>3.主窗口<code>mainwindow</code>接收信号switchRegister，执行槽函数SlotSwitchReg(创建注册界面对象)，展示注册界面<code>registerdialog</code>。mainwindow —–&gt; registerdialog</p><p>4.注册界面registerdialog点击获取按钮(检查邮箱格式)，发送请求获取验证码(调用http管理者<code>httpmgr</code>的发送请求接口)。</p><p>5.注册界面<code>registerdialog</code>点击确定按钮执行槽函数on_sure_btn_clicked，检查输入框的内容，没有问题就发送请求注册用户(调用http管理者<code>httpmgr</code>的发送请求接口)。</p><p>6.管理者<code>httpmgr</code>执行完异步发送请求后(向网关服务器GateServer发送请求)，等待回复，收到回复后，无论成功与否，都发出信号sig_http_finish(附带请求模块)，由自己接收处理。          httpmgr —–&gt; httpmgr</p><p>7.管理者<code>httpmgr</code>收到回复成功信号后，执行槽函数slot_http_finish，根据不同请求，都发出信号sig_login_mod_finish(附带请求模块)</p><p>8.注册界面<code>registerdialog</code>根据接收的信号sig_login_mod_finish，会通过不同的id执行相应的函数对象(注册界面初始化时就注册进去的)，比如说有获取验证码的id、注册用户的id。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;本项目为c++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nod</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://lxx93.online/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lxx93.online/2024/08/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-08-29T07:34:24.000Z</published>
    <updated>2024-09-16T15:46:09.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-设计模式三原则"><a href="#1-设计模式三原则" class="headerlink" title="1. 设计模式三原则"></a>1. 设计模式三原则</h1><p>在进行程序设计的时候，要尽可能地保证程序的可扩展性、可维护性和可读性，所以需要使用一些设计模式，这些设计模式都遵循了以下三个原则。</p><h2 id="1-1-单一职责原则"><a href="#1-1-单一职责原则" class="headerlink" title="1.1 单一职责原则"></a>1.1 单一职责原则</h2><p>C++面向对象三大特性之一的<code>封装</code>指的就是将单一事物抽象出来组合成一个类，所以我们在设计类的时候每个类中处理的是单一事物而不是某些事物的集合。</p><p>设计模式中所谓的单一职责原则：就是对一个类而言，应该仅有一个引起它变化的原因，其实就是将这个类所承担的职责单一化。</p><h2 id="1-2-开放封闭原则"><a href="#1-2-开放封闭原则" class="headerlink" title="1.2 开放封闭原则"></a>1.2 开放封闭原则</h2><p>开放封闭原则：指的是软件实体(类、模块、函数等)可以扩展，但是不可以修改。也就是说对于扩展是开放的，对于修改是封闭的。</p><p>开放封闭原则是面向对象设计的核心所在，这样可以给我们设计出的程序带来巨大的好处，使其可维护性、可扩展性、可复用性、灵活性更好。</p><h2 id="1-3-依赖倒转原则"><a href="#1-3-依赖倒转原则" class="headerlink" title="1.3 依赖倒转原则"></a>1.3 依赖倒转原则</h2><p>关于依赖倒转原则，对应的是两条非常抽象的描述：</p><ul><li>高层模块不应该依赖低层模块，两个都应该依赖抽象。<ul><li>高层模块：可以理解为上层应用，就是业务层的实现</li><li>低层模块：可以理解为底层接口，比如封装好的API、动态库等</li><li>抽象：指的就是抽象类或者接口，在C++中没有接口，只有抽象类</li></ul></li><li>抽象不应该依赖细节，细节应该依赖抽象。<ul><li>里氏代换原则：就是子类类型必须能够替换掉它们的父类类型。</li></ul></li></ul><h1 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2. 单例模式"></a>2. 单例模式</h1><p>在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫<code>单例模式</code>。单例模式的典型应用就是任务队列。</p><p>在实现一个单例模式的类的时候，有两种处理模式：</p><ul><li>饿汉模式</li><li>懒汉模式</li></ul><h2 id="2-1-饿汉模式"><a href="#2-1-饿汉模式" class="headerlink" title="2.1 饿汉模式"></a>2.1 饿汉模式</h2><p>饿汉模式：定义类的时候就创建了单例实例，创建出来后，什么时候用，时候什么就调用静态的成员函数(得到单例对象)。</p><p>缺点：浪费空间</p><p>优点：在多线程的场景下，饿汉模式是没有线程安全问题的(多线程可以同时访问这个单例的对象)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;      <span class="comment">//通过类名来得到的对象是静态的，通过类名访问类里面的属性和方法，这个属性和方法是静态的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//堵死在外部创建对象的方法,防止通过拷贝构造或赋值操作来创建多个实例</span></span><br><span class="line"><span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;                   <span class="comment">//删除了拷贝构造函数</span></span><br><span class="line">TaskQueue&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;      <span class="comment">//赋值运算符重载函数</span></span><br><span class="line"><span class="comment">//静态的公共成员函数，把唯一的单例对象返回给调用者</span></span><br><span class="line"><span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_taskQ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是单例对象的一个成员函数...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;    <span class="comment">//定义了一个无参构造，它与默认的无参构造具有相同的行为</span></span><br><span class="line"><span class="comment">//TaskQueue(const TaskQueue&amp; t) = default;</span></span><br><span class="line"><span class="comment">//TaskQueue&amp; operator = (const TaskQueue&amp; t) = default;</span></span><br><span class="line"><span class="comment">//只能通过类名访问静态属性或方法</span></span><br><span class="line"><span class="type">static</span> TaskQueue* m_taskQ;      <span class="comment">//该静态成员指针只能通过静态成员方法访问</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;   <span class="comment">//类的作用域下，可以访问类的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-懒汉模式"><a href="#2-2-懒汉模式" class="headerlink" title="2.2 懒汉模式"></a>2.2 懒汉模式</h2><p>懒汉模式：什么时候使用这个单例对象，在使用的时候再去创建对应的实例。</p><p>优点：节省空间</p><p>缺点：在多线程的场景下，懒汉模式是有线程安全问题的(若干个线程同时访问单例的实例，会出问题)。</p><ul><li>解决办法：通过互斥锁，阻塞线程，依次访问这个单例对象，就可以避免在懒汉模式下，多线程同时访问单例对象而创建出多了类的实例这种问题</li></ul><p>双重检查锁定：如果没有第9行的判断，该方法对程序执行的效率就很低，因为不管什么时候，多个线程在访问单例对象的时候(执行getInstance()函数)，都是顺序访问的。但通过双重检查锁定可以解决这个问题，只有第一次的时候，多个线程是线性访问，当后面再访问该函数时(m_taskQ指针被实例化处理之后)，多个线程就是并行访问了，因为第9行代码判断为false，直接返回该实例对象即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (m_taskQ == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;       <span class="comment">//像这种不需要初始化的，也需要在外部进行申明，因为它是静态的成员</span></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;       <span class="comment">//开始先置为空，什么时候使用，什么时候就实例化对象出来</span></span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>上面程序第14行代码对应的机器指令有3条，第1条是创建一块内存(无数据)；第2条是创建TaskQueue对象，并吧数据写入到创建的内存里面；第3条是将创建的有效地址传给m_taskQ指针。在底层执行程序的时候，可能会对这些指令做重排，就有可能是执行的顺序是132，在还没有执行第2条时，就先将内存地址传给了指针，这时的指针不为空，但没有TaskQueue对象，同一时刻的其它线程调用该函数就会直接返回指针使用，就造成了系统崩溃。所以下面可以通过原子变量来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;</span><br><span class="line">TaskQueue&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//静态的公共成员函数，把唯一的单例对象返回给调用者</span></span><br><span class="line"><span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TaskQueue* task = m_taskQ.<span class="built_in">load</span>();     <span class="comment">//从原子变量里面加载这个任务队列的实例</span></span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">nullptr</span>) &#123;     <span class="comment">//通过双重检查锁定来避免访问效率低的情况(顺序访问)</span></span><br><span class="line">m_mutex.<span class="built_in">lock</span>();                 <span class="comment">//加锁</span></span><br><span class="line">task = m_taskQ.<span class="built_in">load</span>();          <span class="comment">//通过原子变量加载实例对象</span></span><br><span class="line"><span class="keyword">if</span> (task == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">task = <span class="keyword">new</span> TaskQueue;   <span class="comment">//使用时创建，创建单例实例---&gt;底层指执行这句话的顺序不一样(对应底层3条语句)--&gt;需要用原子变量进行管理</span></span><br><span class="line">m_taskQ.<span class="built_in">store</span>(task);        <span class="comment">//将创建的实例存储起来，保存在原子变量内部</span></span><br><span class="line">&#125;</span><br><span class="line">m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是单例对象的一个成员函数...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;    <span class="comment">//定义了一个无参构造，它与默认的无参构造具有相同的行为</span></span><br><span class="line"><span class="type">static</span> mutex m_mutex;           <span class="comment">//静态变量互斥锁---&gt;需要在类的外面进行一个声明</span></span><br><span class="line"><span class="type">static</span> atomic&lt;TaskQueue*&gt;m_taskQ;         <span class="comment">//通过原子变量把类的实例对象保存起来，保存到了指针里面</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line"><span class="comment">//TaskQueue* TaskQueue::m_taskQ = nullptr;</span></span><br><span class="line">atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;   <span class="comment">//</span></span><br><span class="line">mutex TaskQueue::m_mutex;</span><br></pre></td></tr></table></figure><p>当然，也可以使用静态的局部对象解决线程安全问题。</p><h1 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3. 工厂模式"></a>3. 工厂模式</h1><h2 id="3-1-简单工厂模式"><a href="#3-1-简单工厂模式" class="headerlink" title="3.1 简单工厂模式"></a>3.1 简单工厂模式</h2><p>下面程序就是<code>简单工厂模式</code>实现的例子，首先创建一个产品类作为父类，里面只需要定义一些虚函数即可，供子类继承实现。然后创建一个工厂类，里面实现父类指针指向子类对象，以达到多态的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产品类的父亲 ---&gt; 人造恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSmile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ability</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractSmile</span>() &#123;&#125;    <span class="comment">//虚的析构函数，可以完全清除子类的内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 山羊人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将手臂变成绵羊角的招式--巨羊角&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 狮子人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;火遁 -- 豪火球之术...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 蝙蝠人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;声纳-引剑之万归宗...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义工厂类</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span> :<span class="type">char</span> &#123;Sheep,Lion,Bat&#125;; <span class="comment">//定义了一个枚举类(enum class)Type，并指定了其基础类型为 char。在这个枚举类中，有三个枚举常量：Sheep、Lion和Bat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmileFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">(Type type)</span></span>&#123;     <span class="comment">//父类指针指向了子类对象，实现多态</span></span><br><span class="line">AbstractSmile* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> Type::Sheep:</span><br><span class="line">ptr = <span class="keyword">new</span> SheepSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Type::Lion:</span><br><span class="line">ptr = <span class="keyword">new</span> LionSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Type::Bat:</span><br><span class="line">ptr = <span class="keyword">new</span> BatSmile;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">SmileFactory factory;      <span class="comment">//创建一个工厂对象</span></span><br><span class="line">AbstractSmile* obj = factory.<span class="built_in">createSmile</span>(Type::Lion);</span><br><span class="line">obj-&gt;<span class="built_in">transform</span>();</span><br><span class="line">obj-&gt;<span class="built_in">ability</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-工厂模式"><a href="#3-2-工厂模式" class="headerlink" title="3.2 工厂模式"></a>3.2 工厂模式</h2><p>在上面的简单工厂模式中是只创建了一个工厂类，用于生产需要的对象，但是这种方式有一个弊端，它违反了设计模式中的开放封闭原则，即如果想要生成更多的人造恶魔果实，那么就需要在工厂函数的switch语句中添加更多的case，很明显这违背了封闭原则。所以我们可以使用工厂模式很完美的解决上述的问题。总的来说，就是简单工厂模式是只有一个工厂类，而工厂模式是有很多的工厂类：</p><ul><li>一个基类，包含一个虚工厂函数，用于实现多态。</li><li>多个子类，重写父类的工厂函数。每个子工厂类负责生产一种恶魔果实，这相当于再次解耦，将工厂类的职责再次拆分、细化，如果要生产新品种的恶魔果实，那么只需要添加对应的工厂类，无需修改原有的代码。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂模式相对于简单工厂模式来说，对类的扩展更方便了</span></span><br><span class="line"><span class="comment">//产品类的父亲 ---&gt; 人造恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSmile</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transform</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ability</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractSmile</span>() &#123;&#125;    <span class="comment">//虚的析构函数，可以完全清除子类的内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 山羊人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将手臂变成绵羊角的招式 -- 巨羊角&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 狮子人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;火遁 -- 豪火球之术...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatSmile</span> :<span class="keyword">public</span> AbstractSmile &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;变成人兽 -- 蝙蝠人形态...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ability</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;声纳-引剑之万归宗...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义工厂类 --- 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;       <span class="comment">//抽象类(虚工厂)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产山羊的恶魔果实(通过子工厂来继承虚工厂)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;      <span class="comment">//父类指针指向子类对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SheepSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">SheepFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;SheppFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产狮子的恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LionFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LionSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">LionFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;LionFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产蝙蝠的恶魔果实</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BatFactory</span> : <span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">AbstractSmile* <span class="title">createSmile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BatSmile;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">BatFactory</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BatFactory被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//AbstractFactory factory;    //AbstractFactory是抽象类了，不能这样实例化一个抽象类</span></span><br><span class="line">AbstractFactory* factory = <span class="keyword">new</span> LionFactory;      <span class="comment">//父类指针指向子类对象</span></span><br><span class="line">AbstractSmile* obj = factory-&gt;<span class="built_in">createSmile</span>();     <span class="comment">//同样也是父类指针指向子类对象，factory执行的函数是子类对象重写的</span></span><br><span class="line">obj-&gt;<span class="built_in">transform</span>();</span><br><span class="line">obj-&gt;<span class="built_in">ability</span>();</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line"><span class="keyword">delete</span> factory;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-抽象工厂模式"><a href="#3-3-抽象工厂模式" class="headerlink" title="3.3 抽象工厂模式"></a>3.3 抽象工厂模式</h2><p><code>抽象工厂模式</code>适用于比较复杂的多变的业务场景，总体上就是给一系列功能相同但是属性会发生变化的组件(如：船体材料、武器系统、动力系统)添加一个抽象类，这样就可以非常方便地进行后续的拓展，再搭配工厂类就可以创建出我们需要的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShipBody</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ShipBody</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//木头船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WoodBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;木材&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//钢铁船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IronBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;钢铁&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//合成金属船体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MetalBody</span> :<span class="keyword">public</span> ShipBody &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;使用&lt;合成金属&gt;制作海贼船的船体...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Engine</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手动引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;手动&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//内燃机引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diesel</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;内燃机&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//手动引擎</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nuclear</span> :<span class="keyword">public</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;海贼船的动力方式是&lt;核反应堆&gt;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//武器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getWeapon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Weapon</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//枪</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gun</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;枪&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加农炮</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cannon</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;加农跑&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//激光</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Laser</span> : <span class="keyword">public</span> Weapon &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">getWeapon</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;船上的武器系统是&lt;激光&gt;...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span> &#123;    <span class="comment">//船这个类里面又还要三个子类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//通过传进来的对于子类对象，实现父类指针指向子类对象</span></span><br><span class="line"><span class="built_in">Ship</span>(ShipBody* body, Engine* engine, Weapon* weapon) :       <span class="comment">//三个子对象之间这里是组合关系，当析构船对象的时候，一并析构掉这三个子对象</span></span><br><span class="line"><span class="built_in">m_body</span>(body), <span class="built_in">m_engine</span>(engine), <span class="built_in">m_weapon</span>(weapon) &#123;&#125;</span><br><span class="line">~<span class="built_in">Ship</span>() &#123;                                                   <span class="comment">//组合关系，析构掉三个子对象</span></span><br><span class="line"><span class="keyword">delete</span> m_body;</span><br><span class="line"><span class="keyword">delete</span> m_weapon;</span><br><span class="line"><span class="keyword">delete</span> m_engine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string info = m_body-&gt;<span class="built_in">getBody</span>() + m_weapon-&gt;<span class="built_in">getWeapon</span>() + m_engine-&gt;<span class="built_in">getEngine</span>();</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ShipBody* m_body;             <span class="comment">//船体父类对象</span></span><br><span class="line">Engine* m_engine;             <span class="comment">//引擎父类对象</span></span><br><span class="line">Weapon* m_weapon;             <span class="comment">//武器父类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类 --- 抽象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Ship* <span class="title">createShip</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> WoodBody, <span class="keyword">new</span> Human, <span class="keyword">new</span> Gun);    <span class="comment">//相当于通过传参构造Ship</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;基础型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> IronBody, <span class="keyword">new</span> Diesel, <span class="keyword">new</span> Cannon);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;标准型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//旗舰型海贼船子工厂 ---&gt; 继承父工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UltimataFactory</span> :<span class="keyword">public</span> AbstractFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Ship* <span class="title">createShip</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">Ship* ship = <span class="keyword">new</span> <span class="built_in">Ship</span>(<span class="keyword">new</span> MetalBody, <span class="keyword">new</span> Nuclear, <span class="keyword">new</span> Laser);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;旗舰型的海贼船&gt; 已经建造完毕！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//下单为旗舰型海贼船</span></span><br><span class="line">AbstractFactory* factory = <span class="keyword">new</span> UltimataFactory;   <span class="comment">//父工厂指针指向子工厂对象</span></span><br><span class="line">Ship* ship = factory-&gt;<span class="built_in">createShip</span>();      <span class="comment">//创建对应的船，并返回</span></span><br><span class="line">cout &lt;&lt; ship-&gt;<span class="built_in">getProperty</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> factory;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后对<code>简单工厂模式</code>、<code>工厂模式</code>和<code>抽象工厂模式</code>的区别做如下总结：</p><ul><li>简单工厂模式不能遵守开放封闭原则，工厂和抽象工厂模式可以</li><li>简单工厂模式只有一个工厂类，工厂和抽象工厂有多个工厂类</li><li>工厂模式创建的产品对象相对简单，抽象工厂模式创建的产品对象相对复杂<ul><li>工厂模式创建的对象对应的类不需要提供抽象类(这产品类组件中没有可变因素)</li><li>抽象工厂模式创建的对象对应的类有抽象的基类(这个产品类组件中有可变因素)</li></ul></li></ul><h1 id="4-建造者-生成器-模式"><a href="#4-建造者-生成器-模式" class="headerlink" title="4. 建造者(生成器)模式"></a>4. 建造者(生成器)模式</h1><p>下面程序为创造模式的一个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义桑尼号的船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SunnyShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addParts</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_parts.<span class="built_in">push_back</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_parts) &#123;</span><br><span class="line">cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;string&gt; m_parts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义梅丽号的船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MerryShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assemble</span><span class="params">(string name, string parts)</span> </span>&#123;</span><br><span class="line">m_parts.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(parts,name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showParts</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_parts) &#123;</span><br><span class="line">cout &lt;&lt; item.first&lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; item.second;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">map&lt;string, string&gt; m_parts;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义生成器类：在这个抽象类中定义了建造海贼船所有零部件的方法，在这个类的子类中需要重写这些虚函数，分别完成桑尼号 和梅利号零件的建造。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShipBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ShipBuilder</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//桑尼号生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SunnyBuilder</span> :<span class="keyword">public</span> ShipBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SunnyBuilder</span>() &#123;</span><br><span class="line"><span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny = <span class="keyword">new</span> SunnyShip;        <span class="comment">//创建一个桑尼号船</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SunnyShip* <span class="title">getSunnyShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SunnyShip* ship = m_sunny;     <span class="comment">//当在m_sunny对象里面存储了对应组件后，就可以返回给调用者了</span></span><br><span class="line">m_sunny = <span class="literal">nullptr</span>;             <span class="comment">//旧内存就不需要维护了(后面还需要创建不同型号的桑尼号)</span></span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;船体是神树亚当&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;狮吼炮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;可乐驱动的内燃机&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_sunny-&gt;<span class="built_in">addParts</span>(<span class="string">&quot;非常豪华的内室装修&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">SunnyBuilder</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sunny) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_sunny;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SunnyShip* m_sunny;          <span class="comment">//定义一个桑尼船的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梅丽号生成器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MerryBuilder</span> :<span class="keyword">public</span> ShipBuilder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MerryBuilder</span>() &#123;</span><br><span class="line"><span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry = <span class="keyword">new</span> MerryShip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MerryShip* <span class="title">getMerryShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MerryShip* ship = m_merry;</span><br><span class="line">m_merry = <span class="literal">nullptr</span>;         <span class="comment">//旧内存就不需要维护了</span></span><br><span class="line"><span class="keyword">return</span> ship;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildBody</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;船体是优质木材&quot;</span>,<span class="string">&quot;船体&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildWeapon</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;普通的四门大炮&quot;</span>,<span class="string">&quot;武器系统&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildEngine</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;烧煤的蒸汽机&quot;</span>,<span class="string">&quot;动力系统&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInterior</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">m_merry-&gt;<span class="built_in">assemble</span>(<span class="string">&quot;非常豪华的内室装修&quot;</span>,<span class="string">&quot;内室&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">MerryBuilder</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_merry) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_merry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">MerryShip* m_merry;          <span class="comment">//定义一个桑尼船的对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义管理者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setBuilder</span><span class="params">(ShipBuilder* builder)</span> </span>&#123;      <span class="comment">//多态实现，参数传进来的可能是桑尼号也可能是梅丽号</span></span><br><span class="line">m_builder = builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildSimpleShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_builder-&gt;<span class="built_in">buildBody</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildEngine</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildStandardShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildSimpleShip</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildWeapon</span>();      <span class="comment">//在简约型的基础上多了一个武器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildRegalShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildStandardShip</span>();</span><br><span class="line">m_builder-&gt;<span class="built_in">buildInterior</span>();     <span class="comment">//在标准型基础上多了一个内室装饰</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ShipBuilder* m_builder = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建桑尼号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildSunnyShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Director* director = <span class="keyword">new</span> Director;           <span class="comment">//创建出一个管理类对象</span></span><br><span class="line">SunnyBuilder* builder = <span class="keyword">new</span> SunnyBuilder;    <span class="comment">//创建一个桑尼号船对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line">director-&gt;<span class="built_in">setBuilder</span>(builder);               <span class="comment">//多态实现，父类指针指向子类对象</span></span><br><span class="line">director-&gt;<span class="built_in">buildSimpleShip</span>();                 <span class="comment">//创建一个简约型的桑尼号</span></span><br><span class="line">SunnyShip* ship = builder-&gt;<span class="built_in">getSunnyShip</span>();   <span class="comment">//取出它的一个ship，里面容器存了对应的字符串</span></span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();                           <span class="comment">//打印简约型桑尼号组件</span></span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();                           <span class="comment">//重新创建一个ship的子类(存对应桑尼号组件的)</span></span><br><span class="line">director-&gt;<span class="built_in">buildStandardShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getSunnyShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildRegalShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getSunnyShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> builder;</span><br><span class="line"><span class="keyword">delete</span> director;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建造梅丽号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMerryShip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Director* director = <span class="keyword">new</span> Director;</span><br><span class="line">MerryBuilder* builder = <span class="keyword">new</span> MerryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简约型</span></span><br><span class="line">director-&gt;<span class="built_in">setBuilder</span>(builder);</span><br><span class="line">director-&gt;<span class="built_in">buildSimpleShip</span>();</span><br><span class="line">MerryShip* ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标准型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildStandardShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"></span><br><span class="line"><span class="comment">//豪华型</span></span><br><span class="line">builder-&gt;<span class="built_in">reset</span>();</span><br><span class="line">director-&gt;<span class="built_in">buildRegalShip</span>();</span><br><span class="line">ship = builder-&gt;<span class="built_in">getMerryShip</span>();</span><br><span class="line">ship-&gt;<span class="built_in">showParts</span>();</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line"><span class="keyword">delete</span> builder;</span><br><span class="line"><span class="keyword">delete</span> director;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">buildMerryShip</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">buildSunnyShip</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h1><p>通过父类指针把对应的子类对象拷贝出来，就是让子类重写了父类提供的克隆函数，然后在每个子类的克隆函数里面调用了子类对应的拷贝构造函数，再通过父类指针指向某一个子类对象，这样就通过指针能够调用某个子类里面的克隆函数了，执行的就是对应子类里面的拷贝动作，这样就能够得到对应的子类实例对象(不是原来那个了)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类(抽象类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GermaSoldier</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> GermaSoldier* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">whoAmI</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">GermaSoldier</span>() &#123;&#125;               <span class="comment">//虚析构(同时会析构子类对象)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier66</span> :<span class="keyword">public</span> GermaSoldier &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">GermaSoldier* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Soldier66</span>(*<span class="keyword">this</span>);      <span class="comment">//谁调用clone，this就是谁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">whoAmI</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我是soldier66的士兵!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier67</span> :<span class="keyword">public</span> GermaSoldier &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">GermaSoldier* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Soldier67</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">whoAmI</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我是soldier67的士兵!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GermaSoldier* obj = <span class="keyword">new</span> Soldier66;</span><br><span class="line">GermaSoldier* soldier = obj-&gt;<span class="built_in">clone</span>();   <span class="comment">//obj-&gt;clone克隆出来的是Soldier66的对象</span></span><br><span class="line">cout &lt;&lt; soldier-&gt;<span class="built_in">whoAmI</span>();</span><br><span class="line"><span class="keyword">delete</span> soldier;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> Soldier67;</span><br><span class="line">soldier = obj-&gt;<span class="built_in">clone</span>();                 <span class="comment">//obj-&gt;clone克隆出来的是Soldier67的对象</span></span><br><span class="line">cout &lt;&lt; soldier-&gt;<span class="built_in">whoAmI</span>();</span><br><span class="line"><span class="keyword">delete</span> soldier;</span><br><span class="line"><span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h1><p><code>适配器</code>就是将一个类的接口转换成用户希望的另一个接口，使不兼容的对象能够相互配合并一起工作，这种模式就叫适配器模式。</p><p>STL标准模板库有六大组件，其中之一的就是适配器。</p><ul><li>六大组件分别是：容器、算法、迭代器、仿函数、适配器、空间适配器。</li><li>适配器又可以分为：容器适配器、函数适配器、迭代器适配器</li></ul><p>1.适配器类和熊猫类是关联关系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foreigner</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">confession</span><span class="params">()</span> </span>= <span class="number">0</span>;         <span class="comment">//纯虚函数，让子类实现，美国人和法国人说的话</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setResult</span><span class="params">(string res)</span> </span>&#123;             <span class="comment">//收到熊猫的回复</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Panda say: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Foreigner</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//美国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ammerican</span> : <span class="keyword">public</span> Foreigner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">confession</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我有罪，呼呼呼!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//法国人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">French</span> : <span class="keyword">public</span> Foreigner &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">confession</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;我不是人，哎哎哎!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//熊猫</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Panda</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recvMessage</span><span class="params">(string msg)</span> </span>&#123;         <span class="comment">//接收的数据</span></span><br><span class="line">cout &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;                 <span class="comment">//发送的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;强盗、凶手，罪人是不可能被宽恕和原谅的!! &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractChopper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传入的参数是美国人对象或法国人对象</span></span><br><span class="line"><span class="built_in">AbstractChopper</span>(Foreigner* foreigner) : <span class="built_in">m_foreigner</span>(foreigner) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>= <span class="number">0</span>;       <span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Panda m_panda;                 <span class="comment">//熊猫对象</span></span><br><span class="line">Foreigner* m_foreigner;        <span class="comment">//外国人对象(保存传进来的外国人的实例)  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器子类(熊猫语言与英语之间的转换)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EnglishChopper</span> : <span class="keyword">public</span> AbstractChopper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractChopper::AbstractChopper;    <span class="comment">//在子类里面就继承了所有在父类中定义的构造函数</span></span><br><span class="line"><span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_foreigner-&gt;<span class="built_in">confession</span>();     <span class="comment">//取出美国人说的话</span></span><br><span class="line"><span class="comment">//解析熊猫的语言，并将数据传递给熊猫</span></span><br><span class="line">m_panda.<span class="built_in">recvMessage</span>(<span class="string">&quot;美国人说: &quot;</span> + msg);    <span class="comment">//熊猫接收到美国人的话</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_panda.<span class="built_in">sendMessage</span>();        <span class="comment">//取出熊猫回复的话</span></span><br><span class="line"><span class="comment">//将熊猫语言转换为英语，再传递给外国人</span></span><br><span class="line">m_foreigner-&gt;<span class="built_in">setResult</span>(<span class="string">&quot;美国佬: &quot;</span> + msg);  <span class="comment">//外国人接收到熊猫的话</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器子类(熊猫语言与法语之间的转换)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrechChopper</span> : <span class="keyword">public</span> AbstractChopper &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractChopper::AbstractChopper;    <span class="comment">//在子类里面就继承了所有在父类中定义的构造函数</span></span><br><span class="line"><span class="comment">//把人类的语言转换为熊猫的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToPanda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_foreigner-&gt;<span class="built_in">confession</span>();</span><br><span class="line"><span class="comment">//解析熊猫的语言，并将数据传递给熊猫</span></span><br><span class="line">m_panda.<span class="built_in">recvMessage</span>(<span class="string">&quot;法国人说: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把熊猫的语言转换为人类的语言</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">translateToHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string msg = m_panda.<span class="built_in">sendMessage</span>();</span><br><span class="line"><span class="comment">//将熊猫语言转换为英语，再传递给外国人</span></span><br><span class="line">m_foreigner-&gt;<span class="built_in">setResult</span>(<span class="string">&quot;法国佬: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Foreigner* foreigner = <span class="keyword">new</span> Ammerican;                        <span class="comment">//定义一个外国人的对象(多态实现，指向美国人对象)</span></span><br><span class="line">AbstractChopper* adapter = <span class="keyword">new</span> <span class="built_in">EnglishChopper</span>(foreigner);    <span class="comment">//转换器对象(对应的是英语转换器)</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToPanda</span>();           <span class="comment">//英语转换为熊猫语言</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToHuman</span>();           <span class="comment">//熊猫语言转换为英语</span></span><br><span class="line"><span class="keyword">delete</span> foreigner;</span><br><span class="line"><span class="keyword">delete</span> adapter;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;=====================================&quot;</span> &lt;&lt; endl;</span><br><span class="line">foreigner = <span class="keyword">new</span> French;                         <span class="comment">//定义一个外国人的对象(多态实现，指向美国人对象)</span></span><br><span class="line">adapter = <span class="keyword">new</span> <span class="built_in">FrechChopper</span>(foreigner);    <span class="comment">//转换器对象(对应的是英语转换器)</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToPanda</span>();           <span class="comment">//英语转换为熊猫语言</span></span><br><span class="line">adapter-&gt;<span class="built_in">translateToHuman</span>();           <span class="comment">//熊猫语言转换为英语</span></span><br><span class="line"><span class="keyword">delete</span> foreigner;</span><br><span class="line"><span class="keyword">delete</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.适配器类和熊猫类是继承关系：因为熊猫类是没有子类的，所以可以让适配器父类来继承熊猫类，这样在适配器子类中使用熊猫类的<code>recvMessage()</code>函数和<code>sendMessage()</code>函数就可以直接使用，而不需要通过<code>m_panda.</code>来引用。当然，当外国人类也没有子类时，适配器父类就可以继承熊猫类和适配器类(多个类)来实现相应的功能了。</p><h1 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h1><p><code>桥接模式</code>的原则就是将抽象部分和它的实现部分分离，使它们可以独立的变化。</p><p>比如说在下面程序中，实现桥接模式的方案：</p><ul><li>海贼团之间是继承关系，但是此时的海贼团也只是一个抽象，因为组成海贼团的人已经被抽离了，船员已经和所属的海贼团没有了继承关系。</li><li>关于海贼世界的船员在船上对应不同的职责担任不同的职务，他们是一个团队，所以可以给船员抽象出一个团队类，用于管理船上的成员。</li><li>抽象的海贼团只有一个空壳子，所以要赋予其灵魂也就是给它添加船员，此时的海贼团和船员团队可以通过聚合的方式组合成为一个整体。</li><li>这种解决方案不仅适用于管理海贼团，用于管理海军的各个舰队也是没有问题的。</li></ul><p>测试程序：对海贼世界中的 海贼团 和 海军 通过桥接模式进行管理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员对应的类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string job, string ability, string reward, string beizhu) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;job = job;</span><br><span class="line"><span class="keyword">this</span>-&gt;ability = ability;</span><br><span class="line"><span class="keyword">this</span>-&gt;reward = reward;</span><br><span class="line"><span class="keyword">this</span>-&gt;beizhu = beizhu;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot;被析构了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string name;</span><br><span class="line">string job;</span><br><span class="line">string ability;</span><br><span class="line">string reward;</span><br><span class="line">string beizhu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义实现部分 - 团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractTeam</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractTeam</span>(string name) : <span class="built_in">m_name</span>(name) &#123;&#125;       <span class="comment">//初始化团队的名字</span></span><br><span class="line"><span class="function">string <span class="title">getTeamName</span><span class="params">()</span> </span>&#123;                            <span class="comment">//获取团队的名字</span></span><br><span class="line"><span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addMember</span><span class="params">(Person* p)</span> </span>&#123;</span><br><span class="line">m_teamMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(p-&gt;name, p));      <span class="comment">//插入成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_teamMap) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[name: &quot;</span> &lt;&lt; item.second-&gt;name</span><br><span class="line">&lt;&lt; <span class="string">&quot;, job: &quot;</span> &lt;&lt; item.second-&gt;job</span><br><span class="line">&lt;&lt; <span class="string">&quot;, abilite: &quot;</span> &lt;&lt; item.second-&gt;ability</span><br><span class="line">&lt;&lt; <span class="string">&quot;, reward: &quot;</span> &lt;&lt; item.second-&gt;reward</span><br><span class="line">&lt;&lt; <span class="string">&quot;, beizhu: &quot;</span> &lt;&lt; item.second-&gt;beizhu</span><br><span class="line">&lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractTeam</span>() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_teamMap) &#123;</span><br><span class="line"><span class="keyword">delete</span> item.second;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> </span>= <span class="number">0</span>;          <span class="comment">//纯虚函数的任务函数，让子类来写</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_name;</span><br><span class="line">map&lt;string, Person*&gt; m_teamMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//草帽子团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CaoMaoTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;          <span class="comment">//继承父类的构造函数(获取团队名)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在海上冒险，找到 ONE PIECE 成为海贼王!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//海军子团队</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmokerTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;          <span class="comment">//继承父类的构造函数(获取团队名)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">executeTask</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;为了正义，先将草帽一网打尽!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义抽象部分 - 船</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractShip</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractShip</span>(AbstractTeam* team) :<span class="built_in">m_team</span>(team) &#123;&#125;       <span class="comment">//初始化一个团队</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_team-&gt;<span class="built_in">show</span>();                              <span class="comment">//展示团队成员</span></span><br><span class="line">m_team-&gt;<span class="built_in">executeTask</span>();                       <span class="comment">//打印团队的目标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span> </span>= <span class="number">0</span>;              <span class="comment">//船的名字</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">feature</span><span class="params">()</span> </span>= <span class="number">0</span>;                <span class="comment">//船的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">AbstractTeam* m_team;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梅丽号子船类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Merry</span> :<span class="keyword">public</span> AbstractShip &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractShip::AbstractShip;      <span class="comment">//继承父类的构造函数</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;前进 - 梅利号&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feature</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;-- 船首为羊头，化身船精灵在司法岛舍己救下了草帽一伙!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//海军船子船类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HaiJunShip</span> :<span class="keyword">public</span> AbstractShip &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractShip::AbstractShip;      <span class="comment">//继承父类的构造函数</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;无敌海军号&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feature</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;-- 船底由海楼石建造，可以穿过无风带的巨大炮舰!!! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//CaoMaoTeam* team = new CaoMaoTeam(&quot;草帽海贼团&quot;);             //不通过多态实现也可以</span></span><br><span class="line">CaoMaoTeam* team = <span class="keyword">new</span> <span class="built_in">CaoMaoTeam</span>(<span class="string">&quot;草帽海贼团&quot;</span>);               <span class="comment">//创建一个团队</span></span><br><span class="line">Person* luffy = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;路飞&quot;</span>, <span class="string">&quot;船长&quot;</span>, <span class="string">&quot;橡胶果实能力者&quot;</span>, <span class="string">&quot;30亿贝利&quot;</span>, <span class="string">&quot;爱吃肉&quot;</span>);</span><br><span class="line">Person* zoro = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;索隆&quot;</span>, <span class="string">&quot;剑士&quot;</span>, <span class="string">&quot;三刀流&quot;</span>, <span class="string">&quot;12亿贝利&quot;</span>, <span class="string">&quot;路痴&quot;</span>);</span><br><span class="line">Person* sanji = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;山治&quot;</span>, <span class="string">&quot;厨师&quot;</span>, <span class="string">&quot;火焰腿&quot;</span>, <span class="string">&quot;10亿贝利&quot;</span>, <span class="string">&quot;好色&quot;</span>);</span><br><span class="line">Person* nami = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;娜美&quot;</span>, <span class="string">&quot;航海士&quot;</span>, <span class="string">&quot;天候棒&quot;</span>, <span class="string">&quot;3亿贝利&quot;</span>, <span class="string">&quot;喜欢钱&quot;</span>);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(luffy);                <span class="comment">//因为子团队继承了父团队，所以可以使用父团队的函数</span></span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(zoro);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(sanji);</span><br><span class="line">team-&gt;<span class="built_in">addMember</span>(nami);</span><br><span class="line"><span class="comment">//Merry* ship = new Merry(team);            //不通过多态实现也可以</span></span><br><span class="line">AbstractShip* ship = <span class="keyword">new</span> <span class="built_in">Merry</span>(team);       <span class="comment">//创建梅丽船，传入的参数是草帽团队</span></span><br><span class="line">ship-&gt;<span class="built_in">show</span>();                    <span class="comment">//打印团队成员和目标(该函数里面就是通过传入的草帽团队调用了对应的函数)</span></span><br><span class="line">ship-&gt;<span class="built_in">feature</span>();                 <span class="comment">//打印船的属性</span></span><br><span class="line"><span class="keyword">delete</span> team;</span><br><span class="line"><span class="keyword">delete</span> ship;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8. 组合模式"></a>8. 组合模式</h1><p>能将多个对象组成一个树状结构，用以描述部分—整体的层次关系，使得用户对单个对象和组合对象的使用具有一致性，这样的结构性设计模式叫做<code>组合模式</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义节点的抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractTeam</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AbstractTeam</span>(string name) : <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;                         <span class="comment">//获取团队名字</span></span><br><span class="line"><span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setParent</span><span class="params">(AbstractTeam* team)</span> </span>&#123;       <span class="comment">//设置父对象</span></span><br><span class="line">m_parent = team;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AbstractTeam* <span class="title">getParent</span><span class="params">()</span> </span>&#123;                <span class="comment">//获取父对象</span></span><br><span class="line"><span class="keyword">return</span> m_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">hasChild</span><span class="params">()</span> </span>&#123;          <span class="comment">//是否有子节点，默认返回false(叶子节点就可以不用重写该函数了，管理者节点需要重写)</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这两个函数不能定义成纯虚函数：因为如果这个抽象类的子类是一个叶子节点，叶子节点是用不到这两个函数的，所以就不需要重写这两个</span></span><br><span class="line"><span class="comment">//虚函数。如果定义成纯虚函数，子类就必须重写，不然也是抽象类(不能被实例化)，所以不定义成虚函数，子类就算继承了，该函数也是什么都不执行</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;&#125;        <span class="comment">//添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;&#125;     <span class="comment">//删除节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数(子类必须重写的)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">AbstractTeam</span>() &#123;&#125;         <span class="comment">//虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_name;                       <span class="comment">//记录团队的名字</span></span><br><span class="line">AbstractTeam* m_parent = <span class="literal">nullptr</span>;    <span class="comment">//记录父对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叶子节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeafTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;         <span class="comment">//继承父类定义的所有构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() + m_name + <span class="string">&quot;与黑胡子的船员进行近距离肉搏战... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;下属的&quot;</span> &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">LeafTeam</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_parent-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;下属的&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;,战斗已经结束，拜拜... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理者节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManagerTeam</span> :<span class="keyword">public</span> AbstractTeam &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> AbstractTeam::AbstractTeam;         <span class="comment">//继承父类定义的所有构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt;  m_name + <span class="string">&quot;与黑胡子的恶魔果实能力者战斗... &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasChild</span><span class="params">()</span> </span>&#123;          <span class="comment">//是否有子节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;         <span class="comment">//添加下属团队</span></span><br><span class="line">node-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);                  <span class="comment">//上级节点就为这个类对象</span></span><br><span class="line">m_children.<span class="built_in">push_back</span>(node);             <span class="comment">//加入该团队的下属</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeChild</span><span class="params">(AbstractTeam* node)</span> </span>&#123;      <span class="comment">//删除下属团队</span></span><br><span class="line">node-&gt;<span class="built_in">setParent</span>(<span class="literal">nullptr</span>);               <span class="comment">//给它的上级节点指为空</span></span><br><span class="line">m_children.<span class="built_in">remove</span>(node);                <span class="comment">//移除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;      <span class="comment">//如果是管理者节点，则就打印他的下属团队</span></span><br><span class="line">string info;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : m_children) &#123;         <span class="comment">//遍历他的下属团队</span></span><br><span class="line"><span class="keyword">if</span> (item == m_children.<span class="built_in">back</span>()) &#123;</span><br><span class="line">info += item-&gt;<span class="built_in">getName</span>();              <span class="comment">//如果是最后一个，就直接追加在后面即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">info += item-&gt;<span class="built_in">getName</span>() + <span class="string">&quot;, &quot;</span>;        <span class="comment">//如果不是最后一个，就添加逗号，继续追加</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的船队是[&quot;</span> &lt;&lt; info &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">list&lt;AbstractTeam*&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;               <span class="comment">//取出他的下属</span></span><br><span class="line"><span class="keyword">return</span> m_children;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ManagerTeam</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是[ &quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ] 战斗结束，拜拜...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">list&lt;AbstractTeam*&gt; m_children;        <span class="comment">//来记录它的孩子节点(记录它的下属)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gameover</span><span class="params">(AbstractTeam* root)</span> </span>&#123;             <span class="comment">//递归消除节点</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root &amp;&amp; root-&gt;<span class="built_in">hasChild</span>()) &#123;               <span class="comment">//不为空，且有下属</span></span><br><span class="line">ManagerTeam* team = <span class="built_in">dynamic_cast</span>&lt;ManagerTeam*&gt;(root);</span><br><span class="line">list&lt;AbstractTeam*&gt; children = team-&gt;<span class="built_in">getChildren</span>();        <span class="comment">//取出该节点的子节点(下属)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : children) &#123;           <span class="comment">//</span></span><br><span class="line"><span class="built_in">gameover</span>(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">ManagerTeam* root = <span class="keyword">new</span> <span class="built_in">ManagerTeam</span>(<span class="string">&quot;草帽海贼团&quot;</span>);</span><br><span class="line">vector&lt;string&gt; nameList = &#123; <span class="string">&quot;俊美海贼团&quot;</span>,<span class="string">&quot;巴托俱乐部&quot;</span>,<span class="string">&quot;八宝水军&quot;</span>,<span class="string">&quot;艾迪欧海贼团&quot;</span>,<span class="string">&quot;咚塔塔海贼团&quot;</span>,</span><br><span class="line"><span class="string">&quot;巨兵海贼团&quot;</span>,<span class="string">&quot;约塔玛利亚大船团&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nameList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">ManagerTeam* child = <span class="keyword">new</span> <span class="built_in">ManagerTeam</span>(nameList.<span class="built_in">at</span>(i));</span><br><span class="line">root-&gt;<span class="built_in">addChild</span>(child);</span><br><span class="line"><span class="keyword">if</span> (i == nameList.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">LeafTeam* leaf = <span class="keyword">new</span> <span class="built_in">LeafTeam</span>(<span class="string">&quot;第&quot;</span> + <span class="built_in">to_string</span>(j + <span class="number">1</span>) + <span class="string">&quot;番队&quot;</span>);</span><br><span class="line">child-&gt;<span class="built_in">addChild</span>(leaf);</span><br><span class="line">leaf-&gt;<span class="built_in">fight</span>();</span><br><span class="line">leaf-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">fighting</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-设计模式三原则&quot;&gt;&lt;a href=&quot;#1-设计模式三原则&quot; class=&quot;headerlink&quot; title=&quot;1. 设计模式三原则&quot;&gt;&lt;/a&gt;1. 设计模式三原则&lt;/h1&gt;&lt;p&gt;在进行程序设计的时候，要尽可能地保证程序的可扩展性、可维护性和可读性，所以需要使</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>c++11新特性</title>
    <link href="https://lxx93.online/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://lxx93.online/2024/08/26/%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2024-08-26T10:34:13.000Z</published>
    <updated>2024-10-18T03:33:36.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原始自变量"><a href="#1-原始自变量" class="headerlink" title="1. 原始自变量"></a>1. 原始自变量</h1><p>定义原始字符串的方式为：R “xxx(原始字符串)xxx”，其中()两边的字符串可以省略(不省略的时候就要求一样)。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p><p>用途：主要是防止一些特殊字符，如\t，\n等对想输出的字符串产生影响。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;     <span class="comment">//后面的hello为world就会报错</span></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">&lt;title&gt;</span></span><br><span class="line"><span class="string">海贼王</span></span><br><span class="line"><span class="string">&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;</span></span><br><span class="line"><span class="string">我是要成为海贼王的男人</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)&quot;</span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D:\hello\world\test.text</span><br><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">        海贼王</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">        我是要成为海贼王的男人</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2. 指针空值类型nullptr"></a>2. 指针空值类型nullptr</h1><p>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在c++11标准下，相比NULL和0，使用nullptr初始化空指针可以令编写的程序更加健壮。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* ptr3 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);        <span class="comment">//在c中，NULL是(void*)0---&gt;对0强制转换；而在c++中，NULL就是0</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);    <span class="comment">//c++中，对指针初始化用nullptr，它可以隐式转换为各种类型指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(int p)</span><br><span class="line">void func(int p)</span><br><span class="line">void func(char *p)</span><br></pre></td></tr></table></figure><h1 id="3-constexpr修饰常量表达式"><a href="#3-constexpr修饰常量表达式" class="headerlink" title="3. constexpr修饰常量表达式"></a>3. constexpr修饰常量表达式</h1><p>C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p>注：const和constexpr是等价的，都可以在程序的编译阶段计算出结果。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;          <span class="comment">//对结构体用constexpr是不行的，只能在初始化一个结构体时才可以用该常量</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//a = 12;         报错，不能对常量进行修改了</span></span><br><span class="line"><span class="keyword">constexpr</span> T t&#123; <span class="number">13</span> &#125;;</span><br><span class="line"><span class="comment">//t.a = 12;       报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-自动类型推导"><a href="#4-自动类型推导" class="headerlink" title="4. 自动类型推导"></a>4. 自动类型推导</h1><p>当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字。<br>当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;     <span class="comment">//a1是const int类型 ---&gt; auto相当于是int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;            <span class="comment">//因为a2既没有指针也没有引用，所以a2是int类型,不是const int类型(const被消除了)</span></span><br><span class="line"><span class="comment">//保留赋值的const方法(加解引用或指针)</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a3 = a1;           <span class="comment">//a3是const int类型</span></span><br><span class="line"><span class="keyword">auto</span>* pt1 = &amp;a1;         <span class="comment">//pt1是const int*类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不允许使用auto的四个场景：</p><p>1.不能作为函数参数使用，因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;                    <span class="comment">//错误的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不能用于类的非静态成员变量的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="number">0</span>;                       <span class="comment">//错误</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;                <span class="comment">//错误，类的静态非常量成员不允许在类的内部直接初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;         <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.不能使用auto关键字定义数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;            <span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">auto</span> t1 = array;                        <span class="comment">//正确，t1被推导为int*类型</span></span><br><span class="line"><span class="keyword">auto</span> t2[] = array;                      <span class="comment">//错误，t2相当于是重新定义数组，是无法成功的</span></span><br><span class="line"><span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;              <span class="comment">//错误，auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.无法使用auto推导出模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">Test&lt;<span class="keyword">auto</span>&gt;t1 = t;                 <span class="comment">//错误，无法推导出模板类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-decltype类型推导"><a href="#5-decltype类型推导" class="headerlink" title="5. decltype类型推导"></a>5. decltype类型推导</h1><p>它的作用是在编译器编译的时候推导出一个表达式的类型，如decltype (表达式)；</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure><p>decltype的应用多数出现在泛型编程中，下面编写一个类模板，在里边添加遍历容器的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//T::iterator m_it;                   // 这里不能确定迭代器类型</span></span><br><span class="line">    <span class="comment">//这样就能够推导出对应的T容器它的迭代器类型，基于这个类型定义出了它的迭代器变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;           <span class="comment">//通过T()来得到一个对象，调用它的begin()方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; st1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;list&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line">    c.<span class="built_in">func</span>(st1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历常量的迭代器容器(只读迭代器)</span></span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; st2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; c2;</span><br><span class="line">    c2.<span class="built_in">func</span>(st2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype返回值类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;           <span class="comment">//模板函数1</span></span><br><span class="line"><span class="function">R <span class="title">add1</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;                      <span class="comment">//模板函数2</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;               <span class="comment">//auto可以通过后面的decltype来判断</span></span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> u = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//模板函数1：可以编译，但不合理，外部调用的人，一般不会知道模板函数内部的代码内容，即不知道最后返回值是t+u</span></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">add1</span>&lt;<span class="keyword">decltype</span>(t + u), <span class="type">int</span>, <span class="type">double</span>&gt;(t , u);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//模板函数2：</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">add2</span>(t, u);</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-final和overrid关键字的使用"><a href="#6-final和overrid关键字的使用" class="headerlink" title="6. final和overrid关键字的使用"></a>6. final和overrid关键字的使用</h1><h2 id="6-1-final"><a href="#6-1-final" class="headerlink" title="6.1 final"></a>6.1 final</h2><p><code>final</code>关键字来限制某个类不能被继承，或者某个虚函数不能被重写。</p><div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">修饰函数</button><button type="button" class="tab " data-href="test4-2">修饰类</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>如果用final来修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了。</p><p>解释：当test()是基类中的一个虚函数时，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只能使用，而不能进行重写了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//父类虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>        <span class="comment">//用final修饰从父类继承下来的虚函数，表示之后再继承Child类时，不能重写Test</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span>             <span class="comment">// 语法错误, 不允许重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>如果使用final关键字来修饰类的话，表示该类是不允许被继承的，也就是说这个类不能有派生类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>                                 <span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span>: <span class="keyword">public</span> Base            <span class="comment">//子类继承父类，同时加上了final关键字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child           <span class="comment">//语法错误，不能在继承Child类了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="6-2-override"><a href="#6-2-override" class="headerlink" title="6.2 override"></a>6.2 override</h2><p><code>override</code>关键字确保在派生类中声明的重写函数与基类的虚函数有相同的名字，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span>              <span class="comment">//重写从父类继承下来的虚函数(当函数名不和父类的虚函数名一样时，会提示错误)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="7-委托构造函数和继承构造函数"><a href="#7-委托构造函数和继承构造函数" class="headerlink" title="7.委托构造函数和继承构造函数"></a>7.委托构造函数和继承构造函数</h1><h2 id="7-1-委托构造函数"><a href="#7-1-委托构造函数" class="headerlink" title="7.1 委托构造函数"></a>7.1 委托构造函数</h2><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类也可以通过以下方式来继承父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一个参数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">test</span>(num)&#123;                     <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;两个参数：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">test</span>(num, sum) &#123;      <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;二个参数：&quot; &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;三个参数：&quot;</span> &lt;&lt; tum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-2-继承构造函数"><a href="#7-2-继承构造函数" class="headerlink" title="7.2 继承构造函数"></a>7.2 继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num)&#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num),<span class="built_in">b</span>(sum),<span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">child(int num) :base(num)&#123;&#125;</span></span><br><span class="line"><span class="comment">child(int num, int sum) :base(num,sum) &#123;&#125;</span></span><br><span class="line"><span class="comment">child(int num, int sum, int tum) :base(num, sum,tum) &#123;&#125;*/</span></span><br><span class="line"><span class="keyword">using</span> base::base;        <span class="comment">//可以直接这样写(相当于上面3行代码)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">child <span class="title">x</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; x.a &lt;&lt; x.b &lt;&lt; x.c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line"><span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum), <span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;and&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> base::base;</span><br><span class="line"><span class="keyword">using</span> base::func;               <span class="comment">//也可以通过这行来解决隐藏了父类同名函数的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;                   <span class="comment">//写了一个与父类中的同名函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;lxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;             <span class="comment">//这里必须是带参的构造函数，因为父类中没有默认构造函数</span></span><br><span class="line">    c.base::<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);     <span class="comment">//通过加定义域的方式来得到与父类相同的同名函数</span></span><br><span class="line">c.<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在C++中，如果基类没有默认构造函数，子类也不能自动生成默认构造函数。这是因为子类对象的构造需要先构造基类的部分，如果基类没有默认构造函数，子类在构造时就无法调用基类的构造函数来初始化基类部分。</p></blockquote><h1 id="8-可调用对象包装器和绑定器"><a href="#8-可调用对象包装器和绑定器" class="headerlink" title="8 .可调用对象包装器和绑定器"></a>8 .可调用对象包装器和绑定器</h1><h2 id="8-1-可调用对象"><a href="#8-1-可调用对象" class="headerlink" title="8.1 可调用对象"></a>8.1 可调用对象</h2><p>在c++中有四种可调用对象的定义</p><p>1.是一个函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print;      <span class="comment">// 定义函数指针，指向刚定义的函数</span></span><br></pre></td></tr></table></figure><p>2.是一个具有operator()成员函数的类对象(仿函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">&quot;lxxlxxlxx&quot;</span>);          <span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.是一个可被转换为函数指针的类对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里返回的必须是静态的成员函数，因为静态的是属于类，非静态的属于对象，在还没有定义对象之前，非静态的成员函数是不存在的，而静态成员函数是存在的。</span></span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.是一个类成员函数指针或者类成员指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using func_ptr = void(*)(int, string);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number is: &quot;</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-可调用对象包装器"><a href="#8-2-可调用对象包装器" class="headerlink" title="8.2 可调用对象包装器"></a>8.2 可调用对象包装器</h2><p>可调用对象的包装器是<code>std::function</code>。它是一个类模板，可以容纳除了类(非静态)成员(函数)指针之外的所有可调用对象。使用<code>std::function</code>，必须包含头文件<code>functional</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;          <span class="comment">//打包之后的名字是f1，包装的函数是add</span></span><br><span class="line">    <span class="comment">// 绑定一个类的静态函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;      <span class="comment">//包装的函数需要指明具体的类和函数名</span></span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num, string name)</span> </span>&#123;             <span class="comment">//普通函数</span></span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> funcptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);          <span class="comment">//声明了一个函数指针别名，返回值是void，参数是int和string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;仿函数：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">world</span><span class="params">(<span class="type">int</span> a, string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数参数是一个包装器对象(可以给构造函数传入相同类型的可调用对象，然后通过可调用对象包装器进行打包，保存在了callback里面)</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>(<span class="type">int</span>, string)&gt;&amp; f) :<span class="built_in">callback</span>(f) &#123;&#125;</span><br><span class="line"><span class="comment">//相当于回调操作，通过函数指针就可以进行回调(传入一个函数指针的地址给另一个函数，在另一个函数里面就可以调用该指针，执行对应的函数体)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">int</span> id, string name)</span> </span>&#123;</span><br><span class="line"><span class="built_in">callback</span>(id, name);       <span class="comment">//调用通过构造函数得到的函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, string)&gt;callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">A <span class="title">aa</span><span class="params">(print)</span></span>;                 <span class="comment">//传入一种可调用对象</span></span><br><span class="line">aa.<span class="built_in">notify</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">ab</span><span class="params">(Test::world)</span></span>;           <span class="comment">//传入一种可调用对象</span></span><br><span class="line">ab.<span class="built_in">notify</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在编写程序的时候要用到多种类型的可调用对象，那么就可以通过可调用对象包装器对它们进行打包。因为只要给参数指定为可调用对象包装器类型，只要传进任意一种可调用对象类型(参数和返回值要求是相同类型)，它都会进行隐式的类型转换。通过可调用对象的包装器把这些不同类型的可调用对象封装成一种类型，这样程序就显得更加简洁和灵活。</p><h2 id="8-3-绑定器"><a href="#8-3-绑定器" class="headerlink" title="8.3 绑定器"></a>8.3 绑定器</h2><p><code>std::bind</code>用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用绑定器绑定可调用对象和参数，并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();            <span class="comment">//绑定了普通函数output，指定了2个参数，()表示调用了该仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">3</span>);     <span class="comment">//第一个参数指定了占位符，是后面()中的3</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">9</span>);     <span class="comment">//第二个参数指定了占位符，是后面()中的9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);   //占位符_2会去找()里面的第二个实参，会出问题，应该是_1</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//这种情况是参数1会用2，而不是会用10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可调用对象包装器<code>std::function</code>是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器<code>std::bind</code>的配合之后，就可以完美的解决这个问题了。</p><p>在下面程序中，使用绑定器函数bind()绑定了某一个可调用对象，最终得到一个仿函数f或f1，其实这个仿函数对应的还是绑定的那个可调用对象(参数1)，绑定的时候可以给它指定固定的参数(参数2和参数3)，固定的参数可以是一个变量也可以是一个常量。如果绑定的时候不给它指定一个固定的数值，可以指定占位符，当指定占位符后，它就需要从仿函数调用时候的参数列表里面去读对应的数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定器和包装器结合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&amp; f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">f</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\t x+y=&quot;</span> &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当绑定后，就得到一个仿函数f了 ---&gt; 也是可调用对象的一种</span></span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">bind</span>(output_add, i+<span class="number">100</span>, i+<span class="number">200</span>);     <span class="comment">//参2和参3已经指定了函数output_add的具体参数</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f);                             <span class="comment">//这里的i和i参数不会影响output_add的参数了</span></span><br><span class="line">        <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output_add, placeholders::_1, placeholders::_2);   <span class="comment">//参2和参3已经指定的是占位符</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f1);                            <span class="comment">//这里的i和i参数会影响output_add的参数了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=100    y=200   x+y=300</span><br><span class="line">x=0      y=0     x+y=0</span><br><span class="line">x=102    y=202   x+y=304</span><br><span class="line">x=2      y=2     x+y=4</span><br><span class="line">x=104    y=204   x+y=308</span><br><span class="line">x=4      y=4     x+y=8</span><br><span class="line">x=106    y=206   x+y=312</span><br><span class="line">x=6      y=6     x+y=12</span><br><span class="line">x=108    y=208   x+y=316</span><br><span class="line">x=8      y=8     x+y=16</span><br></pre></td></tr></table></figure><p>下面程序是对类的成员函数以及类的成员变进行绑定和封装。因为可调用包装器<code>std::function</code>不能对类成员函数和变量进行包装，但可以对仿函数进行包装，所以可以先通过绑定器bind来对类成员函数和变量进行绑定，然后可以得到对应的一个仿函数。这样包装器就可以间接的对其进行包装了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员函数绑定</span></span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);   <span class="comment">//&amp;t是output所属对象的地址，得到一个仿函数f2</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f22 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);    <span class="comment">//用包装器对可调用对象f2进行包装(间接包装)</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">1314</span>);       <span class="comment">//通过绑定，将一个二元函数变成一元函数</span></span><br><span class="line"><span class="comment">//成员变量绑定(因为成员变量没有参数，所以bind就没有参3和参4)</span></span><br><span class="line"><span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);  <span class="comment">//f3是一个仿函数，而下面的f33是一个将仿函数进行包装的包装器类型</span></span><br><span class="line">function&lt;<span class="type">int</span>&amp; (<span class="type">void</span>)&gt;f33 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t); <span class="comment">//如果要f33是可读可写，就使用取地址符&amp;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;        <span class="comment">//大于f3的值，它代表的是绑定的变量</span></span><br><span class="line"><span class="built_in">f3</span>() = <span class="number">666</span>;                  <span class="comment">//修改成员变量的值</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中，f3和f33的类型是不一样的，绑定器bind绑定完后得到的是一个仿函数，而f33它是把仿函数进行了包装，得到一个包装器类型，所以这两个不是等价的。需要了解的是，f33这一行是做了隐式的类型转换，f3这一行是做了自动的类型推导。</p><h1 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9. lambda表达式"></a>9. lambda表达式</h1><p><code>lambda</code>表达式的捕获列表可以捕获一定范围内的变量，具体如下：</p><ul><li>[]                     不捕抓任何变量</li><li>[&amp;]                  捕获外部作用域所有的变量，并作为引用在函数体内使用(按引用捕获)</li><li>[&#x3D;]                   捕获外部作用域所有的变量，并作为副本在函数体内使用(按值捕获) —&gt;拷贝的副本在匿名函数体内部是只读的</li><li>[&#x3D;,&amp;foo]         按值捕获外部作用域中的所有变量，并按引用捕获外部变量foo</li><li>[bar]                按值捕获bar变量，同时不捕获其他变量</li><li>[&amp;bar]             按引用捕获bar变量，同时不捕获其他变量</li><li>[this]               捕获当前类中的this指针</li></ul><p><code>lambda</code>表达式的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">[=, &amp;x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line"><span class="type">int</span> c = a;      <span class="comment">//拷贝得来的</span></span><br><span class="line"><span class="type">int</span> d = x;      <span class="comment">//引用得来的</span></span><br><span class="line">b++;            <span class="comment">//如果没有加上mutable，则只能读外部变量</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;();       <span class="comment">//不加()只是被定义，而没有被调用(如果上面()里面有参数，则这里也要相应的加上参数)</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;    <span class="comment">//lambda内部修改了值但不影响外面，因为是拷贝进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于通过值拷贝的方式捕获的外部变量是只读的原因：</p><ol><li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</li><li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li></ol><p>所以<code>mutable</code>选项的作用就在于取消operator()的const属性。</p><p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//1.当[]里面为空时，该匿名函数可以看成是一个函数指针</span></span><br><span class="line">    ptr p1 = [](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">p1</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*2.当[]里面有捕获外部变量时，该匿名函数不能看成是一个函数指针，它是一个仿函数</span></span><br><span class="line"><span class="comment">    ptr p2 = [=](int x)&#123;                //这里是有问题的，一个函数指针指的是仿函数</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    p2(9) */</span></span><br><span class="line">    <span class="comment">//3.用包装器包装lambda表达式(直接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff = [=](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fff</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//4.用绑定器绑定lambda表达式(通过绑定器间接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff1 = <span class="built_in">bind</span>([=](<span class="type">int</span> x)&#123;     <span class="comment">//返回的是一个仿函数，包装到包装器对象里面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;,placeholders::_1);</span><br><span class="line">    <span class="built_in">fff1</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-右值引用"><a href="#10-右值引用" class="headerlink" title="10. 右值引用"></a>10. 右值引用</h1><p>在C++11中增加了一个新的类型，即右值引用，标记为 &amp;&amp;。</p><ul><li><p><code>左值</code>是指存储在内存中、有明确存储地址(可取地址)的数据</p></li><li><p><code>右值</code>是指可以提供数据值的数据(不可取地址)</p></li></ul><p>区别方法：可以对表达式取地址(&amp;)就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//左值</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">9</span>;</span><br><span class="line"><span class="comment">//左值引用</span></span><br><span class="line"><span class="type">int</span>&amp; a = num;           <span class="comment">//a不占用额外的内存地址，它是num的别名</span></span><br><span class="line"><span class="comment">//右值</span></span><br><span class="line"><span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; b = <span class="number">8</span>;            <span class="comment">//必须是使用右值来初始化，左值不行</span></span><br><span class="line"><span class="comment">//常量右值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; d = <span class="number">6</span>;</span><br><span class="line"><span class="comment">//常量左值引用可以通过同类型的左值、同类型的右值引用、同类型的常量右值引用、同类型的常量右值引用都可以初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; c = num;     <span class="comment">//c只能是num的别名，因为它是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; f = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; g = d;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; h = d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const int&amp;&amp; e = b;       //错误，常量的右值引用不能通过右值引用来初始化</span></span><br><span class="line"><span class="comment">//int&amp;&amp; f = b;             //错误。普通的右值引用也不能通过右值引用来初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面程序可以得出结论：右值引用只能通过右值来初始化；常量的左值引用是一个万能的引用类型，可以通过同类型的各种引用来初始化左值引用。</p><p>在下面程序中，是通过右值引用来模拟浅拷贝。移动构造(右值引用)是把临时对象的指针成员移动走了，临时对象析构的时候析构了一个空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造(作用是防止浅拷贝)</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数 -&gt; 复用其它对象中的资源(堆内存) ---&gt; 移动构造就是要使用浅拷贝</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num) &#123;                 <span class="comment">//让新对象的m_num指向了a里面的m_num(浅拷贝)</span></span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;         <span class="comment">//令a的m_num指向空，这样a析构的时候，释放的就是空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class .....&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结论：如果给某一个类指定了移动构造函数，在赋值的时候就有两种方式了，即直接赋值和通过右值引用的方式赋值(不管是哪种方式，要求右边的对象是临时对象)</span></span><br><span class="line">    Test t = <span class="built_in">getObj</span>();          <span class="comment">//只打印1次地址(默认构造时打印)</span></span><br><span class="line">    Test&amp;&amp; t1 = <span class="built_in">getObj</span>();       <span class="comment">//打印的1次地址(默认构造时打印)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;t1.m_num &lt;&lt; endl;     <span class="comment">//地址不变，与上面t1打印的地址一样</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用不带参数的构造函数和移动构造都可以实现浅拷贝，区别在于：不带参的构造函数使用浅拷贝，指针资源不会转移，是两个对象的指针指向同一块内存，析构就会出问题。而使用移动构造是实实在在的对资源进行了转移，转移完了之后，原来这个对象就不拥有这块资源了。</p><p>在上面程序中，<code>getObj()</code>函数里面创建了一个临时的<code>Test</code>对象并返回它。由于<code>t</code>是一个左值(即它有一个持久的名字)，编译器会调用<code>Test</code>类的拷贝构造函数来创建<code>t</code>。而t1是一个右值引用，因此，编译器会调用<code>Test</code>类的移动构造函数来创建<code>t1</code>。</p><p>右值可以分为两种：一个是将亡值，另一个是纯右值。</p><ul><li>纯右值：非引用返回的临时变量，运算表达式产生的临时变量、原始字面量和lambda表达式等。</li><li>将亡值：与右值引用相关的表达式，如T&amp;&amp;类型函数的返回值、std::move的返回值等。</li></ul><h2 id="10-1-的特性"><a href="#10-1-的特性" class="headerlink" title="10.1 &amp;&amp;的特性"></a>10.1 &amp;&amp;的特性</h2><p>在C++中，并不是所有情况下<code>&amp;&amp;</code>都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为<code>T&amp;&amp;</code>，如果是自动类型推导需要指定为<code>auto &amp;&amp;</code>，在这两种场景下<code>&amp;&amp;</code>被称作未定的引用类型。另外还有一点需要额外注意<code>const T&amp;&amp;</code>表示一个右值引用，不是未定引用类型(是不需要推导的)。</p><p>在C++11中引用折叠的规则如下：</p><ul><li><p>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型</p></li><li><p>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</p></li></ul><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">//这种是需要根据传进来的参数进行推导的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;        <span class="comment">//这种是不需要根据传进来的参数进行推导，就一定为右值引用类型</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);                           <span class="comment">//传入10(右值)，推导出为右值引用类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);                            <span class="comment">//传入x(左值)，推导出为左值引用类型</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">10</span>);                          <span class="comment">// 不需要推导，就为右值引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;                          <span class="comment">//x和y都为左值</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;                                  <span class="comment">//推导出v1为左值引用类型</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;                                <span class="comment">//推导出v2为右值引用类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;  <span class="comment">//可以得出decltype(x)为int，那么就为int&amp;&amp;，是int型的右值引用(不需要推导)，给它赋了一个左值，该语法是错误的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子3</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;                         <span class="comment">//a1为右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;                       <span class="comment">//因为a1本身是一个左值，得到bb是一个int型的左值引用(int&amp; bb)</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;                       <span class="comment">//bb1是一个右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;                           <span class="comment">//a2是左值</span></span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;                         <span class="comment">//a3是左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;                       <span class="comment">//cc是一个左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;                      <span class="comment">//cc1是左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;                  <span class="comment">//s1是常量左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;                 <span class="comment">//s2是常量的右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;                       <span class="comment">//dd是常量的左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;                       <span class="comment">//ee是常量的左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;                   <span class="comment">//常量的右值引用</span></span><br></pre></td></tr></table></figure><p>还有一种情况需要注意，例如在下面程序中，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span>                       <span class="comment">//参数在左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span>                      <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span>                        <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传进来右值后，k为右值引用，但如果对它进行传递，那么它就是左值引用(k为它的名字)</span></span><br><span class="line">    <span class="built_in">printValue</span>(k);                           <span class="comment">//用右值引用进行传递，会被看成是左值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;                     <span class="comment">//i是左值</span></span><br><span class="line">    <span class="built_in">printValue</span>(i);                   <span class="comment">//调用的是左值引用的函数</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);                <span class="comment">//调用的是右值引用的函数</span></span><br><span class="line">    forward(<span class="number">250</span>);                    <span class="comment">//传入参数右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出的结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">l-value: 520</span></span><br><span class="line"><span class="section">r-value: 1314</span></span><br><span class="line"><span class="section">l-value: 250</span></span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</li><li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li><li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型(上面有例子)。</li><li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</li></ul><h1 id="11-转移和完美转发"><a href="#11-转移和完美转发" class="headerlink" title="11. 转移和完美转发"></a>11. 转移和完美转发</h1><h2 id="11-1-move方法"><a href="#11-1-move方法" class="headerlink" title="11.1 move方法"></a>11.1 move方法</h2><p>std::move可以给右值引用进行初始化，把一些左值转换为右值；还有就是可以进行资源的转移，如果某一个对象后面不再被使用了，并且需要拷贝这个对象里面的数据到另一个对象中，这种情况下就可以进行资源转移，减少拷贝的次数，提高析构的允许效果。</p><p>程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//move作用1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;                   <span class="comment">//左值</span></span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// 通过左值对右值引用进行初始化是错误的，会报错</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// 通过move，将左值转换为右值，再对右值引用进行初始化，是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move作用2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">move</span>(a);           <span class="comment">//a失效了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-forward方法"><a href="#11-2-forward方法" class="headerlink" title="11.2 forward方法"></a>11.2 forward方法</h2><p>std::forward()函数实现的功能称之为完美转发。因为当一个<code>右值引用</code>作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，就可以使用forward()方法。</p><blockquote><p>std::forward<T>(t);</T></p><p>当T为左值引用类型时，t将被转换为T类型的左值<br>当T不是左值引用类型时，t将被转换为T类型的右值</p></blockquote><p>测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>对于<span class="built_in">testForward</span>(<span class="number">520</span>);            <span class="comment">//传入的是右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对于<span class="built_in">testForward</span>(num);            <span class="comment">//传入的是左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));   <span class="comment">//因为int不是左值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));   <span class="comment">//因为int&amp;是左值引用类型，参数就被转换为左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));     <span class="comment">//因为int是右值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="12-智能指针"><a href="#12-智能指针" class="headerlink" title="12. 智能指针"></a>12. 智能指针</h1><p>智能指针能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。它的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。它的头文件是<code>#include &lt;memory&gt;</code>。</p><p>C++11中提供了如下三种智能指针：</p><ol><li>std::shared_ptr：共享的智能指针</li><li>std::unique_ptr：独占的智能指针</li><li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ol><h2 id="12-1-共享智能指针"><a href="#12-1-共享智能指针" class="headerlink" title="12.1 共享智能指针"></a>12.1 共享智能指针</h2><p>共享智能指针shared_ptr 是一个模板类，它可以让多个智能指针同时管理同一块有效的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;       <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;      <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;                    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;           <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;             <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;                     <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为2</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                   <span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;         <span class="comment">//调用移动构造函数(ptr1失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);    <span class="comment">//调用移动构造函数(ptr2失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过reset方法，它既可以初始化，也可以重置：对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存(通过make_shared来初始化智能指针)</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);        <span class="comment">//引用计数为1了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;                         <span class="comment">//引用计数为2了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                         <span class="comment">//引用计数为3了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;                         <span class="comment">//引用计数为4了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();       <span class="comment">//重置指针ptr4，原来指向的内存引用计数-1，现在ptr4没有指向任何内存，所以引用计数为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化和使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">m_num = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过构造函数初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过移动构造和拷贝函数初始化</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//移动资源了，ptr1失效了，引用计数为0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr3 = ptr2;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3 use_count:&quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line"><span class="comment">//通过std::make_shared初始化</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line">shared_ptr&lt;Test&gt;ptr5 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">8</span>);                  <span class="comment">//通过int型构造类对象</span></span><br><span class="line">shared_ptr&lt;Test&gt;ptr6 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;hello, world&quot;</span>);     <span class="comment">//通过字符串构造类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过reset初始化</span></span><br><span class="line">ptr6.<span class="built_in">reset</span>();                 <span class="comment">//指针重置，现在ptr6引用计数为0，字符串构成的类对象调用析构函数(没有指针指向它)，</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr6 use_count:&quot;</span> &lt;&lt; ptr6.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//引用计数为0</span></span><br><span class="line">ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>));                                <span class="comment">//原来ptr5指向的对象会调用析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr5 use_count:&quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//初始化指针了，引用计数为1，指向完main，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过智能指针对象取出原始地址，基于原始地址调用函数</span></span><br><span class="line">Test* t = ptr5.<span class="built_in">get</span>();         <span class="comment">//这里是通过智能指针对象调用它所对应的类，该类是shared_ptr类里面提供的标准api，所以是加.</span></span><br><span class="line">t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">t-&gt;<span class="built_in">print</span>();</span><br><span class="line"><span class="comment">//通过智能指针对象直接操作</span></span><br><span class="line">ptr5-&gt;<span class="built_in">setValue</span>(<span class="number">999</span>);      <span class="comment">//这时通过智能指针对象去调用它管理的内存对应的类里面的api函数，就按照指针的方式使用对象，所以加-&gt;</span></span><br><span class="line">ptr5-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定删除器：当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。当然我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为<code>删除器</code>，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">m_num = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">pp</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">39</span>),[](Test* t)&#123;   <span class="comment">//在这里，不手动添加删除器也可以，系统会调用默认的删除器</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//释放内存的操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> t;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt; p1(new Test[5]);     //这样会报错，因为只构造5个对象了，但没有析构对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;     <span class="comment">//这样不会报错</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], [](Test* t) &#123;      <span class="comment">//正确</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">delete</span>[] t;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">    <span class="comment">//调用c++提供的默认删除器函数</span></span><br><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], default_delete&lt;Test[]&gt;())</span></span>;   <span class="comment">//这样也正确，默认删除器要指出删除的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：shared_ptr在通过指针对象去管理一块数组内存的时候，必须手动添加删除器，如果不是数组，智能指针默认提供的删除器就会删除这块内存。</p><h2 id="12-2-独占智能指针"><a href="#12-2-独占智能指针" class="headerlink" title="12.2 独占智能指针"></a>12.2 独占智能指针</h2><p><code>std::unique_ptr</code>是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个<code>unique_ptr</code>赋值给另一个<code>unique_ptr</code>。</p><p>初始化和使用的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">9</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过移动构造函数初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);       <span class="comment">//ptr1失效了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过reset初始化</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">8</span>));                  <span class="comment">//ptr2原来指向的内存被析构了，重新指向了新的内存块</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 ---&gt; 和共享智能指针一样</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    Test* pt = ptr3.<span class="built_in">get</span>();                <span class="comment">//获取原始指针(普通指针)</span></span><br><span class="line">    pt-&gt;<span class="built_in">setValue</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    ptr3-&gt;<span class="built_in">setValue</span>(<span class="number">9</span>);                    <span class="comment">//直接使用指针调用指向的内存块里面的api</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除器：<code>unique_ptr</code>指定删除器和<code>shared_ptr</code>指定删除器是有区别的，<code>unique_ptr</code>指定删除器的时候需要确定删除器的类型，所以它不能像<code>shared_ptr</code>那样直接指定删除器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;  <span class="comment">// 正确的，不需要指定删除器类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;  <span class="comment">// 错误的，没有指定删除器的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//情况1：删除器的[]里面为空，则对应的lambda是函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);             <span class="comment">//定义一个函数指针类型</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;   <span class="comment">//需要在前面指定删除器类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//情况2：删除器的[]里面添加了=，则对应的lambda是仿函数类型，就需要通过可调用对象包装器对其类型进行包装，</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [=](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;        <span class="comment">//这种写法会报错</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);    <span class="comment">//正确的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//独占的智能指针可以管理数组类型的地址，能够自动释放</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//这是正确的</span></span><br><span class="line">    <span class="comment">//在c++11中shared_ptr不支持下面的写法，c++11之后才支持的</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//现在这是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆：对于lambda表达式，[]里面为空，则对应的lambda表达式为函数指针类型；否则为仿函数类型。</p><h2 id="12-3-弱引用智能指针"><a href="#12-3-弱引用智能指针" class="headerlink" title="12.3 弱引用智能指针"></a>12.3 弱引用智能指针</h2><p><code>std::weak_ptr</code>可以看做是<code>shared_ptr</code>的助手，它不管理<code>shared_ptr</code>内部的指针。<code>weak_ptr</code>没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在。</p><p>初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;                <span class="comment">//wp1没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;           <span class="comment">//wp2也没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;            <span class="comment">//wp3是被实例化了</span></span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;                        <span class="comment">//直接通过赋值的方式来初始化(实例化)</span></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;                       <span class="comment">//实例化了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他常用方法：</p><ul><li>通过调用<code>weak_ptr</code>类提供的<code>use_count()</code>方法可以获得当前所观测资源的引用计数。</li><li>通过调用<code>weak_ptr</code>类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，如果观察的资源的引用计数为0了，返回的就是true，否则返回false。</li><li>通过调用<code>weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的<code>shared_ptr</code>对象。</li><li>通过调用<code>weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源。</li></ul><p>演示程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);            <span class="comment">//给sp1管理了一块int类型的内存</span></span><br><span class="line">    wp = sp1;                                    <span class="comment">//初始化了wp，它可以观察sp1管理的内存了</span></span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();                             <span class="comment">//通过wp.lock()返回的共享指针的实例，初始化了sp2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//现在就有2个共享指针指向那块内存了，打印为2</span></span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();                                 <span class="comment">//sp1不管理该内存了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;       <span class="comment">//现在只有sp2管理该内存块，打印1</span></span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();   <span class="comment">//因为wp检测了那块内存还没有被释放，所以还可以返回对应的共享指针对象，实例化sp1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//现在是sp1和sp2两个共享指针管理该内存，打印2</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-4-智能指针的注意事项"><a href="#12-4-智能指针的注意事项" class="headerlink" title="12.4 智能指针的注意事项"></a>12.4 智能指针的注意事项</h2><p><code>shared_ptr</code>使用的注意事项：</p><p>1.<code>不能使用一个原始地址初始化多个共享智能指针</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class Test is disstruct...&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这种情况会报错，因为析构了两次</span></span><br><span class="line">    Test* t = <span class="keyword">new</span> Test;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(t);</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt;ptr2(t);      //这种情况会报错，因为析构了两次</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1;    <span class="comment">//这种就正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<code>函数不能返回管理了this的共享智能指针对象</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);      <span class="comment">//返回一个共享指针对象，管理的是this,即外面new出来的一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();   <span class="comment">//因为里面的this指的是ptr1初始化时的new Test，所以本质上是犯了注意事项1的问题，会报错</span></span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中使用同一个指针this构造了两个智能指针对象ptr1和ptr2，这二者之间是没有任何关系的，因为ptr2并不是通过ptr1初始化得到的实例对象。在离开作用域之后this将被构造的两个智能指针各自析构，导致重复析构的错误。</p><p>这个问题可以通过一个模板类叫做<code>std::enable_shared_from_this&lt;T&gt;</code>来解决，这个类中有一个方法叫做<code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，在该函数的底层就是使用<code>weak_ptr</code>来监测this对象，并通过调用<code>weak_ptr</code>的<code>lock()</code>方法返回一个<code>shared_ptr</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : enable_shared_from_this&lt;Test&gt;&#123;        <span class="comment">//把当前的类型指定在模板类型里面</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();       <span class="comment">//底层是通过弱引用类型对象返回一个share_ptr对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//weak_ptr初始化的地方：在ptr1初始化时，new出了一块内存Test让ptr1来管理，而Test类继承了enable_shared_from_this，那么其里面的weak_ptr被实例化了，指向了ptr1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>共享智能指针不能循环引用</code></p><h1 id="13-POD类型"><a href="#13-POD类型" class="headerlink" title="13. POD类型"></a>13. POD类型</h1><p>POD指的就是普通的旧数据 。它通常用于说明一个类型的属性，尤其是用户自定义类型的属性。</p><p>在C++11中将 POD划分为两个基本概念的合集，即∶<code>平凡的(trivial)</code> 和<code>标准布局的(standard layout)</code>。</p><p>## 13 .1 平凡类型</p><p>一个平凡的类或者结构体应该符合以下几点要求：</p><ol><li>拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor)。</li><li>拥有平凡的拷贝构造函数(trivial copy constructor)和移动构造函数(trivial move constructor)。</li><li>拥有平凡的拷贝赋值运算符(trivial assignment operator)和移动赋值运算符(trivial move operator)。</li><li>不包含虚函数以及虚基类。</li></ol><h2 id="13-2-非受限联合体"><a href="#13-2-非受限联合体" class="headerlink" title="13.2 非受限联合体"></a>13.2 非受限联合体</h2><p>在C++11之前我们使用的联合体是有局限性的，主要有以下三点：</p><ul><li>不允许联合体拥有非POD类型的成员</li><li>不允许联合体拥有静态成员</li><li>不允许联合体拥有引用类型的成员</li></ul><p>在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，规定任何<code>非引用类型</code>都可以成为联合体的数据成员，这样的联合体称之为非受限联合体(Unrestricted Union)。</p><h2 id="13-3-非受限联合体中静态成员的使用"><a href="#13-3-非受限联合体中静态成员的使用" class="headerlink" title="13.3 非受限联合体中静态成员的使用"></a>13.3 非受限联合体中静态成员的使用</h2><p>补充知识：</p><ul><li>如果在联合体里面出现了静态成员变量，那么它的初始化要放到联合体的外面(类和结构体也一样的)</li><li>静态成员是属于类的，而不是属于对象(类和结构体也一样的)</li><li>在联合体里面的静态成员和非静态成员使用的不是同一块内存(类和结构体也一样的)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//不允许出现静态成员(成员变量、成员函数)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t1.num1 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num  value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;        <span class="comment">//结果为3 ---&gt;外部初始化的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num1 value: &quot;</span> &lt;&lt; t1.num1 &lt;&lt; endl;              <span class="comment">//结果为100</span></span><br><span class="line"></span><br><span class="line">    Test t2;</span><br><span class="line">    t2.num = <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t2.num &lt;&lt; endl;   <span class="comment">//结果为50</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;   <span class="comment">//结果为50，静态成员被对象t2修改，t1和t2的静态成员是同一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-4-非受限联合体中非POD类型成员的使用"><a href="#13-4-非受限联合体中非POD类型成员的使用" class="headerlink" title="13.4 非受限联合体中非POD类型成员的使用"></a>13.4 非受限联合体中非POD类型成员的使用</h2><p>在c++11里面规定，如果在非受限联合体中使用了非POD里面的成员，编译器就会自动的删除这个联合体的构造函数和析构函数</p><p>placement new：一般情况下，使用new申请空间时，是从系统的堆(heap)中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做<code>placement new</code>即定位放置 new。</p><p>使用定位放置new申请内存空间：<code>ClassName* ptr = new (定位的内存地址)ClassName;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;         <span class="comment">//将该类定义为非TOB类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>() &#123;&#125;        <span class="comment">//不加这个就是TOB类型的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="built_in">Student</span>() &#123;      <span class="comment">//手动创建一个构造函数</span></span><br><span class="line">        <span class="keyword">new</span> (&amp;name)string;         <span class="comment">//选择一块占用空间最大的变量来定义联合体的内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Teacher t;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s.name = <span class="string">&quot;lxx&quot;</span>;</span><br><span class="line">    s.t.<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);         <span class="comment">//占用的都是同一块空间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.name=&quot;</span> &lt;&lt; s.name &lt;&lt; endl;      <span class="comment">//打印的是hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-5-标准布局的"><a href="#13-5-标准布局的" class="headerlink" title="13.5 标准布局的"></a>13.5 标准布局的</h2><p>标准布局类型主要主要指的是类或者结构体的结构或者组合方式。</p><p>标准布局类型的类应该符合以下五点定义，最重要的为前两条：</p><p>1.所有非静态成员有相同 的访问权限(public，private，protected)</p><ul><li>类成员拥有不同的访问权限(非标准布局类型)</li><li>类成员拥有相同的访问权限(标准布局类型)</li></ul><p>2.在类或者结构体继承时，满足以下两种情况之一∶ </p><ul><li>派生类中有非静态成员，基类中包含静态成员(或基类没有变量)。</li><li>基类有非静态成员，而派生类没有非静态成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span>: <span class="keyword">public</span> Base&#123; <span class="type">int</span> b;&#125;;          <span class="comment">// POD类型，既是平凡类型，也是标准布局类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> &#123; <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child1</span>: <span class="keyword">public</span> Base1&#123; <span class="type">static</span> <span class="type">int</span> c;&#125;; <span class="comment">// POD类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child2</span>:<span class="keyword">public</span> Base, <span class="keyword">public</span> Base1 &#123; <span class="type">static</span> <span class="type">int</span> d;); <span class="comment">// POD类型，子类和基类没有同时出现非静态成员变量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child3</span>:<span class="keyword">public</span> Base1&#123; <span class="type">int</span> d;&#125;;         <span class="comment">// 不满足条件，子类和基类同时出现了非静态成员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child4</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Child     <span class="comment">// 不满足条件。继承的多个基类中，有多个基类有非静态成员</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结论：非静态成员只要同时出现在派生类和基类间，即不属于标准布局。对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。</p><p>3.子类中第一个非静态成员的类型与其基类不同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="type">static</span> <span class="type">int</span> a;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Child</span>: <span class="keyword">public</span> Base&#123; </span><br><span class="line">    Base p;       <span class="comment">//Base p放到这里不是POD类型，如果放到int b之后，就是POD类型</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.没有虚函数和虚基类</p><p>5.所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义</p><h2 id="14-扩展的-friend-语法"><a href="#14-扩展的-friend-语法" class="headerlink" title="14. 扩展的 friend 语法"></a>14. 扩展的 friend 语法</h2><p>friend关键字用于声明类的友元，友元可以无视类中成员的属性(public、protected 或是 private)，友元类或友元函数都可以访问，这样虽然完全破坏了面向对象编程中封装性的概念。但有的时候friend关键字确实会让程序少写很多代码。</p><h2 id="14-1-语法改进"><a href="#14-1-语法改进" class="headerlink" title="14.1 语法改进"></a>14.1 语法改进</h2><p>声明一个类为另外一个类的友元时，不再需要使用class关键字，并且还可以使用类的别名(使用 typedef 或者 using 定义)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span>;                   <span class="comment">//先申明有该类</span></span><br><span class="line"><span class="keyword">using</span> Honey = Tom;           <span class="comment">//定义一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jack</span> &#123;</span><br><span class="line">    <span class="comment">//friend class Tom;           //c++98标准</span></span><br><span class="line">    <span class="keyword">friend</span> Tom;                   <span class="comment">//c++11标准</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lucy</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> Honey;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string name = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; j.name &lt;&lt; endl &lt;&lt; l.name &lt;&lt; endl;</span><br><span class="line">        j.<span class="built_in">print</span>();</span><br><span class="line">        l.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Jack j;</span><br><span class="line">    Lucy l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tom t;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-命名空间this-thread"><a href="#14-命名空间this-thread" class="headerlink" title="14. 命名空间this_thread"></a>14. 命名空间this_thread</h1><p><code>std::this_thread</code>是关于线程的命名空间，在这个命名空间中提供了四个公共的成员函数，通过这些成员函数就可以对当前线程进行相关的操作了。</p><h2 id="14-1-get-id"><a href="#14-1-get-id" class="headerlink" title="14. 1 get_id()"></a>14. 1 get_id()</h2><p>std::this_thread中的get_id()方法可以得到当前线程的线程ID。测试程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;     <span class="comment">//得到当前线程的线程ID(子线程)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;     <span class="comment">//得到当前线程的线程ID(主线程)</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;           <span class="comment">//指定的函数func()会在子线程中执行</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-2-sleep-for"><a href="#14-2-sleep-for" class="headerlink" title="14.2 sleep_for()"></a>14.2 sleep_for()</h2><p>与进程一样，线程被创建后也有五种状态：<code>创建态</code>，<code>就绪态</code>，<code>运行态</code>，<code>阻塞态(挂起态)</code>，<code>退出态(终止态)</code>。</p><p>众所周知的，在计算机中启动的多个线程都需要占用CPU资源，但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。为了能够实现并发处理，多个线程都是<code>分时复用</code>CPU时间片，快速的交替处理各个线程中的任务。因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行(因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况)。</p><p>而sleep_for()是用于让线程休眠的函数，调用这个函数的线程会马上从<code>运行态</code>变成<code>阻塞态</code>并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。这个函数的参数需要指定一个休眠时长，是一个时间段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));       <span class="comment">//休息1s</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：程序休眠完成之后，会从<code>阻塞态</code>重新变成<code>就绪态</code>，<code>就绪态</code>的线程需要再次争抢CPU时间片，抢到之后才会变成<code>运行态</code>，这时候程序才会继续向下运行。</p><h2 id="14-3-sleep-until"><a href="#14-3-sleep-until" class="headerlink" title="14.3 sleep_until()"></a>14.3 sleep_until()</h2><p><code>sleep_until()</code>也是一个休眠函数，它是指定线程阻塞到某一个指定的时间点(time_point类型)，之后解除阻塞。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();         <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">        <span class="function">chrono::seconds <span class="title">sec</span><span class="params">(<span class="number">2</span>)</span></span>;                         <span class="comment">// 时间间隔为2s</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_until</span>(now + sec);            <span class="comment">// 在当前时间点之后休眠两秒</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-4-yield"><a href="#14-4-yield" class="headerlink" title="14.4 yield()"></a>14.4 yield()</h2><p>当线程中调用这个函数<code>yield()</code>之后，如果它正处于运行态，那么它会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。需要注意的是，线程调用了<code>yield()</code>之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;子线程: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li>yield() 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降</li><li>yield() 是让当前线程主动放弃了当前自己抢到的CPU资源，但是在下一轮还会继续抢</li></ul><h1 id="15-线程类"><a href="#15-线程类" class="headerlink" title="15. 线程类"></a>15. 线程类</h1><blockquote><p>可执行文件的运行过程：如果在磁盘上有一个可执行的文件a.exe(占用的是硬盘资源)，双击该文件，就可以得到一个应用程序(占用内存和cpu资源)，将该应用程序称为进程。这个进程在物理内存里面占一块虚拟地址空间，相对于应用程序来说只能算一个中转站，是我们把程序启动起来之后，程序里面所有的数据被加载到这块虚拟地址空间里面，然后通过cpu里面的MMU(cpu里面的内存管理单元)，它会把虚拟地址空间里面的数据映射到物理内存的另外一个位置。</p></blockquote><p>每一个启动起来的进程都对应一块虚拟空间，其由两部分组成，一部分是内核区，一部分是用户区。如果是多进程，每个进程都对应一个虚拟地址空间。比如说进程1创建了一个新的进程2，在操作系统里面就会额外的再次分配一个虚拟地址空间。每个进程都对应一个虚拟地址空间。如果是线程的话，不会创建额外的虚拟地址空间，即多个线程是共用同一个虚拟地址空间的。</p><p>虚拟内存空间是虚拟的，一个进程存储的数据都是存储在虚拟内存映射的那块物理内存中，作用就是保护数据，确保进程之间的隔离，提高系统的安全性和稳定性，其中磁盘作为辅助。具体来说，当进程访问虚拟地址时，操作系统会将这些地址映射到实际的物理内存地址中，物理内存满了的话，就会将物理内存的一些不常用的数据存到磁盘，从而空出多余的内存空间。我们通过代码打印出来的地址都是物理内存里面分配的虚拟空间地址。</p><p>虚拟内存地址到物理内存地址的映射是通过分页或分段等机制来实现的，当通过虚拟地址空间写入数据时，如果对应的虚拟页在物理内存中，则直接在物理内存中进行修改。如果物理内存满了，操作系统会将不常用的页面换出到磁盘，确保有足够的内存用于当前的写入操作。</p><h2 id="15-1-线程初始化"><a href="#15-1-线程初始化" class="headerlink" title="15.1 线程初始化"></a>15.1 线程初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是子线程，叫做lxx...&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(string name, <span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是子线程，叫做&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;,age:&quot;</span> &lt;&lt; age &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//1.创建空的线程对象</span></span><br><span class="line">    thread t1;</span><br><span class="line">    <span class="comment">//2.创建一个可用的子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">    <span class="comment">//3.创建一个带参数的可用子线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(func1, <span class="string">&quot;罗罗诺亚&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="comment">//4.创建一个匿名函数的子线程(带一个参数)</span></span><br><span class="line">    <span class="function">thread <span class="title">t4</span><span class="params">([=](<span class="type">int</span> id) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout &lt;&lt; <span class="string">&quot;arg id:&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;thread id:&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;,<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="comment">//5.通过移动构造的方式创建子线程</span></span><br><span class="line">    thread t5 = <span class="built_in">move</span>(t4);</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    t5.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-2-常用的成员函数"><a href="#15-2-常用的成员函数" class="headerlink" title="15.2 常用的成员函数"></a>15.2 常用的成员函数</h2><p>1.<code>get_id()</code>：每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的。通过该函数可用获取线程的ID。</p><p>2.<code>join()</code>：调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。</p><p>3.<code>detach()</code>：因为在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。</p><p>4.<code>joinable()</code>：该函数用于判断主线程和子线程是否处于关联(连接)状态，一般情况下，二者之间的关系处于关联状态，会返回一个true，否则返回一个false。</p><p>5.<code>thread::hardware_concurrency()</code>：用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程。</p><h2 id="15-3-类的成员函数作为子线程的任务函数"><a href="#15-3-类的成员函数作为子线程的任务函数" class="headerlink" title="15.3 类的成员函数作为子线程的任务函数"></a>15.3 类的成员函数作为子线程的任务函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMsg</span><span class="params">(string name, <span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我的名字是：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;,今年 &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot;岁了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是罗罗诺亚!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello，欢迎来到新世界!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;                <span class="comment">//普通函数作为任务函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递静态成员函数</span></span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::message)</span></span>;      <span class="comment">//只需要指明静态函数属于的类，传入其地址即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传递非静态成员函数</span></span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(&amp;Base::showMsg, b, <span class="string">&quot;卡卡罗特&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="comment">//thread t3(&amp;Base::showMsg, &amp;b, &quot;卡卡罗特&quot;, 23);        //也可用区b的地址</span></span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(bind(&amp;Base::showMsg, b, <span class="string">&quot;卡卡罗特&quot;</span>, <span class="number">23</span>))</span></span>;    <span class="comment">//通过仿函数传入，b也可用取地址</span></span><br><span class="line"></span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br><span class="line">t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-call-once"><a href="#16-call-once" class="headerlink" title="16. call_once"></a>16. call_once</h1><p>在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次，就可以使用<code>std::call_once()</code>来保证函数在多线程环境下只能被调用一次。特别注意的是，在使用<code>call_once()</code>的时候，需要一个<code>once_flag</code>作为<code>call_once()</code>的传入参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">once_flag g_flag;                  <span class="comment">//定义一个全局的once_flag变量，保证所有的线程都能访问到它</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_once</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">(<span class="type">int</span> age, string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">call_once</span>(g_flag, do_once, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);     <span class="comment">//call_once的do_once()函数只会被调用1次</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;do_something() function num = &quot;</span> &lt;&lt; num++ &lt;&lt; endl;    <span class="comment">//每个线程都会调用这个多次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;ace&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(do_something, <span class="number">20</span>, <span class="string">&quot;sabo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(do_something, <span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">name: luffy, age: 19</span></span><br><span class="line">do_something() function num = 1</span><br><span class="line">do_something() function num = 2</span><br><span class="line">do_something() function num = 3</span><br></pre></td></tr></table></figure><p>应用：实现单例模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个单例模式的类 ---&gt; 懒汉模式</span></span><br><span class="line">once_flag g_flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="type">const</span> Base&amp; obj) = <span class="keyword">delete</span>;                 <span class="comment">//拷贝构造显示的删除(也可用设为私有)</span></span><br><span class="line">Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; obj) = <span class="keyword">delete</span>;      <span class="comment">//拷贝赋值显示的删除</span></span><br><span class="line"><span class="comment">//获取单例类的对象</span></span><br><span class="line"><span class="function"><span class="type">static</span> Base* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                    <span class="comment">//静态函数能够访问的成员只能是静态成员</span></span><br><span class="line"><span class="comment">//被call_once管理的这个匿名函数所对应的处理动作只会被调用1次</span></span><br><span class="line"><span class="built_in">call_once</span>(g_flag, [&amp;]() &#123;</span><br><span class="line">obj = <span class="keyword">new</span> Base;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;实例对象被创建.....&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;&#125;;</span><br><span class="line"><span class="type">static</span> Base* obj;                            <span class="comment">//将单例对象设为静态的</span></span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line">Base* Base::obj = <span class="literal">nullptr</span>;                <span class="comment">//静态成员的初始化要放到外面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">Base::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">setName</span>(name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;my name is: &quot;</span> &lt;&lt; Base::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(myFunc, <span class="string">&quot;路飞&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(myFunc, <span class="string">&quot;艾斯&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t3</span><span class="params">(myFunc, <span class="string">&quot;萨博&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t4</span><span class="params">(myFunc, <span class="string">&quot;索隆&quot;</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">t3.<span class="built_in">join</span>();</span><br><span class="line">t4.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-C-线程同步之互斥锁"><a href="#17-C-线程同步之互斥锁" class="headerlink" title="17. C++线程同步之互斥锁"></a>17. C++线程同步之互斥锁</h1><p>解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，也可以称为互斥量，其头文件是<code>#include &lt;mutex&gt;</code>，在C++11中一共提供了四种互斥锁：</p><ul><li><code>std::mutex</code>：独占的互斥锁，不能递归使用</li><li><code>std::timed_mutex</code>：带超时的独占互斥锁，不能递归使用</li><li><code>std::recursive_mutex</code>：递归互斥锁，不带超时功能</li><li><code>std::recursive_timed_mutex</code>：带超时的递归互斥锁</li></ul><h2 id="17-1-std-mutex"><a href="#17-1-std-mutex" class="headerlink" title="17.1 std::mutex"></a>17.1 std::mutex</h2><p>成员函数：</p><p>1.<code>lock()</code>：函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用。</p><p>2.<code>try_lock()</code>：获取互斥锁的所有权并对互斥锁加锁，它与lock()区别在于try_lock()不会阻塞线程，lock()会阻塞线程。</p><ul><li>如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true</li><li>如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false</li></ul><p>3.<code>unlock()</code>：给锁定的互斥锁解锁，只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。</p><blockquote><p> 线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问效率降低了，但是保证了数据的正确性。</p></blockquote><p>特别需要注意的是：当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行++操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">++number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));             <span class="comment">//休眠0.5s</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行--操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">--number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number = <span class="number">999</span>;</span><br><span class="line">mutex mx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::decrement, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-2-std-lock-guard"><a href="#17-2-std-lock-guard" class="headerlink" title="17.2 std::lock_guard"></a>17.2 std::lock_guard</h2><p><code>lock_guard</code>在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记<code>unlock()</code>操作而导致线程死锁。<code>lock_guard</code>使用了<code>RAII</code>技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。</p><p>使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;               <span class="comment">//对成员变量进行--操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mx)</span></span>;     <span class="comment">//创建了一个guard对象    </span></span><br><span class="line">                --number;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">            &#125;                                    <span class="comment">//声明周期结束，自动析构，解锁</span></span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-3-std-recursive-mutex"><a href="#17-3-std-recursive-mutex" class="headerlink" title="17.3 std::recursive_mutex"></a>17.3 std::recursive_mutex</h2><p>递归互斥锁<code>std::recursive_mutex</code>允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">mx.<span class="built_in">lock</span>();</span><br><span class="line">++number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">mx.<span class="built_in">unlock</span>();</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>));             <span class="comment">//休眠0.5s</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">&#123;</span><br><span class="line">lock_guard&lt;recursive_mutex&gt;<span class="built_in">lock_guard</span>(mx);   <span class="comment">//使用递归互斥锁(如果使用的不是递归互斥锁，该程序会报错)</span></span><br><span class="line"><span class="built_in">increment</span>(<span class="number">2</span>);</span><br><span class="line">--number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---current number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">this_thread::<span class="built_in">yield</span>();       <span class="comment">//放弃抢夺时间片，开始下一轮的的抢夺</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number = <span class="number">999</span>;</span><br><span class="line">recursive_mutex mx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::decrement, &amp;b, <span class="number">10</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-4-std-timed-mutex"><a href="#17-4-std-timed-mutex" class="headerlink" title="17.4 std::timed_mutex"></a>17.4 std::timed_mutex</h2><p><code>std::timed_mutex</code>是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。</p><h1 id="18-原子变量atomic"><a href="#18-原子变量atomic" class="headerlink" title="18. 原子变量atomic"></a>18. 原子变量atomic</h1><p>C++11提供了一个原子类型<code>std::atomic&lt;T&gt;</code>，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给原子类型指定<code>bool</code>、<code>char</code>、<code>int</code>、<code>long</code>、<code>指针</code>等类型作为模板参数。</p><p>测试程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>(<span class="type">int</span> n, string s) : <span class="built_in">age</span>(n), <span class="built_in">name</span>(s) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">atomic&lt;<span class="type">char</span>&gt;<span class="built_in">c</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="function">atomic_char <span class="title">cc</span><span class="params">(<span class="string">&#x27;b&#x27;</span>)</span></span>;       <span class="comment">//效果与上面这种写法一样</span></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"><span class="built_in">atomic_init</span>(&amp;b, <span class="number">9</span>);       <span class="comment">//对b进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">cc = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">b.<span class="built_in">store</span>(<span class="number">88</span>);</span><br><span class="line"><span class="type">char</span> ccc = c.<span class="built_in">exchange</span>(<span class="string">&#x27;e&#x27;</span>);         <span class="comment">//c现在存储的是e,exchange返回原来存的内容a,即ccc是a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function">Base <span class="title">base</span><span class="params">(<span class="number">123</span>, <span class="string">&quot;luffy&quot;</span>)</span></span>;</span><br><span class="line">atomic&lt;Base*&gt;<span class="built_in">atc_base</span>(&amp;base);        <span class="comment">//原子类型的模板类可以是指针类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c value: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ccc value: &quot;</span> &lt;&lt; ccc &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b value: &quot;</span> &lt;&lt; b.<span class="built_in">load</span>() &lt;&lt; endl;</span><br><span class="line">Base* tmp = atc_base.<span class="built_in">load</span>();        <span class="comment">//取出地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; tmp-&gt;name &lt;&lt; <span class="string">&quot;,age: &quot;</span> &lt;&lt; tmp-&gt;age &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>局限性：使用原子变量的时候，它不能够保护复合类型，比如说<code>atomic&lt;Base*&gt; base</code>，现在base里面存储的就是Base类的指针，Base原子变量里面现在不能保护base这块指针指向的内存块里面的数据安全，它只能保护这个指针做算术运算时的线程安全，即将地址做移动时安全。</p></blockquote><p>原子变量处理线程同步：使用原子变量或互斥量对公共资源进行处理，可以达到数据同步的效果，即以下程序最后可以刚好将number加到200，否则，可能小于200。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">number++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;+++ increment thread id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;,number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>)); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">number++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*** increment1 thread id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;,number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">atomic_int number = <span class="number">0</span>;       <span class="comment">//把一个整形数放到原子变量的类对象里面</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base b;</span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(&amp;Base::increment, &amp;b)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">t2</span><span class="params">(&amp;Base::increment1, &amp;b)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-原始自变量&quot;&gt;&lt;a href=&quot;#1-原始自变量&quot; class=&quot;headerlink&quot; title=&quot;1. 原始自变量&quot;&gt;&lt;/a&gt;1. 原始自变量&lt;/h1&gt;&lt;p&gt;定义原始字符串的方式为：R “xxx(原始字符串)xxx”，其中()两边的字符串可以省略(不省略</summary>
      
    
    
    
    <category term="必备技能" scheme="https://lxx93.online/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>Http高并发服务器项目</title>
    <link href="https://lxx93.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/"/>
    <id>https://lxx93.online/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-08-20T14:09:56.000Z</published>
    <updated>2024-08-23T06:22:20.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。</p><p>过程：</p><p>客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会自动下载到本地，如果能够展示，它在本地指定的下载目录是不会又对应文件的，因为它下载到本地之后，就直接将内容显示到窗口上了，可以理解为它下载下来的只是一个缓存，该缓存能够支撑它在浏览器上把内容显示出来，当数据显示完成之后，浏览器会定期地清除缓存，那么该资源也就不存在了。</p><h1 id="2-单反应堆的服务器模型"><a href="#2-单反应堆的服务器模型" class="headerlink" title="2. 单反应堆的服务器模型"></a>2. 单反应堆的服务器模型</h1><p>在网络编程中，为了提高访问通信的效率，就可以使用单反应堆的服务器模型，它是IO多路复用与多线程相结合的一种技术。</p><p>设计思路：</p><p>在主线程里面，服务器绑定本地的ip和端口来得到一个通信的套接字，因为通信的套接字需要监听它的读事件，所以就将它的读事件注册给Reactor，也就是反应堆模型。该反应堆模型底层用到的是poll、epoll或select，这三种IO多路转接技术不是同时用，而是选择其中的某一种。在选择了底层的IO模型之后，把用于监听的文件描述符的读事件注册给该模型，然后内核就可以帮助我们检测这用于监听的文件描述符的读事件是否被激活了。如果被激活了，说明有新连接到达，那么我们就需要调用用于监听的文件描述符对应的处理函数，该处理函数其实就是负责与对端建立新连接，主要的处理核心动作核就是调用accept()函数，因此就能得到一个用于通信的文件描述符，然后对该通信描述符进行一个封装。在封装的时候，给该用于通信的文件描述符指定了读回调和写回调，至于为什么要指定读写回调，是因为反应堆模型就是基于回调的。TcpConnection模型当检测到了对应的文件描述符它的读事件或写事件被触发了之后，该框架就会自动的调用这个事件的处理函数，这种机制就称为反应堆机制。其实本质就是回调函数。</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_10.png" style="zoom:67%;"><h1 id="3-多反应堆的服务器模型"><a href="#3-多反应堆的服务器模型" class="headerlink" title="3. 多反应堆的服务器模型"></a>3. 多反应堆的服务器模型</h1><p>对于多反应堆模型，反应堆的数量取决于线程的数量。</p><p>在主线程里面，它是有一个用于监听的套接字Listener，我们需要将它注册给主线程的MainReactor反应堆模型。在主线程的反应堆模型里面可以选择poll、epoll或select，它们就能帮助我们检测对应的监听文件描述符的读事件是否被触发。如果被触发了，就需要建立一个新连接，调用accept()函数得到一个新的用于通信的文件描述符connfd。然后对它进行封装，封装时为它指定一个读回调和写回调。又因为这是一个多反应堆模型，在得到了用于通信的套接字之后，就不要在主线程里面做通信了，把通信交给主线程的线程池，在主线程的线程池里面有多个子线程，每个子线程里面也有一个反应堆模型，该反应堆模型里面主要就是指定的IO多路转接poll、epoll或select。</p><p>然后我们只需要把用于通信的文件描述符的事件注册给到对应的子线程的反应堆模型(随机给的)，因为这个过程是做了注册的，所以当用于通信的套接字，它的读事件或写事件触发了，对应的回调函数就会知道。当真正的事件被触发之后，子线程里的反应堆模型就会调用响应的处理函数。</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_11.png" style="zoom:67%;"><h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-http请求"><a href="#4-1-http请求" class="headerlink" title="4.1 http请求"></a>4.1 http请求</h2><p>属于应用层协议，位于最上层，通过这个协议就可以对通信的数据进行封装。如果网络模型是B&#x2F;S结构，就必须使用<code>http</code>协议，<code>https</code>协议是在<code>http</code>协议的基础上做了加密。</p><p>在数据发送之前，使用协议对数据进行封装，接收到数据之后，按照协议格式解析接收到的数据。</p><p>Http协议分为两部分：</p><p>1.http请求</p><ul><li><p>客户端给服务器发送数据，叫<code>http</code>请求，有两种请求方式</p><ul><li><p>get请求</p></li><li><p>post请求</p></li></ul></li></ul><p>2.http响应</p><ul><li>服务器给客户端回复数据叫做<code>http</code>响应</li></ul><p><code>http</code>协议封装好数据之后是一个数据块，得到若干行数据，使用的换行符是<code>\r\n</code>。通过这个<code>\r\r</code>进行判断，就知道这行是否结束了。</p><blockquote><p>http请求消息分为四部分：</p><p>1.请求行</p><ul><li>不管get请求还是post请求，请求行是分为三部分</li></ul><p>2.请求头</p><p>3.空行</p><p>4.客户端向服务器提交的数据</p></blockquote><p>如果使用get方式提交数据，第四部分是空的。</p><p>get与post分析比较:</p><ol><li><p>从给服务器发送的数据的量上来分析</p><ul><li>get：主要是向服务器索取数据，提交的数据量比较少</li><li>post：上传文件一般都会使用post，可以提交的数据量是非常大的</li></ul></li><li><p>从上传的数据安全性来分析</p><ul><li>get：提交的数据不安全，提交的数据会显示到地址栏中，数据容易被泄露</li><li>post：提交的数据并不会显示到地址栏中，完全不可见的，因此更安全</li></ul></li></ol><h2 id="4-2-get请求"><a href="#4-2-get请求" class="headerlink" title="4.2 get请求"></a>4.2 get请求</h2><p>下面是浏览器对用户的请求数据进行了封装之后，得到的原始的http请求数据：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93:9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><p>第1行是请求行：分为3部分，</p><ul><li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p></li><li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p></li><li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p></li></ul><p>第2-8行是请求头：由若干个键值对组成：</p><ul><li><p>Host表示要连接的服务器是192.168.88.93，绑定的端口是9393；</p></li><li><p>Connection的keep-alive表示客户端想要与服务器一直保持连接</p></li><li><p>User-Agent表示浏览器的版本，指的是内核版本</p></li><li><p>Accept-Encoding设置压缩的方式使用的是gzip</p></li><li><p>Accept-Language设置默认的语言</p></li></ul><p>注意：如果我们使用的是get请求，并且get请求里面携带了一些动态数据，这些数据会出现在浏览器的地址栏里面，而该地址栏它的缓存是有上限的，因此如果携带的数据量很多，后面的数据就会丢失。</p><p>第9行是空行，空行完之后，就是通过这个请求协议给服务器提交的数据。如果是get请求，这部分内容是空的。因为如果通过get请求向服务器提交动态数据，这个动态数据也不会出现在请求协议的第4部分，而是出现在请求行的第2部分，即：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_12.png" style="zoom:67%;"><h2 id="4-3-post请求"><a href="#4-3-post请求" class="headerlink" title="4.3 post请求"></a>4.3 post请求</h2><p>下面是post请求数据的格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93：9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>98</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">username</span>=subwen%<span class="number">40</span>qq.com&amp;phon=<span class="number">111111</span>&amp;email=sub%<span class="number">40</span>qq.com&amp;date=<span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>&amp;sex=male&amp;class=<span class="number">1</span>&amp;rule=<span class="literal">on</span></span></span><br></pre></td></tr></table></figure><p>如果我们通过post向服务器提交数据，那么这个数据肯定是动态的，即请求的数据在服务器上是不存在的。如注册账号，向服务器提供用户名和密码等信息。</p><p>第1行是请求行：分为3部分，</p><ul><li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p></li><li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p></li><li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p></li></ul><p>第2-12行是请求头：由若干个键值对组成：</p><ul><li>Content-Length表示提交的内容长度</li><li>Content-Type表示客户端向服务器提交的数据块的格式(还有其它很多种格式)</li></ul><p>第13行是空行\r\n</p><p>第14行是客户端向服务器提交的数据块</p><h2 id="4-4-http响应"><a href="#4-4-http响应" class="headerlink" title="4.4 http响应"></a>4.4 http响应</h2><blockquote><p>服务器给客户端回复数据，称之为http响应，协议的格式分为四部分：：<br>1.状态行</p><p>2.消息报头&#x2F;响应头</p><p>3.空行</p><p>4.回复给客户端的数据块</p><ul><li>http响应消息也是一个数据块，若干行组成，换行是\r\n</li></ul></blockquote><p>响应消息(Response)</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Http/1.1 200 Ok</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>micro_httpd</span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Fri, 18 Jul 2014 14:34:26 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain; charset=iso-8859-1 (必选项)</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>32</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://www.lxx93.online</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>zh-CN</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 18 Jul 2014 08:36:36 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1行是状态行，分为3部分：</p><ol><li><p>Http的版本</p></li><li><p>服务器对客户端请求的处理状态(状态码)，200就代表处理成功了</p></li><li><p>是对状态码的描述</p></li></ol><p>第2到9行是响应头，由一系列的键值对组成：</p><ul><li>Content-Type：表示的是http响应消息，响应的数据块的格式，text&#x2F;plain代表的是一个纯文本，charset表示使用的字符编码</li><li>Content-Length：表示服务器给客户端回复的数据块的大小(要准确，不确定的话就不写)</li></ul><p>第10行是空行</p><p>第11到16行是http响应给客户端的信息</p><p>http状态码类别：</p><p>状态码有三位数字组成，第一个数字定义了响应的类别，共分5种类别：</p><ul><li>1xx：指示信息–表示请求已经被接收，没有处理完，还正在处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作(网络地址的重新访问)</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul><p>常见的状态码：</p><table><thead><tr><th align="center">状态码</th><th align="center">状态描述</th><th align="center">文字描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td align="center">客户端请求成功</td></tr><tr><td align="center">400</td><td align="center">Bad Request</td><td align="center">客户端请求有语法错误，不能被服务器所理解</td></tr><tr><td align="center">401</td><td align="center">Unauthorized</td><td align="center">请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用</td></tr><tr><td align="center">403</td><td align="center">Forbidden</td><td align="center">服务器收到请求，但是拒绝提供服务</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">请求资源不存在，如：输入了错误的URL</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器发送不可预期的错误</td></tr><tr><td align="center">503</td><td align="center">Server Unavailable</td><td align="center">服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td></tr></tbody></table><p>整个处理流程：</p><p>首先调用threadPoolInit()函数，得到线程池的实例，得到该实例后，调用threadPoolRun()把线程池启动起来，即把线程池里面的子线程启动起来。然后就可以通过takeWorkerEventLoop()从线程池里面取出某一个子线程，得到子线程就能够得到对应的反应堆evLoop实例，将其返回给函数的调用者。调用者就可以通过这个evLoop实例往它的任务队列里面添加任务，当任务添加到evLoop对应的任务队列过后，就可以开始处理这个任务队列了，再根据这个任务队列节点的类型来处理这个dispatcher的检测集合。有3种情况，第1种是往检测集合里面添加新的节点；第2种是往检测集合里面删除节点；第3种情况就是修改检测集合里面某个文件描述符对应的事件。dispatcher这个检测集合处理完毕之后，对应的反应堆模型就开始进行循环了，它需要循环的调用底层的poll、epoll_wait或select来检测这个集合里面有没有激活的文件描述符。如果有激活的文件描述符，那么就通过这个文件描述符找到对应的channel，找到chennel后，然后再基于激活的事件，调用事件对应的回调函数，该回调函数调用完之后，对应的事件也就处理完毕了。</p><h1 id="5-多反应堆-线程池高并发服务器"><a href="#5-多反应堆-线程池高并发服务器" class="headerlink" title="5. 多反应堆+线程池高并发服务器"></a>5. 多反应堆+线程池高并发服务器</h1><h2 id="5-1-反应堆模型"><a href="#5-1-反应堆模型" class="headerlink" title="5.1 反应堆模型"></a>5.1 反应堆模型</h2><h2 id="5-2-多线程"><a href="#5-2-多线程" class="headerlink" title="5.2 多线程"></a>5.2 多线程</h2><h2 id="5-3-I-O模型的Buffer"><a href="#5-3-I-O模型的Buffer" class="headerlink" title="5.3 I&#x2F;O模型的Buffer"></a>5.3 I&#x2F;O模型的Buffer</h2><h2 id="5-4-服务器TcpServer"><a href="#5-4-服务器TcpServer" class="headerlink" title="5.4 服务器TcpServer"></a>5.4 服务器TcpServer</h2><h2 id="5-5-服务器Listener"><a href="#5-5-服务器Listener" class="headerlink" title="5.5 服务器Listener"></a>5.5 服务器Listener</h2><h2 id="5-6-I-O模型的TcpConnection"><a href="#5-6-I-O模型的TcpConnection" class="headerlink" title="5.6 I&#x2F;O模型的TcpConnection"></a>5.6 I&#x2F;O模型的TcpConnection</h2><p>流程：</p><p>从main()函数开始，先通过函数tcpServerInit()创建一个服务器的实例，并设置了主线程启动后，它线程池里面的子线程个数为4，这样就得到了一个服务器的实例对象server，随后就可以调用它的一个Run方法了。</p><p>在启动服务器的时候，就是把线程池启动起来，并且把用于监听的套接字用于封装，然后把它放到了当前主线程对应的反应堆模型里面，之后主线程的反应堆模型就运行起来了，那么它底层的pool、epool或select也就运行起来了。它就可以检测监听描述符lfd里面的事件，这里是指读事件。如果有新的客户端连接，读事件就触发了，然后读回调函数acceptConnection就被调用了。</p><p>在读回调函数acceptConnection里，它第一件事就是和客户端建立连接得到了一个通信的文件描述符，然后从主线程里面取出了一个子线程，并且把子线程的反应堆模型evLoop取出来，然后把用于通信的文件描述符放到了evLoop里面。在tcpConnectionInit()函数里面，其实就是把cfd进行了封装，最终得到了一个新的channel，然后把这个channel放到了evLoop子线程的反应堆模型里面。</p><p>总的来说，就是当主线程建立连接之后，它并不会去处理与客户端的通信，和客户端的通信全都是在子线程里面处理的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;该项目的架构是B&amp;#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Http" scheme="https://lxx93.online/tags/Http/"/>
    
    <category term="linux" scheme="https://lxx93.online/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Qt斗地主项目(下)</title>
    <link href="https://lxx93.online/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/"/>
    <id>https://lxx93.online/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/</id>
    <published>2024-08-08T09:24:35.000Z</published>
    <updated>2024-08-24T15:15:10.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-结束面板窗口类EndingPanel"><a href="#1-结束面板窗口类EndingPanel" class="headerlink" title="1. 结束面板窗口类EndingPanel"></a>1. 结束面板窗口类EndingPanel</h1><p>结束面板窗口类是用于在当一个玩家打完自己手中的牌时，也就意味着游戏结束。当结束的时候，会在主窗口的正中间跳入一个结束面板窗口，上面记录了各个玩家的得分。</p><p>结束分数面板窗口类：新建、c++、c++clase、类名为EndignPanel，基类为QWidget。</p><h2 id="1-1-EndingPanel类头文件"><a href="#1-1-EndingPanel类头文件" class="headerlink" title="1.1 EndingPanel类头文件"></a>1.1 EndingPanel类头文件</h2><p>结束面板窗口类的头文件主要就是定义一些有关结束面板的私有变量，如背景、按钮等。同时也定义一个关于是否继续游戏的信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EndingPanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EndingPanel</span><span class="params">(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取玩家的得分，并显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">continueGame</span><span class="params">()</span></span>;               <span class="comment">//添加一个自定义信号(点击继续按钮时，发出该信号)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_bk;                     <span class="comment">//结束面板的背景</span></span><br><span class="line">    QLabel* m_title;                  <span class="comment">//地主赢或输、农民赢或输的标签</span></span><br><span class="line">    ScorePanel *m_score;              <span class="comment">//之前创建的分数窗口</span></span><br><span class="line">    QPushButton* m_continue;          <span class="comment">//继续游戏按钮</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-EndingPanel类函数实现"><a href="#1-2-EndingPanel类函数实现" class="headerlink" title="1.2 EndingPanel类函数实现"></a>1.2 EndingPanel类函数实现</h2><p>这部分就是对头文件定义的函数实现，通过构造函数，直接初始化完结束面板窗口上的所有内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">EndingPanel::<span class="built_in">EndingPanel</span>(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_bk.<span class="built_in">load</span>(<span class="string">&quot;:/images/gameover.png&quot;</span>);            <span class="comment">//先把结束面板加载出来</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_bk.<span class="built_in">size</span>());                     <span class="comment">//设置大小为图片大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示用户玩家的角色以及游戏状态</span></span><br><span class="line">    m_title = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                    <span class="comment">//创建一个标签</span></span><br><span class="line">    <span class="keyword">if</span>(isLord &amp;&amp; isWin)&#123;                           <span class="comment">//如果用户是地主，且赢了，就在标签上加载对应的图</span></span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLord &amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_fail.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_fail.png&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    m_title-&gt;<span class="built_in">move</span>(<span class="number">125</span>,<span class="number">125</span>);                <span class="comment">//标签显示位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分数面板</span></span><br><span class="line">    m_score = <span class="keyword">new</span> <span class="built_in">ScorePanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">move</span>(<span class="number">75</span>, <span class="number">230</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">setFixedSize</span>(<span class="number">260</span>, <span class="number">160</span>);              <span class="comment">//设置结束面板中，显示分数面板的大小</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontColor</span>(ScorePanel::Red);     <span class="comment">//设置字体颜色为红色</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontSize</span>(<span class="number">18</span>);                   <span class="comment">//设置字体大小为8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续游戏按钮</span></span><br><span class="line">    m_continue = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_continue-&gt;<span class="built_in">move</span>(<span class="number">84</span>, <span class="number">429</span>);</span><br><span class="line">    QString style = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            QPushButton&#123;border-image: url(:/images/button_normal.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:hover&#123;border-image: url(:/images/button_hover.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:pressed&#123;border-image: url(:/images/button_pressed.png)&#125;</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">    m_continue-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    m_continue-&gt;<span class="built_in">setFixedSize</span>(<span class="number">231</span>,<span class="number">48</span>);       <span class="comment">//按钮大小</span></span><br><span class="line">    <span class="built_in">connect</span>(m_continue, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;EndingPanel::continueGame);     <span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score-&gt;<span class="built_in">setScores</span>(left, right, me);           <span class="comment">//直接调用左上角分数面板的设置分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_bk);         <span class="comment">//参1：这个图像要显示到哪个矩形区域里面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-动画效果类AnimationWindow"><a href="#2-动画效果类AnimationWindow" class="headerlink" title="2. 动画效果类AnimationWindow"></a>2. 动画效果类AnimationWindow</h1><p>动画效果类主要就是负责在游戏构成中，在主窗口显示的一些动画。比如说当抢地主阶段，每个玩家的下注分数或不叫。和当有用户打出王炸、顺子、飞机等特殊牌型时，都会有触发一些动画，来提高游戏的体验感。</p><p>动画效果类创建：选择新建、c++、c++clase、类名为AnimationWindow，基类为QWidget。</p><h2 id="2-1-AnimationWindow类头文件"><a href="#2-1-AnimationWindow类头文件" class="headerlink" title="2.1 AnimationWindow类头文件"></a>2.1 AnimationWindow类头文件</h2><p>动画效果类的头文件定义了一些特殊牌型的动画显示函数和下注的分数显示函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnimationWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Sequence, Pair&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AnimationWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示下注分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBetScore</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//显示顺子和连对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showSequence</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="comment">//显示王炸</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showJokerBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示炸弹</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示飞机</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPlane</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_image;                <span class="comment">//加载图片的对象</span></span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-AnimationWindow类函数实现"><a href="#2-2-AnimationWindow类函数实现" class="headerlink" title="2.2 AnimationWindow类函数实现"></a>2.2 AnimationWindow类函数实现</h2><p>这不是是对AnimationWindow类头文件中定义的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">AnimationWindow::<span class="built_in">AnimationWindow</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示分数窗口加载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBetScore</span><span class="params">(<span class="type">int</span> bet)</span>         <span class="comment">//主窗口创建AnimationWindow类对象后，会调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score1.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score2.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score3.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();              <span class="comment">//将加载的图片显示到窗口</span></span><br><span class="line">    <span class="comment">//当抢地主完毕之后，就隐藏该显示分数这个窗口，也就是让被实例化的AnimationWindow对象调用hide方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, &amp;AnimationWindow::hide);        <span class="comment">//定时器只触发一次(一次性信号)，2秒钟后隐藏分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showSequence</span><span class="params">(AnimationWindow::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QString name = type == Pair ? <span class="string">&quot;:/images/liandui.png&quot;</span> : <span class="string">&quot;:/images/shunzi.png&quot;</span>;      <span class="comment">//通过传进来的参数加载对应的图片</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(name);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,&amp;AnimationWindow::hide);               <span class="comment">//2s后隐藏动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showJokerBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">8</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于8了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">8</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/joker_bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">12</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于12了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showPlane</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="built_in">width</span>();                                  <span class="comment">//x轴就默认为动画窗口的宽度</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/plane_1.png&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedHeight</span>(m_image.<span class="built_in">height</span>());               <span class="comment">//y轴就为图片的高度</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="built_in">width</span>() / <span class="number">5</span>;                        <span class="comment">//将宽度分为5份，得到5份取区间</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> dist = <span class="number">0</span>;                       <span class="comment">//飞机移动的距离</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> timers = <span class="number">0</span>;</span><br><span class="line">        dist += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist&gt;=step)&#123;                            <span class="comment">//如果满足，说明某一个区间已经走完了,就进入下一个区间</span></span><br><span class="line">            dist = <span class="number">0</span>;</span><br><span class="line">            timers++;</span><br><span class="line">            QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/plane_%1.png&quot;</span>).<span class="built_in">arg</span>(timers%<span class="number">5</span>+<span class="number">1</span>);      <span class="comment">//图片在1到5之间切换</span></span><br><span class="line">            m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_x &lt;= <span class="number">-110</span>)&#123;                <span class="comment">//当飞机飞出动画窗口，就结束</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">            dist = timers = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">hide</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_x -= <span class="number">5</span>;              <span class="comment">//每次往左走5像素</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">15</span>);             <span class="comment">//每个15毫秒执行一次，画一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//因为对于飞机动画来说，m_x是移动的，而其它动画不移动，所以就把m_x初始化为0</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(m_x,<span class="number">0</span>,m_image.<span class="built_in">width</span>(),m_image.<span class="built_in">height</span>(),m_image);        <span class="comment">//加载的图片在窗口中的位置x和y；宽度和高度；QPixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-闹钟窗口类CountDown"><a href="#3-闹钟窗口类CountDown" class="headerlink" title="3. 闹钟窗口类CountDown"></a>3. 闹钟窗口类CountDown</h1><p>闹钟窗口类主要是在主窗口为用户玩家创建了一个定时闹钟，轮到用户玩家出牌阶段，用户玩家只能在指定的时间内完成出牌或不出，当15秒过后，就默认玩家放弃出牌。当然，闹钟会起作用的前提是玩家必须出牌阶段，比如说当玩家抢完地主后或出牌后，没有前提玩家出牌，又该自己出时，这两种情况闹钟是不会出现的，其他情况，闹钟都会起作用。</p><p>闹钟窗口类：新建、c、c++、类名为<code>CountDown</code>，基类为QWidget</p><h2 id="3-1-CountDown类头文件"><a href="#3-1-CountDown类头文件" class="headerlink" title="3.1 CountDown类头文件"></a>3.1 CountDown类头文件</h2><p>闹钟窗口类CountDown的头文件就是定义了闹钟的图像对象和倒计时数字的图片对象，又定义显示闹钟函数来完成对应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountDown</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CountDown</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCountDown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopCountDown</span><span class="params">()</span></span>; <span class="comment">//终止倒计时的(当闹钟的秒数还没有读到0，但用户玩家已经将牌打出去了，这种情况也需要终止倒计时)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notMuchTime</span><span class="params">()</span></span>;                 <span class="comment">//当闹钟的秒数减到5时，向主界面发送提醒信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">()</span></span>;                     <span class="comment">//当闹钟的秒数减到0时，向主界面发送信号(切换当前玩家为下一个玩家)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_clock;                <span class="comment">//加载闹钟图片对象</span></span><br><span class="line">    QPixmap m_number;               <span class="comment">//加载闹钟上的数字对象</span></span><br><span class="line">    QTimer* m_timer;</span><br><span class="line">    <span class="type">int</span>  m_count;                   <span class="comment">//倒计时的总时长</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-CountDown类函数实现"><a href="#3-2-CountDown类函数实现" class="headerlink" title="3.2 CountDown类函数实现"></a>3.2 CountDown类函数实现</h2><p>这部分就是对CountDown类头文件中定义的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">CountDown::<span class="built_in">CountDown</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">70</span>,<span class="number">70</span>);               <span class="comment">//给当前闹钟窗口显示固定大小(与图片大小一样)</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_count--;                         <span class="comment">//每次-1</span></span><br><span class="line">        <span class="keyword">if</span>(m_count&lt;<span class="number">10</span> &amp;&amp; m_count&gt;<span class="number">0</span>)&#123;       <span class="comment">//当count大于0小于10时，显示闹钟出来</span></span><br><span class="line">            m_clock.<span class="built_in">load</span>(<span class="string">&quot;:/images/clock.png&quot;</span>);</span><br><span class="line">            <span class="comment">//加载数字到闹钟上，数字的宽度是30像素，间隙是10个像素，从后从30*42像素缩放成20*30像素</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/number.png&quot;</span>).<span class="built_in">copy</span>(m_count*(<span class="number">30</span>+<span class="number">10</span>), <span class="number">0</span>, <span class="number">30</span>, <span class="number">42</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">30</span>);   <span class="comment">//x轴上是从远到近</span></span><br><span class="line">            <span class="keyword">if</span>(m_count == <span class="number">5</span>)&#123;</span><br><span class="line">                emit <span class="built_in">notMuchTime</span>();         <span class="comment">//当秒数减为5时，发出信号(播放提示音乐)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">            emit <span class="built_in">timeout</span>();                     <span class="comment">//发出信号(切换当前玩家)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::showCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_count = <span class="number">15</span>;</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);                <span class="comment">//启动定时器(每隔1s切换闹钟里面的数字)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::stopCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">    m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">    m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_clock);                                       <span class="comment">//绘制闹钟</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="number">24</span>,<span class="number">24</span>,m_number.<span class="built_in">width</span>(),m_number.<span class="built_in">height</span>(),m_number);     <span class="comment">//绘制数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-背景音乐类BGMControl"><a href="#4-背景音乐类BGMControl" class="headerlink" title="4. 背景音乐类BGMControl"></a>4. 背景音乐类BGMControl</h1><p>背景音乐类是负责整个游戏的一个配音，有的是循环一直播放，有的是只播放一次。比如说游戏的背景音乐就是一直播放，我们出牌时，男生和女生的声音就是只一次播放，还有一写特殊牌型的声音也是只播放一次，如飞机、炸弹等。</p><p>背景音乐类：新建、c++、c++clase、类名为BGMControl、基类为QObject。</p><h2 id="4-1-BGMControl类头文件"><a href="#4-1-BGMControl类头文件" class="headerlink" title="4.1 BGMControl类头文件"></a>4.1 BGMControl类头文件</h2><p>背景音乐类的头文件定义了一个牌型的枚举类，它与文件中的json文件里面的配音目录顺序一致，这样方便在程序中调用。同时定义了在不同情况下，播放不同的音乐函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BGMControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">RoleSex</span>&#123;Man, Woman&#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardType</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 单张牌</span></span><br><span class="line">            Three,</span><br><span class="line">            Foue,</span><br><span class="line">            Five,</span><br><span class="line">            Six,</span><br><span class="line">            Seven,</span><br><span class="line">            Eight,</span><br><span class="line">            Nine,</span><br><span class="line">            Ten,</span><br><span class="line">            Jack,</span><br><span class="line">            Queen,</span><br><span class="line">            King,</span><br><span class="line">            Ace,</span><br><span class="line">            Tow,</span><br><span class="line">            SmallJoker,</span><br><span class="line">            BigJoker,</span><br><span class="line">            <span class="comment">// 两张牌</span></span><br><span class="line">            Three_Double,</span><br><span class="line">            Foue_Double,</span><br><span class="line">            Five_Double,</span><br><span class="line">            Six_Double,</span><br><span class="line">            Seven_Double,</span><br><span class="line">            Eight_Double,</span><br><span class="line">            Nine_Double,</span><br><span class="line">            Ten_Double,</span><br><span class="line">            Jack_Double,</span><br><span class="line">            Queen_Double,</span><br><span class="line">            King_Double,</span><br><span class="line">            Ace_Double ,</span><br><span class="line">            Tow_Double,</span><br><span class="line">            <span class="comment">// 三张牌</span></span><br><span class="line">            Three_Triple,</span><br><span class="line">            Foue_Triple,</span><br><span class="line">            Five_Triple,</span><br><span class="line">            Six_Triple,</span><br><span class="line">            Seven_Triple,</span><br><span class="line">            Eight_Triple,</span><br><span class="line">            Nine_Triple,</span><br><span class="line">            Ten_Triple,</span><br><span class="line">            Jack_Triple,</span><br><span class="line">            Queen_Triple,</span><br><span class="line">            King_Triple,</span><br><span class="line">            Ace_Triple,</span><br><span class="line">            Tow_Triple,</span><br><span class="line">            <span class="comment">// 其他组合</span></span><br><span class="line">            Plane,          <span class="comment">// 飞机</span></span><br><span class="line">            SequencePair,   <span class="comment">// 连对</span></span><br><span class="line">            ThreeBindOne,   <span class="comment">// 三带一</span></span><br><span class="line">            ThreeBindPair,  <span class="comment">// 三带一对</span></span><br><span class="line">            Sequence,       <span class="comment">// 顺子</span></span><br><span class="line">            FourBindTwo,    <span class="comment">// 四带二(单张)</span></span><br><span class="line">            FourBind2Pair,  <span class="comment">// 四带两对</span></span><br><span class="line">            Bomb,           <span class="comment">// 炸弹</span></span><br><span class="line">            JokerBomb,      <span class="comment">// 王炸</span></span><br><span class="line">            Pass1,          <span class="comment">// 过</span></span><br><span class="line">            Pass2,</span><br><span class="line">            Pass3,</span><br><span class="line">            Pass4,</span><br><span class="line">            MoreBiger1,     <span class="comment">// 大你</span></span><br><span class="line">            MoreBiger2,</span><br><span class="line">            Biggest,        <span class="comment">// 压死</span></span><br><span class="line">            <span class="comment">// 抢地主</span></span><br><span class="line">            NoOrder,        <span class="comment">// 不叫</span></span><br><span class="line">            NoRob,          <span class="comment">// 不抢</span></span><br><span class="line">            Order,          <span class="comment">// 叫地主</span></span><br><span class="line">            Rob1,           <span class="comment">// 抢地主</span></span><br><span class="line">            Rob2,</span><br><span class="line">            Last1,          <span class="comment">// 只剩1张牌</span></span><br><span class="line">            Last2           <span class="comment">// 只剩2张牌</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AssistMusic</span>       <span class="comment">//辅助音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispatch,   <span class="comment">// 发牌</span></span><br><span class="line">        SelectCard, <span class="comment">// 选牌</span></span><br><span class="line">        PlaneVoice, <span class="comment">// 飞机</span></span><br><span class="line">        BombVoice,  <span class="comment">// 炸弹</span></span><br><span class="line">        Alert,      <span class="comment">// 提醒</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BGMControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化播放列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.背景音乐(播放和停止播放)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopBGM</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.播放玩家抢地址音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span>;</span><br><span class="line">    <span class="comment">//3.播放出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span>;           <span class="comment">//播放剩余1张或2张牌的音乐</span></span><br><span class="line">    <span class="comment">//4.播放不出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playPassMusic</span><span class="params">(RoleSex sex)</span></span>;</span><br><span class="line">    <span class="comment">//5.播放辅助音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playAssistMusic</span><span class="params">(AssistMusic type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopAssistMusic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//6.播放结尾音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    QVector&lt;QMediaPlayer*&gt; m_players;</span><br><span class="line">    QVector&lt;QMediaPlaylist* &gt; m_lists;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-BGMControl函数实现"><a href="#4-2-BGMControl函数实现" class="headerlink" title="4.2 BGMControl函数实现"></a>4.2 BGMControl函数实现</h2><p>这部分就是实现了<code>BGMControl</code>类中定义的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">BGMControl::<span class="built_in">BGMControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QMediaPlayer* player = <span class="keyword">new</span> <span class="built_in">QMediaPlayer</span>(<span class="keyword">this</span>);             <span class="comment">//创建多媒体对象</span></span><br><span class="line">        QMediaPlaylist* list = <span class="keyword">new</span> <span class="built_in">QMediaPlaylist</span>(<span class="keyword">this</span>);           <span class="comment">//创建播放列表对象</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span> || i == <span class="number">4</span>)                 <span class="comment">//当是0、1或4时，音乐只播放一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::CurrentItemOnce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)                   <span class="comment">//当是2时，就循环播放音乐</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::Loop);</span><br><span class="line">        &#125;</span><br><span class="line">        player-&gt;<span class="built_in">setPlaylist</span>(list);</span><br><span class="line">        player-&gt;<span class="built_in">setVolume</span>(<span class="number">100</span>);                <span class="comment">//音量</span></span><br><span class="line">        m_players.<span class="built_in">push_back</span>(player);</span><br><span class="line">        m_lists.<span class="built_in">push_back</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">initPlayList</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化播放列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::initPlayList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList list;</span><br><span class="line">    list &lt;&lt; <span class="string">&quot;Man&quot;</span> &lt;&lt; <span class="string">&quot;Woman&quot;</span> &lt;&lt; <span class="string">&quot;BGM&quot;</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="string">&quot;Ending&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读json配置文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/conf/playList.json&quot;</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QByteArray json = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// 解析从文件中读出的json数据</span></span><br><span class="line">    QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(json);</span><br><span class="line">    QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QString prefix = list.<span class="built_in">at</span>(i);</span><br><span class="line">        QJsonArray array = obj.<span class="built_in">value</span>(prefix).<span class="built_in">toArray</span>();</span><br><span class="line">        <span class="comment">// 初始化多媒体播放列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[i]-&gt;<span class="built_in">addMedia</span>(<span class="built_in">QMediaContent</span>(<span class="built_in">QUrl</span>(array.<span class="built_in">at</span>(j).<span class="built_in">toString</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏背景音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2是背景音乐，其音频对应的下标是2</span></span><br><span class="line">    m_lists[<span class="number">2</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">setVolume</span>(volume);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">play</span>();                  <span class="comment">//通过对应的多媒体对象的play播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopBGM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">stop</span>();                  <span class="comment">//停止播放背景音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家下注了没有?</span></span><br><span class="line"><span class="comment">// 玩家的性别?</span></span><br><span class="line"><span class="comment">// 什么时候播放什么样的音频文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(isFirst &amp;&amp; point &gt; <span class="number">0</span>)                 <span class="comment">//如果是第一个叫地主，且下注分数大于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Order);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">0</span>)                      <span class="comment">//下注分数为0，即没有叫地主</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFirst)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoOrder);          <span class="comment">//如果是第一家就播放不叫音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoRob);            <span class="comment">//如果不是第一家就播放不抢音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">2</span>)                        <span class="comment">//下注2分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">3</span>)                        <span class="comment">//下注3分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob2);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();             <span class="comment">//通过多媒体对象播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌的音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到播放列表</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    QMediaPlaylist* list = m_lists[index];           <span class="comment">//通过男生或女生，得到相应的播放列表对象</span></span><br><span class="line"></span><br><span class="line">    Card::CardPoint pt = Card::CardPoint::Card_Begin;</span><br><span class="line">    <span class="comment">// 取出牌型 然后进行判断</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();</span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Single || type == PlayHand::Hand_Pair || type == PlayHand::Hand_Triple)</span><br><span class="line">    &#123;</span><br><span class="line">        pt = cards.<span class="built_in">takeRandomCard</span>().<span class="built_in">point</span>();    <span class="comment">//如果是单牌、双牌或三牌，取出其点数(取出随机一张牌即可)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        number = pt - <span class="number">1</span>;           <span class="comment">//因为pt的枚举类是从begin开始的，需要减1才能和json文件里面的枚举类一一对应</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 对牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span>;      <span class="comment">//对牌在单牌后面，所以需要跳过单牌个数15</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三张点数相同的牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span> + <span class="number">13</span>;         <span class="comment">//跳过对牌个数13</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带一</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        number = ThreeBindOne;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带二</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        number = ThreeBindPair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 飞机</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">    <span class="comment">// 飞机带两个单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">    <span class="comment">// 飞机带两个对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        number = Plane;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 连对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:</span><br><span class="line">        number = SequencePair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 顺子</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:</span><br><span class="line">        number = Sequence;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:</span><br><span class="line">        number = Bomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 王炸</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers:</span><br><span class="line">        number = JokerBomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Pair:</span><br><span class="line">    <span class="comment">// 炸弹带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Two_Single:</span><br><span class="line">    <span class="comment">// 王炸带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Pair:</span><br><span class="line">    <span class="comment">// 王炸带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Two_Single:</span><br><span class="line">        number = FourBindTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isFirst &amp;&amp; (number &gt;= Plane &amp;&amp; number &lt;= FourBindTwo))</span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(MoreBiger1 + QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    <span class="keyword">if</span>(number == Bomb || number == JokerBomb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(BombVoice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number == Plane)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(PlaneVoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="keyword">if</span>(m_players[index]-&gt;<span class="built_in">state</span>() == QMediaPlayer::StoppedState)     <span class="comment">//如果当前对应的多媒体播放是空闲状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">        m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">1500</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">            m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playPassMusic</span><span class="params">(RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">4</span>);    <span class="comment">//随机生成一个数字，0到3</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(Pass1 + random);                  <span class="comment">//随机播放不要音乐</span></span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playAssistMusic</span><span class="params">(AssistMusic type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMediaPlaylist::PlaybackMode mode;                <span class="comment">//定义一个播放模式</span></span><br><span class="line">    <span class="keyword">if</span>(type == Dispatch)                              <span class="comment">//如果是发牌状态，就循环播放音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环播放</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemInLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                       <span class="comment">//其它情况，只播放一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单曲播放一次</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemOnce;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">    list-&gt;<span class="built_in">setPlaybackMode</span>(mode);</span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopAssistMusic</span><span class="params">()</span>           <span class="comment">//停止辅助音乐播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输或赢播放音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isWin)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[<span class="number">4</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-游戏主窗口类GamePanel"><a href="#5-游戏主窗口类GamePanel" class="headerlink" title="5. 游戏主窗口类GamePanel"></a>5. 游戏主窗口类GamePanel</h1><p>游戏主窗口类是游戏的展示界面，玩家玩游戏的整个过程都是在这个窗口中显示的。</p><h2 id="5-1-GamePanel类头文件"><a href="#5-1-GamePanel类头文件" class="headerlink" title="5.1 GamePanel类头文件"></a>5.1 GamePanel类头文件</h2><p>游戏窗口类的头文件需要定义很多初始化的函数，同时也需要接收很多发送过来的信号，然后通过相应的函数(槽函数)来实现对应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePanel</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GamePanel</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">GamePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AnimationType</span>&#123;ShunZi, LianDui, Plane, JokerBomb, Bomb, Bet&#125;;             <span class="comment">//效果动画类要显示的一些动画</span></span><br><span class="line">    <span class="comment">//初始化游戏控制类信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameControlInit</span><span class="params">()</span></span>;       <span class="comment">//该函数也负责信号槽的一些连接</span></span><br><span class="line">    <span class="comment">//更新分数面板的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//切割并存储图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCardMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//裁剪图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cropImage</span><span class="params">(QPixmap&amp; pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span></span>;       <span class="comment">//参数：裁剪图片对象，x位置，y位置，卡牌对象(需要它的花色和点数)</span></span><br><span class="line">    <span class="comment">//初始化游戏按钮组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtonsGroup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化玩家在窗口中的上下文环境(每个玩家的位置信息)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayerContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化游戏场景</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initGameScene</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理游戏的状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span></span>;     <span class="comment">//参数枚举类型游戏状态，有发牌、叫地主和出牌</span></span><br><span class="line">    <span class="comment">//发牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardMoveStep</span><span class="params">(Player* player, <span class="type">int</span> curPos)</span></span>;</span><br><span class="line">    <span class="comment">//处理分发得到的扑克牌(发牌时卡牌区域更新)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disposeCard</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;        <span class="comment">//参数：处理的牌属于哪个玩家，要处理的牌(一张或多张)</span></span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示(把玩家得到的牌更新到该显示的位置上,和打出的牌更新到出牌区域)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerCards</span><span class="params">(Player* player)</span></span>;          <span class="comment">//更新的是哪个玩家的扑克牌窗口</span></span><br><span class="line">    <span class="comment">//加载玩家的头像</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器的处理动作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家状态的变化(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayerStatusChanged</span><span class="params">(Player* player, GameControl::PlayerStatus status)</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家抢地主情况，再在主窗口显示(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;     <span class="comment">//参数：具体哪个玩家，下注分数，是否是第一个叫地主的玩家</span></span><br><span class="line">    <span class="comment">//处理玩家的出牌显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDisposePlayHand</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家鼠标选牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPlayHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理用户放弃出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示特效动画</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showAnimation</span><span class="params">(AnimationType type, <span class="type">int</span> bet=<span class="number">0</span>)</span></span>;  <span class="comment">//因为室友特效动画都是该函数显示，所以直接传入动画枚举类，当是抢地主分数的时候，会用到参2</span></span><br><span class="line">    <span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hidePlayerDropCards</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="comment">// 显示玩家的最终得分(结束面板设置)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showEndingScorePanel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化闹钟倒计时</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCountDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写父类的虚函数---事件处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardAlign</span>&#123;Horizontal, Vertical&#125;;             <span class="comment">//对齐方式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PlayerContext</span>&#123;                   <span class="comment">//每个玩家有一个这样的结构体,是存放玩家对应的位置信息</span></span><br><span class="line">        <span class="comment">//1.玩家扑克牌显示的区域</span></span><br><span class="line">        QRect cardRect;</span><br><span class="line">        <span class="comment">//2.出牌的区域</span></span><br><span class="line">        QRect playHandRect;</span><br><span class="line">        <span class="comment">//3.扑克牌的对齐方式(水平 or 垂直)</span></span><br><span class="line">        CardAlign align;</span><br><span class="line">        <span class="comment">//4.扑克牌显示正面还是背面</span></span><br><span class="line">        <span class="type">bool</span> isFrontSide;</span><br><span class="line">        <span class="comment">//5.游戏过程中的提示信息，比如：不出</span></span><br><span class="line">        QLabel* info;</span><br><span class="line">        <span class="comment">//6.玩家的头像</span></span><br><span class="line">        QLabel* roleImg;</span><br><span class="line">        <span class="comment">//7.玩家刚打出的牌</span></span><br><span class="line">        Cards lastCards;</span><br><span class="line">    &#125;;</span><br><span class="line">    Ui::GamePanel *ui;</span><br><span class="line">    QPixmap m_bkImage;                     <span class="comment">//背景图片的加载对象</span></span><br><span class="line">    GameControl* m_gameCtl;                <span class="comment">//游戏控制类对象</span></span><br><span class="line">    QVector&lt;Player*&gt; m_playerList;         <span class="comment">//存放三个玩家对象的实例</span></span><br><span class="line">    QMap&lt;Card, CardPanel*&gt;m_cardMap;       <span class="comment">//保存卡牌数据和卡牌窗口对象的容器</span></span><br><span class="line">    QSize m_cardSize;                      <span class="comment">//卡牌大小(宽和高)</span></span><br><span class="line">    QPixmap m_cardBackImg;                 <span class="comment">//卡牌背景图加载对象</span></span><br><span class="line">    QMap&lt;Player*, PlayerContext&gt; m_contextMap;      <span class="comment">//将玩家与其对应的位置结构体存到map</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_baseCard;              <span class="comment">//刚开始，发牌区的扑克牌</span></span><br><span class="line">    CardPanel* m_moveCard;              <span class="comment">//移动中的扑克牌</span></span><br><span class="line">    QVector&lt;CardPanel*&gt;m_last3Card;     <span class="comment">//最后三张底牌</span></span><br><span class="line"></span><br><span class="line">    QPoint m_baseCardPos;               <span class="comment">//起始时，牌的初始位置(中心偏上一点)</span></span><br><span class="line">    GameControl::GameStatus m_gameStatus;           <span class="comment">//存放游戏状态</span></span><br><span class="line">    QTimer* m_timer;                    <span class="comment">//定时器</span></span><br><span class="line"></span><br><span class="line">    AnimationWindow* m_animation;            <span class="comment">//动画效果类对象</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_curSelCard;       <span class="comment">//鼠标选择的卡牌窗口对象(只限自己手牌的，因为点击其它机器人玩家的牌，在onCardSelected()函数中已经被排除了)</span></span><br><span class="line">    QSet&lt;CardPanel*&gt; m_selectCards;       <span class="comment">//保存用户鼠标选择的卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//下面两个在updatePlayerCards()里面初始化的</span></span><br><span class="line">    QRect m_cardsRect;                          <span class="comment">//存储用户玩家剩余的牌显示区域</span></span><br><span class="line">    QHash&lt;CardPanel*,QRect&gt; m_userCards;         <span class="comment">//记录用户玩家手中的牌，以及每张牌在窗口中的位置</span></span><br><span class="line"></span><br><span class="line">    CountDown* m_countDown;                <span class="comment">//闹钟类对象指针</span></span><br><span class="line"></span><br><span class="line">    BGMControl* m_bgm;                     <span class="comment">//BGM音乐类对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-2-GamePanel类函数实现"><a href="#5-2-GamePanel类函数实现" class="headerlink" title="5.2 GamePanel类函数实现"></a>5.2 GamePanel类函数实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br></pre></td><td class="code"><pre><span class="line">GamePanel::<span class="built_in">GamePanel</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::GamePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 背景图</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>);          <span class="comment">//生成0到9随机数</span></span><br><span class="line">    QString path = <span class="built_in">QString</span>(<span class="string">&quot;:/images/background-%1.png&quot;</span>).<span class="built_in">arg</span>(num+<span class="number">1</span>);     <span class="comment">//拼接背景图路径</span></span><br><span class="line">    m_bkImage.<span class="built_in">load</span>(path);   <span class="comment">//随机加载一张背景图(刚开始时)，通过事件处理器函数painEvent就能将背景图画到窗口上了，当窗口初始化好后，painEvent会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.窗口的标题和大小(固定)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;欢乐斗地主&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1000</span>, <span class="number">650</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实例化游戏控制类对象</span></span><br><span class="line">    <span class="built_in">gameControlInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 玩家得分(更新)</span></span><br><span class="line">    <span class="built_in">updatePlayerScore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 切割游戏图片</span></span><br><span class="line">    <span class="built_in">initCardMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 初始化游戏中的按钮组</span></span><br><span class="line">    <span class="built_in">initButtonsGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 初始化玩家在窗口中的上下文环境</span></span><br><span class="line">    <span class="built_in">initPlayerContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 扑克牌场景初始化</span></span><br><span class="line">    <span class="built_in">initGameScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 倒计时窗口初始化</span></span><br><span class="line">    <span class="built_in">initCountDown</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器实例化</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;GamePanel::onDispatchCard);     <span class="comment">//每触发一次定时器，就会调用槽函数，发牌</span></span><br><span class="line"></span><br><span class="line">    m_animation = <span class="keyword">new</span> <span class="built_in">AnimationWindow</span>(<span class="keyword">this</span>);          <span class="comment">//创建一个动画效果类，指定了父对象，它就显示在父对象窗口上面，而且没有边框</span></span><br><span class="line">    m_bgm = <span class="keyword">new</span> <span class="built_in">BGMControl</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GamePanel::~<span class="built_in">GamePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameControlInit</span><span class="params">()</span>       <span class="comment">//实例化游戏控制类对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_gameCtl = <span class="keyword">new</span> <span class="built_in">GameControl</span>(<span class="keyword">this</span>);       <span class="comment">//指定父对象，窗口析构的时候，就会先自动析构m_gameCtl了</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">playerInit</span>();                 <span class="comment">//三个玩家对象被创建出来了</span></span><br><span class="line">    <span class="comment">//得到三个玩家的实例对象</span></span><br><span class="line">    Robot* leftRobot = m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>();</span><br><span class="line">    Robot* rightRobot = m_gameCtl-&gt;<span class="built_in">getRightRobot</span>();</span><br><span class="line">    UserPlayer* user = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();</span><br><span class="line">    m_playerList &lt;&lt; leftRobot &lt;&lt; rightRobot &lt;&lt; user;        <span class="comment">//存储顺序：左侧机器人，右侧机器人，用户玩家</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家状态变化)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::playerStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::onPlayerStatusChanged);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(抢地主的情况)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyGrabLordBet, <span class="keyword">this</span>, &amp;GamePanel::onGrabLordBet);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(游戏状态变化),主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::gameStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::gameStatusPrecess);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家出牌了),主窗口接收并处理相应的槽函数(处理一些动画效果，更新玩家的牌，并将出的牌显示在出牌区域)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyPlayHand, <span class="keyword">this</span>, &amp;GamePanel::onDisposePlayHand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不管是哪个玩家得到牌后都会发出一个信号，主窗口接收该信号</span></span><br><span class="line">    <span class="built_in">connect</span>(leftRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(rightRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(user, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;scorePanel-&gt;<span class="built_in">setScores</span>(                    <span class="comment">//setScores函数负责将传入的得分显示在窗口上</span></span><br><span class="line">                m_playerList[<span class="number">0</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">1</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">2</span>]-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCardMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.加载大图</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/card.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//2.计算每张图片的大小</span></span><br><span class="line">    m_cardSize.<span class="built_in">setWidth</span>(pixmap.<span class="built_in">width</span>()/<span class="number">13</span>);</span><br><span class="line">    m_cardSize.<span class="built_in">setHeight</span>(pixmap.<span class="built_in">height</span>()/<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//3.背面图加载(裁剪)，需要提供背景图左上角的点，copy(x轴，y轴，要裁剪的宽度，要裁剪的高度)</span></span><br><span class="line">    m_cardBackImg = pixmap.<span class="built_in">copy</span>(<span class="number">2</span>*m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">    <span class="comment">//正常花色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,pt=Card::Card_Begin+<span class="number">1</span>; pt&lt;Card::Card_SJ; pt++,j++)&#123;</span><br><span class="line">            <span class="function">Card <span class="title">card</span><span class="params">((Card::CardPoint)pt, (Card::CardSuit)suit)</span></span>;</span><br><span class="line">            <span class="comment">//裁剪图片(参数：大图对象，裁剪卡牌的x轴，裁剪卡牌的y轴，对应的单张卡牌对象(记录的是对应的花色和点数))</span></span><br><span class="line">            <span class="built_in">cropImage</span>(pixmap, j*m_cardSize.<span class="built_in">width</span>(), i*m_cardSize.<span class="built_in">height</span>(), card);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小王</span></span><br><span class="line">    Card c;</span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_SJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, <span class="number">0</span>, <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">    <span class="comment">//大王</span></span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_BJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cropImage</span><span class="params">(QPixmap &amp;pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span>              <span class="comment">//裁剪图片</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap sub = pix.<span class="built_in">copy</span>(x, y, m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());       <span class="comment">//得到一张扑克牌正面</span></span><br><span class="line">    CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);           <span class="comment">//创建一张卡牌窗口对象</span></span><br><span class="line">    panel-&gt;<span class="built_in">setImage</span>(sub, m_cardBackImg);              <span class="comment">//参数：正面图片对象，背面图片对象 -----&gt;图片显示的已经是对应的花色和点数了</span></span><br><span class="line">    panel-&gt;<span class="built_in">setCard</span>(c);                                <span class="comment">//设置花色和点数   -----&gt;这相当于是记录该图片的花色和点数</span></span><br><span class="line">    panel-&gt;<span class="built_in">hide</span>();                                    <span class="comment">//隐藏</span></span><br><span class="line">    m_cardMap.<span class="built_in">insert</span>(c,panel);                        <span class="comment">//裁剪成功的卡牌存入容器，方便后期管理和处理</span></span><br><span class="line">    <span class="comment">//接收CardPanel类发出的鼠标选择信号---&gt;每张牌的窗口对象只要满足条件，都可以发出信号</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;CardPanel::cardSelected, <span class="keyword">this</span>, &amp;GamePanel::onCardSelected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initButtonsGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">initButtons</span>();                                <span class="comment">//所有的按钮初始化完成</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Start);              <span class="comment">//开始时，显示的是开始游戏页面</span></span><br><span class="line">    <span class="comment">//处理各个按钮发出的信号</span></span><br><span class="line">    <span class="comment">//初始页面的开始按钮，当发出startGame信号，就说明开始游戏的按钮被按下了</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::startGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//界面的初始化</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">clearPlayerScore</span>();          <span class="comment">//将所有玩家的得分清0(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();                    <span class="comment">//更新所有玩家的得分(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="comment">//修改游戏状态 ---&gt; 发牌</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);        <span class="comment">//基于这个参数，里面是通过switcha函数来执行不同游戏状态下的函数</span></span><br><span class="line">        <span class="comment">//播放背景音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);                 <span class="comment">//指定音量为80</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::playHand, <span class="keyword">this</span>, &amp;GamePanel::onUserPlayHand); <span class="comment">//当点击了出牌按钮，会发出playHand信号</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::pass, <span class="keyword">this</span>, &amp;GamePanel::onUserPass);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::betPoint, <span class="keyword">this</span>, [=](<span class="type">int</span> bet)&#123;        <span class="comment">//叫地主几分按钮</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">grabLordBet</span>(bet);</span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//按完下注分数按钮后，就执行选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initPlayerContext</span><span class="params">()</span>              <span class="comment">//为每个玩家设置对应的位置信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.设置玩家扑克牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect cardsRect[]=&#123;</span><br><span class="line">        <span class="comment">//x,y,width,heught</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">90</span>,<span class="number">130</span>,<span class="number">100</span>,<span class="built_in">height</span>()<span class="number">-200</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-190</span>, <span class="number">130</span>, <span class="number">100</span>, <span class="built_in">height</span>()<span class="number">-200</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">250</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-120</span>, <span class="built_in">width</span>()<span class="number">-500</span>,<span class="number">100</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2.玩家出牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect playHandRect[]=&#123;</span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">260</span>,<span class="number">150</span>,<span class="number">100</span>,<span class="number">100</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-360</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">150</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-290</span>, <span class="built_in">width</span>()<span class="number">-300</span>,<span class="number">105</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3.玩家头像显示的位置</span></span><br><span class="line">    <span class="type">const</span> QPoint roleImgPos[]=&#123;</span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">0</span>].<span class="built_in">left</span>()<span class="number">-80</span>,cardsRect[<span class="number">0</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),         <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">1</span>].<span class="built_in">right</span>()+<span class="number">10</span>,cardsRect[<span class="number">1</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">2</span>].<span class="built_in">right</span>()<span class="number">-10</span>,cardsRect[<span class="number">2</span>].<span class="built_in">top</span>()<span class="number">-10</span>)              <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());     <span class="comment">//得到m_playerList存放用户玩家的下标索引(是2,但是不想把代码写死，所以通过这行代码获取)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>();i++)&#123;                          <span class="comment">//变量三个玩家</span></span><br><span class="line">        PlayerContext context;                                <span class="comment">//为每个玩家创建各自的PlayerContext位置结构体</span></span><br><span class="line">        context.align = i==index ? Horizontal:Vertical;             <span class="comment">//对齐方式：机器人玩家和用户玩家是不一样的</span></span><br><span class="line">        context.isFrontSide = i==index ? <span class="literal">true</span>:<span class="literal">false</span>;                  <span class="comment">//扑克牌展示正面还是背面，需要判定，i=index，说明是用户玩家</span></span><br><span class="line">        context.cardRect = cardsRect[i];                              <span class="comment">//卡牌区域(因为m_playerList和cardsRect的顺序是一样的，所以直接赋值即可)</span></span><br><span class="line">        context.playHandRect = playHandRect[i];                       <span class="comment">//出牌区域</span></span><br><span class="line">        <span class="comment">//提示信息(每个玩家的提示信息位置)</span></span><br><span class="line">        context.info = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个标签</span></span><br><span class="line">        context.info-&gt;<span class="built_in">resize</span>(<span class="number">160</span>, <span class="number">98</span>);                  <span class="comment">//指定标签大小</span></span><br><span class="line">        context.info-&gt;<span class="built_in">hide</span>();                           <span class="comment">//初始是隐藏的</span></span><br><span class="line">        <span class="comment">//将提示信息显示到出牌区域的中心位置</span></span><br><span class="line">        QRect rect = playHandRect[i];                   <span class="comment">//每个玩家的出牌区域</span></span><br><span class="line">        <span class="function">QPoint <span class="title">pt</span><span class="params">(rect.left()+(rect.width()-context.info-&gt;width())/<span class="number">2</span>, rect.top()+(rect.height()-context.info-&gt;height())/<span class="number">2</span>)</span></span>;   <span class="comment">//获取出牌区域的中心位置，需要(出牌区域框架-提示信息框架)/2</span></span><br><span class="line">        context.info-&gt;<span class="built_in">move</span>(pt);          <span class="comment">//将提示信息移动到pt位置</span></span><br><span class="line">        <span class="comment">//玩家头像</span></span><br><span class="line">        context.roleImg = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);         <span class="comment">//创建一个放头像的标签</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">resize</span>(<span class="number">84</span>, <span class="number">120</span>);           <span class="comment">//固定大小</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">hide</span>();                    <span class="comment">//隐藏</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">move</span>(roleImgPos[i]);       <span class="comment">//将头像标签移动到指定位置</span></span><br><span class="line">        m_contextMap.<span class="built_in">insert</span>(m_playerList.<span class="built_in">at</span>(i), context);   <span class="comment">//key存玩家对象，value存对应的位置结构体context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initGameScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面三部分，每一部分都对应一张或多张扑克牌，每张扑克牌都是一个卡牌窗口，所以需要创建卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//1.发牌区的扑克牌</span></span><br><span class="line">    m_baseCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_baseCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 2. 发牌过程中移动的扑克牌</span></span><br><span class="line">    m_moveCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_moveCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 3. 最后的三张底牌(用于窗口的显示)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">        panel-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">        m_last3Card.<span class="built_in">push_back</span>(panel);</span><br><span class="line">        panel-&gt;<span class="built_in">hide</span>();              <span class="comment">//初始先隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发牌区和移动过程扑克牌的位置(同一个)</span></span><br><span class="line">    m_baseCardPos = <span class="built_in">QPoint</span>((<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>()) / <span class="number">2</span>, <span class="built_in">height</span>() / <span class="number">2</span> - <span class="number">100</span>);     <span class="comment">//中心位置偏上一点</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">move</span>(m_baseCardPos);         <span class="comment">//设置发牌区的扑克牌位置</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(m_baseCardPos);          <span class="comment">//设置移动过程中扑克牌的位置</span></span><br><span class="line">    <span class="comment">//底牌位置(三种牌的x轴不一样，y轴一样)</span></span><br><span class="line">    <span class="type">int</span> base = (<span class="built_in">width</span>() - <span class="number">3</span> * m_cardSize.<span class="built_in">width</span>() - <span class="number">2</span> * <span class="number">10</span>) / <span class="number">2</span>;   <span class="comment">//width()是当前窗口的总宽度，三张牌有2个空隙(2*10)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_last3Card[i]-&gt;<span class="built_in">move</span>(base + (m_cardSize.<span class="built_in">width</span>() + <span class="number">10</span>) * i, <span class="number">20</span>);      <span class="comment">//分别设置三张底牌的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span>            <span class="comment">//处理游戏的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录游戏状态</span></span><br><span class="line">    m_gameStatus = status;</span><br><span class="line">    <span class="comment">//处理游戏状态</span></span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::DispatchCard:        <span class="comment">//开始发牌状态</span></span><br><span class="line">        <span class="built_in">startDispatchCard</span>();               <span class="comment">//调用发牌函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::CallingLord:         <span class="comment">//叫地主状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出底牌数据</span></span><br><span class="line">        CardList last3Card = m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">toCardList</span>();     <span class="comment">//将存放三张底牌的set容器转为了QVector容器</span></span><br><span class="line">        <span class="comment">//给底牌窗口设置图片</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;last3Card.<span class="built_in">size</span>(); i++)&#123;        <span class="comment">//遍历三张底牌</span></span><br><span class="line">            QPixmap front = m_cardMap[last3Card.<span class="built_in">at</span>(i)]-&gt;<span class="built_in">getImage</span>();         <span class="comment">//获取每张牌它的一个图像</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">setImage</span>(front,m_cardBackImg);            <span class="comment">//设置该卡牌的正面图片和反面图片</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">hide</span>();                                   <span class="comment">//先是隐藏的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始叫地主</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">startLordCard</span>();      <span class="comment">//gamecontrol的一个函数，里面会发出一个信号，主窗口再接收处理槽函数onPlayerStatusChanged</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GameControl::PlayingHand:           <span class="comment">//出牌状态(抢完地主)</span></span><br><span class="line">        <span class="comment">//隐藏发牌区的底牌和移动的牌</span></span><br><span class="line">        m_baseCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="comment">//显示留给地主的三张底牌(顶部)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">show</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            PlayerContext &amp;context = m_contextMap[m_playerList.<span class="built_in">at</span>(i)];       <span class="comment">//获取每个玩家的位置结构体</span></span><br><span class="line">            context.info-&gt;<span class="built_in">hide</span>();                       <span class="comment">//隐藏各个玩家抢地主过程中的提示信息</span></span><br><span class="line">            <span class="comment">//显示各个玩家的头像</span></span><br><span class="line">            Player* player = m_playerList.<span class="built_in">at</span>(i);</span><br><span class="line">            QPixmap pixmap = <span class="built_in">loadRoleImage</span>(player-&gt;<span class="built_in">getSex</span>(),player-&gt;<span class="built_in">getDirection</span>(), player-&gt;<span class="built_in">getRole</span>());   <span class="comment">//得到对应玩家的头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">setPixmap</span>(pixmap);     <span class="comment">//设置头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">show</span>();                <span class="comment">//显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::startDispatchCard</span><span class="params">()</span>            <span class="comment">//发牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重置每张卡牌的属性(不是所有属性)   QMap&lt;Card, CardPanel*&gt;m_cardMap;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cardMap.<span class="built_in">begin</span>(); it!=m_cardMap.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);     <span class="comment">//设置非选中状态</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);     <span class="comment">//显示正面图片</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">hide</span>();                  <span class="comment">//窗口隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//隐藏三张底牌</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置玩家的窗口上下文信息(位置)</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());        <span class="comment">//传入用户玩家对象，得到它在m_playerList的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;                            <span class="comment">//对玩家容器进行遍历</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].lastCards.<span class="built_in">clear</span>();              <span class="comment">//玩家上一次打出的牌进行清空</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].info-&gt;<span class="built_in">hide</span>();                   <span class="comment">//隐藏游戏过程中的提示信息</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].roleImg-&gt;<span class="built_in">hide</span>();                <span class="comment">//玩家的头像隐藏</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].isFrontSide = i==index ? <span class="literal">true</span> : <span class="literal">false</span>;   <span class="comment">//显示正面还是背面(用户玩家显示正面，机器人玩家显示背面)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置所有玩家的卡牌数据</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">resetCardData</span>();        <span class="comment">//该函数里面是做了：洗牌、清空三个玩家的手牌、将出牌玩家对象指向空和出的牌清空</span></span><br><span class="line">    <span class="comment">//显示底牌</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">show</span>();            <span class="comment">//正中间的扑克牌，刚开是背面时(显示出来)</span></span><br><span class="line">    <span class="comment">//隐藏按钮面板</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//传入的是空窗口</span></span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">10</span>);               <span class="comment">//每隔10毫秒，定时器就触发一次</span></span><br><span class="line">    <span class="comment">//播放背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Dispatch);             <span class="comment">//播放发牌的音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cardMoveStep</span><span class="params">(Player *player, <span class="type">int</span> curPos)</span>     <span class="comment">//参数：具体是哪个玩家，移动步长的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到每个玩家的扑克牌展示区域</span></span><br><span class="line">    QRect cardRect = m_contextMap[player].cardRect;</span><br><span class="line">    <span class="comment">//每个玩家的单位步长</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> unit[] = &#123;(m_baseCardPos.<span class="built_in">x</span>() - cardRect.<span class="built_in">right</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">left</span>() - m_baseCardPos.<span class="built_in">x</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">top</span>() - m_baseCardPos.<span class="built_in">y</span>())/<span class="number">100</span> &#125;;   <span class="comment">//左侧玩家:(发牌区域x坐标-左侧玩家区域右变x轴)/长度；右侧玩家</span></span><br><span class="line">    <span class="comment">//每次窗口移动的时候，每个玩家对应的移动牌的实时坐标位置</span></span><br><span class="line">    <span class="type">const</span> QPoint pos[]=&#123; <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() - curPos * unit[<span class="number">0</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() + curPos * unit[<span class="number">1</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>(), m_baseCardPos.<span class="built_in">y</span>() + curPos * unit[<span class="number">2</span>])&#125;;  <span class="comment">//左侧机器人x轴坐标越来越小；右侧机器人x轴坐标越来越大</span></span><br><span class="line">    <span class="comment">//移动扑克牌窗口</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(player);          <span class="comment">//得到对应玩家的下标</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(pos[index]);                      <span class="comment">//卡牌移动到对应玩家 移动路径上 的某一点</span></span><br><span class="line">    <span class="comment">//临界状态处理</span></span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">0</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">show</span>();      <span class="comment">//说明该牌才刚开始移动，想要展示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">100</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();      <span class="comment">//说明该牌已经到了对应玩家的卡牌区域，就需要隐藏了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一张或多张卡牌时，会发出一个信号告诉主窗口，该函数就是接收该信号的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::disposeCard</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span>      <span class="comment">//卡牌区域更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards&amp; myCard = <span class="built_in">const_cast</span>&lt;Cards&amp;&gt;(cards);</span><br><span class="line">    CardList list = myCard.<span class="built_in">toCardList</span>();</span><br><span class="line">    <span class="comment">//CardList list = cards.toCardList();           //CardList是QVector&lt;Card&gt;的一个别名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//通过Card取出对应的窗口对象</span></span><br><span class="line">        panel-&gt;<span class="built_in">setOwner</span>(player);                        <span class="comment">//设置该张卡牌窗口的所有者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerCards</span><span class="params">(Player *player)</span>       <span class="comment">//把玩家得到的牌更新到该显示的位置上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards = player-&gt;<span class="built_in">getCards</span>();             <span class="comment">//取出该玩家得到的牌(手牌)</span></span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将得到的牌存放到QVector，默认是降序排列</span></span><br><span class="line"></span><br><span class="line">    m_cardsRect = <span class="built_in">QRect</span>();             <span class="comment">//先将m_cardsRect初始化</span></span><br><span class="line">    m_userCards.<span class="built_in">clear</span>();               <span class="comment">//每次进来要清空，因为手牌位置发生变化了</span></span><br><span class="line">    <span class="comment">//取出展示扑克牌的区域</span></span><br><span class="line">    <span class="type">int</span> cardSpace = <span class="number">20</span>;               <span class="comment">//卡牌间相隔的像素(也是每张牌能显示出来的宽度)</span></span><br><span class="line">    QRect cardsRect = m_contextMap[player].cardRect;       <span class="comment">//取出该玩家的手牌区域坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;                   <span class="comment">//遍历每一张手牌</span></span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//每一张牌对应一张卡牌窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">show</span>();                       <span class="comment">//显示窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">raise</span>();                      <span class="comment">//让当前的卡牌窗口升起来(就是让当前卡牌窗口是所有之前出现的卡牌子窗口中最上层那个)</span></span><br><span class="line">        panel-&gt;<span class="built_in">setFrontSide</span>(m_contextMap[player].isFrontSide);    <span class="comment">//玩家的卡牌(手牌)显示正面还是反面</span></span><br><span class="line">        <span class="comment">//水平 or 垂直显示 -----&gt;下面是为了让卡牌显示在卡牌区域的正中间(卡牌区域要大一点)</span></span><br><span class="line">        <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;          <span class="comment">//如果是水平(用户玩家)</span></span><br><span class="line">            <span class="comment">//(总宽度-牌占用的宽度)/2：卡牌区域左边距离+(卡牌区域总宽度 - (卡牌总数量-1)*间隔 - 最后一张牌的完整宽度)/2</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>()+(cardsRect.<span class="built_in">width</span>()-(list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - m_cardSize.<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域上面距离+(卡牌区域高度-卡牌高度)/2</span></span><br><span class="line">            <span class="keyword">if</span>(panel-&gt;<span class="built_in">isSelected</span>())&#123;       <span class="comment">//如果这张扑克牌是被选中了，有各向上的弹跳效果</span></span><br><span class="line">                topY -= <span class="number">10</span>;                <span class="comment">//y轴像素-10</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX + cardSpace*i, topY);     <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">            m_cardsRect = <span class="built_in">QRect</span>(leftX, topY, cardSpace*i+m_cardSize.<span class="built_in">width</span>(),m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">            <span class="type">int</span> curWidth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.<span class="built_in">size</span>()<span class="number">-1</span> == i)&#123;                 <span class="comment">//如果是最后一张牌了，则该牌的宽度是一整张</span></span><br><span class="line">                curWidth = m_cardSize.<span class="built_in">width</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curWidth = cardSpace;               <span class="comment">//如果不是最后一张牌，则宽度就是间隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">QRect <span class="title">cardRect</span><span class="params">(leftX + cardSpace*i, topY, curWidth, m_cardSize.height())</span></span>;</span><br><span class="line">            m_userCards.<span class="built_in">insert</span>(panel, cardRect);      <span class="comment">//将每张牌对象和在窗口的位置</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//如果是垂直(机器人玩家)</span></span><br><span class="line">            <span class="comment">//因为不是在窗口的最左测，所以还是需要加上cardsRect.left()</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>() + (cardsRect.<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域左边距离+(卡牌区域宽度-卡牌宽度)/2</span></span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - (list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//m_cardSize和panel都可以表示牌的高度</span></span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX, topY+i*cardSpace);         <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示玩家打出的牌</span></span><br><span class="line">    <span class="comment">//得到当前玩家的出牌区域以及本轮打出的牌</span></span><br><span class="line">    QRect playCardRect = m_contextMap[player].playHandRect;</span><br><span class="line">    Cards lastCards = m_contextMap[player].lastCards;                <span class="comment">//玩家本轮打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!lastCards.<span class="built_in">isEmpty</span>())&#123;                                        <span class="comment">//如果不为空(本轮出牌了)</span></span><br><span class="line">        <span class="type">int</span> playSpacing = <span class="number">24</span>;                      <span class="comment">//出牌区域中牌与牌的间隙</span></span><br><span class="line">        CardList lastCardList = lastCards.<span class="built_in">toCardList</span>();              <span class="comment">//将出的牌存到QVector容器</span></span><br><span class="line">        CardList::ConstIterator itplayed = lastCardList.<span class="built_in">constBegin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; itplayed!=lastCardList.<span class="built_in">constEnd</span>(); itplayed++,i++)&#123;             <span class="comment">//通过常量迭代器遍历本轮出的牌</span></span><br><span class="line">            CardPanel* panel = m_cardMap[*itplayed];          <span class="comment">//得到对应的卡牌窗口对象</span></span><br><span class="line">            panel-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);                        <span class="comment">//显示正面</span></span><br><span class="line">            panel-&gt;<span class="built_in">raise</span>();           <span class="comment">//提升牌(让当前窗口能显示在同以级别窗口的上方)---&gt;当有多张考牌时，为了达到堆叠的效果，2叠1，3叠2，4叠3</span></span><br><span class="line">            <span class="comment">//将打出的牌移动到出牌区域</span></span><br><span class="line">            <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;            <span class="comment">//水平</span></span><br><span class="line">                <span class="type">int</span> leftBase = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-(lastCardList.<span class="built_in">size</span>()<span class="number">-1</span>)*playSpacing-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>() + (playCardRect.<span class="built_in">height</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(leftBase+i*playSpacing, top);      <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> left = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;   <span class="comment">//出牌区域左像素+卡牌x在出牌区域x的中点像素</span></span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>();               <span class="comment">//y轴就是出牌区域的y轴</span></span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(left, top+i*playSpacing);           <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">show</span>();                 <span class="comment">//不确定是隐藏还是显示的，预防是隐藏的，所以就将其显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QPixmap <span class="title">GamePanel::loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span>  <span class="comment">//参2是图像的显示方位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找图片</span></span><br><span class="line">    QVector&lt;QString&gt;lordMan;</span><br><span class="line">    QVector&lt;QString&gt;lordWoman;</span><br><span class="line">    QVector&lt;QString&gt;farmerMan;</span><br><span class="line">    QVector&lt;QString&gt;farmerWoman;</span><br><span class="line">    lordMan &lt;&lt; <span class="string">&quot;:/images/lord_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_man_2.png&quot;</span>;</span><br><span class="line">    lordWoman &lt;&lt; <span class="string">&quot;:/images/lord_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_woman_2.png&quot;</span>;</span><br><span class="line">    farmerMan &lt;&lt; <span class="string">&quot;:/images/farmer_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_man_2.png&quot;</span>;</span><br><span class="line">    farmerWoman &lt;&lt; <span class="string">&quot;:/images/farmer_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_woman_2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过QImage加载图片,因为其提供镜像操作(将朝向左的图片变为朝向右的图片)</span></span><br><span class="line">    QImage image;</span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);          <span class="comment">//随机用一张图片</span></span><br><span class="line">    <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Lord)&#123;                   <span class="comment">//如果是男性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Farmer)&#123;           <span class="comment">//如果是男性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Lord)&#123;           <span class="comment">//如果是女性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Farmer)&#123;         <span class="comment">//如果是女性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    <span class="keyword">if</span>(direct == Player::Left)&#123;        <span class="comment">//如果图片是显示在左侧的，就不需要做镜像</span></span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image);        <span class="comment">//因为返回值是QPixmap，所以还得进行转换</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image.<span class="built_in">mirrored</span>(<span class="literal">true</span>,<span class="literal">false</span>));   <span class="comment">//参1：是否做水平镜像；参2：是否做垂直镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pixmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDispatchCard</span><span class="params">()</span>                 <span class="comment">//每触发一次定时器就会执行该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录扑克牌的位置(各玩家的牌移动距离都分100次步长完成)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> curMovePos = <span class="number">0</span>;     <span class="comment">//主要是记录移动了多少个步长(第一次进该函数执行一次后，以后进该函数，都不执行该句)</span></span><br><span class="line">    <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(curMovePos &gt;= <span class="number">100</span>)&#123;               <span class="comment">//满足条件的话，就说明当前玩家得到了牌，轮到下一个玩家得牌了</span></span><br><span class="line">        <span class="comment">//给当前玩家发一张牌</span></span><br><span class="line">        Card card = m_gameCtl-&gt;<span class="built_in">takeOneCard</span>();            <span class="comment">//随机获取一张牌</span></span><br><span class="line">        curPlayer-&gt;<span class="built_in">storeDispatchCard</span>(card);              <span class="comment">//将该牌存入到当前玩家的手牌中</span></span><br><span class="line">        <span class="comment">//Cards cs(card);                   //带参构造函数</span></span><br><span class="line">        <span class="comment">//disposeCard(curPlayer,cs);   //卡牌区域更新，该函数在上面执行storeDispatchCard()时，里面就发出了信号，并执行disposeCard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换当前玩家</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(curPlayer-&gt;<span class="built_in">getNextPlayer</span>());      <span class="comment">//将下一个玩家改为当前玩家，轮到发牌给他了</span></span><br><span class="line">        curMovePos = <span class="number">0</span>;           <span class="comment">//重新将步长次数置为0</span></span><br><span class="line">        <span class="comment">//发牌动画</span></span><br><span class="line">        <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);</span><br><span class="line">        <span class="comment">//判断牌是否发完了</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">cardCount</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//终止定时器</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            <span class="comment">//切换游戏状态</span></span><br><span class="line">            <span class="built_in">gameStatusPrecess</span>(GameControl::CallingLord);        <span class="comment">//切换为叫地主状态</span></span><br><span class="line">            <span class="comment">//终止发牌音乐的播放(牌发完了)</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">stopAssistMusic</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);        <span class="comment">//参数：当前玩家，移动步长的次数</span></span><br><span class="line">    curMovePos += <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理玩家状态的变化(槽函数)---&gt;gamecontrol类发出的信号(玩家状态变化)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onPlayerStatusChanged</span><span class="params">(Player *player, GameControl::PlayerStatus status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForCallLord:                        <span class="comment">//考虑叫地主</span></span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                 <span class="comment">//只有当前玩家是用户玩家时，才执行下面(机器人玩家没有该按钮组窗口)</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::CallLord, m_gameCtl-&gt;<span class="built_in">getPlayerMaxBet</span>()); <span class="comment">//切换按钮组窗口为抢地主的窗口(修改目前下注最高分)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForPlayHand:                        <span class="comment">//考虑出牌</span></span><br><span class="line">        <span class="comment">//玩家出牌前，隐藏上一轮打出的牌</span></span><br><span class="line">        <span class="built_in">hidePlayerDropCards</span>(player);</span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                       <span class="comment">//先判断玩家是否是用户玩家</span></span><br><span class="line">            <span class="comment">//取出出牌玩家的对象</span></span><br><span class="line">            Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();            <span class="comment">//取出上一次的出牌玩家，如果为空，说明出牌刚开始,</span></span><br><span class="line">            <span class="keyword">if</span>(pendPlayer == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>() || pendPlayer == <span class="literal">nullptr</span>)&#123;              <span class="comment">//如果用户玩家是上一次的出牌玩家(说明上一次出的牌，机器人玩家不要)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PlayCard);           <span class="comment">//显示相应的按钮组窗口(这是用户玩家自由出牌)</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                                       <span class="comment">//不是上一次的出牌玩家(轮到自己了，可以出牌，也可以不出牌)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PassOrPlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                        <span class="comment">//如果玩家是机器人玩家，则就不用显示空即可</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::Winning:</span><br><span class="line">        m_bgm-&gt;<span class="built_in">stopBGM</span>();                    <span class="comment">//结束播放背景音乐</span></span><br><span class="line">        <span class="comment">//如果玩家赢了，就要显示出其它玩家的牌(由背面变为正面)</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()].isFrontSide = <span class="literal">true</span>;        <span class="comment">//先将遍历置为true</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()].isFrontSide = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>());            <span class="comment">//updatePlayerCards会将剩余的牌会显示正面</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getRightRobot</span>());</span><br><span class="line">        <span class="comment">//更新玩家的得分</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();</span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(player);            <span class="comment">//将本局赢的玩家又设为当前玩家(下一局由它先决定要不要地主)</span></span><br><span class="line">        <span class="built_in">showEndingScorePanel</span>();                         <span class="comment">//显示游戏结束面板</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onGrabLordBet</span><span class="params">(Player *player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span>   <span class="comment">//处理抢地主情况的槽函数(显示在主窗口)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//显示抢地主的信息提示</span></span><br><span class="line">    PlayerContext context = m_contextMap[player];</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;                      <span class="comment">//分数为0，说明不叫地主</span></span><br><span class="line">        context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/buqinag.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;         <span class="comment">//如果是第一次叫地主</span></span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/jiaodizhu.png&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/qiangdizhu.png&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示叫地主的分数(如果不叫地主，下注分数是0，就没有必要显示，所以这句代码写在else语句里)</span></span><br><span class="line">        <span class="built_in">showAnimation</span>(Bet,bet);            <span class="comment">//调用动画效果类。参1是动画效果枚举类的分数枚举，参2是具体的分数</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.info-&gt;<span class="built_in">show</span>();              <span class="comment">//显示出提示信息</span></span><br><span class="line">    <span class="comment">//播放分数的背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playerRobLordMusic</span>(bet, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>(),flag);        <span class="comment">//性别需要强制转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDisposePlayHand</span><span class="params">(Player *player, Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//存储玩家当轮打出的牌</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);         <span class="comment">//获取出牌玩家的一些位置信息</span></span><br><span class="line">    it-&gt;lastCards = cards;</span><br><span class="line">    <span class="comment">//2.根据牌型播放游戏特效</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//获得牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Plane || type==PlayHand::Hand_Plane_Two_Pair || type== PlayHand::Hand_Plane_Two_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Plane);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Pair)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(LianDui);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(ShunZi);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Bomb);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(JokerBomb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果玩家打出的是空牌(不出牌)，显示提示信息</span></span><br><span class="line">    <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/pass.png&quot;</span>));</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">show</span>();         <span class="comment">//把info对应的窗口显示出来(之前被隐藏掉了)</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playPassMusic</span>((BGMControl::RoleSex)player-&gt;<span class="built_in">getRole</span>());      <span class="comment">//播放不要音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;            <span class="comment">//如果不为空，就需要判断是不是第一个(自由)出牌的玩家</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==player || m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==<span class="literal">nullptr</span>)&#123;    <span class="comment">//如果是自由出牌</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">true</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());     <span class="comment">//播放音乐，是自由出牌，参2为true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">false</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.更新玩家剩余的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">    <span class="comment">//4. 播放提示音乐</span></span><br><span class="line">    <span class="comment">//判断玩家剩余的牌的数量</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">2</span>)&#123;              <span class="comment">//剩余2张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last2, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">1</span>)&#123;        <span class="comment">//剩余1张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last1, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数是一个槽函数，是接收到control发出的键盘选择信号后，执行的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 判断是不是出牌状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus==GameControl::DispatchCard || m_gameStatus==GameControl::CallingLord)&#123;  <span class="comment">//如果当前是发牌或叫地主状态，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断发出信号的牌的所有者是不是当前用户玩家(有时候我们的鼠标点击了机器人玩家的牌。这样对应的牌窗口也会发出信号，所以需要进行判断)</span></span><br><span class="line">    CardPanel* panel = (CardPanel*)<span class="built_in">sender</span>();       <span class="comment">//sender()返回的是QObject类型的指针()，转换后，得到发出信号的卡牌窗口对象</span></span><br><span class="line">    <span class="keyword">if</span>(panel-&gt;<span class="built_in">getOwner</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;     <span class="comment">//判断发出信号的卡牌窗口的所有者，如果不是用户对象，就直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 保存当前被选中的牌的窗口对象</span></span><br><span class="line">    m_curSelCard = panel;               <span class="comment">//记录在当前手牌中选择的卡牌对象</span></span><br><span class="line">    <span class="comment">//4. 判断参数的鼠标键是左键还是右键</span></span><br><span class="line">    <span class="keyword">if</span>(button == Qt::LeftButton)&#123;                 <span class="comment">//点击的是左键，就设置对应的卡牌窗口加入到准备出牌的容器中</span></span><br><span class="line">        <span class="comment">//设置扑克牌的选中状态</span></span><br><span class="line">        panel-&gt;<span class="built_in">setSeclected</span>(!panel-&gt;<span class="built_in">isSelected</span>());    <span class="comment">//设置选择状态(如果之前没有选中，经过该函数就变为选中，之前选中了，经过该函数就是不选中)</span></span><br><span class="line">        <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(panel-&gt;<span class="built_in">getOwner</span>());</span><br><span class="line">        <span class="comment">//保存或删除扑克牌窗口对象</span></span><br><span class="line">        QSet&lt;CardPanel*&gt;::const_iterator it = m_selectCards.<span class="built_in">find</span>(panel);</span><br><span class="line">        <span class="keyword">if</span>(it == m_selectCards.<span class="built_in">constEnd</span>())&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">insert</span>(panel);       <span class="comment">//没有找到，将该牌添加到容器里面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::SelectCard);          <span class="comment">//播放出牌音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(button == Qt::RightButton)&#123;            <span class="comment">//点击的是右键，就打出牌(如果不满足出牌规则，就不响应)</span></span><br><span class="line">        <span class="comment">//调用出牌按钮对应的槽函数</span></span><br><span class="line">        <span class="built_in">onUserPlayHand</span>();          <span class="comment">//调用处理用户玩家出牌函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断游戏状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus != GameControl::PlayingHand)&#123;     <span class="comment">//当前游戏状态不是出牌状态，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断玩家是不是用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;       <span class="comment">//当前玩家如果不是用户玩家，也直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断要出的牌是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(m_selectCards.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//用户玩家要出的牌容器如果为空，也直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到要打出的牌的牌型(m_selectCards容器不为空)</span></span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        Card card = (*it)-&gt;<span class="built_in">getCard</span>();</span><br><span class="line">        cs.<span class="built_in">add</span>(card);                           <span class="comment">//将用户要打出的牌都放到Cards容器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cs)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();           <span class="comment">//获取要打出牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type==PlayHand::Hand_Unknown)&#123;                       <span class="comment">//如果打出的牌类型是不规则(没有定义)的，也就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前玩家的牌能不能压住上一家的牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;  <span class="comment">//先判断上一次的出牌玩家是不是用户玩家，如果不是，就不能随意出牌(要大过对方)</span></span><br><span class="line">        Cards cards = m_gameCtl-&gt;<span class="built_in">getPendCards</span>();        <span class="comment">//获取上一次的出牌玩家打出的牌</span></span><br><span class="line">        <span class="keyword">if</span>(!hand.<span class="built_in">canBeat</span>(<span class="built_in">PlayHand</span>(cards)))&#123;             <span class="comment">//判断用户玩家准备打出的牌能否击败对方的牌，不能就直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                  <span class="comment">//出完牌了，停止倒计时</span></span><br><span class="line">    <span class="comment">//通过玩家对象出牌(调用出牌函数)</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">playHand</span>(cs);      <span class="comment">//playHand()函数里面会从手牌中移除要打出的牌，并发出信号，通知主窗口接收</span></span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                <span class="comment">//清空用户玩家准备出牌的这个容器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家的放弃出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                     <span class="comment">//用户玩家放弃出牌，终止倒计时</span></span><br><span class="line">    <span class="comment">//判断是不是用户玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();          <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();            <span class="comment">//获取用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(curPlayer != userPlayer)&#123;               <span class="comment">//如果当前玩家不是用户玩家，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前用户玩家是不是上一次出牌的玩家(可以不处理)</span></span><br><span class="line">    Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(pendPlayer==userPlayer || pendPlayer==<span class="literal">nullptr</span>)&#123; <span class="comment">//如果上一次出牌玩家是自己(其它玩家要不起出的牌)或者第一次出牌，这两种清空都直接退出(因为必须要出牌)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打出一个空的Cards是对象</span></span><br><span class="line">    Cards empty;</span><br><span class="line">    userPlayer-&gt;<span class="built_in">playHand</span>(empty);</span><br><span class="line">    <span class="comment">//清空用户选择的牌(玩家可能选择了一些牌，但是没有打出去)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);         <span class="comment">//将选中的牌都设置为非选中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                  <span class="comment">//清空准备出牌容器</span></span><br><span class="line">    <span class="comment">//更新玩家待出牌区域的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(userPlayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特效动画函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showAnimation</span><span class="params">(GamePanel::AnimationType type, <span class="type">int</span> bet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::LianDui:</span><br><span class="line">    <span class="keyword">case</span> AnimationType::ShunZi:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">150</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showSequence</span>((AnimationWindow::Type)type);          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Plane:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>, <span class="number">75</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showPlane</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">180</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::JokerBomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showJokerBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bet:           <span class="comment">//如果是抢地主分数</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">160</span>, <span class="number">98</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-140</span>); <span class="comment">//x和y都先取中间位置，y还需要往上移</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBetScore</span>(bet);          <span class="comment">//调用加载分数的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个主要是考虑到其它动画，因为显示分数是在2s后，会将AnimationType窗口隐藏起来，这样其它动画窗口会看不见，所以在这里调用一下显示</span></span><br><span class="line">    m_animation-&gt;<span class="built_in">show</span>();     <span class="comment">//让隐藏的窗口再显示出来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::hidePlayerDropCards</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);          <span class="comment">//根据当前玩家得到对应的一些信息的位置(如果没有找到传进去的玩家，就返回迭代器end)</span></span><br><span class="line">    <span class="keyword">if</span>(it != m_contextMap.<span class="built_in">end</span>())&#123;                 <span class="comment">//如果it不等于end，说明找到了</span></span><br><span class="line">        <span class="keyword">if</span>(it-&gt;lastCards.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果为空，说明上次没有出牌</span></span><br><span class="line">            it-&gt;info-&gt;<span class="built_in">hide</span>();                     <span class="comment">//先隐藏对应的提示信息</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Cards ---&gt; Card   注：CardList = QVector&lt;Card&gt;</span></span><br><span class="line">            CardList list = it-&gt;lastCards.<span class="built_in">toCardList</span>();             <span class="comment">//将最后打出的牌全部存入到QVector容器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> last=list.<span class="built_in">begin</span>(); last!=list.<span class="built_in">end</span>(); last++)&#123;        <span class="comment">//遍历每一张牌</span></span><br><span class="line">                m_cardMap[*last]-&gt;<span class="built_in">hide</span>();    <span class="comment">//每一张牌都有对应的CardPanel，存到m_cardMap容器的，进行隐藏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it-&gt;lastCards.<span class="built_in">clear</span>();                    <span class="comment">//清空玩家最后一次打出的牌容器(不然会堆叠)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示玩家的最终得分(结束面板设置)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showEndingScorePanel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> islord = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getRole</span>() == Player::Lord?<span class="literal">true</span>:<span class="literal">false</span>;     <span class="comment">//玩家是否是地主</span></span><br><span class="line">    <span class="type">bool</span> isWin = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">isWin</span>();                                   <span class="comment">//玩家是否获胜</span></span><br><span class="line">    EndingPanel* panel = <span class="keyword">new</span> <span class="built_in">EndingPanel</span>(islord, isWin, <span class="keyword">this</span>);       <span class="comment">//创建一个结束面板窗口，参3的this表示在主窗口中显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">show</span>();                                           <span class="comment">//显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, -panel-&gt;<span class="built_in">height</span>());       <span class="comment">//结束面板刚开始显示在主窗口外(看不见)</span></span><br><span class="line">    panel-&gt;<span class="built_in">setPlayerScore</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">    <span class="comment">//根据玩家的输赢来播放对应的音乐</span></span><br><span class="line">    <span class="keyword">if</span>(isWin)&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置结束面板的动画效果</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(panel, <span class="string">&quot;geometry&quot;</span>, <span class="keyword">this</span>);   <span class="comment">//参1：给哪个对象指定动画效果；参3：父对象</span></span><br><span class="line">    <span class="comment">//动画持续时间</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">1500</span>);           <span class="comment">//1.5s</span></span><br><span class="line">    <span class="comment">//设置窗口的起始位置和终止位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(panel-&gt;<span class="built_in">x</span>(), panel-&gt;<span class="built_in">y</span>(), panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>, panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    <span class="comment">//设置窗口的运动曲线</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(<span class="built_in">QEasingCurve</span>(QEasingCurve::OutBounce));</span><br><span class="line">    <span class="comment">//播放动画效果</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//处理窗口信号(当点击继续游戏按钮，就会发出continueGame信号，然后这里也会接收该信号)</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;EndingPanel::continueGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        panel-&gt;<span class="built_in">close</span>();                  <span class="comment">//关闭结束界面窗口，但没有析构(但由于指定了父对象，所以的父对象没有结束，也就不会析构panel)</span></span><br><span class="line">        panel-&gt;<span class="built_in">deleteLater</span>();            <span class="comment">//手动析构panel结束界面窗口</span></span><br><span class="line">        animation-&gt;<span class="built_in">deleteLater</span>();        <span class="comment">//手动析构动画对象</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);               <span class="comment">//按钮组隐藏，显示空按钮的按钮组</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);                <span class="comment">//将游戏状态设置位发牌状态</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);              <span class="comment">//播放背景音乐(开始)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown = <span class="keyword">new</span> <span class="built_in">CountDown</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个闹钟类对象，父对象为主窗口</span></span><br><span class="line">    m_countDown-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_countDown-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_countDown-&gt;<span class="built_in">height</span>())/<span class="number">2</span>+<span class="number">30</span>);    <span class="comment">//显示位置</span></span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::notMuchTime, <span class="keyword">this</span>, [=]()&#123;             <span class="comment">//当闹钟秒数减为5s时,会发出信号</span></span><br><span class="line">        <span class="comment">//播放提示音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Alert);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::timeout, <span class="keyword">this</span>, &amp;GamePanel::onUserPass); <span class="comment">//当秒数减为0s时，会发出信号，执行的槽函数当放弃出牌情况处理</span></span><br><span class="line">    UserPlayer* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();               <span class="comment">//得到用户对象</span></span><br><span class="line">    <span class="built_in">connect</span>(userPlayer, &amp;UserPlayer::startCountDown, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//当用户玩家准备出牌时，会发出信号startCountDown</span></span><br><span class="line">        <span class="comment">//要在主屏幕上显示闹钟，必须是用户玩家可以放弃出牌的情况，比如说上一次出牌玩家不是自己且不是第一次刚开始出牌</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=userPlayer &amp;&amp; m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_countDown-&gt;<span class="built_in">showCountDown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_bkImage);         <span class="comment">//参数：窗口矩形区域、</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span>          <span class="comment">//鼠标移动过程中框选多张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="comment">//ev-&gt;buttons()里面有多种鼠标按住的移动方式(如左键、右键等)</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;                 <span class="comment">//判断一下是否有鼠标左键(大于0说明左键参与了行动)</span></span><br><span class="line">        QPoint pt = ev-&gt;<span class="built_in">pos</span>();                         <span class="comment">//得到鼠标在窗口中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(!m_cardsRect.<span class="built_in">contains</span>(pt))&#123;               <span class="comment">//如果pt不在出牌区域</span></span><br><span class="line">            m_curSelCard = <span class="literal">nullptr</span>;                  <span class="comment">//将鼠标选择的卡牌窗口置为nullptr</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                      <span class="comment">//如果鼠标按住的位置在卡牌区域，就要找到是哪些卡牌</span></span><br><span class="line">            QList&lt;CardPanel*&gt; list = m_userCards.<span class="built_in">keys</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                CardPanel* panel = list.<span class="built_in">at</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(m_userCards[panel].<span class="built_in">contains</span>(pt) &amp;&amp; m_curSelCard!=panel)&#123;  <span class="comment">//如果找到对应卡牌，且如果一直在一张卡牌上面，也只模拟点击一次</span></span><br><span class="line">                    <span class="comment">//点击这张扑克牌(模拟点击效果)</span></span><br><span class="line">                    panel-&gt;<span class="built_in">clicked</span>();       <span class="comment">//该函数会发出一个信号，接收者是GamePanel</span></span><br><span class="line">                    m_curSelCard = panel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6-游戏的启动过程"><a href="#6-游戏的启动过程" class="headerlink" title="6. 游戏的启动过程"></a>6. 游戏的启动过程</h1><blockquote><p> 在这个斗地主的小游戏中，虽然创建了许多类对象，但基本上会在主窗口类中做初始化，并实现各个类的功能，将每个类的功能结合在一起，就实现了单机版的斗地主小游戏。</p></blockquote><p>首先是在主窗口类<code>GamePanel</code>中，设置了主窗口的左上角标题和窗口大小，又往主窗口中加载了背景图，背景图有9张，每次启动游戏随机取1张。</p><p>在<code>initButtonsGroup()</code>函数中先初始化5个页面的按钮组，选择初始界面的按钮组为开始界面，即只有一个开始按钮。然后通过信号槽机制，当点击开始按钮后，就执行匿名函数(发牌操作)。这个匿名函数会切换按钮组窗口，切换成空按钮的窗口，将所有玩家的得分清0，然后又马上更新每个玩家的得分。通过函数<code>gameStatusPrecess()</code>将游戏状态改为发牌状态。在<code>gameStatusPrecess()</code>函数里，因为传进来的参数是发牌状态的参数，通过switch执行对应的状态分支，即开始发牌函数<code>startDispatchCard()</code>。在该开始发牌函数中，它会设置各个玩家和扑克牌在窗口中显示的一些属性，如玩家的头像显示、玩家的手牌是否可见以及正中间的卡牌。同时，在这个函数中，也启动了一个定时器，该定时器每隔10毫秒会发送一次，该定时器是定义在主窗口类GamePanel的构造函数中的，它是每隔固定时间会执行发牌函数<code>onDispatchCard()</code>，这个函数中，是慢慢移动卡牌位置，然后利用定时器实现一个动态的发牌效果，当还剩下3张牌时，停止定时器，通过函数<code>gameStatusPrecess()</code>切换游戏状态为叫地主状态。在该状态下，通过switch执行了对应的分支。在该分支下，先是将3张底牌隐藏起来，然后调用游戏控制类的开始叫地主<code>startLordCard()</code>函数。这个函数里面执行了从父类继承下来的虚函数<code>prepareCallLord()</code>，机器人玩家和用户玩家作为子类，它们实现的操作不一样。首先是用户玩家，用户玩家在这个虚函数里面没有执行任何操作，然后又向主窗口发出了信号<code>playerStatusChanged</code>，主窗口类的<code>gameControlInit()</code>函数里面通过connect来处理该信号，令<code>onPlayerStatusChanged()</code>槽函数执行相应操作。在该函数里，会先判断是否是用户玩家，如果是用户玩家，就切换按钮组窗口，切换叫地主的一些按钮出来。</p><p>用户玩家的叫地主按钮显示出来后，又回到了<code>initButtonsGroup()</code>函数，在该函数，通过信号槽机制connect设置，当点击对应下注按钮时，会携带对应的分数执行匿名函数，在这个匿名函数中，因为用户玩家已经下注了，所以就切换按钮组窗口，切换为空按钮组。同时它会执行Player类的<code>grabLordBet()</code>函数，这个函数会发出信号<code>notifyGrabLordBet</code>，在发出该信号后，在主窗口的构造函数中，游戏控制类初始化函数<code>gameControlInit()</code>里面执行的<code>playerInit()</code>函数，在该函数里面会通过信号槽机制connect来接收信号，并执行槽函数<code>onGrabBet()</code>，在这个函数里面，它会根据用户玩家的下注分数，来判断是否还需要继续执行抢地主的操作，大概有两种情况：</p><p>1.用户玩家按的按钮是不抢地主、下注1分或下注2分，这些情况都说明还需要继续执行抢地主状态，就发送一个信号<code>notifyGrabLordBet</code>，主窗口函数会在构造函数的<code>gameControlInit()</code>函数里面通过信号槽来接收处理，执行槽函数<code>onGrabLordBet()</code>，这个函数里面就是显示提示信息和播放对应的背景音乐。然后回到<code>onGrabBet()</code>函数，它会切换玩家，将下一个玩家更新为当前玩家，并向主窗口发出信号<code>playerStatusChanged</code>，主窗口接收该信号后执行的槽函数中，通过switch执行对应的抢地主分支，而抢地主分支是只有用户玩家时，才会切换出叫地主的按钮组，不是用户玩家，就什么都不执行，退出即可。然后回到onGrabBet()函数，通过当前玩家(机器人玩家)对象调用准备叫地主函数<code>prepareCallLord()</code>。在机器人玩家类中，重写的这个函数里面会创建一个叫地主的子线程，该子线程会先睡眠2s(模拟思考效果)，然后执行考虑叫地主函数<code>thinkCallLord()</code>，在该函数里，会分析对应机器人玩家的手牌情况，看是否满足叫地主的条件，通过最后计算出来的权重来断定下注多数分。然后发送信号<code>notifyGrabLordBet</code>，游戏控制类接受信号并执行槽函数<code>onGrabBet()</code>，在这个函数如果不满足某些条件，就会继续切换下一个玩家叫地主，依次下去。当满足一定条件时，就会确定地主玩家，执行成为地主函数<code>becomeLord()</code>。</p><p>2.用户玩家下注3分，直接成为地主，执行函数<code>becomeLord()</code>。</p><p>在<code>becomeLord()</code>函数中，先是设置各个玩家的身份，将当前地主身份的玩家设置为当前玩家(先出牌)，又将三张底牌添加到地主玩家的手牌中。然后这定义了一个定时器，每隔1s就发送信号<code>gameStatusChanged</code>和<code>playerStatusChanged</code>。其中由主窗口接收信号<code>gameStatusChanged</code>，执行槽函数<code>gameStatusPrecess()</code>，这个槽函数里面就是通过switch语句执行对应的分支，该分支下主要就是将底牌、中间的发牌隐藏、提示信息等，和显示玩家带身份的头像；主窗口也接收<code>playerStatusChanged</code>信号，并执行槽函数<code>onPlayerStatusChanged()</code>，通过执行对应的分支，该分支主要就是判断当前是否是用户玩家，如果是用户玩家，就切换按钮组窗口为出牌情况，不是的话就切换为空按钮主窗口。在处理完两个信号的槽函数后，在定时器中又调用了对应玩家的出牌函数<code>preparePlayHand()</code>，这个出牌函数是用户玩家和机器人玩家执行的程序不一样，用户玩家就执行发出一条信号<code>startCountDown</code>，用于出牌倒计时即可；机器人玩家会创建对应的出牌子线程，在子线程中会执行考虑出牌函数<code>thinkPlayHand()</code>，接下来就是小项目中设定的一些策略了，机器人玩家在什么情况下出什么样的牌。</p><h1 id="7-游戏效果"><a href="#7-游戏效果" class="headerlink" title="7. 游戏效果"></a>7. 游戏效果</h1><p>当点击启动程序时，会先显示一个加载的界面，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_13.png"></p><p>当加载页面完成后，就会出现游戏场景的页面了，在这个页面中右上角显示的是个玩家的分数，因为才启动程序，所以都是0分。场景的正中间是发卡牌的扑克牌，下面是开始按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_14.png"></p><p>当点击开始游戏按钮后，就进入了发牌阶段，只有用户玩家的手牌是显示正面的，其它两个机器人玩家的手牌是显示背面的。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_15.png"></p><p>当发牌结束后，就游戏就进入了叫地主状态，当用户玩家直接点击3分按钮后，就可以直接成为地主，结束叫地主状态。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_16.png"></p><p>而当用户玩家点击除3分按钮的其它按钮，就会轮到下一个(机器人)玩家考虑是否叫地主。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_17.png"></p><p>当3个玩家都下注后，最后由下注分数最大的玩家当地主，其它两个玩家作为农民。并且三张底牌显示在正上方。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_18.png"></p><p>叫地主状态结束后，用鼠标选择卡牌，点击出牌即可。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_19.png"></p><p>当出的牌是一些特殊牌型，如炸弹、飞机、顺子等，还会有特效出现。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_20.png"></p><p>当某个玩家出完牌后，表示胜利，然后正中间出现结束面板，显示当前三个玩家的得分，同时右上角也显示当前三个玩家的得分。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_21.png"></p><p>当点击继续游戏按钮时，可以马上又进入下一局游戏，主窗口的右上角依然保存三个玩家的得分。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_22.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-结束面板窗口类EndingPanel&quot;&gt;&lt;a href=&quot;#1-结束面板窗口类EndingPanel&quot; class=&quot;headerlink&quot; title=&quot;1. 结束面板窗口类EndingPanel&quot;&gt;&lt;/a&gt;1. 结束面板窗口类EndingPanel&lt;/h1</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Qt斗地主项目(上)</title>
    <link href="https://lxx93.online/2024/08/04/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8A)/"/>
    <id>https://lxx93.online/2024/08/04/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8A)/</id>
    <published>2024-08-04T10:35:30.000Z</published>
    <updated>2024-08-21T14:14:48.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>这是一个基于Qt开发的单机版的斗地主小游戏。该项目一共涉及到的类有如下：</p><p>1.卡牌类</p><ul><li>单张卡牌：Card</li><li>多张卡牌：Cards</li></ul><p>2.玩家类</p><ul><li><p>玩家类(父类)：Player</p></li><li><p>机器人玩家(子类)：Robot</p></li><li><p>非机器人玩家(子类)：UserPlayer</p></li></ul><p>3.窗口类</p><ul><li><p>游戏开始加载动画窗口：Loading</p></li><li><p>游戏主窗口：GamePanel</p></li><li><p>单张卡牌窗口：CardPanel</p></li><li><p>特效动画窗口：AnimationWindow</p></li><li><p>游戏窗口中的按钮窗口：ButtonGroup</p></li><li><p>游戏结束玩家的成绩窗口：EndingPanel</p></li><li><p>自定义按钮：MyButton</p></li><li><p>游戏分数面板窗口：ScorePanel</p></li></ul><p>4.游戏策略类</p><ul><li><p>出牌类：PlayHand</p></li><li><p>游戏策略类：Strategy</p></li></ul><p>5.游戏控制类</p><ul><li>游戏控制类：GameControl</li></ul><p>6.线程类</p><ul><li><p>机器人玩家抢地主：RobotGrapLord</p></li><li><p>机器人玩家出牌：RobotPlayHand</p></li></ul><p>7.音频类</p><ul><li>控制播放游戏中的所有音频：BGMControl</li></ul><p>首先，创建一个项目，项目名为Landlords，再创建一个游戏主窗口类<code>GamePanel</code>，继承的基类是<code>QMainWindow</code>。该类也将作为斗地主小游戏的一个主窗口。</p><h1 id="2-单张卡牌类Card"><a href="#2-单张卡牌类Card" class="headerlink" title="2. 单张卡牌类Card"></a>2. 单张卡牌类Card</h1><p>单张卡牌类Card主要完成的是扑克牌中花色和点数的定义，以及一些操作符重载，以方便后序的开发中更加简便和高效。</p><p>单张卡牌类Card的创建：通过选择新建、c++、c++class、类名为<code>Card</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p><h2 id="2-1-Card类的头文件"><a href="#2-1-Card类的头文件" class="headerlink" title="2.1 Card类的头文件"></a>2.1 Card类的头文件</h2><p>该头文件主要就是定义了卡牌花色和点数的枚举类，并通过有参构造来定义一张扑克牌。在这里为了后期的开发简便，事先定义了两个card类的排序函数，后期可以通过这两个函数实现对玩家手牌的排序。由于卡牌是存储在QSet容器里面的(定义在Cards类里面的)，Qt中规定该容器里面存储的元素数据必须是可以分配和可以指定的类型，如果要存储一个自定义对象类型，需要提供其比较操作符函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>              <span class="comment">//卡牌类：每张牌的一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//花色枚举类(为了操作方便，给枚举类加上开始和结尾)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardSuit</span>&#123;</span><br><span class="line">        Suit_Begin,</span><br><span class="line">        Diamond,             <span class="comment">//方块</span></span><br><span class="line">        Club,                <span class="comment">//梅花</span></span><br><span class="line">        Heart,               <span class="comment">//红桃</span></span><br><span class="line">        Spade,               <span class="comment">//黑桃</span></span><br><span class="line">        Suit_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//点数枚举类</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardPoint</span>&#123;</span><br><span class="line">        Card_Begin,         <span class="comment">//对应整数0</span></span><br><span class="line">        Card_3,</span><br><span class="line">        Card_4,</span><br><span class="line">        Card_5,</span><br><span class="line">        Card_6,</span><br><span class="line">        Card_7,</span><br><span class="line">        Card_8,</span><br><span class="line">        Card_9,</span><br><span class="line">        Card_10,</span><br><span class="line">        Card_J,</span><br><span class="line">        Card_Q,</span><br><span class="line">        Card_K,</span><br><span class="line">        Card_A,</span><br><span class="line">        Card_2,</span><br><span class="line">        Card_SJ,               <span class="comment">//小王</span></span><br><span class="line">        Card_BJ,               <span class="comment">//大王</span></span><br><span class="line">        Card_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Card</span>();</span><br><span class="line">    <span class="built_in">Card</span>(CardPoint point, CardSuit suit);      <span class="comment">//通过点数和花色创建一张扑克牌</span></span><br><span class="line">    <span class="comment">//设置成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(CardPoint point)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuit</span><span class="params">(CardSuit suit)</span></span>;</span><br><span class="line">    <span class="comment">//返回成员变量</span></span><br><span class="line">    <span class="function">CardPoint <span class="title">point</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">CardSuit <span class="title">suit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CardPoint m_point;           <span class="comment">//成员变量点数</span></span><br><span class="line">    CardSuit m_suit;             <span class="comment">//成员变量花色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象比较</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;         <span class="comment">//升序调用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;      <span class="comment">//降序调用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2);      <span class="comment">//操作符重载(&lt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用QSet容器,里面的使用的数据必须是可以分配和可以指定的类型(常用的基础数据类型)，如果是要存储一个对象的，不能处理的情况，就需要提供一个比较操作符的重载，并且重写</span></span><br><span class="line"><span class="comment">//一个qHash的全局函数，该函数作用是得到某个对象对应的哈希值，计算方式可以自己指定。</span></span><br><span class="line"><span class="comment">//操作符重载(==)</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right);     <span class="comment">//因为QSet容器存储自定义类型Card是有问题的，不能进行比较</span></span><br><span class="line"><span class="comment">//重写全局函数qHash</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line"><span class="comment">//定义类型的别名</span></span><br><span class="line"><span class="keyword">using</span> CardList = QVector&lt;Card&gt;;</span><br></pre></td></tr></table></figure><h2 id="2-2-Card类函数实现"><a href="#2-2-Card类函数实现" class="headerlink" title="2.2 Card类函数实现"></a>2.2 Card类函数实现</h2><p>这部分就是对单张卡牌Card类声明的函数进行实现，即卡牌进行构造，设置卡牌点数、花色，获取卡牌点数、花色等。也完成了一些Card类运算符的重载实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Card::<span class="built_in">Card</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//提供卡牌点数和花色初始化一张牌</span></span><br><span class="line">Card::<span class="built_in">Card</span>(Card::CardPoint point, Card::CardSuit suit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setPoint</span>(point);</span><br><span class="line">    <span class="built_in">setSuit</span>(suit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setPoint</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_point = point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌花色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setSuit</span><span class="params">(Card::CardSuit suit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_suit = suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Card::point</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的花色</span></span><br><span class="line"><span class="function">Card::CardSuit <span class="title">Card::suit</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const对象只能调用带const限定的函数，所以point和suit需要加const限定</span></span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &lt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &lt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &gt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &gt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right)&#123;</span><br><span class="line">    <span class="built_in">return</span> (left.<span class="built_in">point</span>()==right.<span class="built_in">point</span>()&amp;&amp;left.<span class="built_in">suit</span>()==right.<span class="built_in">suit</span>());      <span class="comment">//花色和点数完成相等放回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> card.<span class="built_in">point</span>()*<span class="number">100</span>+card.<span class="built_in">suit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lessSort</span>(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-多张卡牌类Cards"><a href="#3-多张卡牌类Cards" class="headerlink" title="3. 多张卡牌类Cards"></a>3. 多张卡牌类Cards</h1><p>多张卡牌类Cards主要是在Card类的基础上，将对卡牌的一些功能操作进行完善和增添。</p><p>多张卡牌类Cards创建：通过选择新建、c++、c++class、类名为<code>Cards</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p><h2 id="3-1-Cards类的头文件"><a href="#3-1-Cards类的头文件" class="headerlink" title="3.1 Cards类的头文件"></a>3.1 Cards类的头文件</h2><p>该头文件主要定义了一个成员变量<code>m_cards</code>，它是存储多张卡牌的的一个容器对象，以及定义了一系列的成员函数，如对卡牌的添加、删除，和获得<code>m_cards</code>对象的属性，如几张卡牌，是否为空等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cards</span>                  <span class="comment">//多张卡牌类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">SortType</span>&#123;Asc,Desc,NoSort&#125;;          <span class="comment">//枚举类，卡牌排序类型</span></span><br><span class="line">    <span class="built_in">Cards</span>();</span><br><span class="line">    <span class="built_in">Cards</span>(<span class="type">const</span> Card&amp; card);       <span class="comment">//带参的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;                   <span class="comment">//添加单张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;                 <span class="comment">//添加多张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp; cards)</span></span>;        <span class="comment">//添加一个容器的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次性插入多个数据(操作符重载&lt;&lt;)</span></span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card);</span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp;cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cardCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">maxPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//最小点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">minPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//指定点数的牌的数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pointCount</span><span class="params">(Card::CardPoint point)</span></span>;</span><br><span class="line">    <span class="comment">//某张(些)牌是否在集合中(底层是通过是否存在子集来返回)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机取出一张扑克牌(发牌时会用)</span></span><br><span class="line">    <span class="function">Card <span class="title">takeRandomCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将QSet容器转为Qvector容器，实现排序功能</span></span><br><span class="line">    <span class="function">CardList <span class="title">toCardList</span><span class="params">(SortType type = Desc)</span></span>; <span class="comment">//CardList是在card.h里面定义的一种QVector&lt;Card&gt;的一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSet&lt;Card&gt; m_cards;     <span class="comment">//容器里存的是单张卡牌类对象(不重复、无序的)，不能进行排序，要排序就只能转QVector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-Cards类函数实现"><a href="#3-2-Cards类函数实现" class="headerlink" title="3.2 Cards类函数实现"></a>3.2 Cards类函数实现</h2><p>这部分就是对多张卡牌Cards类声明的函数进行实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">Cards::<span class="built_in">Cards</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Cards::<span class="built_in">Cards</span>(<span class="type">const</span> Card &amp;card)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">insert</span>(card);             <span class="comment">//添加单张卡牌就直接往容器m_cards插入即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">unite</span>(cards.m_cards);    <span class="comment">//添加多张卡牌就通过并联添加到容器m_cards里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">count</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写操作符</span></span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card)&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards)&#123;</span><br><span class="line">    <span class="built_in">add</span>(cards);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;            <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">remove</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(card);                 <span class="comment">//从容器中移出卡牌card</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">subtract</span>(cards.m_cards);      <span class="comment">//通过差集将容器m_cards移出多张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::cardCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断手牌是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">isEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除m_cards容器里的卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最大点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::maxPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint max = Card::Card_Begin;             <span class="comment">//Card_Begin对应的枚举类值为0</span></span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &gt; max)&#123;</span><br><span class="line">                max = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;       <span class="comment">//返回容器中最大点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最小点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::minPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint min = Card::Card_End;</span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &lt; min)&#123;</span><br><span class="line">                min = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;       <span class="comment">//返回容器中最小点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到点数为point的卡牌</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::pointCount</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;            <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() == point)&#123;</span><br><span class="line">            count++;          <span class="comment">//如果等于指定点数，数量就+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(card);            <span class="comment">//是否存在该张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(cards.m_cards);    <span class="comment">//是否存在该些卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌，后面发牌操作会用到</span></span><br><span class="line"><span class="function">Card <span class="title">Cards::takeRandomCard</span><span class="params">()</span>          <span class="comment">//随机取出一张卡牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成一个随机数</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(m_cards.<span class="built_in">size</span>());     <span class="comment">//返回一个0到(卡牌数-1)范围的数字，即0到51</span></span><br><span class="line">    QSet&lt;Card&gt;::const_iterator it = m_cards.<span class="built_in">constBegin</span>();              <span class="comment">//const_iterator是只读迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++,it++);</span><br><span class="line">    Card card = *it;         <span class="comment">//记录随机数对应的卡牌</span></span><br><span class="line">    m_cards.<span class="built_in">erase</span>(it);       <span class="comment">//从容器中移出该卡牌</span></span><br><span class="line">    <span class="keyword">return</span> card;             <span class="comment">//返回随机数对应的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对手牌进行升序还是降序</span></span><br><span class="line"><span class="function">CardList <span class="title">Cards::toCardList</span><span class="params">(Cards::SortType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        list &lt;&lt; *it;           <span class="comment">//每遍历一个元素，就将元素存入list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == Asc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),lessSort);            <span class="comment">//升序</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == Desc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),greaterSort);         <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-卡牌窗口类CardPanel"><a href="#4-卡牌窗口类CardPanel" class="headerlink" title="4. 卡牌窗口类CardPanel"></a>4. 卡牌窗口类CardPanel</h1><p>因为每张卡牌在主界面中都是以窗口的形式出现，所以该卡牌窗口类<code>CardPanel</code>相当于是对卡牌对象更充分的完善。</p><p>卡牌窗口类创建：通过选择新建、c++、c++class、类名为<code>CardPanel</code>，基类为QWidget。</p><h2 id="4-1-CardPanel类头文件"><a href="#4-1-CardPanel类头文件" class="headerlink" title="4.1 CardPanel类头文件"></a>4.1 CardPanel类头文件</h2><p>该头文件加载了每张卡牌的的图片，其定义了一系列的成员变量和成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CardPanel</span> : <span class="keyword">public</span> QWidget          <span class="comment">//卡牌窗口类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CardPanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置获取图片函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span>;      <span class="comment">//保存图片信息的，参数1是正面图片；参数2是背面图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">getImage</span><span class="params">()</span></span>;               <span class="comment">//获取正面图片信息(背面都是一样的)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌显示哪一面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFrontSide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录窗口是否被选中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSelected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function">Card <span class="title">getCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的所有者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOwner</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getOwner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;             <span class="comment">//事件处理函数，更新窗口信息的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;        <span class="comment">//重写鼠标按下事件</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;       <span class="comment">//用户玩家的鼠标选择信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_front;</span><br><span class="line">    QPixmap m_back;</span><br><span class="line">    <span class="type">bool</span> m_isfront=<span class="literal">true</span>;                <span class="comment">//是否是正面</span></span><br><span class="line">    <span class="type">bool</span> m_isSelect=<span class="literal">false</span>;              <span class="comment">//是否被选中</span></span><br><span class="line">    Card m_card;                        <span class="comment">//卡牌类对象</span></span><br><span class="line">    Player* m_owner=<span class="literal">nullptr</span>;            <span class="comment">//玩家类对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2-CardPanel类函数实现"><a href="#4-2-CardPanel类函数实现" class="headerlink" title="4.2 CardPanel类函数实现"></a>4.2 CardPanel类函数实现</h2><p>这部分就是卡牌窗口类<code>CardPanel</code>里面声明的函数进行实现。可以通过该类成员获得卡牌窗口的一些属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">CardPanel::<span class="built_in">CardPanel</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)&#123;&#125;</span><br><span class="line"><span class="comment">//加载卡牌窗口图片</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_front = front;</span><br><span class="line">    m_back = back;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_front.<span class="built_in">size</span>());        <span class="comment">//设置当前的窗口大小为图片大小</span></span><br><span class="line">    <span class="built_in">update</span>();                           <span class="comment">//刷新窗口，调用的是paintEvent()函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌窗口的正面</span></span><br><span class="line"><span class="function">QPixmap <span class="title">CardPanel::getImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置是正面还是反面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isfront = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isFrontSide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isfront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isSelect = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isSelect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_card = card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Card <span class="title">CardPanel::getCard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setOwner</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_owner = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的所有者</span></span><br><span class="line"><span class="function">Player *<span class="title">CardPanel::getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_owner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(Qt::LeftButton)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口刷新函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::paintEvent</span><span class="params">(QPaintEvent *event)</span>     <span class="comment">//当setImage()函数把图片设置好后，就可以重新绘制窗口了，即调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);               <span class="comment">//处理event参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;             <span class="comment">//定义一个画家类</span></span><br><span class="line">    <span class="keyword">if</span>(m_isfront)&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_front);      <span class="comment">//如果是正面，就画正面，大小和当前窗口一样大rect()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_back);       <span class="comment">//如果是背面，就画背面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新写鼠标划过函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(event-&gt;button())</span></span>;             <span class="comment">//游戏的主窗口接收该信号(鼠标按键的选择)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-玩家类Player"><a href="#5-玩家类Player" class="headerlink" title="5. 玩家类Player"></a>5. 玩家类Player</h1><p>该类是作为游戏里的三个玩家的基类，即两个机器人玩家类和用户玩家类。作为基类，它定义了一些共同的属性，提示为后序的开发提供了一些辅助函数，方便得到需要的属性内容。</p><p>玩家类创建：通过选择新建、c++、c++class、类名为<code>Player</code>，基类为QObject。</p><h2 id="5-1-Player类头文件"><a href="#5-1-Player类头文件" class="headerlink" title="5.1 Player类头文件"></a>5.1 Player类头文件</h2><p>该头文件不仅定义了许多关于玩家的成员变量和成员函数，还定义了四个虚函数，通过多态的方式来实现不同机器人玩家的这个处理逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> QObject               <span class="comment">//玩家类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Role</span>&#123;Lord, Farmer&#125;;             <span class="comment">//角色</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Sex</span>&#123;Man, Woman&#125;;                <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;Left, Right&#125;;         <span class="comment">//头像的显示方位</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Robot, User, UnKnow&#125;;      <span class="comment">//玩家的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QString name, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(QString name)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function">Role <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSex</span><span class="params">(Sex sex)</span></span>;</span><br><span class="line">    <span class="function">Sex <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头像方位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirection</span><span class="params">(Direction direction)</span></span>;</span><br><span class="line">    <span class="function">Direction <span class="title">getDirection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setType</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getScore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//游戏结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供当前对象的上家/下家对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrevPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getPrevPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getNextPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//叫地主、抢地主(传出一个信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">grabLordBet</span><span class="params">(<span class="type">int</span> point)</span></span>;           <span class="comment">//传入的是分数(1，2，3，0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储扑克牌(发牌的时候得到的)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Cards&amp; cards)</span></span>;        <span class="comment">//抢地主得到的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到所有的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空玩家手中所有的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">(Cards&amp; cards)</span></span>;            <span class="comment">//出牌可以出一张也可以出多张</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取待出牌玩家对象以及这个玩家打出的牌(比如说当前玩家出牌后，要记录出牌的玩家和出的牌，下一个出牌玩家会用到)</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storePendingInfo</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚函数 通过多态来实现机器人玩家A和机器人玩家B(有相同的同名函数，但处理逻辑不一样，所以用多态实现)</span></span><br><span class="line">    <span class="comment">//下面4个虚函数在play只需要定义即可，功能实现交给子类，即机器人玩家和用户玩家</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span></span>;           <span class="comment">//准备叫地主(启动 考虑叫地主 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span></span>;           <span class="comment">//准备出牌(启动 考虑出牌 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span></span>;             <span class="comment">//考虑叫地主(计算权重)---&gt;机器人玩家类Robot会重写该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span></span>;             <span class="comment">//考虑出牌---&gt;计算机玩家类Robot会重写该函数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//通知已经叫地主下注</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;         <span class="comment">//参数：叫地主的玩家，下的分数</span></span><br><span class="line">    <span class="comment">//通知已经出牌(playHand()出牌函数会使用，当玩家出完牌后，需要发送的信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;        <span class="comment">//参数：出牌玩家，出的牌</span></span><br><span class="line">    <span class="comment">//向主窗口通知已经得到了卡牌(两种情况，普通得牌和得3张底牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPickCards</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                       <span class="comment">//子类也需要访问这些成员属性遍历，所以得是protected类型</span></span><br><span class="line">    QString m_name;              <span class="comment">//玩家姓名</span></span><br><span class="line">    Role m_role;                 <span class="comment">//玩家角色(枚举类)，地主还是农民</span></span><br><span class="line">    Sex m_sex;                   <span class="comment">//玩家性别(枚举类)，角色性别</span></span><br><span class="line">    Direction m_direction;       <span class="comment">//玩家的头像的显示方位(枚举类)，左或右</span></span><br><span class="line">    Type m_type;                 <span class="comment">//玩家的类型(枚举类)，机器人、用户或未知</span></span><br><span class="line">    <span class="type">int</span> m_score;                 <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="type">bool</span> m_isWin;                <span class="comment">//玩家是否获胜</span></span><br><span class="line"></span><br><span class="line">    Player* m_prev;            <span class="comment">//上家</span></span><br><span class="line">    Player* m_next;            <span class="comment">//下家</span></span><br><span class="line"></span><br><span class="line">    Cards m_cards;             <span class="comment">//存储多张扑克牌(玩家手中的牌)</span></span><br><span class="line"></span><br><span class="line">    Cards m_pendCards;                    <span class="comment">//打出的扑克牌</span></span><br><span class="line">    Player* m_pendPlayer = <span class="literal">nullptr</span>;         <span class="comment">//打出扑克牌的玩家(初始化先置为空)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-2-Player类函数实现"><a href="#5-2-Player类函数实现" class="headerlink" title="5.2 Player类函数实现"></a>5.2 Player类函数实现</h2><p>该玩家类Player实现了两种类的构造函数方法，同时实现了设置和获取玩家的相关属性。而虚函数在这里只需要定义出来即可，不需要实现，留给子类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">Player::<span class="built_in">Player</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)        <span class="comment">//玩家类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    m_score = <span class="number">0</span>;                  <span class="comment">//分数初始化为0</span></span><br><span class="line">    m_isWin = <span class="literal">false</span>;              <span class="comment">//初始化是否赢</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;       <span class="comment">//上次出牌玩家开始指向空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当用的是这个构造函数时，也会初始化父类的构造函数</span></span><br><span class="line">Player::<span class="built_in">Player</span>(QString name, QObject *parent) : <span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的名字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setName</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">Player::getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的角色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setRole</span><span class="params">(Role role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_role = role;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Role <span class="title">Player::getRole</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_role;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家性别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setSex</span><span class="params">(Player::Sex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Sex <span class="title">Player::getSex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的头像方位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setDirection</span><span class="params">(Player::Direction direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_direction = direction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Direction <span class="title">Player::getDirection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的类型(机器人玩家还是用户玩家)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setType</span><span class="params">(Player::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Type <span class="title">Player::getType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Player::getScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家身份获胜</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isWin = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Player::isWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isWin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家的上一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setPrevPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_prev = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置玩家的下一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setNextPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_next = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的上一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPrevPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的下一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getNextPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::grabLordBet</span><span class="params">(<span class="type">int</span> point)</span>      <span class="comment">//抢地主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(<span class="keyword">this</span>, point)</span></span>;  <span class="comment">//发出玩家叫地主的信号，游戏控制类接收该信号，参数：抢地主玩家，下的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入单张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(card);</span><br><span class="line">    Cards cs;</span><br><span class="line">    cs.<span class="built_in">add</span>(card);</span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>, cs)</span></span>;            <span class="comment">//向主窗口通知得到牌了(发牌阶段)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存入多张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(cards);           <span class="comment">//添加底牌</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>,cards)</span></span>;      <span class="comment">//向主窗口通知得到3张底牌了(在游戏控制类中becomelords()中,添加底牌会调用该函数)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::clearCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::playHand</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(cards);                 <span class="comment">//从玩家手中的牌移出要出的牌</span></span><br><span class="line">    <span class="comment">//发出信号，因为该信号可能是机器人玩家发出，也可能是用户玩家发出，所以就通过基类指针this指向子类对象</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(<span class="keyword">this</span>, cards)</span></span>;         <span class="comment">//该信号由游戏控制类接收处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得上一次的出牌玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得上一次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录上一次的出牌玩家和出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storePendingInfo</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pendPlayer = player;</span><br><span class="line">    m_pendCards = cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只定义出四个虚函数即可，留给子类实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::prepareCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::preparePlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkPlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-机器人玩家类Robot"><a href="#6-机器人玩家类Robot" class="headerlink" title="6. 机器人玩家类Robot"></a>6. 机器人玩家类Robot</h1><p>机器人玩家类Robot的基类是玩家类Player，它主要任务就是实现从父类继承下来的虚函数。</p><p>机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>Robot</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将基类改为Player类。</p><h2 id="6-1-Robot类头文件"><a href="#6-1-Robot类头文件" class="headerlink" title="6.1 Robot类头文件"></a>6.1 Robot类头文件</h2><p>机器人玩家类Robot只需要实现从父类继承来的虚函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span> : <span class="keyword">public</span> Player          <span class="comment">//机器人玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Robot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑出牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-2-Robot类函数实现"><a href="#6-2-Robot类函数实现" class="headerlink" title="6.2 Robot类函数实现"></a>6.2 Robot类函数实现</h2><p>这部分主要就是实现了准备叫地主、考虑叫地主、准备出牌和考虑出牌。</p><p>当是机器人玩家时，它会将从父类Player继承下来的虚函数进行重写。首先是在准备叫地主函数<code>prepareCallLord()</code>中，它会创建一个叫地主的子线程类<code>RobotGrapLord</code>(在后面)，然后执行<code>strat()</code>，它会启动子线程类里面的<code>run()</code>函数，而<code>run()</code>函数是睡眠了2s后，调用考虑叫地主函数<code>thinkCallLord()</code>。机器人玩家通过计算手牌的权重来得出是否叫地主的决定。对于准备和考虑出牌过程和这个一模一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Robot::<span class="built_in">Robot</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::Robot;         <span class="comment">//确定玩家类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::prepareCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotGrapLord* subThread = <span class="keyword">new</span> <span class="built_in">RobotGrapLord</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑叫地主的子线程类</span></span><br><span class="line">    <span class="comment">//当子线程里面内容都执行完了，会发出finished信号过后，就调用deleteLater()方法，释放掉该线程占用的内存</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotGrapLord 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();        <span class="comment">//启动考虑叫地主子线程类的run，run函数里面会调用thinkCallLord()来计算权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::preparePlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotPlayHand* subThread = <span class="keyword">new</span> <span class="built_in">RobotPlayHand</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑出牌的子线程类</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotPlayHand 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();             <span class="comment">//启动run函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑叫地主</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  机器人玩家基于手中的牌计算权重，根据权重来考虑是否叫地主</span></span><br><span class="line"><span class="comment">        大小王：6</span></span><br><span class="line"><span class="comment">        顺子/炸弹：5</span></span><br><span class="line"><span class="comment">        三张点数相同的牌：4</span></span><br><span class="line"><span class="comment">        2的权重：3</span></span><br><span class="line"><span class="comment">        对牌：1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;</span><br><span class="line">    weight += st.<span class="built_in">getRangeCards</span>(Card::Card_SJ,Card::Card_BJ).<span class="built_in">cardCount</span>()*<span class="number">6</span>;     <span class="comment">//得到手牌中大小王的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;optSeq = st.<span class="built_in">pickOptimalSeqSingles</span>();   <span class="comment">//pickOptimalSeqSingles函数内部还是再找顺子之前，已经剔除了炸弹、3带1和飞机类型牌</span></span><br><span class="line">    weight += optSeq.<span class="built_in">size</span>()*<span class="number">5</span>;                   <span class="comment">//得到手牌中的顺子的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;bombs = st.<span class="built_in">findCardsByCount</span>(<span class="number">4</span>);</span><br><span class="line">    weight += bombs.<span class="built_in">size</span>()*<span class="number">5</span>;                                 <span class="comment">//得到手牌中炸弹的权重</span></span><br><span class="line"></span><br><span class="line">    weight += m_cards.<span class="built_in">pointCount</span>(Card::Card_2) * <span class="number">3</span>;           <span class="comment">//得到2的权重</span></span><br><span class="line"></span><br><span class="line">    Cards tmp = m_cards;                            <span class="comment">//防止计算权重的牌重复，先复制手牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(optSeq);                             <span class="comment">//剔除顺子</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(bombs);                              <span class="comment">//剔除炸弹</span></span><br><span class="line">    Cards card2 = st.<span class="built_in">getRangeCards</span>(Card::Card_2,Card::Card_2);       <span class="comment">//先取出点数为2的牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(card2);                              <span class="comment">//剔除2</span></span><br><span class="line">    QVector&lt;Cards&gt;triples = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">3</span>);  <span class="comment">//在剔除相应牌型后，再继续找三张相同的牌</span></span><br><span class="line">    weight += triples.<span class="built_in">size</span>()*<span class="number">4</span>;                                      <span class="comment">//得到三张点数相同的牌的权重</span></span><br><span class="line"></span><br><span class="line">    tmp.<span class="built_in">remove</span>(triples);                           <span class="comment">//剔除三张相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;pairs = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">2</span>);   <span class="comment">//在tmp里找对牌</span></span><br><span class="line">    weight += pairs.<span class="built_in">size</span>()*<span class="number">1</span>;                                       <span class="comment">//得到对牌的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(weight &gt;= <span class="number">22</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">22</span> &amp;&amp; weight&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">18</span> &amp;&amp; weight&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;              <span class="comment">//先构造一个Strategy对象，这样就可以使用Strategy类里面的函数了</span></span><br><span class="line">    Cards cs = st.<span class="built_in">makeStrategy</span>();                  <span class="comment">//调用出牌策略函数，可以直接得到机器人玩家要出的牌</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;打出的牌数量：&quot;</span> &lt;&lt;cs.<span class="built_in">cardCount</span>();</span><br><span class="line">    <span class="built_in">playHand</span>(cs);                                  <span class="comment">//出牌，即从手牌中移除要出的牌cs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-用户玩家类UserPlayer"><a href="#7-用户玩家类UserPlayer" class="headerlink" title="7. 用户玩家类UserPlayer"></a>7. 用户玩家类UserPlayer</h1><p>用户玩家类UserPlayer只需要实现从基类Player继承下来的虚函数准备叫地主和准备出牌，且都不需要写太多程序操作，因为这些过程都是用户通过鼠标点击来完成的。</p><p>非机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>UserPlayer</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将其基类改为Player。</p><h2 id="7-1-UserPlayer类头文件"><a href="#7-1-UserPlayer类头文件" class="headerlink" title="7.1 UserPlayer类头文件"></a>7.1 UserPlayer类头文件</h2><p>该类只定义从基类继承下来的虚函数准备叫地主和准备出牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserPlayer</span> : <span class="keyword">public</span> Player              <span class="comment">//非机器人(用户)玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                   <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UserPlayer</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家准备出牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startCountDown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-2-UserPlayer类函数实现"><a href="#7-2-UserPlayer类函数实现" class="headerlink" title="7.2 UserPlayer类函数实现"></a>7.2 UserPlayer类函数实现</h2><p>该部分实现的两个虚函数都不需要做太多操作，因为是用户玩家，这些过程都是通过鼠标完成。但在准备出牌函数中，发出了一个信号<code>startCountDown</code>，表示从轮到用户玩家出牌开始就通知主窗口计时，当秒数从15变为0时，就默认用户玩家放弃出牌。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UserPlayer::<span class="built_in">UserPlayer</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::User;         <span class="comment">//确定玩家类型(用户)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::prepareCallLord</span><span class="params">()</span>               <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::preparePlayHand</span><span class="params">()</span>               <span class="comment">//用户玩家准备出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">startCountDown</span><span class="params">()</span></span>;                       <span class="comment">//发射一个信号，告知主窗口是用户玩家准备出牌，要开始倒计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-叫地主线程类RobotGrapLord"><a href="#8-叫地主线程类RobotGrapLord" class="headerlink" title="8. 叫地主线程类RobotGrapLord"></a>8. 叫地主线程类RobotGrapLord</h1><p>叫地主线程类<code>RobotGrapLord</code>是专为机器人玩家设计的类，就是负责模拟叫地主这一过程。</p><p>机器人玩家叫地主线程类创建：新建、c、c++、类名为<code>RobotGrapLord</code>，基类为QObject，创建好后修改基类为QThread。</p><h2 id="8-1-RobotGrapLord类头文件"><a href="#8-1-RobotGrapLord类头文件" class="headerlink" title="8.1 RobotGrapLord类头文件"></a>8.1 RobotGrapLord类头文件</h2><p>叫地主线程类RobotGrapLord就定义了一个从基类继承下来的run()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RobotGrapLord</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotGrapLord</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//重写QThread类里面的run方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;                <span class="comment">//执行机器人玩家叫地主</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-2-RobotGrapLor类函数实现"><a href="#8-2-RobotGrapLor类函数实现" class="headerlink" title="8.2 RobotGrapLor类函数实现"></a>8.2 RobotGrapLor类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑叫地主函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RobotGrapLord::<span class="built_in">RobotGrapLord</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player= player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过start()来调用run()函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotGrapLord::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);                      <span class="comment">//睡2秒，模拟机器人玩家一个思考的过程</span></span><br><span class="line">    m_player-&gt;<span class="built_in">thinkCallLord</span>();         <span class="comment">//直接调用Robot类写的考虑叫地主函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-出牌线程类RobotPlayHand"><a href="#9-出牌线程类RobotPlayHand" class="headerlink" title="9. 出牌线程类RobotPlayHand"></a>9. 出牌线程类RobotPlayHand</h1><p>出牌线程类<code>RobotPlayHand</code>是专为机器人玩家设计的类，就是负责模拟出牌这一过程。</p><p>机器人玩家出牌线程类创建：新建、c、c++、类名为<code>RobotPlayHand</code>，基类为QObject，创建好后修改基类为QThread。</p><h2 id="9-1-RobotPlayHand类头文件"><a href="#9-1-RobotPlayHand类头文件" class="headerlink" title="9.1 RobotPlayHand类头文件"></a>9.1 RobotPlayHand类头文件</h2><p>出牌线程类RobotPlayHand就定义了一个从基类继承下来的run()方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机器人玩家出牌子线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotPlayHand</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotPlayHand</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;                   <span class="comment">//重写</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-2-RobotPlayHand类函数实现"><a href="#9-2-RobotPlayHand类函数实现" class="headerlink" title="9.2 RobotPlayHand类函数实现"></a>9.2 RobotPlayHand类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑出牌函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RobotPlayHand::<span class="built_in">RobotPlayHand</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player = player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotPlayHand::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);</span><br><span class="line">    m_player-&gt;<span class="built_in">thinkPlayHand</span>();        <span class="comment">//调用考虑出牌函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-玩家分数窗口类ScorePanel"><a href="#10-玩家分数窗口类ScorePanel" class="headerlink" title="10. 玩家分数窗口类ScorePanel"></a>10. 玩家分数窗口类ScorePanel</h1><p>分数窗口类ScorePanel就是负责显示各个玩家的分数，在该小项目中，有两处会使用该分数窗口。一个是主窗口的左上角会显示各个玩家的分数；还有一个是一局游戏结束后，在结束面板上显示各个玩家的分数。</p><h2 id="10-1-制作分数面板窗口"><a href="#10-1-制作分数面板窗口" class="headerlink" title="10.1 制作分数面板窗口"></a>10.1 制作分数面板窗口</h2><p>创建子窗口：</p><p>1.游戏分数面板子窗口：通过选择新建、Qt、Qt设计师界面类、选择Widget类型的窗口(可以内嵌的，以没有边框的形式完美的附着在父窗口上面)，类名为<code>ScorePanel</code>。</p><p>2.将分数窗口添加到主窗口(右上方)</p><p>在主窗口拖入一个Widget子窗口，因为它是一个Widget类型，而不是分数面板的类型，所以就需要进行提升，即就是把父类变为子类。基于这个理论，可以发现分数面板类ScorePanel的基类是Widget类型，所以就可以将该Widget类提升为ScorePanel类型。这样就将Qt中的标准控件变为了自定义控件(把一个基类变成了子类类型)。</p><h2 id="10-2-ScorePanel类头文件"><a href="#10-2-ScorePanel类头文件" class="headerlink" title="10.2 ScorePanel类头文件"></a>10.2 ScorePanel类头文件</h2><p>分数窗口类ScorePanel就定义了一些设置属性的函数，如字体的大小和颜色，这样后期要使用分数窗口的时候，也可以根据环境来设置适合的字体和颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FontColor</span>&#123;Black, White,Red,Blue,Green&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ScorePanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ScorePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置玩家的得分(将得分显示在窗口上)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span>;     <span class="comment">//参数是三个玩家的得分</span></span><br><span class="line">    <span class="comment">//设置字体大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span>;</span><br><span class="line">    <span class="comment">//设置字体的颜色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontColor</span><span class="params">(FontColor color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ScorePanel *ui;</span><br><span class="line">    QVector&lt;QLabel*&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="10-3-ScorePanel类函数实现"><a href="#10-3-ScorePanel类函数实现" class="headerlink" title="10.3 ScorePanel类函数实现"></a>10.3 ScorePanel类函数实现</h2><p>该部分就是实现了头文件定义的成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> QString MYCOLOR[] = &#123;<span class="string">&quot;black&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line">ScorePanel::<span class="built_in">ScorePanel</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ScorePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将拖到ui上的标签都存入到m_list容器中</span></span><br><span class="line">    m_list &lt;&lt; ui-&gt;meScore &lt;&lt; ui-&gt;leftScore &lt;&lt; ui-&gt;rightScore</span><br><span class="line">           &lt;&lt; ui-&gt;meTitle &lt;&lt; ui-&gt;leftTitle &lt;&lt; ui-&gt;rightTitle</span><br><span class="line">           &lt;&lt; ui-&gt;score1 &lt;&lt; ui-&gt;score2 &lt;&lt; ui-&gt;score3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScorePanel::~<span class="built_in">ScorePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置3个玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要将整形数据转换为字符串类型数据</span></span><br><span class="line">    ui-&gt;leftScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(left));</span><br><span class="line">    ui-&gt;rightScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(right));</span><br><span class="line">    ui-&gt;meScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(user));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置字体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;微软雅黑&quot;</span>, point, QFont::Bold)</span></span>;               <span class="comment">//定义一个字体对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;                     <span class="comment">//遍历分数面板的所有按钮，都设置为该字体</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontColor</span><span class="params">(ScorePanel::FontColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString style = <span class="built_in">QString</span>(<span class="string">&quot;QLabel&#123;color:%1&#125;&quot;</span>).<span class="built_in">arg</span>(MYCOLOR[color]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;              <span class="comment">//遍历分数面板的所有按钮，都设置为该颜色</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-自定义按钮类MyButton"><a href="#11-自定义按钮类MyButton" class="headerlink" title="11. 自定义按钮类MyButton"></a>11. 自定义按钮类MyButton</h1><p>自定义按钮类MyButton主要就是对按钮进行美化，当鼠标经过按钮、按下按钮都加载显示不同的图片，起到一个有点击的效果。</p><h2 id="11-1-自定义按钮类"><a href="#11-1-自定义按钮类" class="headerlink" title="11.1 自定义按钮类"></a>11.1 自定义按钮类</h2><p>创建自定义按钮类：</p><p>通过选择新建、c++、c++class、类名为<code>MyButton</code>，基类设为QWidget。但创建好后，就将MyButton的基类QWidget修改为QPushButton。</p><p>不用带ui，该类只对按钮做美化，按钮上要放什么东西，不在考虑内。从QpushButton派生，然后基于QpushButton在按钮上做美化。</p><h2 id="11-2-MyButton类头文件"><a href="#11-2-MyButton类头文件" class="headerlink" title="11.2 MyButton类头文件"></a>11.2 MyButton类头文件</h2><p>自定义按钮类<code>MyButton</code>主要就是将从基类继承下来的函数进行定义，如鼠标按下、鼠标释放、鼠标进入和鼠标离开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//鼠标按下</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标进入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标离开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//绘图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    </span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//成员变量，对应三张图片的路径</span></span><br><span class="line">    QString m_normal;            <span class="comment">//定义的是正常情况下的图片路径</span></span><br><span class="line">    QString m_hover;             <span class="comment">//定义的是鼠标滑过按钮的图片路径</span></span><br><span class="line">    QString m_pressed;           <span class="comment">//定义的是鼠标按下按钮的图片路径</span></span><br><span class="line"></span><br><span class="line">    QPixmap m_pixmap;           <span class="comment">//得到的路径需要转为QPixmap对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="11-3-MyButton类函数实现"><a href="#11-3-MyButton类函数实现" class="headerlink" title="11.3 MyButton类函数实现"></a>11.3 MyButton类函数实现</h2><p>这部分就是对自定义按钮类MyButton的头文件定义的函数进行实现，不同情况，加载不同图片，也显示不同图片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">MyButton::<span class="built_in">MyButton</span>(QWidget *parent) : <span class="built_in">QPushButton</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_normal = normal;</span><br><span class="line">    m_hover = hover;</span><br><span class="line">    m_pressed = pressed;</span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);           <span class="comment">//默认情况下，就加载m_normal图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span>               <span class="comment">//鼠标按下</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标按下的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_pressed);                             <span class="comment">//加载m_pressed图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mousePressEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span>             <span class="comment">//鼠标释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标释放的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_normal);                              <span class="comment">//加载m_normal图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mouseReleaseEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::enterEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标进入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_hover);                                     <span class="comment">//鼠标经过按钮，加载hover图片</span></span><br><span class="line">    <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::leaveEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标离开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);                                     <span class="comment">//鼠标经过按钮，加载normal图片</span></span><br><span class="line">    <span class="built_in">update</span>();                       <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::paintEvent</span><span class="params">(QPaintEvent *ev)</span>   <span class="comment">//绘图,当窗口刷新的时候被调用重绘，而产生鼠标事件是不会调用该对象的，所以需要手动强制重绘update()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="comment">//对应的事件产生之后，就需要将相关的图片挂到当前的按钮对象上</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;                        <span class="comment">//创建一个画家类，参数是指定绘图设备(当前按钮对象)</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_pixmap);          <span class="comment">//将对应图片完整画到当前对象上。参数：当前按钮所对应的矩形区域、指定m_pixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-按钮组窗口类ButtonGroup"><a href="#12-按钮组窗口类ButtonGroup" class="headerlink" title="12. 按钮组窗口类ButtonGroup"></a>12. 按钮组窗口类ButtonGroup</h1><p>按钮组窗口类主要是为用户玩家服务的，因为开始游戏界面、抢地主界面、必须出牌界面和可放弃出牌界面都需要显示出不同的按钮，所以得在ui中使用Stacked Widget栈窗口，它可以容纳多张不同的窗口，然后通过函数调用切换即可。</p><h2 id="12-1-创建按钮组窗口"><a href="#12-1-创建按钮组窗口" class="headerlink" title="12.1 创建按钮组窗口"></a>12.1 创建按钮组窗口</h2><p>1.窗口创建：</p><p>选择新建、Qt、Qt设计师界面类(是带ui界面的)、选择Widget类型的窗口，类名为<code>ButtonGroup</code>。</p><p>该类是在ui界面上拖入了一个Stacked Widget栈窗口，在该栈窗口中建了5个页面。第1个页面是开始页面；第2个页面是必须出牌页面；第3个为可放弃出牌页面；第4个为叫地主页面；第5个是空白页面。并利用信号槽机制实现了connect操作，即按下按钮，就会触发响应的按钮信号，然后发送自定义信号。该类只负责发送信号即可，不用处理相关的操作。</p><p>2.对每个页面的按钮做美化</p><p>将Stacked Widget栈窗口中的5个窗口的按钮都提升为<code>MyButton</code>类。然后基于<code>MyButton</code>类对窗口所有按钮进行美化。</p><p>3.添加资源文件：选择新建、Qt、Qt Resource File、名称为res。</p><p>4.将按钮组窗口添加到主窗口(中下方)</p><p>在主窗口的下方拖入一个Widget窗口，将其提升为ButtonGroup类。因为主窗口最下方放的是扑克牌，所以得在最下面放一根弹簧将ButtonGroup窗口撑起来一点。然后在主窗口析构函数中，初始化按钮组，并设定刚开的页面为游戏开始页面的按钮组即可。</p><h2 id="12-2-ButtonGroup类头文件"><a href="#12-2-ButtonGroup类头文件" class="headerlink" title="12.2 ButtonGroup类头文件"></a>12.2 ButtonGroup类头文件</h2><p>按钮组窗口类ButtonGroup就是定义了一个Page页的切换函数，通过传入的参数配置页枚举类的不同，会发出信号通知主窗口该显示哪个按钮组窗口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Panel</span>&#123;Start, PlayCard, PassOrPlay,CallLord,Empty&#125;;         <span class="comment">//配置页枚举类</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ButtonGroup</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ButtonGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化按钮</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtons</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Page页的切换(因为第2个参数是只有抢地主页面按钮组时才会用到，其它按钮组页面窗口用不到，所以设置默认参数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectPanel</span><span class="params">(Panel type, <span class="type">int</span> bet = <span class="number">0</span>)</span></span>; <span class="comment">//传入的参数是配置页的枚举类，即窗口,当是叫地主窗口时，要目前下注最高分数(用户玩家需要知道)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//不出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抢地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">betPoint</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ButtonGroup *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-3-ButtonGroup类函数实现"><a href="#12-3-ButtonGroup类函数实现" class="headerlink" title="12.3 ButtonGroup类函数实现"></a>12.3 ButtonGroup类函数实现</h2><p>这部分代码实现了头文件定义的函数，对每个按钮都加载了三种图片，即常规状态下、鼠标滑过状态下和点击按钮状态下。同时也通过信号槽机制，对每个按钮按下后，都会发出信号，触发对应的槽函数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">ButtonGroup::<span class="built_in">ButtonGroup</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ButtonGroup)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ButtonGroup::~<span class="built_in">ButtonGroup</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有按钮的图片初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::initButtons</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    ui-&gt;start-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/start-1.png&quot;</span>, <span class="string">&quot;:/images/start-3.png&quot;</span>, <span class="string">&quot;:/images/start-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    ui-&gt;playCard-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;playCard1-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不要</span></span><br><span class="line">    ui-&gt;pass-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/pass_btn-1.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-3.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不抢</span></span><br><span class="line">    ui-&gt;giveup-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/buqiang-1.png&quot;</span>, <span class="string">&quot;:/images/buqiang-3.png&quot;</span>, <span class="string">&quot;:/images/buqiang-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//1，2，3分</span></span><br><span class="line">    ui-&gt;oneScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/1fen-1.png&quot;</span>, <span class="string">&quot;:/images/1fen-3.png&quot;</span>, <span class="string">&quot;:/images/1fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;twoScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/2fen-1.png&quot;</span>, <span class="string">&quot;:/images/2fen-3.png&quot;</span>, <span class="string">&quot;:/images/2fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;threeScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/3fen-1.png&quot;</span>, <span class="string">&quot;:/images/3fen-3.png&quot;</span>, <span class="string">&quot;:/images/3fen-2.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置按钮的大小</span></span><br><span class="line">    QVector&lt;MyButton*&gt;btns;</span><br><span class="line">    btns &lt;&lt; ui-&gt;start &lt;&lt; ui-&gt;playCard &lt;&lt; ui-&gt;playCard1 &lt;&lt; ui-&gt;pass &lt;&lt; ui-&gt;giveup &lt;&lt; ui-&gt;oneScore &lt;&lt; ui-&gt;twoScore &lt;&lt; ui-&gt;threeScore;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;btns.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        btns[i]-&gt;<span class="built_in">setFixedSize</span>(<span class="number">90</span>,<span class="number">45</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击不同按钮，发出信号后，处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::startGame);     <span class="comment">//按下开始按钮(初始界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);   <span class="comment">//按下出牌按钮(必须出牌界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard1, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);  <span class="comment">//按下出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pass, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::pass);      <span class="comment">//按下放弃出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;giveup, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                  <span class="comment">//按下不抢地主按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">0</span>);       <span class="comment">//当点击的是放弃抢地主，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;oneScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注1分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">1</span>);       <span class="comment">//当点击1分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;twoScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注2分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">2</span>);       <span class="comment">//当点击2分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;threeScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//按下下注3分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">3</span>);       <span class="comment">//当点击3分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示对应的按钮组窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::selectPanel</span><span class="params">(ButtonGroup::Panel type, <span class="type">int</span> bet)</span>   <span class="comment">//传入的是页数,分数(用户玩家才会调用该函数，要知道目前下注的最高分)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(type);           <span class="comment">//设置当前要找展示的按钮页面窗口</span></span><br><span class="line">    <span class="keyword">if</span>(type != CallLord)&#123;             <span class="comment">//如果不是叫地主状态，就直接返回(说明用户玩家不叫地主)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是用户玩家是叫地主状态</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;            <span class="comment">//如果目前最高分是0，说明还可以显示1，2，3分三个按钮</span></span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//2分按钮隐藏</span></span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-游戏控制类GameControl"><a href="#13-游戏控制类GameControl" class="headerlink" title="13. 游戏控制类GameControl"></a>13. 游戏控制类GameControl</h1><p>游戏控制类负责对游戏整个过程进行一个管理和控制，像游戏状态、玩家状态等都想要通过该类来进行一个维护。同时该类也会和主窗口类直接连接，在游戏控制过程中，每个玩家的变化、游戏的变化都需要通过信号的方式通知主窗口。</p><p>游戏控制类添加：通过选择新建、c++、c++class、类名为<code>GameControl</code>，基类为QObject。</p><h2 id="13-1-GameControl类头文件"><a href="#13-1-GameControl类头文件" class="headerlink" title="13.1 GameControl类头文件"></a>13.1 GameControl类头文件</h2><p>游戏控制类<code>GameControl</code>定义了枚举类游戏状态和玩家状态，当它们发送变化时，都会通过信号发送出去。同时，该头文件还定义了许多游戏过程函数，如发牌、叫地主、出牌等。而且有些后面开发会用到的信息都会记录保存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BetRecord</span>&#123;     <span class="comment">//存放三个玩家叫地主情况的结构体(因为c++的结构体类似于类，所以可以有构造函数)</span></span><br><span class="line">    <span class="built_in">BetRecord</span>()&#123;      <span class="comment">//当创建BetRecord时，就自动清空，初始化了</span></span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player = <span class="literal">nullptr</span>;</span><br><span class="line">        bet = <span class="number">0</span>;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Player* player;</span><br><span class="line">    <span class="type">int</span> bet;</span><br><span class="line">    <span class="type">int</span> times;       <span class="comment">//第几次叫地主</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//游戏状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">GameStatus</span>&#123;</span><br><span class="line">        DispatchCard,                 <span class="comment">//发牌状态</span></span><br><span class="line">        CallingLord,                  <span class="comment">//叫地主状态</span></span><br><span class="line">        PlayingHand                   <span class="comment">//出牌状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//玩家状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PlayerStatus</span>&#123;</span><br><span class="line">        ThinkingForCallLord,          <span class="comment">//考虑叫地主</span></span><br><span class="line">        ThinkingForPlayHand,          <span class="comment">//考虑出牌</span></span><br><span class="line">        Winning                       <span class="comment">//玩家赢了</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化玩家,将三个对象创建出来</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到玩家的实例化对象</span></span><br><span class="line">    <span class="function">Robot* <span class="title">getLeftRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Robot* <span class="title">getRightRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UserPlayer* <span class="title">getUserPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和获取当前玩家</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentPlayer</span><span class="params">(Player* player)</span></span>;         <span class="comment">//参数是玩家类型，由于不知道具体玩家类型，传它们的父类</span></span><br><span class="line">    <span class="function">Player *<span class="title">getCurrentPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到出牌玩家和打出的牌</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化扑克牌(所有)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initAllCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//每次发一张牌</span></span><br><span class="line">    <span class="function">Card <span class="title">takeOneCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到最后的三张底牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getSurplusCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//重置卡牌数据(当完成一局游戏就会清空玩家手中的扑克牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetCardData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startLordCard</span><span class="params">()</span></span>;       <span class="comment">//该函数会发出信号，主窗口接收</span></span><br><span class="line">    <span class="comment">//成为地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">becomeLord</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//清空所有玩家的得分</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearPlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到玩家下注的最高得分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPlayerMaxBet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理叫地主(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;        <span class="comment">//参数：具体是哪个玩家，玩家叫地主时下的分数</span></span><br><span class="line">    <span class="comment">//处理出牌(槽函数) ---&gt;当玩家调用了playhand()出牌函数后，会发出出牌信号，由该槽函数接收处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;    <span class="comment">//参数：出牌的玩家，出的牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//向主窗口通知 玩家的状态变化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerStatusChanged</span><span class="params">(Player* player, PlayerStatus status)</span></span>;     <span class="comment">//告诉主窗口是哪个玩家，当前玩家是什么状态(考虑叫地主，考虑出牌，玩家赢了)</span></span><br><span class="line">    <span class="comment">//向主窗口通知是哪个玩家抢了地主以及下注分数(然后轮到其它玩家抢地主下分)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="comment">//游戏状态变化的信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusChanged</span><span class="params">(GameStatus status)</span></span>;         <span class="comment">//参数是游戏的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向主窗口通知玩家出牌了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;       <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line">    <span class="comment">//给玩家传递出牌数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pendingInfo</span><span class="params">(Player* player, Cards&amp; card)</span></span>;          <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Robot* m_robotLeft=<span class="literal">nullptr</span>;</span><br><span class="line">    Robot* m_robotRight=<span class="literal">nullptr</span>;</span><br><span class="line">    UserPlayer* m_user=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Player* m_currPlayer=<span class="literal">nullptr</span>;           <span class="comment">//保存当前玩家对象的指针(实时变化的)</span></span><br><span class="line"></span><br><span class="line">    Player* m_pendPlayer=<span class="literal">nullptr</span>;           <span class="comment">//出牌的玩家</span></span><br><span class="line">    Cards m_pendCards;              <span class="comment">//出牌玩家打出的牌</span></span><br><span class="line"></span><br><span class="line">    Cards m_allCards;               <span class="comment">//一副扑克牌</span></span><br><span class="line"></span><br><span class="line">    BetRecord m_betRecord;          <span class="comment">//存放三个玩家叫地主的情况结构体对象</span></span><br><span class="line">    <span class="type">int</span> m_curBet = <span class="number">0</span>;               <span class="comment">//记录下注底分，方便后期计算</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13-2-GameControl类函数实现"><a href="#13-2-GameControl类函数实现" class="headerlink" title="13.2 GameControl类函数实现"></a>13.2 GameControl类函数实现</h2><p>这部分实现了头文件定义的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line">GameControl::<span class="built_in">GameControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::playerInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.对象实例化,通过构造函数指定名字，并给该对象指定一个父对象(当释放GameControl时，会自动释放该对象)</span></span><br><span class="line">    m_robotLeft = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人A&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    m_robotRight = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人B&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    m_user = <span class="keyword">new</span> <span class="built_in">UserPlayer</span>(<span class="string">&quot;我自己&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.给各对象设置属性信息</span></span><br><span class="line">    <span class="comment">//头像的显示</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setDirection</span>(Player::Left);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    m_user-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    Player::Sex sex;</span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setSex</span>(sex);                                     <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setSex</span>(sex);                                    <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setSex</span>(sex);                                          <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    <span class="comment">//玩家出牌顺序</span></span><br><span class="line">    <span class="comment">// user</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setPrevPlayer</span>(m_robotLeft);</span><br><span class="line">    m_user-&gt;<span class="built_in">setNextPlayer</span>(m_robotRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left robot</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setPrevPlayer</span>(m_robotRight);</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setNextPlayer</span>(m_user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right robot</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setPrevPlayer</span>(m_user);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setNextPlayer</span>(m_robotLeft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定当前玩家为用户(优先叫地主的权力)</span></span><br><span class="line">    m_currPlayer = m_user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家发射出的抢地主信号(几分)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递出牌玩家对象和玩家打出的牌给其它玩家</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotLeft, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotRight, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_user, &amp;Robot::storePendingInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家出牌</span></span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到左手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getLeftRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotLeft;        <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到右手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getRightRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotRight;      <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到用户玩家对象</span></span><br><span class="line"><span class="function">UserPlayer *<span class="title">GameControl::getUserPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_user;            <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置和获取当前出牌玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::setCurrentPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getCurrentPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_currPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出牌的玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化所有的牌(发牌会用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::initAllCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_allCards.<span class="built_in">clear</span>();             <span class="comment">//先对一副扑克牌做清空操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=Card::Card_Begin+<span class="number">1</span>; p&lt;Card::Card_SJ; p++)&#123;           <span class="comment">//遍历点数，枚举类型不能做算术运算，所以定义p只能是int,不能是Card::CardPoint</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=Card::Suit_Begin+<span class="number">1</span>; s&lt;Card::Suit_End; s++)&#123;      <span class="comment">//遍历花色</span></span><br><span class="line">            <span class="function">Card <span class="title">c</span><span class="params">((Card::CardPoint)p, (Card::CardSuit)s)</span></span>;         <span class="comment">//再将int类型强制转换为枚举类型</span></span><br><span class="line">            m_allCards.<span class="built_in">add</span>(c);         <span class="comment">//创建完一张扑克牌，就插入到m_allCards中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_SJ, Card::Suit_Begin));              <span class="comment">//插入小王</span></span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_BJ, Card::Suit_Begin));              <span class="comment">//插入大王</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌(发牌)</span></span><br><span class="line"><span class="function">Card <span class="title">GameControl::takeOneCard</span><span class="params">()</span>                <span class="comment">//一次发一张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards.<span class="built_in">takeRandomCard</span>();          <span class="comment">//调用Cards类里面定义的函数，随机返回一张扑克牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地主得到3张底牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getSurplusCards</span><span class="params">()</span>           <span class="comment">//获取底牌函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards;                         <span class="comment">//当发完后，做后留下的三张牌就作为底牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发牌前的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::resetCardData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//洗牌</span></span><br><span class="line">    <span class="built_in">initAllCards</span>();</span><br><span class="line">    <span class="comment">//清空所有玩家的牌(就是将玩家对象里的Cards容器清空)</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_user-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    <span class="comment">//初始化出牌玩家和牌(新一局开始之前，是没有出牌玩家的)</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;           <span class="comment">//出牌对象也先默认为空</span></span><br><span class="line">    m_pendCards.<span class="built_in">clear</span>();              <span class="comment">//打出的牌也是空的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::startLordCard</span><span class="params">()</span>        <span class="comment">//准备叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用叫地主函数</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();         <span class="comment">//m_currPlayer可能是用户玩家，也可能是机器人玩家(多态实现)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, ThinkingForCallLord)</span></span>;      <span class="comment">//发出信号，参数：当前玩家，当前玩家状态(准备叫地主)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::becomeLord</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>  <span class="comment">//成为地主，参数传进来的是地主角色，其它两个角色就是农民了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_curBet = bet;             <span class="comment">//保存下注的底分，出牌(炸弹)和打完牌后计算需要用到</span></span><br><span class="line">    player-&gt;<span class="built_in">setRole</span>(Player::Lord);</span><br><span class="line">    player-&gt;<span class="built_in">getPrevPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的上一家是农民</span></span><br><span class="line">    player-&gt;<span class="built_in">getNextPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的下一家是农民</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成为地主的是要先出牌，所以他是当前玩家</span></span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">    player-&gt;<span class="built_in">storeDispatchCard</span>(m_allCards);     <span class="comment">//给该玩家的手牌添加三张底牌(m_allCards是发完牌后，剩下三张)</span></span><br><span class="line"></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">1000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">gameStatusChanged</span>(PlayingHand);                       <span class="comment">//发送游戏的状态信号(出牌状态)</span></span><br><span class="line">        emit <span class="built_in">playerStatusChanged</span>(player, ThinkingForPlayHand);     <span class="comment">//玩家状态(考虑出牌)</span></span><br><span class="line">        <span class="comment">//调用准备出牌函数</span></span><br><span class="line">        m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::clearPlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_user-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GameControl::getPlayerMaxBet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_betRecord.bet;        <span class="comment">//结构体里面存的就是最高分(因为高分信息会覆盖低分信息)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onGrabBet</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>     <span class="comment">//处理叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 通知主界面，该玩家叫地主了(主界面就要更新信息提示)</span></span><br><span class="line">    <span class="keyword">if</span>(bet==<span class="number">0</span> || m_betRecord.bet&gt;=bet)&#123;           <span class="comment">//这种情况说明该玩家放弃抢地主</span></span><br><span class="line">        <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(player, <span class="number">0</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet&gt;<span class="number">0</span> &amp;&amp; m_betRecord.bet==<span class="number">0</span>)&#123; <span class="comment">//如果当前玩家下注的分数大于0，且之前结构体存的是0分(说明之前玩家没有抢地主或现在是第一次下注)</span></span><br><span class="line">        <span class="comment">//第1个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">true</span>);      <span class="comment">//如果是第一个抢地主的玩家，参数3置为true(主窗口需要知道第一个抢地主的玩家)</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//第2或3个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断玩家下注是不是3分，如果是就抢地主成功(抢地主就结束了)</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//该玩家成为地主</span></span><br><span class="line">        <span class="built_in">becomeLord</span>(player,bet);            <span class="comment">//调用成为地主的函数</span></span><br><span class="line">        <span class="comment">//清空抢地主结构体数据</span></span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span>;            <span class="comment">//直接退出了。当某个玩家给出3分时，那么该玩家就是地主了，不用再执行下面内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.下注不够3分，对玩家的分数进行比较，分数高的是地主(低的被覆盖)</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.bet &lt; bet)&#123;  <span class="comment">//m_betRecord结构体是玩家抢地主，就存其信息，当下一个玩家也抢地主，如果分数比之前的高，m_betRecord就进行更新</span></span><br><span class="line">        m_betRecord.bet = bet;             <span class="comment">//重新存储分数</span></span><br><span class="line">        m_betRecord.player = player;       <span class="comment">//重新存储地主玩家</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_betRecord.times++;                   <span class="comment">//下注抢地主的次数++</span></span><br><span class="line">    <span class="comment">//如果每个玩家都抢过一次地主，抢地主结束</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.times == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_betRecord.bet == <span class="number">0</span>)&#123;        <span class="comment">//如果分数还是为0，说明没有玩家叫地主</span></span><br><span class="line">            <span class="function">emit <span class="title">gameStatusChanged</span><span class="params">(DispatchCard)</span></span>;        <span class="comment">//通知此时需要改变为发牌状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;     <span class="comment">//如果不为0，说明有玩家会成为地主</span></span><br><span class="line">            <span class="built_in">becomeLord</span>(m_betRecord.player, m_betRecord.bet);              <span class="comment">//成为地主的玩家是结构体中保存的玩家对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();          <span class="comment">//结构体重置，为下一节游戏清空结构体(因为到了下一句游戏，不会重新创建，还是用这个创建好的结构体)</span></span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">//直接返回，就不用执行下面玩家切换了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.切换玩家，通知下一个玩家继续抢地主</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();      <span class="comment">//改变当前玩家</span></span><br><span class="line">    <span class="comment">//发送信号给主界面，告知当前状态还是为抢地主状态</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer,ThinkingForCallLord)</span></span>;</span><br><span class="line">    <span class="comment">//每个玩家都有一个prepareCallLord()函数，即考虑叫地主，如果是机器人玩家，有专门的线程来处理该操作，如果是用户玩家，该函数就是空的(只需要点击按钮完成操作)</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();      <span class="comment">//告诉新的当前玩家继续抢地主</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onPlayHand</span><span class="params">(Player *player, Cards &amp;card)</span>    <span class="comment">//处理出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 将玩家出牌信号转给主界面(主界面更新出出牌窗口内容)</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(player, card)</span></span>;</span><br><span class="line">    <span class="comment">//2. 如果不是空牌，给其它玩家发送信号，保存出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!card.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_pendCards = card;</span><br><span class="line">        m_pendPlayer = player;</span><br><span class="line">        <span class="function">emit <span class="title">pendingInfo</span><span class="params">(player, card)</span></span>;       <span class="comment">//发出信号给玩家，参数是打出牌的当前玩家和打出的牌(其它玩家需要根据出的牌和玩家，做相应的处理)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有炸弹，底分翻倍</span></span><br><span class="line">    PlayHand::HandType type = <span class="built_in">PlayHand</span>(card).<span class="built_in">getHandType</span>();      <span class="comment">//传入当前玩家出的牌，得到出牌类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Bomb || type == PlayHand::Hand_Bomb_Jokers)&#123;      <span class="comment">//如果出的牌是炸弹和王炸</span></span><br><span class="line">        m_curBet = m_curBet*<span class="number">2</span>;                     <span class="comment">//将底分*2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 如果玩家的牌都出完了，计算本局游戏的总分</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Player* prev = player-&gt;<span class="built_in">getPrevPlayer</span>();                  <span class="comment">//获取当前玩家的上一个玩家</span></span><br><span class="line">        Player* next = player-&gt;<span class="built_in">getNextPlayer</span>();                  <span class="comment">//获取当前玩家的下一个玩家</span></span><br><span class="line">        <span class="keyword">if</span>(player-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;                   <span class="comment">//如果当前玩家为地主</span></span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + <span class="number">2</span>*m_curBet);       <span class="comment">//当前玩家加分(原来得分+当前得分)</span></span><br><span class="line">            prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;             <span class="comment">//当前玩家为农民</span></span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;             <span class="comment">//如果当前玩家的上一个玩家是地主</span></span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                           <span class="comment">//如果当前玩家的上一个玩家是农民</span></span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(player, GameControl::Winning)</span></span>;          <span class="comment">//向主窗口通知 当前玩家的状态变化(赢了)</span></span><br><span class="line">        <span class="keyword">return</span>;         <span class="comment">//赢了就退出了，不然还会执行下面程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 如果牌没有出完，下一个玩家继续出牌</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();                <span class="comment">//将下一个玩家更新为当前玩家</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();         <span class="comment">//更新的当前玩家准备出牌(该函数是一个多态实现，不同类型玩家调用会执行不同的处理)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, GameControl::ThinkingForPlayHand)</span></span>;    <span class="comment">//向主窗口通知 更新的当前玩家的状态变化(考虑出牌)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-出牌类PlayHand"><a href="#14-出牌类PlayHand" class="headerlink" title="14. 出牌类PlayHand"></a>14. 出牌类PlayHand</h1><p>该类主要是对一些牌进行分类和识别，得出调用者传入牌的一个牌型。</p><p>出牌类(策略)：新建、c、c++、类名为PlayHand，基类为Custom。</p><h2 id="14-1-PlayHand类头文件"><a href="#14-1-PlayHand类头文件" class="headerlink" title="14.1 PlayHand类头文件"></a>14.1 PlayHand类头文件</h2><p>出牌类PlayeHand定义了一个牌的类型枚举类，它里面都是斗地主小游戏里面所有的牌型。然后定义了对牌的分类函数和识别函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayHand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 出牌组合或者方式</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">HandType</span></span><br><span class="line">        &#123;</span><br><span class="line">            Hand_Unknown,               <span class="comment">// 未知</span></span><br><span class="line">            Hand_Pass,                  <span class="comment">// 过</span></span><br><span class="line">            Hand_Single,                <span class="comment">// 单</span></span><br><span class="line">            Hand_Pair,                  <span class="comment">// 对</span></span><br><span class="line">            Hand_Triple,                <span class="comment">// 三个</span></span><br><span class="line">            Hand_Triple_Single,         <span class="comment">// 三带一</span></span><br><span class="line">            Hand_Triple_Pair,           <span class="comment">// 三带二</span></span><br><span class="line">            Hand_Plane,                 <span class="comment">// 飞机，555_666</span></span><br><span class="line">            Hand_Plane_Two_Single,      <span class="comment">// 飞机带单，555_666_3_4</span></span><br><span class="line">            Hand_Plane_Two_Pair,        <span class="comment">// 飞机带双，555_666_33_44</span></span><br><span class="line">            Hand_Seq_Pair,              <span class="comment">// 连对，33_44_55(_66...)</span></span><br><span class="line">            Hand_Seq_Single,            <span class="comment">// 顺子，34567(8...)</span></span><br><span class="line">            Hand_Bomb,                  <span class="comment">// 炸弹</span></span><br><span class="line">            Hand_Bomb_Single,           <span class="comment">// 炸弹带一个</span></span><br><span class="line">            Hand_Bomb_Pair,             <span class="comment">// 炸弹带一对</span></span><br><span class="line">            Hand_Bomb_Two_Single,       <span class="comment">// 炸弹带两单</span></span><br><span class="line">            Hand_Bomb_Jokers,           <span class="comment">// 王炸</span></span><br><span class="line">            Hand_Bomb_Jokers_Single,    <span class="comment">// 王炸带一个</span></span><br><span class="line">            Hand_Bomb_Jokers_Pair,      <span class="comment">// 王炸带一对</span></span><br><span class="line">            Hand_Bomb_Jokers_Two_Single<span class="comment">// 王炸带两单</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PlayHand</span>();</span><br><span class="line">        <span class="comment">// 传递给类一组牌, 通过类分析出牌型, 点数, 以及相关的附属信息(比如顺子: 记录牌的数量)</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PlayHand</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="built_in">PlayHand</span>(HandType type, Card::CardPoint pt, <span class="type">int</span> extra);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到牌的属性信息</span></span><br><span class="line">        <span class="function">HandType <span class="title">getHandType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Card::CardPoint <span class="title">getCardPoint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getExtra</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较自己的牌和其他人的牌的大小</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">canBeat</span><span class="params">(<span class="type">const</span> PlayHand&amp; other)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 1. 对扑克牌进行分类: 1张相同的, 2张相同的, 3张相同的, 4张相同的</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">classify</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="comment">// 2. 对牌型进行分类</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">judgeCardType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 判断牌的类型</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPass</span><span class="params">()</span></span>;              <span class="comment">// 放弃出牌</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSingle</span><span class="params">()</span></span>;            <span class="comment">// 单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPair</span><span class="params">()</span></span>;              <span class="comment">// 对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriple</span><span class="params">()</span></span>;            <span class="comment">// 三个(相同)</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTripleSingle</span><span class="params">()</span></span>;      <span class="comment">// 三带一</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriplePair</span><span class="params">()</span></span>;        <span class="comment">// 三带二</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlane</span><span class="params">()</span></span>;             <span class="comment">// 飞机</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoSingle</span><span class="params">()</span></span>;    <span class="comment">// 飞机带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoPair</span><span class="params">()</span></span>;      <span class="comment">// 飞机带2对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqPair</span><span class="params">()</span></span>;           <span class="comment">// 连对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqSingle</span><span class="params">()</span></span>;         <span class="comment">// 顺子</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBomb</span><span class="params">()</span></span>;              <span class="comment">// 炸弹</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombSingle</span><span class="params">()</span></span>;        <span class="comment">// 炸弹带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombPair</span><span class="params">()</span></span>;          <span class="comment">// 炸弹带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombTwoSingle</span><span class="params">()</span></span>;     <span class="comment">// 炸弹带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokers</span><span class="params">()</span></span>;        <span class="comment">// 王炸</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersSingle</span><span class="params">()</span></span>;  <span class="comment">// 王炸带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersPair</span><span class="params">()</span></span>;    <span class="comment">// 王炸带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersTwoSingle</span><span class="params">()</span></span>;   <span class="comment">// 王炸带两单</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        HandType m_type;                          <span class="comment">//牌型</span></span><br><span class="line">        Card::CardPoint m_pt;                     <span class="comment">//点数</span></span><br><span class="line">        <span class="type">int</span> m_extra;                              <span class="comment">//附加类型(如顺子是5张还是6张还是7张，连对是3对还是4对还是5对)</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_oneCard;       <span class="comment">//存储单张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_twoCard;       <span class="comment">//存储两种相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_threeCard;     <span class="comment">//存储三张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_fourCard;      <span class="comment">//存储四张相同点数的牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="14-2-PlayHand类函数实现"><a href="#14-2-PlayHand类函数实现" class="headerlink" title="14.2 PlayHand类函数实现"></a>14.2 PlayHand类函数实现</h2><p>该部分实现了头文件定义的函数，首先是通过函数classify()对传进来的牌进行分类，用4个容器进行存放，分别为1张相同点数的牌容器、2张相同点数的牌容器、3张相同点数的牌容器和4张相同点数的牌容器。然后通过judgeCardType()函数基于分类的4个容器来对牌进行分析。记录扑克牌的牌型、点数和附加类型(连对的对数和顺子的张数)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;playhand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(Cards &amp;cards)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.对扑克牌进行分类：1张的，2张，3张，4张有多少种</span></span><br><span class="line">    <span class="built_in">classify</span>(cards);</span><br><span class="line">    <span class="comment">//2.对牌型进行分类</span></span><br><span class="line">    <span class="built_in">judgeCardType</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(PlayHand::HandType type, Card::CardPoint pt, <span class="type">int</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">    m_pt = pt;</span><br><span class="line">    m_extra = extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的牌型</span></span><br><span class="line"><span class="function">PlayHand::HandType <span class="title">PlayHand::getHandType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">PlayHand::getCardPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取附加类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PlayHand::getExtra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较牌是否大于对方</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::canBeat</span><span class="params">(<span class="type">const</span> PlayHand &amp;other)</span>           <span class="comment">//和对方比较牌型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我的牌型是未知的</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Unknown)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对方放弃出牌</span></span><br><span class="line">    <span class="keyword">if</span>(other.m_type == Hand_Pass)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我是王炸</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己是炸弹，而对方是比炸弹小的牌型(牌类型的枚举类是按照牌型从小到大排列的)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type==Hand_Bomb &amp;&amp; other.m_type&gt;=Hand_Single &amp;&amp; other.m_type&lt;=Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双方的牌型是一致的(比点数)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == other.m_type)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_type == Hand_Seq_Pair || m_type == Hand_Seq_Single)&#123;      <span class="comment">//如果是连对或是顺子</span></span><br><span class="line">            <span class="keyword">return</span> m_pt&gt;other.m_pt &amp;&amp; m_extra == other.m_extra;        <span class="comment">//就要求最小点数要比它大，同时个数要一样，才返回true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_pt &gt; other.m_pt;       <span class="comment">//如果是其它类型，就直接比点数了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//如果都不满足上面，就返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将传进来的牌按张数进行分类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::classify</span><span class="params">(Cards &amp;cards)</span>           <span class="comment">//分析传进来的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将转进来牌存到QVector容器</span></span><br><span class="line">    <span class="type">int</span> cardRecord[Card::Card_End];               <span class="comment">//创建一个数组，大小为不同点数类型大小</span></span><br><span class="line">    <span class="built_in">memset</span>(cardRecord, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*Card::Card_End);     <span class="comment">//数组清0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;             <span class="comment">//遍历每一张牌</span></span><br><span class="line">        Card c = list.<span class="built_in">at</span>(i);                      <span class="comment">//取出扑克牌</span></span><br><span class="line">        cardRecord[c.<span class="built_in">point</span>()]++;                  <span class="comment">//卡牌点数与数组里元素的位置是有对应关系的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先清空四个容器(分别存储相同点数只有1张、2张、3张和4张的牌型)</span></span><br><span class="line">    m_oneCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_twoCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_threeCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_fourCard.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Card::Card_End; i++)&#123;         <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(cardRecord[i] == <span class="number">1</span>)&#123;               <span class="comment">//数组某下标位置元素为1，则说明该点数的牌就为1</span></span><br><span class="line">            m_oneCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到1张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            m_twoCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到2张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">3</span>)&#123;</span><br><span class="line">            m_threeCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到3张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">4</span>)&#123;</span><br><span class="line">            m_fourCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到4张相同牌的容器里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析牌的一个类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::judgeCardType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = Hand_Unknown;               <span class="comment">//牌的类型先初始化为未知</span></span><br><span class="line">    m_pt = Card::Card_Begin;             <span class="comment">//初始化点数</span></span><br><span class="line">    m_extra = <span class="number">0</span>;                         <span class="comment">//这个一般是记录像连队多少对，顺子多少张</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPass</span>())&#123;                      <span class="comment">//放弃出牌</span></span><br><span class="line">        m_type = Hand_Pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isSingle</span>())&#123;                 <span class="comment">//单牌</span></span><br><span class="line">        m_type = Hand_Single;          <span class="comment">//记录类型</span></span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];           <span class="comment">//获取其点数</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPair</span>())&#123;                <span class="comment">//一对</span></span><br><span class="line">        m_type= Hand_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriple</span>())&#123;                        <span class="comment">//3张点数相同</span></span><br><span class="line">        m_type= Hand_Triple;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTripleSingle</span>())&#123;                  <span class="comment">//3带1</span></span><br><span class="line">        m_type= Hand_Triple_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriplePair</span>())&#123;                   <span class="comment">//3带一对</span></span><br><span class="line">        m_type= Hand_Triple_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlane</span>())&#123;                         <span class="comment">//飞机</span></span><br><span class="line">        m_type= Hand_Plane;</span><br><span class="line">        <span class="comment">//记录点数最小的牌</span></span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoSingle</span>())&#123;                <span class="comment">//飞机带两单</span></span><br><span class="line">        m_type= Hand_Plane_Two_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoPair</span>())&#123;                  <span class="comment">//飞机带两对</span></span><br><span class="line">        m_type= Hand_Plane_Two_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqPair</span>())&#123;                       <span class="comment">//连对</span></span><br><span class="line">        m_type= Hand_Seq_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//记录连对的个数</span></span><br><span class="line">        m_extra = m_twoCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqSingle</span>())&#123;                     <span class="comment">//顺子</span></span><br><span class="line">        m_type= Hand_Seq_Single;</span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];</span><br><span class="line">        m_extra = m_oneCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBomb</span>())&#123;                           <span class="comment">//炸弹</span></span><br><span class="line">        m_type= Hand_Bomb;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombSingle</span>())&#123;                    <span class="comment">//炸弹带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombPair</span>())&#123;                       <span class="comment">//炸弹带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Pair;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombTwoSingle</span>())&#123;                  <span class="comment">//炸弹带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Two_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokers</span>())&#123;                     <span class="comment">//王炸</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersSingle</span>())&#123;               <span class="comment">//王炸带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Single;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersPair</span>())&#123;                 <span class="comment">//王炸带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Pair;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersTwoSingle</span>())&#123;            <span class="comment">//王炸带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Two_Single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPass</span><span class="params">()</span>           <span class="comment">//放弃出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//每个容器中都为空，说明是放弃出牌了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSingle</span><span class="params">()</span>            <span class="comment">//判断牌(打出的)是否是单牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果存在1张相同点数容器大小为1，其它2、3、4张相同点数的牌容器为空，说明打出的是单牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//打出的是单牌，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPair</span><span class="params">()</span>                <span class="comment">//判断牌(打出的)是否是一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriple</span><span class="params">()</span>              <span class="comment">//判断牌(打出的)是否是三张一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTripleSingle</span><span class="params">()</span>        <span class="comment">//判断牌(打出的)是否是三带一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriplePair</span><span class="params">()</span>           <span class="comment">//三带二(两张要一样)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlane</span><span class="params">()</span>                <span class="comment">//飞机</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoSingle</span><span class="params">()</span>         <span class="comment">//飞机带两单(不能是大小王)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                  <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2 &amp;&amp; m_oneCard[<span class="number">0</span>]!=Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]!=Card::Card_BJ)&#123;       <span class="comment">//必须是相连且不涉及卡牌2且两单不是大小王</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoPair</span><span class="params">()</span>                <span class="comment">// 飞机带2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqPair</span><span class="params">()</span>                    <span class="comment">//连对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_twoCard.<span class="built_in">begin</span>(),m_twoCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="comment">//如果是三个连续的就满足：(最大数-最小数)=(牌类型总数-1)，如456。还必须满足卡牌是3到2之间(不包括2)</span></span><br><span class="line">        <span class="keyword">if</span>(m_twoCard.<span class="built_in">last</span>()-m_twoCard.<span class="built_in">first</span>()==(m_twoCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_twoCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_twoCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqSingle</span><span class="params">()</span>                 <span class="comment">//顺子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()&gt;=<span class="number">5</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">last</span>()-m_oneCard.<span class="built_in">first</span>()==(m_oneCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_oneCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_oneCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBomb</span><span class="params">()</span>                    <span class="comment">//炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombSingle</span><span class="params">()</span>              <span class="comment">//炸弹带一个单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombPair</span><span class="params">()</span>                 <span class="comment">//炸弹带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombTwoSingle</span><span class="params">()</span>            <span class="comment">//炸弹带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()!=Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()!=Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokers</span><span class="params">()</span>           <span class="comment">//王炸</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()==Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersSingle</span><span class="params">()</span>            <span class="comment">//王炸带一单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">1</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">2</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersPair</span><span class="params">()</span>           <span class="comment">//王炸带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">0</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersTwoSingle</span><span class="params">()</span>            <span class="comment">//王炸带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">4</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">2</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">3</span>]==Card::Card_BJ)&#123;    <span class="comment">//两王比两单大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-游戏策略类Strategy"><a href="#15-游戏策略类Strategy" class="headerlink" title="15. 游戏策略类Strategy"></a>15. 游戏策略类Strategy</h1><p>游戏策略类主要是负责制定斗地主小游戏的规则，和模拟机器人玩家出牌的策略。</p><p>游戏策略类创建：选择新建、c、c++、类名为Strategy，基类为Custom。</p><h2 id="15-1-Strategy类头文件"><a href="#15-1-Strategy类头文件" class="headerlink" title="15.1 Strategy类头文件"></a>15.1 Strategy类头文件</h2><p>游戏策略类Strategy头文件定义的多数是一些游戏的规则，和对机器人玩家的出牌策略，机器人玩家会根据自己的手牌来判断该出什么牌，是否抢地主等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Strategy</span>(Player* player, <span class="type">const</span> Cards&amp; cards);          <span class="comment">//只有机器人玩家才会调用该函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.制定出牌策略</span></span><br><span class="line">    <span class="function">Cards <span class="title">makeStrategy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.第一个出牌firstPlay(没有限制，想出啥出啥)---&gt;机器人玩家使用的函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">firstPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//3.得到比指定牌型大的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getGreaterCards</span><span class="params">(PlayHand type)</span></span>;</span><br><span class="line">    <span class="comment">//4.能大过指定的牌时，判断是出牌还是放行，返回true是出牌。返回false是放行</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">whetherToBeat</span><span class="params">(Cards&amp; cs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.找出指定数量(count)的相同点数的牌(point)，找出count张点数为point的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span></span>;       <span class="comment">//满足指定点数、指定数量的牌</span></span><br><span class="line">    <span class="comment">//6.找出所有点数数量为count的牌 ---&gt; 得到一个多张扑克牌数组</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardsByCount</span>(<span class="type">int</span> count);                        <span class="comment">//满足指定数量的牌</span></span><br><span class="line">    <span class="comment">//7.根据点数范围找牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span></span>;     <span class="comment">//满足指定范围的牌</span></span><br><span class="line">    <span class="comment">//8.按牌型找牌，并且指定要找的牌是否要大过指定的牌型</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardType</span>(PlayHand hand, <span class="type">bool</span> beat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.从指定的Cards对象中挑选出满足条件的顺子(allSeqRecord中每个元素都是一个容器，里面装着满足条件的顺子)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt;&gt;&amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt;&amp;seqSingle, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//10.筛选最优的顺子的集合</span></span><br><span class="line">    <span class="function">QVector&lt;Cards&gt; <span class="title">pickOptimalSeqSingles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> function = <span class="built_in">Cards</span> (Strategy::*)(Card::CardPoint point);      <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CardInfo</span>&#123;</span><br><span class="line">        Card::CardPoint begin;</span><br><span class="line">        Card::CardPoint end;</span><br><span class="line">        <span class="type">int</span> extra;                    <span class="comment">//顺子或连对的数量</span></span><br><span class="line">        <span class="type">bool</span> beat;</span><br><span class="line">        <span class="type">int</span> number;                   <span class="comment">//指定点数的牌的数量(1表示找单排，就是寻找顺子；2表示找对子，就是寻找连对)</span></span><br><span class="line">        <span class="type">int</span> base;                     <span class="comment">//最基础的顺子或者连对的数量(连对是3或顺子是5)</span></span><br><span class="line">        function getSeq;              <span class="comment">//函数指针对象，主要是用来生成基础连对和基础顺子</span></span><br><span class="line">    &#125;;</span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getCards</span>(Card::CardPoint point, <span class="type">int</span> number);     <span class="comment">//从point点数开始查找，找number张---找单、双、三</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getTripleSingleOrPair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//起始点开始找；带1还是带对</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane</span>(Card::CardPoint begin);                <span class="comment">//飞机不带牌</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane2SingleOr2Pair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//飞机带2单还是2对</span></span><br><span class="line">    <span class="comment">//QVector&lt;Cards&gt;getSepPairOrSeqSingle(Card::CardPoint begin, int extra, bool beat);       //连对或顺子</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getSepPairOrSeqSingle</span>(CardInfo &amp;info);       <span class="comment">//连对或顺子</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span></span>;          <span class="comment">//生成基础连对函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span></span>;        <span class="comment">//生成基础顺子函数</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getBomb</span>(Card::CardPoint begin);         <span class="comment">//炸弹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">    Cards m_cards;                 <span class="comment">//存放的是玩家手牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-2-Strategy类函数实现"><a href="#15-2-Strategy类函数实现" class="headerlink" title="15.2 Strategy类函数实现"></a>15.2 Strategy类函数实现</h2><p>这部分是对游戏策略类的头文件中定义的函数进行实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br></pre></td><td class="code"><pre><span class="line">Strategy::<span class="built_in">Strategy</span>(Player *player, <span class="type">const</span> Cards &amp;cards):</span><br><span class="line">    <span class="built_in">m_player</span>(player),</span><br><span class="line">    <span class="built_in">m_cards</span>(cards)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌策略，机器人玩家出牌时直接调用即可，是否出牌和出什么牌都已经处理好了</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::makeStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到出牌玩家对象以及打出的牌</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    Cards pendCards = m_player-&gt;<span class="built_in">getPendCards</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断上次出牌的玩家是不是自己</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer == m_player || pendPlayer == <span class="literal">nullptr</span>)&#123;  <span class="comment">//情况1是上次出牌是我自己，其余玩家没有出牌；情况2是刚开时，上一次出牌玩家就为空</span></span><br><span class="line">        <span class="comment">//直接出牌(没有限制)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">firstPlay</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果不是自己想要，需要找出比出牌玩家点数大的牌</span></span><br><span class="line">        PlayHand <span class="built_in">type</span>(pendCards);               <span class="comment">//构造一个playhand对象，对出的牌进行分析</span></span><br><span class="line">        Cards beatCards = <span class="built_in">getGreaterCards</span>(type);      <span class="comment">//通过分析出类型，得到比上个玩家出队牌更大的牌</span></span><br><span class="line">        <span class="comment">//找到了点数大的牌需要考虑是否出牌</span></span><br><span class="line">        <span class="type">bool</span> shouldBeat = <span class="built_in">whetherToBeat</span>(beatCards);    <span class="comment">//将找到更大的牌作为参数传入</span></span><br><span class="line">        <span class="keyword">if</span>(shouldBeat)&#123;         <span class="comment">//如果出牌，打出要出的牌</span></span><br><span class="line">            <span class="keyword">return</span> beatCards;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//否则返回空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//机器人玩家自由出牌函数</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::firstPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断玩家手中是否只剩下单一的牌型</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(m_cards)</span></span>;           <span class="comment">//传入手牌进行分析</span></span><br><span class="line">    <span class="keyword">if</span>(hand.<span class="built_in">getHandType</span>() != PlayHand::Hand_Unknown)&#123;           <span class="comment">//如果只剩单一牌型</span></span><br><span class="line">        <span class="keyword">return</span> m_cards;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是单一的牌型</span></span><br><span class="line">    <span class="comment">//判断玩家手中是否有顺子</span></span><br><span class="line">    QVector&lt;Cards&gt; optimalSeq = <span class="built_in">pickOptimalSeqSingles</span>();     <span class="comment">//获取顺子(筛选后较大的顺子)---&gt;optimalSeq容器里可能有多个顺子</span></span><br><span class="line">    <span class="keyword">if</span>(!optimalSeq.<span class="built_in">isEmpty</span>())&#123;                    <span class="comment">//如果不为空</span></span><br><span class="line">        <span class="comment">//得到单牌的数量</span></span><br><span class="line">        <span class="type">int</span> baseNum = <span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();            <span class="comment">//没有剔除顺子前的单牌数量</span></span><br><span class="line">        <span class="comment">//把得到的顺子的集合从玩家手中删除</span></span><br><span class="line">        Cards save = m_cards;                  <span class="comment">//复制手牌</span></span><br><span class="line">        save.<span class="built_in">remove</span>(optimalSeq);               <span class="comment">//删除顺子</span></span><br><span class="line">        <span class="type">int</span> lastNum = <span class="built_in">Strategy</span>(m_player,save).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();  <span class="comment">//在去除顺子的手牌中找到单牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(baseNum &gt; lastNum)&#123;           <span class="comment">//这种情况是说明剔除顺子后，单牌数量更少了，是想要的结果</span></span><br><span class="line">            <span class="keyword">return</span> optimalSeq[<span class="number">0</span>];        <span class="comment">//返回其中一个顺子打出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hasPlane, hasTriple, hasPair;</span><br><span class="line">    hasPair = hasTriple = hasPlane = <span class="literal">false</span>;</span><br><span class="line">    Cards backup = m_cards;               <span class="comment">//复制手牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有炸弹</span></span><br><span class="line">    QVector&lt;Cards&gt; bombArray = <span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Bomb, Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    backup.<span class="built_in">remove</span>(bombArray);             <span class="comment">//剔除炸弹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;planeArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Plane,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!planeArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPlane = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(planeArray);        <span class="comment">//剔除飞机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有三张点数相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;seqTripleArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Triple,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqTripleArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasTriple = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqTripleArray);        <span class="comment">//剔除3张点数相同的牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有连对</span></span><br><span class="line">    QVector&lt;Cards&gt;seqPairArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Pair,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqPairArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPair = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqPairArray);        <span class="comment">//剔除连对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPair)&#123;         <span class="comment">//找到了连对不为空，就返回最大连对</span></span><br><span class="line">        Cards maxPair;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqPairArray.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//seqPairArray的元素是类似于34567、345678、3456789....</span></span><br><span class="line">            <span class="keyword">if</span>(seqPairArray[i].<span class="built_in">cardCount</span>() &gt; maxPair.<span class="built_in">cardCount</span>())&#123;        <span class="comment">//比较找出最大连对</span></span><br><span class="line">                maxPair = seqPairArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPlane)&#123;        <span class="comment">//找到了飞机</span></span><br><span class="line">        <span class="comment">//1.飞机带2个对</span></span><br><span class="line">        <span class="type">bool</span> twoPairFond = <span class="literal">false</span>;</span><br><span class="line">        QVector&lt;Cards&gt; pairArray;</span><br><span class="line">        <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">            Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>); <span class="comment">//将搜索的的对子放入pair</span></span><br><span class="line">            <span class="keyword">if</span>(!pair.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                pairArray.<span class="built_in">push_back</span>(pair);             <span class="comment">//添加到pairArray</span></span><br><span class="line">                <span class="keyword">if</span>(pairArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                    twoPairFond = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(twoPairFond)&#123;                       <span class="comment">//如果成功找到2个对</span></span><br><span class="line">            Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">            tmp.<span class="built_in">add</span>(pairArray);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;               <span class="comment">//没有找到2个对，就找2个单牌</span></span><br><span class="line">            <span class="comment">//2.飞机带2个单牌</span></span><br><span class="line">            <span class="type">bool</span> twoSingleFond = <span class="literal">false</span>;</span><br><span class="line">            QVector&lt;Cards&gt; singleArray;</span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;   <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">                <span class="keyword">if</span>(backup.<span class="built_in">pointCount</span>(point) == <span class="number">1</span>)&#123;            <span class="comment">//先查看该点数的牌是否是只有1张，只有1张才进行添加(防止把一些对拆开)</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//将搜索的的单牌放入single</span></span><br><span class="line">                    <span class="keyword">if</span>(!single.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                        singleArray.<span class="built_in">push_back</span>(single);           <span class="comment">//添加到pairArray</span></span><br><span class="line">                        <span class="keyword">if</span>(singleArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                            twoSingleFond = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(twoPairFond)&#123;</span><br><span class="line">                Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">                tmp.<span class="built_in">add</span>(singleArray);</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//如果2对和2单都没有找到满足条件的，就直接打出飞机不带</span></span><br><span class="line">                <span class="comment">//3.直接是飞机</span></span><br><span class="line">                <span class="keyword">return</span> planeArray[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasTriple)&#123;                      <span class="comment">//找到了3张相同的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(seqTripleArray[<span class="number">0</span>]).<span class="built_in">getCardPoint</span>()&lt;Card::Card_A)&#123;         <span class="comment">//如果找到的最小的3张相同牌是小于A的，才执行下面</span></span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_A; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);              <span class="comment">//得到较小点数的牌数</span></span><br><span class="line">                <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;              <span class="comment">//如果是1张，就打出3带1</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//取出点数为point的单牌</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];      <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(single);                          <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount==<span class="number">2</span>)&#123;                      <span class="comment">//如果找到的较小点数的牌数是2</span></span><br><span class="line">                    Cards pair = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);         <span class="comment">//取出点数为point的对子</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];     <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(pair);                     <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到满足条件的单排和对子，就不带副牌</span></span><br><span class="line">        <span class="keyword">return</span> seqTripleArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的牌型都没有得到打出，就考虑打单牌或对牌</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();</span><br><span class="line">    <span class="comment">//如果下一家的手牌数只有1张了，且和下一个玩家不是相同身份</span></span><br><span class="line">    <span class="keyword">if</span>(nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()==<span class="number">1</span> &amp;&amp; m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::<span class="built_in">CardPoint</span>(Card::Card_End<span class="number">-1</span>);</span><br><span class="line">            point&gt;=Card::Card_3; point=Card::<span class="built_in">CardPoint</span>(point<span class="number">-1</span>))&#123;                 <span class="comment">//从大到小遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//如果下一家的手牌数为1且和它是相同身份；如果下一家手牌数大于1且与它不是相同身份；如果下一家手牌数大于1且与它是相同身份</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::Card_3; point&lt;Card::Card_End; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;       <span class="comment">//从小到大遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//上面所有情况呕没有打出牌，就说明牌打完了，直接返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从自己手牌中找到能击败已出牌的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getGreaterCards</span><span class="params">(PlayHand type)</span>         <span class="comment">//参数是要被击败出牌的类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 出牌玩家和当前玩家不是一伙的</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="comment">//上一个出牌玩家出了牌，与它不是一伙，且出牌玩家的手牌已经小于3---&gt;pendPlayer != nullptr是防止第一次出牌的情况(地主自由出)</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer != <span class="literal">nullptr</span> &amp;&amp; pendPlayer-&gt;<span class="built_in">getRole</span>()!=m_player-&gt;<span class="built_in">getRole</span>() &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        QVector&lt;Cards&gt; bombs = <span class="built_in">findCardsByCount</span>(<span class="number">4</span>);      <span class="comment">//通过传入参数4，找出手牌中的所有炸弹，且是从小到大排的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;bombs.<span class="built_in">size</span>(); i++)&#123;               <span class="comment">//从最小开始遍历炸弹比较</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(bombs[i]).<span class="built_in">canBeat</span>(type))&#123;        <span class="comment">//如果我的炸弹类型比出的牌类型大，就会发挥true</span></span><br><span class="line">                <span class="keyword">return</span> bombs[i];                         <span class="comment">//说明找到了击败已出牌的的最小炸弹，就直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有返回，说明没有找到合适的炸弹，就搜索当前玩家有没有王炸</span></span><br><span class="line">        Cards sj = <span class="built_in">findSamePointCards</span>(Card::Card_SJ,<span class="number">1</span>);</span><br><span class="line">        Cards bj = <span class="built_in">findSamePointCards</span>(Card::Card_BJ,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sj.<span class="built_in">isEmpty</span>() &amp;&amp; !bj.<span class="built_in">isEmpty</span>())&#123;        <span class="comment">//如果有王炸，就返回王炸</span></span><br><span class="line">            Cards jokers;</span><br><span class="line">            jokers &lt;&lt; sj &lt;&lt; bj;</span><br><span class="line">            <span class="keyword">return</span> jokers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前玩家和下一个玩家不是一伙的</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();              <span class="comment">//得到下一个玩家对象</span></span><br><span class="line">    <span class="comment">//将玩家手中的顺子剔除出去，万不得已还是不拆除(这里的顺子是指较大的顺子)</span></span><br><span class="line">    Cards remain = m_cards;</span><br><span class="line">    remain.<span class="built_in">remove</span>(<span class="built_in">Strategy</span>(m_player,remain).<span class="built_in">pickOptimalSeqSingles</span>());   <span class="comment">//去除掉手牌中较大的顺子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除冗余的思路：就是将相同的代码放到匿名函数里面，然后通过可调用对象绑定器进行绑定，最后可得到一个可调用对象，要用到的时候，直接使用该可调用对象即可</span></span><br><span class="line">    <span class="keyword">auto</span> beatCard = std::<span class="built_in">bind</span>([=](Cards &amp;cards)&#123;      <span class="comment">//参入的参数是一些牌，返回的还是Cards类型</span></span><br><span class="line">        QVector&lt;Cards&gt;beatCardsArray = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(type, <span class="literal">true</span>);   <span class="comment">//找出已出牌的类型，且要求比它更大一点(true)</span></span><br><span class="line">        <span class="keyword">if</span>(!beatCardsArray.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果找出的不为空，说明找到了比已出牌更大的类型牌</span></span><br><span class="line">            <span class="comment">//如果我与下一个玩家不是相同身份，且下一个玩家的手牌小于等于2了，这时需要出更大的牌，防止下一个玩家能出牌</span></span><br><span class="line">            <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>() &amp;&amp; nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">back</span>();             <span class="comment">//已经找出的牌型是从小到大排的，所以取出最大的牌返回</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//下一个不是相同玩家但牌数小于等于2；下一个是不同玩家，但牌数大于2；下一个是相同玩家，但牌数大于2</span></span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">front</span>();      <span class="comment">//否则的话，就直接返回最小的能压制已出牌的相同牌型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();              <span class="comment">//不满足上面，就返回空对象</span></span><br><span class="line">    &#125;, std::placeholders::_1);</span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(remain)).<span class="built_in">isEmpty</span>())&#123;          <span class="comment">//这是从剔除顺子的手牌中找</span></span><br><span class="line">        <span class="keyword">return</span> cs;                    <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">//如果从剔除顺子的手牌中没有找到，就从所有手牌中找</span></span><br><span class="line">        <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(m_cards)).<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> cs;        <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();               <span class="comment">//没有找到合适出牌类型，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Strategy::whetherToBeat</span><span class="params">(Cards &amp;cs)</span>      <span class="comment">//参数是通过其它函数得到的一个更大的牌，或为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//没有找到能够击败对方的牌,即cs为空</span></span><br><span class="line">    <span class="keyword">if</span>(cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到出牌玩家的对象</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();     <span class="comment">//得到上次出牌的玩家身份</span></span><br><span class="line">    <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>() == pendPlayer-&gt;<span class="built_in">getRole</span>())&#123;   <span class="comment">//如果身份相同，即农民</span></span><br><span class="line">        <span class="comment">//手里的牌所剩无几并且是一个完整的牌型,就可以打</span></span><br><span class="line">        Cards left = m_cards;              <span class="comment">//先复制手牌</span></span><br><span class="line">        left.<span class="built_in">remove</span>(cs);                   <span class="comment">//从手牌移出要打的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(left).<span class="built_in">getHandType</span>()!=PlayHand::Hand_Unknown)&#123;    <span class="comment">//如果手牌剩的类型不是不确定的(即就是可以一下子打完的那中牌类型)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs对象中的牌的最小点数是2，大小王就不出牌</span></span><br><span class="line">        Card::CardPoint basePoint = <span class="built_in">PlayHand</span>(cs).<span class="built_in">getCardPoint</span>();               <span class="comment">//得出要打牌的点数</span></span><br><span class="line">        <span class="keyword">if</span>(basePoint==Card::Card_2 || basePoint==Card::Card_SJ || basePoint==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果过大就不出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//如果与出牌的玩家不是相同身份</span></span><br><span class="line">        PlayHand <span class="built_in">myHand</span>(cs);                       <span class="comment">//先判断要出牌的类型</span></span><br><span class="line">        <span class="comment">//如果是三个2带1，或者带1对，不出牌(保存实力)</span></span><br><span class="line">        <span class="keyword">if</span>((myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Single || myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Pair)</span><br><span class="line">                &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs是对2，并且出牌玩家手中的牌数量大于等于10 &amp;&amp; 自己的牌数量大于等于5，暂时放弃出牌</span></span><br><span class="line">        <span class="keyword">if</span>(myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Pair &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2 &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">10</span> &amp;&amp; m_player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//上面情况都不是，就可以出牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span>     <span class="comment">//指定点数和指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;               <span class="comment">//如果要找的牌的数量小于1或大于4，都是不合法的，返回空对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大小王</span></span><br><span class="line">    <span class="keyword">if</span>(point == Card::Card_SJ || point == Card::Card_BJ)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;              <span class="comment">//非法的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//返回空对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        Card card;</span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);               <span class="comment">//存放点数(大王或小王)</span></span><br><span class="line">        card.<span class="built_in">setSuit</span>(Card::Suit_Begin);     <span class="comment">//存放花色</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;         <span class="comment">//如果该牌在m_cards是真的存在</span></span><br><span class="line">            Cards cards;</span><br><span class="line">            cards.<span class="built_in">add</span>(card);</span><br><span class="line">            <span class="keyword">return</span> cards;                   <span class="comment">//就将该牌添加到cards并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();                    <span class="comment">//没有找到大小王就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是大小王</span></span><br><span class="line">    <span class="type">int</span> findCount = <span class="number">0</span>;                   <span class="comment">//这是用来记录指定点数的牌的数量</span></span><br><span class="line">    Cards findCards;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++)&#123;       <span class="comment">//遍历花色</span></span><br><span class="line">        Card card;                                    <span class="comment">//创建一个card,记录的是指定的点数，和该遍历的花色</span></span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);</span><br><span class="line">        card.<span class="built_in">setSuit</span>((Card::CardSuit)suit);</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;                 <span class="comment">//如果该card在m_cards，说明有该张牌</span></span><br><span class="line">            findCount++;</span><br><span class="line">            findCards.<span class="built_in">add</span>(card);                    <span class="comment">//将该张牌添加到findCards</span></span><br><span class="line">            <span class="keyword">if</span>(findCount == count)&#123;</span><br><span class="line">                <span class="keyword">return</span> findCards;                   <span class="comment">//如果指定点数的牌的数量到达了指定的点数，就返回这些牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();        <span class="comment">//如果遍历完所有的花色，都没有找到指定点数、指定数量的牌，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardsByCount</span><span class="params">(<span class="type">int</span> count)</span>          <span class="comment">//指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();            <span class="comment">//如果指定的数量不合法，就直接返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">    QVector&lt;Cards&gt;cardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(point)==count)&#123;               <span class="comment">//pointCount()函数是指定点数的牌数量</span></span><br><span class="line">            <span class="comment">//如果该点数的牌数量和要求的牌数量相等，就取出该牌(通过上面刚写的函数)</span></span><br><span class="line">            Cards cs;</span><br><span class="line">            cs &lt;&lt; <span class="built_in">findSamePointCards</span>(point,count);       <span class="comment">//取出指定点数、指定数量的牌</span></span><br><span class="line">            cardsArray &lt;&lt; cs;             <span class="comment">//最后返回的容器cardsArray中，一个cards存放的是相同点数的牌</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cardsArray;         <span class="comment">//然后容器，里面存的是指定数量的牌(可能有多中不同点数的牌)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span>      <span class="comment">//指定范围的所有牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards rangeCards;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;   <span class="comment">//遍历这个范围点数的牌</span></span><br><span class="line">        <span class="type">int</span> count = m_cards.<span class="built_in">pointCount</span>(point);                     <span class="comment">//先获得该点数的牌数量</span></span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, count);               <span class="comment">//通过点数、牌数量得到这些牌</span></span><br><span class="line">        rangeCards  &lt;&lt; cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rangeCards;                      <span class="comment">//这里面存的都是在指定范围的牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardType</span><span class="params">(PlayHand hand, <span class="type">bool</span> beat)</span>    <span class="comment">//hand是要求牌的类型，beat是否需要点数更大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//取出要求牌的类型</span></span><br><span class="line">    Card::CardPoint point = hand.<span class="built_in">getCardPoint</span>();         <span class="comment">//取出要求牌的点数</span></span><br><span class="line">    <span class="type">int</span> extra = hand.<span class="built_in">getExtra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定起始点数(如果beat为true，就在原来基础上+1；为false，就直接从最小3开始找)</span></span><br><span class="line">    Card::CardPoint beginPoint = beat?Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>):Card::Card_3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">1</span>);        <span class="comment">//单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">2</span>);        <span class="comment">//对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">3</span>);        <span class="comment">//三个一样</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Single);      <span class="comment">//3带1</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Pair);        <span class="comment">//3带一对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane</span>(beginPoint);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Single);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Pair);</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:                    <span class="comment">//连对</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_Q;          <span class="comment">//最大点数到Q即可</span></span><br><span class="line">        info.number = <span class="number">2</span>;</span><br><span class="line">        info.base = <span class="number">3</span>;                    <span class="comment">//基础连对至少是3对</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqPair;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:               <span class="comment">//顺子</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_10;           <span class="comment">//最大点数到10即可</span></span><br><span class="line">        info.number = <span class="number">1</span>;</span><br><span class="line">        info.base = <span class="number">5</span>;                   <span class="comment">//基础顺子至少是5个</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqSingle;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:                    <span class="comment">//炸弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBomb</span>(beginPoint);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();                <span class="comment">//如果都不是，就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的Cards对象中挑选出顺子(参1和参2都是传出参数，参3是传入参数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Strategy::pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt; &gt; &amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt; &amp;seqSingle, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.得到传入牌cards的所有顺子的组合</span></span><br><span class="line">    QVector&lt;Cards&gt; allSeq = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Single,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(allSeq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//如果为空了，就结束递归，将满足条件的顺子传入allSeqRecord</span></span><br><span class="line">        allSeqRecord &lt;&lt; seqSingle;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;           <span class="comment">//2.对顺子进行筛选</span></span><br><span class="line">        Cards saveCards = cards;      <span class="comment">//先复制手牌，备份使用，马上进入for循环了</span></span><br><span class="line">        <span class="comment">//遍历得到的所有的顺子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;allSeq.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            Cards aScheme = allSeq.<span class="built_in">at</span>(i);             <span class="comment">//将顺子取出</span></span><br><span class="line">            Cards temp = saveCards;</span><br><span class="line">            temp.<span class="built_in">remove</span>(aScheme);                     <span class="comment">//将顺子从用户手中剔除</span></span><br><span class="line"></span><br><span class="line">            QVector&lt;Cards&gt; seqArray = seqSingle;</span><br><span class="line">            seqArray &lt;&lt; aScheme;                      <span class="comment">//将得到的顺子放入seqArray</span></span><br><span class="line">            <span class="comment">//检测还没有其它的顺子</span></span><br><span class="line">            <span class="comment">//seqArray:存储一轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//allSeqRecord:存储多轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//temp:是剔除顺子的手牌</span></span><br><span class="line">            <span class="built_in">pickSeqSingles</span>(allSeqRecord,seqArray,temp);</span><br><span class="line">            <span class="comment">//allSeqRecord里面的存的，比如说第1个元素存的是剔除34567后，手牌中还满足的顺子(包括34567)；第2个元素是剔除345678后还满足的顺子(包括345678)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选最优的顺子</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::pickOptimalSeqSingles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;QVector&lt;Cards&gt;&gt;seqRecord;</span><br><span class="line">    QVector&lt;Cards&gt; seqSingles;</span><br><span class="line">    <span class="comment">//找顺子之前，先把一些更重要的牌型剔除，防止被拆</span></span><br><span class="line">    Cards save = m_cards;                            <span class="comment">//先复制手牌</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">4</span>));                <span class="comment">//剔除炸弹</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">3</span>));                <span class="comment">//剔除一些3带1或飞机类型的牌</span></span><br><span class="line">    <span class="built_in">pickSeqSingles</span>(seqRecord, seqSingles, save);     <span class="comment">//对一些重要的牌进行剔除后，基于剩下的牌save来进行查找顺子</span></span><br><span class="line">    <span class="keyword">if</span>(seqRecord.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果找出的集合为空，说明没有找到顺子，就返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历容器</span></span><br><span class="line">    QMap&lt;<span class="type">int</span>,<span class="type">int</span>&gt;seqMarks;              <span class="comment">//存储对应关系的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqRecord.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Cards backupCards = m_cards;                  <span class="comment">//先复制手牌到backupCards</span></span><br><span class="line">        QVector&lt;Cards&gt;seqArray = seqRecord[i];        <span class="comment">//复制此刻要处理的容器(里面都是顺子)</span></span><br><span class="line">        backupCards.<span class="built_in">remove</span>(seqArray);                 <span class="comment">//从复制的手牌backupCards中移除此刻容器里面的所有顺子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断剩下的单牌数量，数量越少，顺子的组合就越合理</span></span><br><span class="line">        QVector&lt;Cards&gt; singleArray = <span class="built_in">Strategy</span>(m_player, backupCards).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>);     <span class="comment">//将移除顺子容器后的手牌传入</span></span><br><span class="line">        <span class="comment">//因为传入的数量是1,所以返回的singleArray中每个元素cards里面都是存的不同点数的牌，但每个点数的牌数量都为1</span></span><br><span class="line">        CardList cardList;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;singleArray.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cardList &lt;&lt; singleArray[j].<span class="built_in">toCardList</span>();      <span class="comment">//将所有的单牌取出转换后存入到cardList</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里选择点数相对较大一点的顺子，则在两种组合中留下的单牌数量相同的情况下，单牌点数就可能小。所以下面就选择单牌点数小的组合来返回</span></span><br><span class="line">        <span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;cardList.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            mark += cardList[j].<span class="built_in">point</span>() + <span class="number">15</span>;   <span class="comment">//加15的原因，是防止两组组合留下的单牌数不一样情况下，类似3、4和k这两种，应该选择k对应的组合</span></span><br><span class="line">        &#125;</span><br><span class="line">        seqMarks.<span class="built_in">insert</span>(i,mark);          <span class="comment">//将对应的mark值和其最大容器组合下标i的对应关系存到seqMarks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> comMark = <span class="number">1000</span>;                    <span class="comment">//先初始化一个较大值</span></span><br><span class="line">    <span class="keyword">auto</span> it = seqMarks.<span class="built_in">constBegin</span>();       <span class="comment">//常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=seqMarks.<span class="built_in">constEnd</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.<span class="built_in">value</span>() &lt; comMark)&#123;            <span class="comment">//寻找最小的key值对应的value</span></span><br><span class="line">            comMark = it.<span class="built_in">value</span>();</span><br><span class="line">            value = it.<span class="built_in">key</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seqRecord[value];            <span class="comment">//返回最优的顺子(较大的顺子)，是QVector&lt;Cards&gt;类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> number)</span>   <span class="comment">//起点点数point,number张</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint pt=point; pt&lt;Card::Card_End; pt=(Card::CardPoint)(pt+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//目的是尽量不拆分别的牌型</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(pt)==number)&#123;  <span class="comment">//这里是确保找的点数的牌数量与想找的牌数量一样，就执行下面，防止本来有个炸弹，但因为找但牌，就拆开了</span></span><br><span class="line">            Cards cs = <span class="built_in">findSamePointCards</span>(pt, number);</span><br><span class="line">            findCardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getTripleSingleOrPair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到点数相同的三张牌</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getCards</span>(begin,<span class="number">3</span>);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cardsArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//将找到的牌和三张点数相同的牌进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(cardsArray.<span class="built_in">at</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane</span><span class="params">(Card::CardPoint begin)</span>                 <span class="comment">//飞机不带牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;=Card::Card_K; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//根据点数和数量进行搜索</span></span><br><span class="line">        Cards prevCards = <span class="built_in">findSamePointCards</span>(point, <span class="number">3</span>);                      <span class="comment">//找出飞机小</span></span><br><span class="line">        Cards nextCards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">3</span>);  <span class="comment">//找出飞机大</span></span><br><span class="line">        <span class="keyword">if</span>(!prevCards.<span class="built_in">isEmpty</span>() &amp;&amp; !nextCards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            Cards tmp;</span><br><span class="line">            tmp &lt;&lt; prevCards &lt;&lt; nextCards;       <span class="comment">//将飞机小和大存到一个Cards里面，再存入到findCardArray</span></span><br><span class="line">            findCardArray &lt;&lt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane2SingleOr2Pair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span>   <span class="comment">//飞机带2单还是2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getPlane</span>(begin);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type, Card::Card_Begin, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(cardsArray.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//将找到的牌就和飞机进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                Cards tmp;</span><br><span class="line">                tmp &lt;&lt; cardsArray[<span class="number">0</span>] &lt;&lt; cardsArray[<span class="number">1</span>];</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();          <span class="comment">//没有找到，说明不满足这种飞机，就直接清空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者(可能为空)</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连对或顺子(begin是起始点；extra是要找的牌数；beat指是否比原基础上至少大1点)</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getSepPairOrSeqSingle</span><span class="params">(CardInfo &amp;info)</span>    <span class="comment">//连对和顺子提供的数据是不一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt;findCardsArray;</span><br><span class="line">    <span class="keyword">if</span>(info.beat)&#123;       <span class="comment">//为true，表示要找能压制对方的牌</span></span><br><span class="line">        <span class="comment">//最少3个，最大A(连对)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;           <span class="comment">//记录是否查找成功</span></span><br><span class="line">            Cards seqCards;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;info.extra; i++)&#123;</span><br><span class="line">                <span class="comment">//基于点数和数量进行牌的搜索</span></span><br><span class="line">                Cards cards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+i),info.number);     <span class="comment">//连续的2张2张的找连对</span></span><br><span class="line">                <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>() || (point+info.extra&gt;=Card::Card_2))&#123;     <span class="comment">//这种情况就是没有找到</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    seqCards.<span class="built_in">clear</span>();</span><br><span class="line">                    <span class="keyword">break</span>;       <span class="comment">//说明以此刻的point为起点，遍历extra个是找不到的，直接跳出循环，继续下一个point为起点开始查找</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    seqCards &lt;&lt; cards;         <span class="comment">//如果找到了就加入seqCards</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found)&#123;    <span class="comment">//如果以此刻的point为起点找到了满足条件的，就没有必要继续找了，因为压制对方的最小的连对已经找到</span></span><br><span class="line">                findCardsArray &lt;&lt; seqCards;</span><br><span class="line">                <span class="keyword">return</span> findCardsArray;                <span class="comment">//直接返回即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     <span class="comment">//bet为false，意味着要找的连对对点数和数量是没有要求的(不受extra约束)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="comment">//将找到的这个基础连对存储起来</span></span><br><span class="line">            Cards baseSeq = (<span class="keyword">this</span>-&gt;*info.getSeq)(point);       <span class="comment">//使用函数指针，得到一个基础连对或基础顺子</span></span><br><span class="line">            <span class="keyword">if</span>(baseSeq.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果是空，就不执行下面了，重新循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            findCardsArray &lt;&lt; baseSeq;            <span class="comment">//将基础连对存储到最终容器中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> followed = info.base;           <span class="comment">//因为之前已经找到了3对，接下来是再其基础上找连续对子</span></span><br><span class="line">            Cards alreadyFollowedCards;         <span class="comment">//存储后序找到的满足条件的连对</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                Card::CardPoint followedPoint = Card::<span class="built_in">CardPoint</span>(point+followed);      <span class="comment">//新的起始点数</span></span><br><span class="line">                <span class="comment">//判断是否超出了上限</span></span><br><span class="line">                <span class="keyword">if</span>(followedPoint &gt;= Card::Card_2)&#123;              <span class="comment">//如果点数比2大，是不合理的，直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Cards follwedCards = <span class="built_in">findSamePointCards</span>(followedPoint, info.number);     <span class="comment">//如果点数合理，就寻找该点数的对子</span></span><br><span class="line">                <span class="keyword">if</span>(follwedCards.<span class="built_in">isEmpty</span>())&#123;           <span class="comment">//为空表示没有找到，退出循环(说明以此刻的point为起点的后序对子段了或没有了)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//比如说345是基础连对，在此基础上，3456、34567都会作为一个独立的cards存储到最终容器中，当没有8连对时，以345为基础的也结束查找了</span></span><br><span class="line">                    alreadyFollowedCards &lt;&lt; follwedCards;   <span class="comment">//在后面基础每找到一对，就将其存入到alreadyFollowedCards</span></span><br><span class="line">                    Cards newSeq = baseSeq;                 <span class="comment">//通过拷贝赋值得到newSeq，它里面存的是此刻的基础对子</span></span><br><span class="line">                    newSeq &lt;&lt; alreadyFollowedCards;         <span class="comment">//将这一轮找到的对子加入到基础对子，又得到一种新的连对</span></span><br><span class="line">                    findCardsArray &lt;&lt; newSeq;               <span class="comment">//将这一轮得到的新连对存入到最终容器中</span></span><br><span class="line">                    followed++;                             <span class="comment">//++操作，在此刻的基础连对上，继续找下一个对子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;       <span class="comment">//如果遍历完了还没有找到，返回的就是一个空对象，否则里面就有很多连对cards对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span>      <span class="comment">//生成基础连对函数(参数是起始点)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">2</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">2</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">2</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span>    <span class="comment">//生成基础顺子函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">1</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards3 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">3</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards4 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">4</span>),<span class="number">1</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>() &amp;&amp; !cards3.<span class="built_in">isEmpty</span>() &amp;&amp; !cards4.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2 &lt;&lt; cards3 &lt;&lt; cards4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getBomb</span><span class="params">(Card::CardPoint begin)</span>            <span class="comment">//找炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findcardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            findcardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findcardsArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;这是一个基于Qt开发的单机版的斗地主小游戏。该项目一共涉及到的类有如下：&lt;/p&gt;
&lt;p&gt;1.卡牌类&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>QT基础</title>
    <link href="https://lxx93.online/2024/08/03/QT%E5%9F%BA%E7%A1%80/"/>
    <id>https://lxx93.online/2024/08/03/QT%E5%9F%BA%E7%A1%80/</id>
    <published>2024-08-03T13:48:35.000Z</published>
    <updated>2025-03-26T11:07:12.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展以及一些宏，Qt很容易扩展，并且允许真正的组件编程。</p><p>Qt Creator是一个用于Qt开发的轻量级跨平台集成开发环境。Qt Creator可带来两大关键益处：提供首个专为支持跨平台开发而设计的集成开发环境(IDE)，并确保首次接触Qt框架的开发人员能迅速上手和操作。即使不开发Qt应用程序，Qt Creator也是一个简单易用且功能强大的IDE。</p><p>Qt是一套应用程序开发库，但与MFC不同，Qt是跨平台的开发类库。跨平台意味着只需要编写一次程序，在不同平台上无需改动或只需要少许改动后在编译，就可以形成在不同平台上运行的版本。</p><h2 id="1-2-Qt特征"><a href="#1-2-Qt特征" class="headerlink" title="1.2 Qt特征"></a>1.2 Qt特征</h2><p>1.面向对象</p><p>Qt具有模块设计和控件或元素的可重用性的特点。一个控件不需要找到它的内容和用途，通过Signal和slot与外界通信、交流。而且Qt的控件都可通过继承。</p><p>2.控件间的相互通信</p><p>Qt提供signal和slot概念，这是一种安全可靠的方法，它允许回调，并支持对象之间在彼此不知道对方信息的情况下，进行合作，这使Qt非常合适于真正的控件编程。</p><p>3.友好的联机帮助</p><p>Qt包括大量的联机参考文档，有超文本HTML方式、UNIX帮助页、man手册和补充的指南。对于初学者，指南将一步步地解释Qt编程。</p><p>4.用户自定义</p><p>其它的工具包在应用时都存在一个普遍的问题，就是经常没有真正适合需求的控件，生成的自定义控件对用户来说，也是一个黑匣子。比如，在Motif手册中就讨论了用户自定义的控件问题。而在Qt中，能够创建控件，具有绝对的优越性，生成自定义控件非常简单，并且容易修改控件。</p><p>5.方便性</p><p>由于Qt是一种跨平台的GUI工具包，所以它对编程者隐藏了在处理不同窗口系统时的潜在问题。为了将基于Qt程序更加方便，Qt包含了一系列类。该类能够使程序员避免了在文件处理、时间处理等方面存在依赖操作系统方面的细节问题。</p><h1 id="2-Qt编译过程"><a href="#2-Qt编译过程" class="headerlink" title="2. Qt编译过程"></a>2. Qt编译过程</h1><p>1.编写代码</p><p>通过文本文档写入如下代码，后缀改为cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span>                         <span class="comment">//水平布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span>                         <span class="comment">//垂直布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span>                                <span class="comment">//窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;                            <span class="comment">//程序</span></span><br><span class="line">QLabel *infoLabel = <span class="keyword">new</span> QLabel;                        <span class="comment">//信息标签对象</span></span><br><span class="line">QLabel *openLabel = <span class="keyword">new</span> QLabel;                     <span class="comment">//打开标签对象</span></span><br><span class="line">QLineEdit *cmdLineEdit = <span class="keyword">new</span> QLineEdit;        <span class="comment">//文本行编辑框对象</span></span><br><span class="line">QPushButton *commitButton = <span class="keyword">new</span> QPushButton;          <span class="comment">//确定按钮</span></span><br><span class="line">QPushButton *cancelButton = <span class="keyword">new</span> QPushButton;             <span class="comment">//取消按钮</span></span><br><span class="line">QPushButton *browseButton = <span class="keyword">new</span> QPushButton;           <span class="comment">//浏览按钮</span></span><br><span class="line"></span><br><span class="line">infoLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;input cmd：&quot;</span>);</span><br><span class="line">openLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">commitButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line">cancelButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">browseButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;browse&quot;</span>);</span><br><span class="line"></span><br><span class="line">QHBoxLayout *cmdLayout = <span class="keyword">new</span> QHBoxLayout;                 <span class="comment">//水平布局对象</span></span><br><span class="line">cmdLayout-&gt;<span class="built_in">addWidget</span>(openLabel);</span><br><span class="line">cmdLayout-&gt;<span class="built_in">addWidget</span>(cmdLineEdit);</span><br><span class="line"></span><br><span class="line">QHBoxLayout *buttonLayout = <span class="keyword">new</span> QHBoxLayout;             <span class="comment">//水平布局对象</span></span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(commitButton);</span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(cancelButton);</span><br><span class="line">buttonLayout-&gt;<span class="built_in">addWidget</span>(browseButton);</span><br><span class="line"></span><br><span class="line">QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout;              <span class="comment">//垂直布局对象</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">addWidget</span>(infoLabel);</span><br><span class="line">mainLayout-&gt;<span class="built_in">addLayout</span>(cmdLayout);                              <span class="comment">//将布局添加到布局是用addLayout函数</span></span><br><span class="line">mainLayout-&gt;<span class="built_in">addLayout</span>(buttonLayout);</span><br><span class="line"></span><br><span class="line">QWidget w;                                    <span class="comment">//窗口对象</span></span><br><span class="line">w.<span class="built_in">setLayout</span>(mainLayout);             <span class="comment">//将主布局(所有内容都在这个布局里)嵌入到窗口</span></span><br><span class="line">w.<span class="built_in">show</span>()；</span><br><span class="line"><span class="keyword">return</span> app.<span class="built_in">exec</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.生成工程文件</p><ul><li><p>cmd进入工程目录(最好是QT自带的)</p></li><li><p>在过程目录下的cmd输入：<code>qmake -project</code></p></li><li><p>修改工程文件，在工程目录下会生成一个后缀为pro的文件，在该文件的最后一行添加：<code>QT += widgets gui</code></p></li></ul><p>3.生成makefile，终端输入qmake</p><p>4.输入mingw32-make，执行成功就可以在工程目录下的debug或release目录下生成可执行文件。</p><p>注：以上步骤可能存在环境变量文件，如果出现，想要配置</p><h1 id="3-Qt-Creator"><a href="#3-Qt-Creator" class="headerlink" title="3. Qt Creator"></a>3. Qt Creator</h1><p>在创建一个Qt的项目时，也就是创建一个主窗口，基类的选择有以下三种：</p><ul><li><code>QmainWindow</code>：继承QWidget，带有菜单栏、工具栏、状态栏的界面</li><li><code>QWidget</code>：最基础的窗口类，qt里面能看到的东西的基类，不带菜单栏的界面，类似于QQ、微信的登录框</li><li><code>Qdialog</code>：继承QWidget，对话框界面，完成一些业务时，弹出的对话框</li></ul><p>Qt里面绝大部分的类都是继承自QObject，它是一个顶层类</p><p>下面创建了一个MainWindow窗口类，继承的基类是<code>QWidget</code></p><p>下面是创建窗口后，提供的main()函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个应用程序对象：维护qt应用程序生命的一个对象，每个qt有且只有一个对象</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//窗口类的一个对象</span></span><br><span class="line">    MainWindow w;</span><br><span class="line">    <span class="comment">//把窗口显示出来</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//死循环让程序一直运行，生命循环，消息循环</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while(1)&#123;</span></span><br><span class="line"><span class="comment">        if(点击x按钮)&#123;</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if(点击...)&#123;</span></span><br><span class="line"><span class="comment">            执行相应操作</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        .....</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是窗口类的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//宏，引入t信号槽的一个宏</span></span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//parent窗口制作，父窗口对象的指针</span></span><br><span class="line">    <span class="comment">//如果parent为0或者NULL，表示当前窗口对象是个顶层窗口</span></span><br><span class="line">    <span class="comment">//顶层窗口就是在任务栏可以找到的窗口(可以通过函数设置，所以这个说法不一定正确)</span></span><br><span class="line">    <span class="built_in">MainWindow</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">newhello</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是窗口类的构造函数以及一些程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//this-&gt;move(100,100);   //主窗口MainWindow窗口也可以移动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnA = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);  <span class="comment">//指定父对象，这个按钮就可以内嵌到MainWindow这个窗口里面</span></span><br><span class="line">    btnA-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                   <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnA-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnB = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnA);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnA这个按钮窗口里面</span></span><br><span class="line">    btnB-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                  <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnB-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);        <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第三个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnC = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnB);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnB这个窗口里面</span></span><br><span class="line">    btnC-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                 <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnC-&gt;<span class="built_in">setFixedSize</span>(<span class="number">50</span>,<span class="number">50</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，<code>ui</code> 是一个指向UI类对象的指针，该对象通常通过UI设计器生成，并包含了所有UI组件的实例和布局信息。而<code>setupUi</code> 是UI类中的一个成员函数，它的作用是将UI组件添加到主窗口上，并设置它们的位置、大小等属性。<code>this</code> 是一个指向当前对象的指针，通常是主窗口的实例。<code>setupUi</code> 函数会使用这个指针来确定UI组件应该添加到哪个窗口上。</p><p>执行后的效果如下：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Qt/8_1.png" style="zoom: 67%;"><h1 id="4-基本知识1"><a href="#4-基本知识1" class="headerlink" title="4. 基本知识1"></a>4. 基本知识1</h1><p><code>QWidget</code>类是所有用户界面对象的基类，它提供了创建和管理窗口部件的功能。另一方面，<code>QObject</code>类是Qt对象模型的基类，它提供了对象树、信号与槽机制、事件处理等基本功能。</p><h2 id="4-1-父子关系"><a href="#4-1-父子关系" class="headerlink" title="4.1 父子关系"></a>4.1 父子关系</h2><p>默认情况下按钮是没有认父亲的，也就是一个顶层窗口，想要按钮显示在窗口中，就要跟窗口构造父子关系，方法如下：</p><ul><li>setParent</li><li>构造函数传参</li></ul><p>创建了一个MainWindow窗口类，继承的基类是<code>QWidget</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种情况没有建立父子关系，而QPushButton的基类是Widget，所以显示的是顶层窗口(重新显示在一个窗口中)</span></span><br><span class="line">    QPushButton btn1;        <span class="comment">//创建按钮对象</span></span><br><span class="line">    btn1.<span class="built_in">setText</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    btn1.<span class="built_in">show</span>();             <span class="comment">//将按钮显示出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立父子关系：建立父子关系后，该按钮就不需要show了，只要父亲显示出来，它就可以显示出来</span></span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    QPushButton btn2;</span><br><span class="line">    btn2.<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    btn2.<span class="built_in">setParent</span>(&amp;w);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn3</span><span class="params">(<span class="string">&quot;按钮3&quot;</span>,&amp;w)</span></span>;</span><br><span class="line">    btn3.<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-基础"><a href="#4-2-基础" class="headerlink" title="4.2 基础"></a>4.2 基础</h2><p>1.关于Qt的坐标系是以父窗口的左上角为(0，0)的，以向右的方向为x的正方向，以向下的方向为y的正方向，顶层窗口就是以屏幕左上角为(0，0)的。</p><p>2.常用的API:</p><ul><li>move：移动窗口到父窗口某个位置</li><li>resize：重新设置窗口的大小</li><li>setFixedSize()：设置窗口的固定大小</li><li>setWindowTitle()：设置窗口标题</li><li>setGeometry()：同时设置窗口位置和大小，相当于是move和resize的结合体，参数(x轴，y轴，宽，高)</li></ul><p>3.对象树</p><p>概念：各个窗口对象通过建立父子关系构造的一个关系树</p><p>内存管理：父对象释放的时候会自动释放各个子对象</p><p>Qt中有内存回收机制，即对象树，但不是所有被new出的对象被自动回收，满足下面两个条件才可以自动回收：</p><ol><li>创建的对象必须是<code>QObject</code>类的子类(间接子类也可以)，<code>QObject</code>类是没有父类的，Qt中有很大一部分类都是从这个类派生出去的</li><li>创建出的类对象，必须要指定其父对象是谁，一般情况下有两种操作方式：<ul><li>在构造对象时指定父对象</li><li>通过调用<code>QWidget</code>的API指定父窗口对象，就是setParent()方法</li></ul></li></ol><p>下面创建了一个主窗口MainWindow窗口类，继承的基类是QWidget，又创建了一个MyPushButton窗口类，使它继承的基类是QWidget。</p><p>以下是主窗口MainWindow类的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//局部变量在函数退出的时候就会自动释放(窗口就算没有关闭，它的构造函数也会很快执行结束)，所以这种方式在窗口不能显示按钮</span></span><br><span class="line">    <span class="function">QPushButton <span class="title">btn</span><span class="params">(<span class="string">&quot;按钮1&quot;</span>,<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    btn.<span class="built_in">show</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解决办法，让按钮的生命周期长一点：static、类成员变量、new一个，动态内存分配</span></span><br><span class="line">    MyPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">MyPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-信号槽机制"><a href="#5-信号槽机制" class="headerlink" title="5. 信号槽机制"></a>5. 信号槽机制</h1><p>信号：各种事件；槽：相应信号的动作</p><p>信号和槽本质都是函数</p><p>当某个事件发送后，如某个按钮被点击了一下，它就会发出一个被点击的信号(signal)，当某个对象接到这个信号之后，就会做一些相关的处理动作(slot)。但是Qt对象不会无故收到某个信号，要想让一个对象收到另一个对象发出的信号。这时需要建立连接，即connect()。</p><p><code>connect(信号发送者,信号,信号接收者,槽);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(btn, &amp;QPushButton::clicked, this, &amp;Widget::close);</span><br></pre></td></tr></table></figure><p>使用connect的时候保留<code>&amp;</code>符号的原因：</p><ul><li>提高代码可读性(提示这是一个指针)</li><li>自动提示(会根据前面写的内容来提示你接下来可能输入的内容)</li></ul><p>下面编写了多个类，类与类之间想要在Qt中使用信号槽机制，那么必须要满足如下条件：</p><ol><li>这个类必须从<code>QObject</code>类或者是其子类进行派生</li><li>在定义类的头文件种加入Q_OBJECT宏</li></ol><h2 id="5-1-自定义信号与槽"><a href="#5-1-自定义信号与槽" class="headerlink" title="5.1 自定义信号与槽"></a>5.1 自定义信号与槽</h2><p>1自定义信号要求：</p><ul><li>信号是类的成员函数</li><li>返回值是void类型</li><li>信号的名字可以根据实际情况进行指定</li><li>参数可以随意指定，信号也可以重载</li><li>信号需要使用signals关键字进行声明，类似于public</li><li>信号函数只需要声明，不需要定义(没有函数体实现)</li><li>在程序中发送自定义信号，发送的本质就是调用信号函数</li></ul><p>建议：习惯性在信号函数前加关键字emit；其只是显示的声明信号被发送,没有特殊含义。底层emit &#x3D;&#x3D; #define emit</p><p>2.槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的，要求：</p><ul><li>返回值是void类型</li><li>槽也是函数，因此也支持重载</li><li>Qt中的槽函数的类型有类的成员函数、全局函数、静态函数和lambda表达式(匿名函数)</li><li>槽函数可以使用关键字进行声明：public slots、private slots、protected slots</li></ul><p>3.信号槽使用扩展：</p><ul><li><p>一个信号可以连接多个槽函数，发送一个信号有多个处理函数</p><ul><li>需要写多个connect连接</li><li>槽函数的执行顺序是随机的，和connect函数的调用顺序没有关系</li><li>信号的接收者可以是一个对象，也可以是多个对象</li></ul></li><li><p>一个槽函数可以连接多个信号，多个不同的信号，处理动作是相同的</p><ul><li>写多个connect就可以</li></ul></li><li><p>信号可以连接信号：信号接收者可以接收信号，继续发出新的信号，即传递了数据，并没有进行处理</p></li><li><p>信号槽是可以断开的，通过disconnect()函数，其与connect函数的参数一样</p></li></ul><p>4.参数的二义性问题：当某个类具有两个相同名字的信号，一个带参数，一个不带参数，那么接收该信号的类不知道该执行哪个槽函数，所以会报错，需要通过下面两种方法来解决：</p><ul><li>使用函数指针赋值，让编译器自动挑选符合类型的函数</li><li>使用static_cast强制转换，让编译器自动挑选符合类型的函数</li></ul><p>下面是一个窗口类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    tea = <span class="keyword">new</span> <span class="built_in">teacher</span>(<span class="keyword">this</span>);      <span class="comment">//创建teacher类型对象</span></span><br><span class="line">    stu = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="keyword">this</span>);      <span class="comment">//创建Student类型对象</span></span><br><span class="line">    </span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;按钮1&quot;</span>, <span class="keyword">this</span>);      <span class="comment">//以窗口为父对象，创建一个按钮1</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [&amp;]()&#123;       <span class="comment">//点击按钮触发信号</span></span><br><span class="line">       emit tea-&gt;<span class="built_in">hungry</span>();</span><br><span class="line">       emit tea-&gt;<span class="built_in">hungry</span>(<span class="string">&quot;kfc&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//connect(tea, &amp;teacher::hungry, stu, &amp;Student::treat);      //直接执行会报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法1</span></span><br><span class="line">    <span class="built_in">void</span> (teacher::*tq)(QString) = &amp;teacher::hungry;       <span class="comment">//带参的函数指针，指向信号(也可以不带参)</span></span><br><span class="line">    <span class="built_in">void</span> (Student::*sq)(QString) = &amp;Student::treat;        <span class="comment">//带参的函数指针，指向槽函数(也可以不带参)</span></span><br><span class="line"><span class="built_in">connect</span>(tea, tq, stu, sq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：强制类型转换为想要的信号和槽函数(下面是转换为不带参的)</span></span><br><span class="line">    <span class="built_in">connect</span>(tea, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (teacher::*)()&gt;(&amp;teacher::hungry), stu, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (Student::*)()&gt;(&amp;Student::treat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面程序中也可以信号连接信号，如果有同名但参数不同的信号，还需要进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, tea, &amp;teacher::hungry);</span><br></pre></td></tr></table></figure><p>5.Qt4中的信号和槽</p><p>使用两个宏 SIGNAL和SLOT，它们的原理是将后面的参数转换成字符串，使用方式为：</p><p><code>connect(信号发送者, SIGNAL(函数原型), 信号接收者, SLOT(函数原型));</code></p><ul><li>好处：没有重载二义性的问题，有无参数可以直接写在connect里面</li><li>坏处：写错了，编译期间不报错(在项目中就很难排查错误)</li></ul><p>6.QDebug输出QString默认会转义，比如说当给信号传入的参数是<code>emit tea-&gt;hungry(&quot;kfc\r\n&quot;);</code>，控制台输出的也是<code>&quot;kfc\r\n&quot;</code>。</p><p>解决办法：</p><ul><li>将QString转成char*：<code>qDebug()&lt;&lt;&quot;请吃&quot;&lt;&lt;what.toUtf8().data();</code></li><li>使用qDebug().noquote()：<code>qDebug().noquote()&lt;&lt;&quot;请吃&quot;&lt;&lt;what;</code></li></ul><h2 id="5-2-定时器程序"><a href="#5-2-定时器程序" class="headerlink" title="5.2 定时器程序"></a>5.2 定时器程序</h2><p>下面是一个非自定义的信号与槽，所以就需要先手动在ui界面添加两个按钮和两个标签。然后通过系统提供的按钮信号来触发槽函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器对象</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);  <span class="comment">//new一个定时器对象，给其指定一个父对象(构成对象树，当析构MainWindow时，先析构timer)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改定时器对象的精度(可有可无)---&gt;添加后，显示时间时，1秒会只相差几毫秒，不然会相差有点大</span></span><br><span class="line">    timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);   <span class="comment">//PreciseTimer表示设置了最高精度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击loopBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())&#123;     <span class="comment">//如果定时器正在工作</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();         <span class="comment">//关闭定时器</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//定时器还没有工作</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);    <span class="comment">//启动定时器，1000ms==1s,即1秒发一个timeout信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>,[=]()&#123;        <span class="comment">//发出一个timeout信号处理该动作</span></span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();                <span class="comment">//得到当前的一个时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);    <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">        ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);                    <span class="comment">//在标签上显示时间(动态显示，因为每1秒会发timeout)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击onceBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//获取2s以后的系统时间</span></span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">            QTime tm = QTime::<span class="built_in">currentTime</span>();              <span class="comment">//得到当前的一个时间</span></span><br><span class="line">            QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);  <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">            ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);                 <span class="comment">//在标签上显示时间(静态显示，只有按下按钮才发信息)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-QMainWindow"><a href="#6-QMainWindow" class="headerlink" title="6. QMainWindow"></a>6. QMainWindow</h1><p>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏(menu bar)、多个工具栏(tool bars)、多个停靠部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。具体结果如下：</p><p><img src="/.online//图床数据\Qt\8_3.png"></p><p>1.下面创建了一个窗口类MainWindow，继承的基类是QMainWindow，在该窗口中添加各个部件内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单栏，获取当前窗口的菜单栏，没有的话会自动创建一个</span></span><br><span class="line">    QMenuBar *mb = <span class="keyword">this</span>-&gt;<span class="built_in">menuBar</span>();</span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    QMenu *menuFile = mb-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">    QMenu * menuEdit = mb-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">    <span class="comment">//往菜单里面添加菜单项</span></span><br><span class="line">    QAction *actionNew = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">    QAction *actionOpen = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加分隔符</span></span><br><span class="line">    menuFile-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line"></span><br><span class="line">    QAction *actionRename = menuFile-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;重命名&quot;</span>);    <span class="comment">//菜单项</span></span><br><span class="line">    <span class="comment">//添加二级菜单</span></span><br><span class="line">    QMenu *menuRecent = menuFile-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;最近打开的文件&quot;</span>);</span><br><span class="line">    menuRecent-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工具栏(可以拖动)，可以有多个</span></span><br><span class="line">    QToolBar *toolBar = <span class="keyword">this</span>-&gt;<span class="built_in">addToolBar</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//工具栏添加工具</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(actionNew);</span><br><span class="line">    toolBar-&gt;<span class="built_in">addAction</span>(actionOpen);</span><br><span class="line">    <span class="comment">//默认停靠在左边</span></span><br><span class="line">    <span class="comment">//this-&gt;addToolBar(Qt::LeftToolBarArea, toolBar);</span></span><br><span class="line">    <span class="comment">//只允许停靠在左边或者右边</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftToolBarArea|Qt::RightToolBarArea);</span><br><span class="line">    <span class="comment">//设置工具栏不可以浮动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置工具栏不允许拖动</span></span><br><span class="line">    toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态栏只有一个，这种就可以不需要添加</span></span><br><span class="line">    QStatusBar *sb = <span class="keyword">this</span>-&gt;<span class="built_in">statusBar</span>();           <span class="comment">//获取窗口的状态栏</span></span><br><span class="line">    <span class="comment">//往状态栏里面添加信息</span></span><br><span class="line">    <span class="comment">//添加左侧信息</span></span><br><span class="line">    QLabel *labelLeft = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;左侧信息&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    sb-&gt;<span class="built_in">addWidget</span>(labelLeft);</span><br><span class="line">    <span class="comment">//添加右侧信息</span></span><br><span class="line">    QLabel *labelRight = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧信息&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    sb-&gt;<span class="built_in">addPermanentWidget</span>(labelRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停靠部件(可以拖动)，可以有多个</span></span><br><span class="line">    QDockWidget *dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;停靠部件&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//默认情况下没有核心部件作为参照物，停靠部件就会占完窗口</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">addDockWidget</span>(Qt::BottomDockWidgetArea, dockWidget);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加核心部件</span></span><br><span class="line">    QTextEdit *textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个编辑框</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.UI文件的使用</p><p>创建项目时保留UI，setupUI函数就是关联UI文件的代码到程序，原理就是qt将ui文件转化成了c++代码。</p><p>3.资源文件使用</p><p>创建资源文件：新建 —–&gt; Qt —–&gt; Qt Resource  File —–&gt; 名称为res</p><h1 id="7-QDialog对话框"><a href="#7-QDialog对话框" class="headerlink" title="7. QDialog对话框"></a>7. QDialog对话框</h1><p>对话框是GUI程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中，比如用于完成一次性任务的功能(如登录功能、现在某个文件打开、保存文件)。对话框通常会是一个顶层窗口，出现在程序最上层，用于实习短期任务或者简洁的用户交互。</p><p>Qt中使用QDialog类实现对话框，但是声明一个QDialog对象的时候，不管这个对话框对象跟哪个窗口建立了父子关系，当它显示出来的时候都还是一个顶层的窗口。</p><p>1.对话框没有最大化、最小化按钮的窗口，其可以分为<code>模态对话框</code>和<code>非模态对话框</code>：</p><ul><li>模态对话框：就是对话框还没有关闭前不能操作同一个进程的其它窗口<ul><li>创建模态：QDialog::exec()函数，是一个阻塞的消息循环函数</li></ul></li><li>非模态对话框：就是对话框没有关闭前也能操作同一个进程的其它窗口<ul><li>使用show()函数来直接显示窗口就可以，非阻塞的情况下要使用new的方式来创建对话框对象，不然容易随着所在区域的释放而释放。</li><li>内存泄漏问题，模态对话框关闭后可能并不会马上释放，所以就得通过设置窗口的属性来让其关闭后自动释放：<ul><li><code>dlg-&gt;setAttribute(Qt::WA_DeleteOnClose);</code></li></ul></li></ul></li></ul><p>下面通过两个按钮的发送信号来触发槽函数，从而实现创建模态和非模态对话框</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_model_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个模态对话框</span></span><br><span class="line">    <span class="function">QDialog <span class="title">dlg</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    dlg.<span class="built_in">exec</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;hello model dialog&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::on_nonmodel_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个非模态对话框</span></span><br><span class="line">    <span class="comment">//因为show()是非阻塞的函数，所以当dlg所在的区域释放后，dlg对话框也会释放，得通过new创建</span></span><br><span class="line">    <span class="comment">//QDialog dlg(this);</span></span><br><span class="line">    QDialog *dlg = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//释放问题，只有父对象释放的时候子对象才在释放</span></span><br><span class="line">    dlg-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);       <span class="comment">//通过设置窗口的属性，让它关闭的时候自动释放</span></span><br><span class="line">    dlg-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;hello nonmodel dialog&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.系统标准对话框</p><p>QMessageBox用来提示用户某条信息，分为以下几种：</p><ul><li>错误提示框：<code>QMessageBox::critical();</code></li><li>警告提示框：<code>QMessageBox::warning();</code></li><li>信息提示框：<code>QMessageBox::information();</code></li><li>问题提示框：<code>QMessageBox::question();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数依次是：父对象窗口；提示框标题；提示框提示的信息</span></span><br><span class="line">QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;错误&quot;</span>, <span class="string">&quot;critical&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;警告&quot;</span>, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;信息&quot;</span>, <span class="string">&quot;information&quot;</span>);</span><br><span class="line">QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;ONE PIECE&quot;</span>, <span class="string">&quot;Does it really exist?&quot;</span>, QMessageBox::Ok|QMessageBox::Cancel);</span><br></pre></td></tr></table></figure><p>问题提示框相较于其它几个提示框比较特殊，可以指定对话框的按钮，通过返回值来获取用户点击了哪个按钮。</p><p>3.文件对话框</p><p>使用QFileDialog来打开一个文件对话框，常用的函数是getOpenFileName来选择单一某文件，返回值是用户选择的文件路径。</p><p>在下面程序的中，设置的过滤器表示为将打开的目录种类分为PNG、ICO和all类型，默认先显示的是PNG类别的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认打开的是当前项目所在的文件</span></span><br><span class="line">QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开一个文件&quot;</span>);</span><br><span class="line"><span class="comment">//参数3和参数4是可选的，参3是设置打开的目录，参4是过滤器，将打开目录分为设置的机种类别</span></span><br><span class="line">QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开一个文件&quot;</span>, <span class="string">&quot;C:\\Qt\\Bird&quot;</span>, <span class="string">&quot;PNG (*.png) ;; ICO (*.ico) ;; all (*.*)&quot;</span>);</span><br></pre></td></tr></table></figure><p>4.布局</p><p>有如下两类布局：</p><ul><li>静态：就是位置和大小不会跟着外部窗口变化而变化</li><li>动态：就是位置和大小会跟着外部窗口变化而变化</li></ul><p>常用的动态布局：水平、垂直、栅格、表单布局，推荐使用widget的自带的布局功能</p><p>使用弹簧来调整布局的位置(居中)，栅格布局可以将空间分为几行几列的表格，方便对齐</p><p>大小策略：默认情况下动态布局，子窗口的大小会跟着父窗口的大小变化而变化，调整水平或垂直策略，变为固定</p><p>调整子窗口和父窗口之间的间隙，设置父窗口的margin，调整子窗口之间的间隙就调整spacing</p><p>调整窗口的固定大小，就是将窗口的最大值和最小值都设为同一个值</p><p>5.按钮组</p><ul><li><p>radio button单选按钮：互斥域的问题，如果想将某些单选按钮隔离开，就用容器将它们隔离，一般用Group Box</p></li><li><p>check box多选按钮：有三态(tristate)，每次点击按钮的时候stateChange信号里边传进来</p></li></ul><p>6.QListWidget窗口</p><p>往ListWidget窗口中添加内容有两种方式：</p><ul><li>往ListWidget窗口中，通过addItem添加QListWidgetItem对象(一个一个添加，可以修改item的属性)</li><li>往ListWidget窗口中，通过addItems添加QStringList对象(一次性添加多个，不可以修改item的属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次性添加一个</span></span><br><span class="line">QListWidgetItem *item = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;嘻嘻哈哈&quot;</span>);</span><br><span class="line">item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignHCenter);         <span class="comment">//这是设置了item居中显示</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性添加多个</span></span><br><span class="line">QStringList list;</span><br><span class="line">list&lt;&lt;<span class="string">&quot;嘻嘻哈哈&quot;</span>&lt;&lt;<span class="string">&quot;叽叽喳喳&quot;</span>&lt;&lt;<span class="string">&quot;把卡把卡&quot;</span>;</span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItems</span>(list);</span><br></pre></td></tr></table></figure><p>7.treeWidget窗口</p><ul><li>设置标题，会根据setHeaderLabels函数里面的成员数生成对应的列数</li><li>添加根节点通过addTopLevelItem函数</li><li>根节点下面添加子节点通过addChild函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设置标题</span></span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">setHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;简介&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加跟节点</span></span><br><span class="line">QTreeWidgetItem *liliangItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;力量&quot;</span>);</span><br><span class="line">QTreeWidgetItem *minjieItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;敏捷&quot;</span>);</span><br><span class="line">QTreeWidgetItem *zhiliItem = <span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;智力&quot;</span>);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(liliangItem);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(minjieItem);</span><br><span class="line">ui-&gt;treeWidget-&gt;<span class="built_in">addTopLevelItem</span>(zhiliItem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加相应的子节点</span></span><br><span class="line">QStringList heroL1, heroL2, heroM1, heroM2, heroZ1, heroZ2;</span><br><span class="line">heroL1&lt;&lt;<span class="string">&quot;亚瑟&quot;</span>&lt;&lt;<span class="string">&quot;对拼刺刀&quot;</span>;</span><br><span class="line">heroL2&lt;&lt;<span class="string">&quot;坦克&quot;</span>&lt;&lt;<span class="string">&quot;血条厚&quot;</span>;</span><br><span class="line">heroM1&lt;&lt;<span class="string">&quot;李白&quot;</span>&lt;&lt;<span class="string">&quot;花里胡哨&quot;</span>;</span><br><span class="line">heroM2&lt;&lt;<span class="string">&quot;刺客&quot;</span>&lt;&lt;<span class="string">&quot;太秀了&quot;</span>;</span><br><span class="line">heroZ1&lt;&lt;<span class="string">&quot;孙策&quot;</span>&lt;&lt;<span class="string">&quot;无证驾船&quot;</span>;</span><br><span class="line">heroZ2&lt;&lt;<span class="string">&quot;上单&quot;</span>&lt;&lt;<span class="string">&quot;横冲直撞&quot;</span>;</span><br><span class="line">liliangItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL1));</span><br><span class="line">liliangItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroL2));</span><br><span class="line">minjieItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroM1));</span><br><span class="line">minjieItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroM2));</span><br><span class="line">zhiliItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroZ1));</span><br><span class="line">zhiliItem-&gt;<span class="built_in">addChild</span>(<span class="keyword">new</span> <span class="built_in">QTreeWidgetItem</span>(heroZ2));</span><br></pre></td></tr></table></figure><p>得到的效果图如下</p><p><img src="/.online//图床数据\Qt\8_4.png"></p><p>8.tableWidget窗口</p><ul><li>设置行数通过setRowCount()函数、设置列数通过setColumnCount()函数</li><li>设置水平的标题通过setHorizontalHeaderLabels()函数</li><li>设置表格某行某列的数据setItem(row, col, item)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置行数、列数</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setRowCount</span>(<span class="number">5</span>);</span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setColumnCount</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//设置标题</span></span><br><span class="line">ui-&gt;tableWidget-&gt;<span class="built_in">setHorizontalHeaderLabels</span>(<span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;英雄&quot;</span>&lt;&lt;<span class="string">&quot;性别&quot;</span>&lt;&lt;<span class="string">&quot;年龄&quot;</span>);</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">QStringList heroNames = <span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;亚瑟&quot;</span>&lt;&lt;<span class="string">&quot;妲己&quot;</span>&lt;&lt;<span class="string">&quot;安其拉&quot;</span>&lt;&lt;<span class="string">&quot;赵云&quot;</span>&lt;&lt;<span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line">QStringList herogenders = <span class="built_in">QStringList</span>()&lt;&lt;<span class="string">&quot;男&quot;</span>&lt;&lt;<span class="string">&quot;女&quot;</span>&lt;&lt;<span class="string">&quot;女&quot;</span>&lt;&lt;<span class="string">&quot;男&quot;</span>&lt;&lt;<span class="string">&quot;雄性&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>; row&lt;<span class="number">5</span>; row++)&#123;</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">0</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(heroNames[row]));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">1</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(herogenders[row]));</span><br><span class="line">    ui-&gt;tableWidget-&gt;<span class="built_in">setItem</span>(row,<span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">QTableWidgetItem</span>(QString::<span class="built_in">number</span>(row + <span class="number">18</span>)));     <span class="comment">//需要将整数转为string类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的效果图如下：</p><p><img src="/.online//图床数据\Qt\8_5.png" alt="8_5"></p><p>9.容器</p><p>stacked Widget 页面切换需要我们自己去实现，一般使用按钮点击的时候切换，通过setCurrentIndex()方式切换到第几页，序号从0开始</p><p>10、显示控件</p><ul><li><p>label可以显示静态图，通过pixmap属性即可完成</p></li><li><p>label也可以显示动态图gif，需要先创建movie对象，再通过setMovie()函数设置电影，最后通过start()函数来播放动画</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMovie *movie = new QMovie(&quot;:/Image/mario.gif&quot;, QByteArray(), this);</span><br><span class="line">ui-&gt;label_1-&gt;setMovie(movie);</span><br><span class="line">movie-&gt;start();</span><br></pre></td></tr></table></figure><p>11.自定义控件</p><p>当系统提供的控件不能满足我们生产中的一个功能时，就需要自己创建一些控件。</p><p>比如说一个自定义一个按钮控件，需要先创建一个自定义按钮类MyButton，让它继承QPushButton类，在MyButton类的析构函数中实现一些想要的功能，最后将主窗口中的按钮(QPushButton类)提升为MyButton类，这样就可以实现自定义按钮的一些功能了。</p><h1 id="8-事件"><a href="#8-事件" class="headerlink" title="8. 事件"></a>8. 事件</h1><p>事件(event)是由系统或者Qt应用程序本身在不同的时刻发出的。当用户按下鼠标、敲下键盘、或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p><p>在所有组件的父类QWidget中，定义了很多事件处理的函数，如：</p><ul><li>keyPressEvent()：键盘按键按下事件</li><li>keyReleaseEvent()：键盘按键松开事件</li><li>mouseDoubleClickEvent()：鼠标双击事件</li><li>mouseMoveEvent()：鼠标移动事件</li></ul><p>1.在下面程序中，先创建一个主窗口widget，将一个Label标签拖入其中，再创建一个自定义标签类MyLabel，使它继承QLabel类，然后在该类里面添加对应的事件功能函数，最后将主窗口的Label标签提升为自定义标签类MyLabel。</p><p>自定义标签类的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//重写鼠标按键处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">//重写鼠标移动的处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//重写event分发函数(事件的分发机制)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *e)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写事件过滤器eventFilter</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义标签对应的事件函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">MyLabel::<span class="built_in">MyLabel</span>(QWidget *parent) : <span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//默认情况下，窗口不会主动跟踪鼠标(鼠标进入窗口，先不会触发任何事件)</span></span><br><span class="line">    <span class="comment">//只有当某个鼠标按键按下的情况下才开始跟踪</span></span><br><span class="line">    <span class="comment">//如果想一开始跟踪，就要使用以下函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//事件过滤器的使用</span></span><br><span class="line">    <span class="comment">//1.窗口调用installEventFilter来安装一个事件过滤器</span></span><br><span class="line">    <span class="comment">//2.参数是一个事件过滤器对象QObject,该对象的类要重写eventFilter的函数</span></span><br><span class="line">    <span class="comment">//事件过滤的时候，事件会先到达事件过滤器的eventFilter函数</span></span><br><span class="line">    <span class="comment">//返回值：true表示拦截，false表示不拦截，不拦截情况下事件会继续到达窗口</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);       <span class="comment">//将当前窗口安装过滤器，对象可以使用自己作为自己的过滤器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标坐标</span></span><br><span class="line">    <span class="type">int</span> x = ev-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y = ev-&gt;<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标按键</span></span><br><span class="line">    Qt::MouseButton btn = ev-&gt;<span class="built_in">button</span>();       <span class="comment">//单个事件</span></span><br><span class="line">    QString strbutton = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::LeftButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;LeftButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::RightButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;RightButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btn == Qt::MidButton)&#123;</span><br><span class="line">        strbutton = <span class="string">&quot;MidButton&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;pres[%1,%2][%3]&quot;</span>).<span class="built_in">arg</span>(x).<span class="built_in">arg</span>(y).<span class="built_in">arg</span>(strbutton);            <span class="comment">//label也可以显示html</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取鼠标坐标</span></span><br><span class="line">    <span class="type">int</span> x = ev-&gt;<span class="built_in">x</span>();</span><br><span class="line">    <span class="type">int</span> y = ev-&gt;<span class="built_in">y</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标按键</span></span><br><span class="line">    Qt::MouseButtons btns = ev-&gt;<span class="built_in">buttons</span>();      <span class="comment">//多个事件</span></span><br><span class="line">    QString strbutton = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::LeftButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;LeftButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::RightButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;RightButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(btns &amp; Qt::MidButton)&#123;</span><br><span class="line">        strbutton += <span class="string">&quot;MidButton;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;move[%1,%2][%3]&quot;</span>).<span class="built_in">arg</span>(x).<span class="built_in">arg</span>(y).<span class="built_in">arg</span>(strbutton);            <span class="comment">//label也可以显示html</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLabel::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//返回值：true表示该事件得到处理，如果是false，表示没有被处理，事件会继续传递到父窗口</span></span><br><span class="line">    <span class="comment">//QEvent就是所有事件(event类)的父亲</span></span><br><span class="line">    <span class="comment">//判断event的类型</span></span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>() == QEvent::MouseMove)&#123;          <span class="comment">//如果是鼠标移动事件</span></span><br><span class="line">        <span class="comment">//如果注释掉下面这一行，将对鼠标移动事件起到屏蔽作用，因为当我们在主窗口移动鼠标的时候，该事件会先经过我们重写的分发函数，因为我们对该事件没有进行处理，直接就返回了，所以系统啥都不会做，如果是其它事件，因为这里我们没有处理其它事件的函数，所以会调用父类的分发函数去实现处理，一样会生效起作用。</span></span><br><span class="line">        <span class="comment">//this-&gt;mouseMoveEvent(static_cast&lt;QMouseEvent *&gt;(e));    //调用鼠标移动处理函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);      <span class="comment">//其它事件这里没有处理，所以就给父类的分发函数去处理其它事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装了该过滤器的窗口都会执行该函数，所以一个过滤器可能会有多个窗口使用，则参数1(watched)表示目前传过来的窗口对象，参2则是存储触发事件的一些信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLabel::eventFilter</span><span class="params">(QObject *watched, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">type</span>() == QEvent::MouseMove)&#123;</span><br><span class="line">        <span class="comment">//返回ture表示拦截该事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定时器事件timerEvent</p><p>闹钟就是定时器，闹钟响了就是定时器事件</p><p>在头文件中需要重写定时器事件：<code>void timerEvent(QTimerEvent* event);</code>里面实现的功能即为定时器时间到后执行的操作</p><p>在需要的位置通过startTimer来启动一个定时器，返回值就是定时器的id，参数是毫秒，每隔相应的时间就会触发一次定时器事件</p><p>通过函数killtimer()来杀死一个定时器，参数就是要杀死定时器的id</p><p>timerEvent定时器事件处理函数中可以通过event参数获取到当前事件是哪个定时器发出的，如：event-&gt;timerId()</p><p>3.系统封装好的定时器QTimer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">    timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);       <span class="comment">//创建定时器对象</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, [=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ui-&gt;lcdNumber-&gt;<span class="built_in">display</span>(num++);        <span class="comment">//主窗口的lcd插件显示对应的数字</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_start_clicked</span><span class="params">()</span>         <span class="comment">//start按钮触发的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">10</span>);                   <span class="comment">//启动定时器，10毫秒发出一次信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::on_end_clicked</span><span class="params">()</span>           <span class="comment">//end按钮触发的槽函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer-&gt;<span class="built_in">stop</span>();                      <span class="comment">//停止定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.绘图事件</p><ul><li><p>什么时候画</p><ul><li>绘图事件：窗口需要重新显示的时候(大小发生变化、窗口切换等)，就会收到一个绘图事件paintEvent，收到绘图事件之后，窗口就要将自己画出来。</li></ul></li><li><p>怎么画</p><ul><li>通过定义一个画家QPainter，给出一个画图设备QPaintDevice(窗口)作为参数。</li></ul></li></ul><p>5.创建了一个窗口Widget，在该窗口头文件重写了画图事件，下面为该画图事件函数里面的功能实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个画家，绘图设备为当前窗口</span></span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画家偏移，搬动画家到某个坐标上开始画画</span></span><br><span class="line">    painter.<span class="built_in">translate</span>(<span class="number">100</span>,<span class="number">0</span>);      <span class="comment">//现在默认窗口的(100,0)为画家的起点了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一支画笔</span></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.<span class="built_in">setColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>));     <span class="comment">//设置颜色</span></span><br><span class="line">    pen.<span class="built_in">setWidth</span>(<span class="number">3</span>);                   <span class="comment">//设置笔宽</span></span><br><span class="line">    pen.<span class="built_in">setStyle</span>(Qt::DashLine);        <span class="comment">//设置画笔的风格</span></span><br><span class="line">    <span class="comment">//画家设置画笔</span></span><br><span class="line">    painter.<span class="built_in">setPen</span>(pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个画刷(用来填充)</span></span><br><span class="line">    QBrush brush;</span><br><span class="line">    brush.<span class="built_in">setColor</span>(Qt::cyan);            <span class="comment">//填充的颜色</span></span><br><span class="line">    brush.<span class="built_in">setStyle</span>(Qt::Dense4Pattern);   <span class="comment">//默认情况下，画刷不会填充，还得设置风格</span></span><br><span class="line">    <span class="comment">//画家设置画刷</span></span><br><span class="line">    painter.<span class="built_in">setBrush</span>(brush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画一条线</span></span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);       <span class="comment">//起点为(0,0)，终点为(100,100)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">20</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">50</span>);       <span class="comment">//左上角点为(20,20)，长为50，宽为50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画圆形，使用椭圆(自己调整)</span></span><br><span class="line">    painter.<span class="built_in">drawEllipse</span>(<span class="built_in">QPoint</span>(<span class="number">100</span>,<span class="number">100</span>),<span class="number">50</span>,<span class="number">50</span>);     <span class="comment">//圆心，x轴半径，y轴半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画文字</span></span><br><span class="line">    painter.<span class="built_in">drawText</span>(<span class="number">200</span>, <span class="number">100</span>, <span class="string">&quot;好好学习，天天向上&quot;</span>);     <span class="comment">//文字坐标，文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.手动触发绘图事件</p><p>在一些应用场景，我们或许希望能手动的触发绘图事件，而不是等到窗口发生变化再触发绘图事件，所以就可以使用下面方法完成。</p><ul><li>可以使用两个函数<ul><li>repaint：会马上触发绘图事件，当某一处函数调用了多次repaint时，会触发多次绘图事件</li><li>update：update做了一些优化，当某一处函数调用了多次update时，只会触发一次绘图事件</li></ul></li></ul><p>注意：不要再绘图事件paintEvent()函数中再触发绘图事件，会导致无线循环</p><p>下面程序实现了将本地存在的图片绘制到窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//painter绘制已经存在到达图片</span></span><br><span class="line"><span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;C:\\Qt\\素材\\llfcchat-master\\llfcchat-master\\client\\llfcchat\\res\\head_5.jpg&quot;</span>)</span></span>;</span><br><span class="line">painter.<span class="built_in">drawPixmap</span>(<span class="number">0</span>,<span class="number">0</span>,pixmap);</span><br></pre></td></tr></table></figure><p>7.绘图设备</p><p>绘图设备是指继承QPainterDevice的子类，Qt一共提供了4个这样的类，分别是QPixmap、QBitmap、QImage和QPicture，其中：</p><ul><li>QPixmap专本为图像在屏幕上的显示做了优化</li><li>QBitmap是QPixmap的一个子类，它的色深限定为1，可以使用QPixmap的isQBitmap()函数来确定这个QPixmap是不是一个QBitmap。</li><li>QImage专门为图像的像素级访问做了优化</li><li>QPicture则可以记录和重现QPainter的各条命令。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是Qt&quot;&gt;&lt;a href=&quot;#1-1-什么是Qt&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Qt" scheme="https://lxx93.online/categories/Qt/"/>
    
    
    <category term="Qt" scheme="https://lxx93.online/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>c++并发编程(下)</title>
    <link href="https://lxx93.online/2024/08/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8B)/"/>
    <id>https://lxx93.online/2024/08/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</id>
    <published>2024-08-01T16:22:33.000Z</published>
    <updated>2024-08-06T15:40:28.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-引用计数实现无锁并发栈"><a href="#1-引用计数实现无锁并发栈" class="headerlink" title="1. 引用计数实现无锁并发栈"></a>1. 引用计数实现无锁并发栈</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>在C++并发编程中提出了两种计数，一种是外部计数，一种是内部计数，二者加起来就是有效的引用计数，下面提出一种新的方法，利用引用计数实现无锁并发的栈。</p><h2 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h2><p>栈结构函数：栈函数里面实现了栈的默认构造函数、析构函数和创建了一个原子类型的头部节点，同时也定义好了栈的内部节点类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single_ref_stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">single_ref_stack</span>():<span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;        <span class="comment">//默认构造函数</span></span><br><span class="line">    ~<span class="built_in">single_ref_stack</span>() &#123;                      <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">pop</span>());     <span class="comment">//循环出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;                      <span class="comment">//引用节点(栈的内部节点)</span></span><br><span class="line">        std::shared_ptr&lt;T&gt;  _data;         <span class="comment">//1 数据域智能指针</span></span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; _ref_count;       <span class="comment">//2 引用计数</span></span><br><span class="line">        ref_node* _next;                   <span class="comment">//3  下一个节点</span></span><br><span class="line">        <span class="comment">//构造函数，接收外部传来的数据，根据数据构造一个节点</span></span><br><span class="line">        <span class="built_in">ref_node</span>(T <span class="type">const</span>&amp; data_):_data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)), _ref_count(<span class="number">1</span>), _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//头部节点</span></span><br><span class="line">    std::atomic&lt;ref_node*&gt; head;           <span class="comment">//会被多个线程操作，设为原子类型的头部节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>push操作函数：这段程序就是解决两个线程同时push的情况，但同一时刻也只有一个线程会成功，那么另一个线程在while进行比较的时候，就会发现它的new_node的next与head不相等，那么它就会继续循环，而且将新的head值赋值给new_node的next，这样在没有其它线程抢先指向while的话，该线程就会更新head的值，将head指向了它的new_node，并退出循环，这样该线程就完成了节点的push。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;              <span class="comment">//参数是要push的T类型的数据</span></span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">ref_node</span>(data);      <span class="comment">//通过data创建出一个新的ref_node类型节点，并得到其指针</span></span><br><span class="line">    new_node-&gt;next = head.<span class="built_in">load</span>();            <span class="comment">//新节点的next要指向头部节点</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next, new_node));     <span class="comment">//通过重试的方式更新头部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作函数：在下面程序中，是通过引用计数为0或1来判断该节点是否可以直接delete。比如说当线程1进入2处的if，线程2这时候就只能进入7处else，如果线程1在4处，将引用计数-2后，发现还等于1，那么线程1是回收不了该节点的，此时如果线程2发现该节点的引用计数为1，则此时只有它在访问该节点，所以线程2就可以进行回收。但当线程1执行4处时，引用计数为0，说明只有它在访问，这样线程1就可以对该节点进行回收。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node* old_head = head.<span class="built_in">load</span>();             <span class="comment">//先取出头部元素</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!old_head) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();          <span class="comment">//如果为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 只要执行pop就对引用计数+1</span></span><br><span class="line">        ++(old_head-&gt;_ref_count);</span><br><span class="line">        <span class="comment">//2 比较head和old_head想等则交换，更新head,返回true；否则说明head已经被其他线程更新,返回false</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, old_head-&gt;_next)) &#123;</span><br><span class="line">            <span class="comment">//此时head已经为old_head的next了</span></span><br><span class="line">            <span class="keyword">auto</span> cur_count = old_head-&gt;_ref_count.<span class="built_in">load</span>();    <span class="comment">//取出原来头部节点的引用计数</span></span><br><span class="line">            <span class="keyword">auto</span> new_count;</span><br><span class="line">            <span class="comment">//3  循环重试保证引用计数安全更新</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//4 减去本线程增加的1次和初始的1次,如果为0，说明没有其它线程访问该节点</span></span><br><span class="line">                new_count = cur_count - <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!old_head-&gt;_ref_count.<span class="built_in">compare_exchange_weak</span>(cur_count,  new_count));</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;            <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(old_head-&gt;_data);    <span class="comment">//5 交换数据，取出要删除节点old_head的值，此时old_head的值为0了</span></span><br><span class="line">            <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count == <span class="number">0</span>) &#123;    <span class="comment">//继续判断，如果此时old_head的引用计数还为0，就delete掉</span></span><br><span class="line">                <span class="keyword">delete</span> old_head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//7 </span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> old_head;     <span class="comment">//如果判断引用计数等于1的，说明也只有它应该在使用该节点，也可以直接delete</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上pop操作函数的大体流程如下：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_7.png" style="zoom:67%;"><p>从流程上来看，该程序存在着很大的问题，在刚开没有pop前，所有节点的引用计数都为1；如果两个线程进入pop函数后，head的引用计数进行++，变为了3，此时线程1的old_head和线程2的old_head都指向head；当线程1先执行操作2时，它会更新head的指向，并且进入if程序里面，而线程2再来执行操作2时，因为此时的head被更改了，所以它会将它的old_head执行新的head，并执行else里面的程序，这时线程1将引用计数减2后为1，它就负责只将要删除的节点值返回，而没有delete掉要删除的节点(原头节点)，以为线程2会delete掉该节点，而线程2判断当前old_head指向的节点引用计数为1，它以为指向的是原节点，所以就会直接delete，但指向的是要删除节点的下一个节点，这样系统就会崩溃。</p><p>所以为了解决这些问题，可以将引用计数提出来，不放在指针里，和指针解耦。下面程序是将原来的节点结构拆成两个，并且新增<code>_dec_count</code>表示减少的引用计数，放在node结构里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt;  _data;          <span class="comment">//1 数据域智能指针</span></span><br><span class="line">    ref_node _next;                     <span class="comment">//2  下一个节点</span></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : _data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt;  _dec_count;       <span class="comment">//减少的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;</span><br><span class="line">    <span class="type">int</span> _ref_count;                <span class="comment">// 引用计数</span></span><br><span class="line">    node* _node_ptr;</span><br><span class="line">    <span class="built_in">ref_node</span>( T <span class="type">const</span> &amp; data_):_node_ptr(<span class="keyword">new</span> <span class="built_in">node</span>(data_)), _ref_count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ref_node</span>():_node_ptr(<span class="literal">nullptr</span>),_ref_count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//头部节点</span></span><br><span class="line">std::atomic&lt;ref_node&gt; head;            <span class="comment">//将栈中的head结构变为ref_node类型的原子变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ref_node new_head;               <span class="comment">//1 只要执行pop就对引用计数+1并更新到head中</span></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_head = old_head;</span><br><span class="line">            new_head._ref_count += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, new_head));</span><br><span class="line">        old_head = new_head;</span><br><span class="line">        <span class="keyword">auto</span>* node_ptr = old_head._node_ptr;       <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (node_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  std::<span class="built_in">shared_ptr</span>&lt;T&gt;();        <span class="comment">//为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 比较head和old_head相等则交换否则说明head已经被其他线程更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, node_ptr-&gt;_next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;             <span class="comment">//要返回的值</span></span><br><span class="line">            res.<span class="built_in">swap</span>(node_ptr-&gt;_data);          <span class="comment">//交换智能指针</span></span><br><span class="line">            <span class="type">int</span> increase_count = old_head._ref_count - <span class="number">2</span>;      <span class="comment">//5 增加的数量 </span></span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_add</span>(increase_count) == -increase_count) &#123;  <span class="comment">//6 </span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;    <span class="comment">//7</span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-内存模型回顾"><a href="#2-内存模型回顾" class="headerlink" title="2. 内存模型回顾"></a>2. 内存模型回顾</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>之前实现的那些无锁并发的栈结构，它们对于原子变量的读，写以及读改写操作默认采用的是<code>memory_order_seq_cst</code>，<code>memory_order_seq_cst</code>为全局顺序模型，即所有线程看到的执行顺序是一致的。这种模型对性能消耗较大，所以可以在无锁栈的基础上通过更为宽松的模型提升性能。</p><h2 id="2-2-release-acquire同步"><a href="#2-2-release-acquire同步" class="headerlink" title="2.2 release-acquire同步"></a>2.2 release-acquire同步</h2><p>在之前了解的6中内存顺序，其中可以通过<code>release</code>和<code>acquire</code>的方式实现同步的效果。也就是说，线程A执行store操作，采用<code>memory_order_release</code>顺序模型，线程B执行load操作采用<code>memory_order_acquire</code>顺序模型。如果线程B的load操作读取到线程A的store操作的数值，就可以称线程A的store操作 synchronizes-with(同步) 线程B的load操作。</p><h2 id="2-3-happens-before先行"><a href="#2-3-happens-before先行" class="headerlink" title="2.3 happens-before先行"></a>2.3 happens-before先行</h2><p>如果 a-&gt;store 同步于 b-&gt;load， 则 a-&gt;store 先行于 b-&gt;load。只要同步就能推出先行，所谓先行就是逻辑执行的顺序，一定是a-&gt;store 先于 b-&gt;load。先行还包括一种情况，sequenced-before(顺序执行)， 所谓顺序执行就是单线程中执行的顺序为从上到下的顺序。</p><p>先行具有传递性 操作1 <code>happens-before</code> 操作2，操作2 <code>happens-before</code> 操作3，则操作1 <code>happens-before</code> 操作3</p><p>在下面程序中， 操作2处使用了release内存序，保证操作1会排在操作2之前。 操作3采用了acquire内存序，保证操作4排在操作3之后，且如果操作3能读到操作2的写入值，则保证操作1已经先于操作3执行完。因为while重试的机制，保证操作2同步于操作3，即操作2先于操作3执行，又因为操作1先于操作2执行，而操作3先于操作4执行，所以得出操作1先于操作4执行，那么操作4处断言正确就不会崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>;                                           <span class="comment">//1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release);            <span class="comment">//2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.load(std::memory_order_acquire));       <span class="comment">//3 </span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>);                                  <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-释放序列的扩展"><a href="#2-4-释放序列的扩展" class="headerlink" title="2.4 释放序列的扩展"></a>2.4 释放序列的扩展</h2><blockquote><p>如果存储操作的标记是memory_order_release、memory_order_acq_rel或memory_order_seq_cst，而载入操作则以memory_order_consume、memory_order_acquire或memory_order_seq_cst标记，这些操作前后相扣成链，每次载入的值都源自前面的存储操作，那么该操作链由一个<strong>释放序列</strong>组成。若最后的载入操作服从内存次序memory_order_acquire或memory_order_seq_cst，则最初的存储操作与它构成同步关系。但如果该载入操作服从的内存次序是memory_order_consume，那么两者构成前序依赖关系。操作链中，每个“读-改-写”操作都可选用任意内存次序，甚至也能选用memory_order_relaxed次序。</p></blockquote><p>release-sequnece：针对一个原子变量M的release操作A完成后, 接下来M上可能还会有一连串的其他操作。如果这一连串操作是由</p><ol><li>同一线程上的写操作</li><li>或者任意线程上的 read-modify-write(可以是任意内存顺序) 操作</li></ol><p>这两种构成的，则称这一连串的操作为以release操作A为首的release sequence。这里的写操作和read-modify-write操作可以使用任意内存顺序。</p><p>同步：一个acquire操作在同一个原子变量上读到了一个release操作写入的值，或者读到了以这个release操作为首的release sequence写入的值，那么这个release操作 “synchronizes-with” 这个 acquire 操作。所以release-sequence不一定构成同步，只有acquire到release的值才算作同步。</p><p>下面程序中，在入队函数的操作1处使用的是<code>memory_order_release</code>内存序来记录入队的数量，这样一方面保证了它之前的代码都执行完了，另一方在出队函数的操作3处有<code>memory_order_acquire</code>的载入操作，这样它们就构成了同步关系。<code>fetch_sub</code>是一个原子操作函数，用于从原子变量 <code>count</code> 的当前值中减去指定的值，即1，并返回操作前的原始值。所以就可以通过该函数来完成队列数据的读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; queue_data;                <span class="comment">//存储数据的队列</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;                     <span class="comment">//记录入队的数量</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; store_finish = <span class="literal">false</span>;     <span class="comment">//表示是否存储完成</span></span><br><span class="line"><span class="comment">//入队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> number_of_items = <span class="number">20</span>;</span><br><span class="line">    queue_data.<span class="built_in">clear</span>();                     <span class="comment">//队列清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_items; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        queue_data.<span class="built_in">push_back</span>(i);       <span class="comment">//从0到20，往队列放入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 最初的存储操作</span></span><br><span class="line">    count.<span class="built_in">store</span>(number_of_items, std::memory_order_release); <span class="comment">//记录入队数量，内存序用的是memory_order_release</span></span><br><span class="line">    store_finish.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);   <span class="comment">//将store_finish置未true，不太关注时效性和同步性，所以就用宽松的内存序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2 循环等待存储完成，使用的是宽松的内存序</span></span><br><span class="line">        <span class="keyword">while</span> (!store_finish.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">        <span class="type">int</span> item_index;</span><br><span class="line">        <span class="comment">//3 读—改—写”操作</span></span><br><span class="line">        <span class="keyword">if</span> ((item_index = count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acquire)) &lt;= <span class="number">0</span>)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">//当count为0的时候，会执行到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 从内部容器queue_data 读取数据项是安全行为</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;queue_data is  &quot;</span> &lt;&lt; queue_data[item_index<span class="number">-1</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_8.png" style="zoom:67%;"><p>从打印结果可以看到消费者线程b和c并没有打印重复的数据，说明他们互斥访问count，每个线程取到的count不一样进而访问queue_data中的不同数据。</p><p>如果单从线程角度考虑，b和c并不能构成同步，但是线程b和c必然有一个线程会先执行执行fetch_sub(原子变量的操作任何顺序模型都能保证操作的原子性)。假设b先执行，和a构成release-sequence关系，b读取到a执行的count.store的结果， b处于以a线程的release为首的释放序列中，则b的store操作会和c的读-改-写(fetch操作，只限这一段代码)构成同步。</p><p>如下图所示：实线表示先行关系，虚线标识释放序列</p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_9.jpg" style="zoom:67%;"><p>结论如下：</p><ol><li>a线程和b线程构成release-sequence的释放序列。</li><li>即使b线程和c线程不构成同步，但是b线程的读改写操作处于release-sequence中，且c线程采用acquire方式读改写，则b的读改写和c线程的读改写构成同步，以a线程的release为首的sequence序列和c线程的读改写构成同步。</li><li>这里要强调一点，如果a release-sequence b，a和b不一定构成同步，但是b sychronizes with c，则a synchronizes with c。也就是说处于release序列中的任意读改写操作和其他的线程构成同步，那么我们就能得出release-sequence为首的操作和其他线程同步。</li></ol><h1 id="3-优化无锁栈"><a href="#3-优化无锁栈" class="headerlink" title="3. 优化无锁栈"></a>3. 优化无锁栈</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>对于想要更好的优化无锁栈，可以结合释放序列这一技术来完成。当有数据入栈时，那么pop时要读取最新入栈的数据。所以我们要让push操作同步给pop操作，想到的办法很简单，push对head的修改采用release内存序列，pop对head的读改写采用acquire内存序列。多个线程并发pop，执行读改写操作，这些线程本来是无法同步的，但是最先pop的线程会和push线程构成同步关系，且形成release-sequence。那之后的线程pop就会和第一个pop的线程的写操作形成同步。</p><p>如果没有元素入栈，这时多个线程pop也不会产生问题，可以根据head内部的ptr指向为空判断空栈直接返回空指针。</p><p>总的来说，就是以下两方面含义：</p><ol><li>因为要保证pop操作时节点的数据是有效的。push和pop要构成同步关系，即push采用release内存序修改head；pop采用acquire内存序修改head</li><li>第一个pop的线程的写操作和之后的pop线程读操作要构成同步关系</li></ol><h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><p>push操作函数：该函数就是创建一个新节点，将新节点的next指向head，最后操作1处执行比较交换操作，当head等于新节点的next时，使用的是release内存序，并返回true；当head不等于新节点的next时(head被其它线程更新)，使用的是relaxed内存序(因为要重试，所以什么内存序都可以)，并返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_node;               <span class="comment">//定义一个新的节点指针</span></span><br><span class="line">    new_node.ptr = <span class="keyword">new</span> <span class="built_in">count_node</span>(data);     <span class="comment">//通过yao创建的data数据，来构造一个节点</span></span><br><span class="line">    new_node.external_count = <span class="number">1</span>;             <span class="comment">//将该节点的引用计数置1</span></span><br><span class="line">    new_node.ptr-&gt;next = head.<span class="built_in">load</span>();        <span class="comment">//另新节点的next指向head</span></span><br><span class="line">    <span class="comment">//1 比较交换操作</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node.ptr-&gt;next, new_node, memory_order::memory_order_release, memory_order::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop操作函数：在<code>increase_head_count</code>函数中，操作7的比较交换成功时，使用的是acquire的内存序，这样也是为了与push操作函数中操作1处的比较交换的release内存序构成同步关系。如果考虑两个线程并发执行，有两种情况发生：</p><ol><li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程2先执行完操作5，则内部引用计数就为-1(线程2因为不满足条件，不能进入释放ptr，留给线程1释放ptf)，这时操作2就不会再用ptr了，线程1的操作4就可以进入if释放ptr了。</li><li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程1先执行操作4，那么它会将内部引用计数变为1，并且返回0，不满足条件就不能释放ptr，就退出了。线程2这时执行操作5就能满足条件，从而释放ptr。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();     <span class="comment">//取出head</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);             <span class="comment">//增加引用计数</span></span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;      <span class="comment">//获取old_head的指向</span></span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();           <span class="comment">//如果为空，返回空指针即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始头部更新，如果线程1的old_head与head相等，说明还没有其它线程抢占到head，线程1就负责回收数据和将外部引用计数转为内部引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;              <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);                 <span class="comment">//交换数据</span></span><br><span class="line">            <span class="comment">//3 因为外部引用计数初始化为1，该进行进来时又+1，所以减2，可以统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase) == -count_increase) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;       <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//如果old_head与head不相等，有两种情况：其它线程把head更新了；还有就是该线程先将head引用计数++，后面又被其它线程将head引用计数++了，因为该线程的old_head是局部变量的一个缓存，所以head引用计数更新了，old_head还是旧数据</span></span><br><span class="line">            <span class="comment">//该线程负责减少内部引用计数(该进程进pop的时候，加的是外部引用计数)，最后是判断，外部的引用计数和内部引用计数相加为0，就做回收操作</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;    <span class="comment">//当前线程减少内部引用计数，返回之前值为1说明指针仅被当前线程引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加头部节点引用数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr&amp; old_counter)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_counter;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        new_counter = old_counter;</span><br><span class="line">        ++new_counter.external_count;</span><br><span class="line">    &#125;<span class="comment">//7 循环判断保证head和old_counter相等时做更新,多线程情况保证引用计数原子递增。</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(old_counter,  new_counter, std::memory_order_acquire, std::memory_order_relaxed));</span><br><span class="line">    <span class="comment">//8 走到此处说明head的external_count已经被更新了</span></span><br><span class="line">    old_counter.external_count = new_counter.external_count; <span class="comment">//因为old_counter是引用传进来的，所以external_count更新了想要传给它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于一个原子变量M，其释放序列中的读改写操作无论采用何种模型都能读取M的最新值(原子变量来保证的)。</li><li>为了保证原子变量上下程序的操作能和其它线程同步，可以利用内存顺序模型用来保证数据在多个线程的可见顺序。</li></ul><h2 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h2><p>虽然以上程序优化了无锁栈，但还需要保证ptr的data在被删除之前swap到res里。</p><p>改进后的pop函数：在下面程序中，线程1如果是进入了操作4处执行delete，那么是需要保证swap操作先于fetch_add之后的delete操作，所以fetch_add可以采用release模型；而对于线程2执行操作5，内部delete操作之前，也需要保证其它线程执行的swap操作完成，所以操作5处的fetch_sub要采用acquire内存序，这样它就和操作4构成同步关系，即操作4先于操作5，而操作4完成之前可以保证它上面的程序执行完，所以swap就可以先于操作5了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);</span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;</span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 本线程如果抢先完成head的更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next,  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">//返回头部数据</span></span><br><span class="line">            std::shared_ptr&lt;T&gt; res;</span><br><span class="line">            <span class="comment">//交换数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);</span><br><span class="line">            <span class="comment">//3 减少外部引用计数，先统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase, std::memory_order_release) == -count_increase) &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(<span class="number">-1</span>, std::memory_order_acquire) == <span class="number">1</span>) &#123; <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//ptr-&gt;internal_count.load(std::memory_order_acquire);</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;     <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，操作5处使用内存序relaxed也可以的，只要保证swap操作相较于delete先执行完即可，所以在操作6的delete上面添加内部引用计数的acquire内存序加载，即可和前面的释放序列构成同步关系。</p><h1 id="4-双引用实现无锁队列"><a href="#4-双引用实现无锁队列" class="headerlink" title="4. 双引用实现无锁队列"></a>4. 双引用实现无锁队列</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>队列和栈容器它们的结构是不同的，对于队列结构，push()和pop()分别访问其不同部分，而在栈容器上，这两项操作都访问头节点，所以两种数据结构所需的同步操作相异。如果某线程在队列一端做出改动，而另一线程同时访问队列另一端，程序就要保证前者的改动过程能正确地为后者所见。</p><h2 id="4-2-单线程队列"><a href="#4-2-单线程队列" class="headerlink" title="4.2 单线程队列"></a>4.2 单线程队列</h2><p>下面程序是一个单线程情况下实现的队列操作，在单线程情况下是不会出现问题的，但在多线程情况下，push和pop都会出现问题。</p><p>对于push操作，当两个线程都执行push，如果线程1在操作3先创建了新节点p1，然后数据交换，并让尾指针指向了p1，正准备执行操作7，更新尾指针位置，这时时间片被线程2抢到了，线程2就会覆盖线程1执行的操作，令尾指针指next向p2，并执行了操作7，移动尾指针，让尾指针指向了p2，这时线程1在执行操作7，就令尾指针指向p1。这样就导致数据混乱了，即队列中最后连接的是p2，但尾指针指向p1去了。</p><p>对于pop操作，当两个线程都执行pop时，当线程1通过old_head取出头节点时，正准备执行操作1，这时轮到线程2执行了，线程2也通过old_head取出头节点后，并且先执行了操作1，将head头指针更新为了原头节点的next，这时线程1有执行操作1，由于它的old_head是原头节点，所以它执行完操作7，还是将head头指针更新为原头节点的next。这样就导致，两个进行调用pop，结果head头指针只移动一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePopPush</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>            <span class="comment">//节点的结构类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;     <span class="comment">//节点的数据域</span></span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::atomic&lt;node*&gt; head;            <span class="comment">//头指针</span></span><br><span class="line">    std::atomic&lt;node*&gt; tail;            <span class="comment">//尾指针</span></span><br><span class="line">    <span class="comment">//弹出头部节点</span></span><br><span class="line">    <span class="function">node* <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>();       <span class="comment">//接收头指针</span></span><br><span class="line">        <span class="keyword">if</span> (old_head == tail.<span class="built_in">load</span>())              <span class="comment">//如果头指针和尾指针相等，则是空的，直接返回空指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 没有空，就直接更新头指针，指向删除节点的next</span></span><br><span class="line">        head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;          <span class="comment">//返回要删除的节点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglePopPush</span>():<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">load</span>())&#123;&#125;       <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">SinglePopPush</span>(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePopPush&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SinglePopPush</span>()&#123;</span><br><span class="line">        <span class="keyword">while</span> (node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//循环取出头指针，为空就返回，不为空就delete掉</span></span><br><span class="line">            head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">            <span class="keyword">delete</span> old_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>                <span class="comment">//出队函数(消费者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* old_head = <span class="built_in">pop_head</span>();        <span class="comment">//先取出要删除的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (!old_head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();         <span class="comment">//为空，就返回头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，就取出要删除节点的数据值</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(old_head-&gt;data)</span></span>;</span><br><span class="line">        <span class="keyword">delete</span> old_head;           <span class="comment">//delete要删除的头节点</span></span><br><span class="line">        <span class="keyword">return</span> res;                <span class="comment">//返回数据值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>                 <span class="comment">//入队函数(生产者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(std::make_shared&lt;T&gt;(new_value))</span></span>;     <span class="comment">//先构造好数据</span></span><br><span class="line">        node* p = <span class="keyword">new</span> node;             <span class="comment">//3 创建一个新节点</span></span><br><span class="line">        node* <span class="type">const</span> old_tail = tail.<span class="built_in">load</span>();       <span class="comment">//4 获取尾节点指针</span></span><br><span class="line">        old_tail-&gt;data.<span class="built_in">swap</span>(new_data);      <span class="comment">//5 数据交换(old_tail-&gt;data原来是没有数据的空指针)</span></span><br><span class="line">        old_tail-&gt;next = p;           <span class="comment">//6 令尾节点的next指向p</span></span><br><span class="line">        tail.<span class="built_in">store</span>(p);                <span class="comment">//7 更新尾指针，令尾指针存储新节点p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-3-多线程push"><a href="#4-3-多线程push" class="headerlink" title="4.3 多线程push"></a>4.3 多线程push</h2><p>为了解决多线程push的竞争问题，可以采用以下程序来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> T(new_value))</span></span>;   <span class="comment">//先创建处要push的数据</span></span><br><span class="line">    counted_node_ptr new_next;           <span class="comment">//定义一个可计数的节点指针，有两个参数</span></span><br><span class="line">    new_next.ptr=<span class="keyword">new</span> node;               <span class="comment">//ptr指向新建的一个节点</span></span><br><span class="line">    new_next.external_count=<span class="number">1</span>;           <span class="comment">//外部引用计数为1</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        node* <span class="type">const</span> old_tail=tail.<span class="built_in">load</span>();        <span class="comment">//1 将尾部节点加载出来(它的data和next开始都是空的)</span></span><br><span class="line">        T* old_data=<span class="literal">nullptr</span>;                     <span class="comment">//定义并初始化T类型的old_data为空</span></span><br><span class="line">        <span class="comment">//2 尾节点的data如果还是空的，就更新尾节点的data为new_data的数据data，并返回true</span></span><br><span class="line">        <span class="keyword">if</span>(old_tail-&gt;data.<span class="built_in">compare_exchange_strong</span>(old_data, new_data.<span class="built_in">get</span>()))   </span><br><span class="line">        &#123;</span><br><span class="line">            old_tail-&gt;next=new_next;         <span class="comment">//将尾节点的next指向一个空的可计数的节点</span></span><br><span class="line">            tail.<span class="built_in">store</span>(new_next.ptr);        <span class="comment">//3 更新尾指针为最后连接的一个节点</span></span><br><span class="line">            new_data.<span class="built_in">release</span>();          <span class="comment">//解绑new_data的裸指针，因为该指针已经交给old_tail的data管理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是将data指针原子化，通过比较-交换操作来设置它的值。如果比较-交换操作成功，所操作的节点即为真正的尾节点，我们便可安全地设定next指针，使之指向新节点。若比较-交换操作失败，就表明有另一线程同时存入了数据，我们应该进行循环，重新读取tail指针并从头开始操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-引用计数实现无锁并发栈&quot;&gt;&lt;a href=&quot;#1-引用计数实现无锁并发栈&quot; class=&quot;headerlink&quot; title=&quot;1. 引用计数实现无锁并发栈&quot;&gt;&lt;/a&gt;1. 引用计数实现无锁并发栈&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    <category term="并发编程" scheme="https://lxx93.online/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++并发编程(中)</title>
    <link href="https://lxx93.online/2024/07/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%AD)/"/>
    <id>https://lxx93.online/2024/07/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%AD)/</id>
    <published>2024-07-28T02:46:20.000Z</published>
    <updated>2024-11-17T03:21:44.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-内存顺序和内存模型使用实现"><a href="#1-内存顺序和内存模型使用实现" class="headerlink" title="1. 内存顺序和内存模型使用实现"></a>1. 内存顺序和内存模型使用实现</h1><h2 id="1-1-sequencial-consistent模型-最严格的"><a href="#1-1-sequencial-consistent模型-最严格的" class="headerlink" title="1.1 sequencial consistent模型(最严格的)"></a>1.1 sequencial consistent模型(最严格的)</h2><p><code>memory_order_seq_cst</code>代表全局一致性顺序，可以用于 <code>store</code>、 <code>load</code> 和 <code>read-modify-write</code> 操作实现 <code>sequencial consistent</code>的顺序模型。在这个模型下, 所有线程看到的所有操作都有一个一致的顺序，即使这些操作可能针对不同的变量，运行在不同的线程。</p><p>在下面程序中，线程1修改完x和y的值，线程2立刻就能见到x和y修改的值，所以当线程2读到y为true时就会退出循环，然后读到的x也一定为true。因为需要保证与线程1修改顺序是一致的，线程1修改了x再修改y，当线程1修改完y的时候，x早就被修改为true了，所以当线程2读到了y为true时，接下来读到的x也一定为true。这样的话，z就是从0变为1，就不会发生断言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;       <span class="comment">//定义两个bool类型的原子变量</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;           <span class="comment">//定义一个int类型的原子变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先写x再写y，采用的顺序是全局一次性顺序</span></span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);       <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);       <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先读y再读x，采用的顺序也是全局一次性顺序，</span></span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;       <span class="comment">// 3.当y得到的是true时，就退出循环</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;      <span class="comment">//4.如果x为true的情况，就++z</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);                <span class="comment">// 5.当z还为0的时候，就会触发断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>sequencial consistent</code>模型有一定的开销，现代 CPU 通常有多核，每个核心还有自己的缓存。为了做到全局顺序一致，每次写入操作都必须同步给其他核心(也就是一个核心写的时候，其它核心读都不能读，必须等该核心写完后同步到memory中，其它核心才能读)。为了减少性能开销，如果不需要全局顺序一致，我们应该考虑使用更加宽松的顺序模型，比如<code>Acquire-release</code>和<code>Relaxed</code>模型。</p><h2 id="1-2-relaxed模型-最宽松的"><a href="#1-2-relaxed模型-最宽松的" class="headerlink" title="1.2 relaxed模型(最宽松的)"></a>1.2 relaxed模型(最宽松的)</h2><p><code>memory_order_relaxed</code>可以用于<code>store</code>、<code>load</code>和<code>read-modify-write</code>操作, 实现<code>relaxed</code>的顺序模型。在这种模型下只能保证操作的原子性和修改顺序(modification order)一致性(但改完了不一定立刻能见到)，无法实现<code>synchronizes-with</code>的关系。</p><p>在下面程序中，是存在隐患的，即可能会发生断言，但因为现在c++尽可能的帮外面规避了这些问题，所以执行结果很难会出现断言崩溃，但还是尽量不这样编写程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_relaxed));   <span class="comment">//3.当ry被修改为true时，会执行循环里面的语句</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed));    <span class="comment">//4.虽然ry被修改为true，但rx因为某些原因还是可能为false</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Acquire-Release模型-最常用的"><a href="#1-3-Acquire-Release模型-最常用的" class="headerlink" title="1.3 Acquire-Release模型(最常用的)"></a>1.3 Acquire-Release模型(最常用的)</h2><p>在 <code>acquire-release</code>模型中, 会使用<code>memory_order_acquire</code>、<code>memory_order_release</code>和<code>memory_order_acq_rel</code>这三种内存顺序。它们的具体用法：</p><ul><li><p>对原子变量的 load 可以使用 memory_order_acquire 内存顺序，这称为 acquire 操作</p></li><li><p>对原子变量的 store 可以使用 memory_order_release 内存顺序，这称为 release 操作</p></li><li><p>read-modify-write 操作即读(load)又写(store)，它可以使用memory_order_acquire, memory_order_release 和 memory_order_acq_rel：</p><ul><li>如果使用 memory_order_acquire，则作为 acquire 操作</li><li>如果使用 memory_order_release，则作为 release 操作</li><li>如果使用 memory_order_acq_rel，则同时为两者</li></ul></li></ul><p><code>Acquire-release</code>可以实现<code>synchronizes-with</code>的关系。如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值，则这个 release 操作 “synchronizes-with” 这个 acquire 操作。</p><p>在下面的程序中，对rx进行story和load使用的都是宽松的内存顺序，但对ry采用的是同步的内存顺序。如果线程2先运行，由于ry还是false，所以会一直执行循环，直到ry为true。当ry为true时，3处会退出循环，执行4处，由于线程1中ry都已经修改，所以rx也被修改，则4处的断言就不会发生。由于release在acquire之前，就构成了同步关系，2同步给了3，即2在3之前执行。</p><p>从cpu指令角度理解，如果编译器发现了一个store操作，且是release内存顺序，也发现了之前操作也是store，不管该store操作是什么内存顺序，编译器都会先把该store写入内存，再把该release的store写入内存。所以当线程2中把ry读到为true时，rx也一定被修改为了true，这样就不会发生断言的情况了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed);      <span class="comment">// 1.写，对rx进行releaxed操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release);      <span class="comment">// 2.写，对ry进行release操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire));     <span class="comment">//3读，进行的是acquire操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed));      <span class="comment">//4读，进行的是relaxed操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Acquire-release</code>的开销比<code>sequencial consistent</code>小。在 x86 架构下，<code>memory_order_acquire</code>和<code>memory_order_release</code>的操作不会产生任何其他的指令(它们两个操作的中间是原子化的)，只会影响编译器的优化。<strong>任何指令都不能重排到acquire操作的前面，且不能重排到release操作的后面</strong>。否则会违反 acquire-release 的语义。因此很多需要实现<code>synchronizes-with</code>关系的场景都会使用 <code>acquire-releas</code>。</p><p>还有一种情况，多个线程对同一个变量release操作，另一个线程对这个变量acquire，那么只有一个线程的release操作和这个acquire线程构成同步关系。在下面程序中，线程1对xd和yd都做了存储操作，线程2只对yd进行存储操作，而在线程3中，断言语句是可能被触发的，因为操作2和操作4是构成同步关系的，操作3和操作4也是构成同步关系的，这种情况下，只有一个会与操作4构成同步关系。如果是操作3和操作4构成同步关系，断言就会触发；如果是操作2和操作4构成同步关系，断言就不会触发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleasAcquireDanger2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; xd&#123;<span class="number">0</span>&#125;, yd&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; zd;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        xd.store(<span class="number">1</span>, std::memory_order_release);  <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//  (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">2</span>, std::memory_order_release);  <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!yd.load(std::memory_order_acquire)); <span class="comment">//（4）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(xd.load(std::memory_order_acquire) == <span class="number">1</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-release-sequence"><a href="#1-4-release-sequence" class="headerlink" title="1.4 release sequence"></a>1.4 release sequence</h2><p>针对一个原子变量M的<code>release</code>操作A完成后，接下来M上可能还会有一连串的其他操作。如果这一连串操作是由同一线程上的写操作或任意线程上的<code>read-modify-write</code>操作这两种构成的，则称这一连串的操称为以<code>release</code>操作A为首的<code>release sequence</code>。 这里的写操作和<code>read-modify-write</code>操作可以使用任意内存顺序。</p><p>如果一个<code>acquire</code>操作在同一个原子变量上读到了一个<code>release</code>操作写入的值，或者读到了以这个<code>release</code>操作为首的<code>release sequence</code>写入的值，那么这个release操作 “synchronizes-with” 这个acquire操作。</p><p>在下面程序中，可以知道操作2和操作3构成release sequence，而操作4也需要读到这个操作的最后一个结果(flag为2)，则操作2和操作4构成同步关系。有因为操作1在操作2之前，操作5在操作4之后，所以最后不会触发断言问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data.push_back(<span class="number">42</span>);  <span class="comment">//(1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//(2)对flag进行修改为1，以下是以操作2为首的release sequence</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//对flasg进行读改写，如果flag不等于expected,就返回false,循环一直执行；相等的时候，就会把flag改为2，并返回true，退出循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">            expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)当flag等于2时，循环会退出</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data.at(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)判断断言</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-memory-order-consume"><a href="#1-5-memory-order-consume" class="headerlink" title="1.5 memory_order_consume"></a>1.5 memory_order_consume</h2><p><code>memory_order_consume</code> 其实是 <code>acquire-release</code> 模型的一部分，但是它比较特殊，它涉及到数据间相互依赖的关系，也可以理解为是同步关系。</p><p><code>memory_order_consume</code>可以用于 load 操作，使用 memory_order_consume 的 load 称为 consume 操作。如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值，或以其为首的 release sequence 写入的值，则这个 release 操作 “dependency-ordered before” 这个 consume 操作。</p><p>在下面程序中，操作3和操作4构成了依赖关系，也就是操作3在操作4之前执行的，也可以理解为同步关系。因为操作1发生在操作3之前，操作5发生在操作6之后，所以操作5不会发生断言问题；而memory_order_consumer要考虑依赖关系，data并不依赖p，所以data可能不等于42，所以操作6可能触发断言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumeDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p = <span class="keyword">new</span> std::string(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>;                                          <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ptr.store(p, std::memory_order_release);            <span class="comment">// (3)把p的值写入ptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p2;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!(p2 = ptr.load(std::memory_order_consume))); <span class="comment">// (4)对ptr进行读取，空就执行循环，不空就退出循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(*p2 == <span class="string">&quot;Hello World&quot;</span>);                        <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>);                                  <span class="comment">// (6)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-内存模式实现单例模式"><a href="#1-6-内存模式实现单例模式" class="headerlink" title="1.6 内存模式实现单例模式"></a>1.6 内存模式实现单例模式</h2><p>之前用智能指针双重检测方式实现的单例模式是存在线程安全问题的，但可以通过内存模式来实现单例模式，这样可以解决改弊端。在底层，new一个对象再赋值给变量时会存在多个指令顺序。</p><p>第一种情况：</p><ol><li>为对象allocate一块内存空间</li><li>调用construct构造对象</li><li>将构造到的对象地址返回</li></ol><p>第二种情况：</p><ol><li>为对象allocate一块内存空间</li><li>先将开辟的空间地址返回</li><li>调用construct构造对象</li></ol><p>如果是第二种情况，当还未构造对象就将地址返回赋值给single，而此时有线程运行至1处判断single不为空直接返回单例实例，如果该线程调用这个单例的成员函数就会崩溃(结合代码看)。</p><p>下面就分别是通过智能指针和内存模型的方法实现单例模式：</p><div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">智能指针方法</button><button type="button" class="tab " data-href="test4-2">内存模式方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>在下面这个程序，在4处虽然allocate开辟了一块空间，并返回给single(不为空了)，但还没有调用construct，如果其它线程此时在1处用了single，因为不为空，就直接返回了single，并且调用了成员函数，就会出现系统崩溃。所以，实际上，1处和4处是会出现线程安全的，即4处还没有完全结束，就会返回一个还没有构造好的对象把地址返回了，而其它线程判断不为空，就会使用这个没有构造好的对象，就会产生崩溃。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 3处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> SingleAuto);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>在下面程序中，因为锁的权力是最大的，它能保证所有看到的线程是一致的，所以3处有宽松的模型没有问题的。最后，因为是在4处的代码完全执行后，_b_init才会被设置为true，其它线程才能通过1处进入函数执行(对1处有加锁)。而智能指针的方式就是因为没有这种方法对1处加锁，所以其它线程随时都可以判断single是否为空，这样4处还没有完全执行完时，其它线程就可能判断single不为空，而直接返回使用没有完全构造好的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMemoryModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleMemoryModel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1处 在这里，只有读到_b_init为true,才会返回single使用</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//如果为true，说明之前初始化过，直接返回使用即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();    <span class="comment">//如果多个线程经过1都为false，在这里就只有一个线程会加锁，加锁成功就执行下面</span></span><br><span class="line">        <span class="comment">// 3处 由于锁的保护(锁要求全局看到的都是一致的)，在其它线程将_b_init设为true后，另外一个线程在这里不管用什么内存序，读到的都是true</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_relaxed))    <span class="comment">//进来的线程判断，如果变为true了，就解锁返回，直接使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleMemoryModel&gt;(<span class="keyword">new</span> SingleMemoryModel);</span><br><span class="line">        _b_init.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);    <span class="comment">//这里是只有在4处执行完后，才将_b_init设为true</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; _b_init ;         <span class="comment">//定义一个原子类型的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleMemoryModel&gt; SingleMemoryModel::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleMemoryModel::s_mutex;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; SingleMemoryModel::_b_init = <span class="literal">false</span>;       <span class="comment">//将改变量初始化为false，没有还没有实例化指针</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h1 id="2-无锁队列实现"><a href="#2-无锁队列实现" class="headerlink" title="2. 无锁队列实现"></a>2. 无锁队列实现</h1><p>下面主要是通过无锁队列的方式来实现无锁并发。</p><h2 id="2-1-无锁队列"><a href="#2-1-无锁队列" class="headerlink" title="2.1 无锁队列"></a>2.1 无锁队列</h2><p>要实现无锁并发，经常会用到一种结构无锁队列，而无锁队列和在数据结构经常使用的队列颇有不同，它采用的是环状的队列结构，至于为什么成环？主要有两个好处，一个是成环的队列大小是固定的，另外一个我们通过移动头和尾就能实现数据的插入和取出。</p><h2 id="2-2-用锁实现环形队列"><a href="#2-2-用锁实现环形队列" class="headerlink" title="2.2 用锁实现环形队列"></a>2.2 用锁实现环形队列</h2><p>下面就是用锁实现环形队列，在push和pop时分别加锁，并通过head和tail计算队列是否为满或者空。最后通过测试代码，在添加完5个元素后，已经满了，再添加，是添加不进去的；弹出完5个元素后，再弹出，也是弹不出来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="comment">//继承自 std::allocator&lt;T&gt;，这意味着可以管理内存分配和释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLk</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;   <span class="comment">//定义一个模板类 CircularQueLk，接受类型参数T和大小参数Cap</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化最大大小、使用分配器的allocate函数分配队列的内存、将头指针和尾指针设置为0。</span></span><br><span class="line">    <span class="built_in">CircularQueLk</span>() :_max_size(Cap + <span class="number">1</span>),_data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//删除拷贝构造和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">CircularQueLk</span>(<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CircularQueLk</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(_mtx)</span></span>;    <span class="comment">//获取锁，以确保线程安全</span></span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;                    <span class="comment">//依次销毁队列中的元素</span></span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head+<span class="number">1</span>）% _max_size;               <span class="comment">//销毁完当前元素，head++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);    <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;    <span class="comment">//emplace 是一个模板函数，接受可变参数列表 Args，允许插入不同类型的参数</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;     <span class="comment">//加锁</span></span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;             <span class="comment">//判断队列是否满了</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">//满了就直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//插入成功就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);                <span class="comment">//左值引用的插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));     <span class="comment">//右值引用的插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;          <span class="comment">//加锁</span></span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;                    <span class="comment">//判断是否为空</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                        <span class="comment">//为空就直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);        <span class="comment">//这行不添加也可以</span></span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;        <span class="comment">//出队了，头部指针++</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;                  <span class="comment">//存储队列的最大容量</span></span><br><span class="line">    T* _data;                          <span class="comment">//是一个指向队列元素的指针</span></span><br><span class="line">    std::mutex _mtx;                   <span class="comment">//是一个互斥锁，用于同步访问队列</span></span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;                  <span class="comment">//头部指针</span></span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;                  <span class="comment">//尾部指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------下面是测试-------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCircularQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个CircularQueLk类型的实例cq_lk，模板参数MyClass表示队列存储的元素类型，5 表示队列的最大容量。</span></span><br><span class="line">    CircularQueLk&lt;MyClass, <span class="number">5</span>&gt; cq_lk;</span><br><span class="line">    <span class="comment">//创建了两个 MyClass 类型的对象 mc1 和 mc2，分别初始化为值 1 和 2。</span></span><br><span class="line">    <span class="function">MyClass <span class="title">mc1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc1);                 <span class="comment">//通过左值引用的方式添加元素</span></span><br><span class="line">    cq_lk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(mc2));      <span class="comment">//通过右值引用的方式添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyClass <span class="title">mc</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">push</span>(mc);      <span class="comment">//通过左值引用的方式添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc2);              <span class="comment">//左值添加元素，但满了，添加不进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        MyClass mc1;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);     <span class="comment">//弹出元素5次</span></span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pop success, &quot;</span> &lt;&lt; mc1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);      <span class="comment">//继续弹出元素，但空了，弹不成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-无锁队列"><a href="#2-3-无锁队列" class="headerlink" title="2.3 无锁队列"></a>2.3 无锁队列</h2><p>如果用原子变量而不是用锁实现环形队列，那就是无锁并发的队列了。下面是之前用过的原子变量的读改写操作，<code>compare_exchange_strong</code>会比较原子变量<code>atomic&lt;T&gt;</code>的值和<code>expected</code>的值是否相等，如果相等则执行交换操作，将<code>atomic&lt;T&gt;</code>的值换为<code>desired</code>并且返回true，否则将expected的值修改为<code>atomic&lt;T&gt;</code>的值，并且返回false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure><p>用代码来理解就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)&#123;</span><br><span class="line">        m_val = desired;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        expected = m_val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compare_exchange_weak</code>功能比<code>compare_exchange_strong</code>弱一些，他不能保证<code>atomic&lt;T&gt;</code>的值和<code>expected</code>的值相等时也会做交换，很可能原子变量和预期值相等也会返回false，所以使用要多次循环使用。</p><p>下面程序中，将类的成员变量<code>mutex</code>换成<code>atomic</code>类型的原子变量，利用自旋锁的思路将锁替换为原子变量循环检测的方式，进而达到锁住互斥逻辑的效果。在析构函数中，因为<code>_atomic_using</code>初始化时为false，当线程1到到操作1处时，<code>_atomic_using</code>会被赋值为<code>use_desired</code>的值(true)，并且返回false，退出循环，完成队列类<code>CircularQueSeq</code>的销毁和空间回收。在这个过程中，如果有其它线程要进入，当来到操作1处时，因为<code>_atomic_using</code>已经为true了，与<code>use_expected</code>不相等，就会让<code>use_expected</code>赋值为<code>_atomic_using</code>的值(这是不希望的，所以do里面会每次都重新设置，就是防止这种情况)，并返回false，继续循环，只有当线程1执行完2处后，<code>_atomic_using</code>为false时，其它线程才能够退出循环1处，进入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueSeq</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>() :_max_size(Cap + <span class="number">1</span>), _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _atomic_using(<span class="literal">false</span>),_head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//删除拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">CircularQueSeq</span>(<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CircularQueSeq</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired)); <span class="comment">// 1处</span></span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head+<span class="number">1</span>）% _max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));   <span class="comment">//2处</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; _atomic_using;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这种方式虽然通过原子变量的方式解决线程安全问题，但当某一线程线程通过do-while后，其它线程都得像自旋锁一样一直轮询检查，就造成了不必要的开销，下面是对这种方法的一种改进。</p><p>对于pop逻辑代码：先在1处取出头部的下标索引，进行判断，如果头部的下标与尾部下标相等，说明为空，就直接返回false退出，否则就通过头部的下标取出数据，然后在3处，如果线程1先到达这里，因为<code>_head</code>等于h，所以就将<code>_head</code>进行+1，这样其它线程来到这里的时候，由于<code>_head</code>不等于h了，就返回false，继续循环。这时继续循环时，由于<code>_head</code>已经等于h+1了，所以改线程在1处获得的下标就是h+1，那么它要pop的是h+1，不是h，就不会出现多次弹出同一个数据的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = _head.<span class="built_in">load</span>();  <span class="comment">//1处 先获得头部的一个下标索引</span></span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//相等就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        val = _data[h]; <span class="comment">// 2处 就从头部取出要pop的数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, (h+<span class="number">1</span>)% _max_size)); <span class="comment">//3处 !_head等于h的时候就+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>push逻辑代码：push逻辑与pop逻辑处理在这里是一样的，但push的这种处理是存在线程安全问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = _tail.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>( (t+<span class="number">1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % _max_size)); <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-利用栅栏实现同步模型"><a href="#3-利用栅栏实现同步模型" class="headerlink" title="3. 利用栅栏实现同步模型"></a>3. 利用栅栏实现同步模型</h1><h2 id="3-1-线程可见顺序"><a href="#3-1-线程可见顺序" class="headerlink" title="3.1 线程可见顺序"></a>3.1 线程可见顺序</h2><p>有时候我们线程1对A的store操作采用release内存序，而线程2对B的load采用acquire内存序，并不能保证A 一定比 B先执行。因为两个线程并行执行无法确定先后顺序，我们指的先行不过是说如果B读取了A操作的结果，则称A先行于B。</p><p>在下面这段程序中，看似断言是不会触发，但在一些极端的情况下，还是可能触发断言的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//3</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------下面是测试--------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">//5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z value is &quot;</span> &lt;&lt; z.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在一个4核CPU结构的主机上，a,b,c,d分别运行在不同的CPU内核上，如下图所示。线程a执行<code>x.store(true)</code>先被线程c读取，而此时线程b对y的store还没有被线程c读取到新的值，所以此时c读取的x为true，y为false。同样的道理，d可以读取b修改y的最新值，但是没来的及读取x的最新值，那么读取到y为true，x为false。这样在上面程序中就会出现断言的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_2.jpg"></p><p>所以即使采用release和acquire方式也不能保证全局顺序一致。如果一个线程对变量执行release内存序的store操作，另一个线程不一定会马上读取到。</p><h2 id="3-2-栅栏"><a href="#3-2-栅栏" class="headerlink" title="3.2 栅栏"></a>3.2 栅栏</h2><p>其实也可以通过栅栏机制保证指令的写入顺序，栅栏的机制和<code>memory_order_release</code>类似。</p><p>下面程序中，在1和3中间添加了一个release内存序的栅栏2，这样可以确保该指令2之前的指令(什么内存序都包括)的编排不会编排到该指令2之后。在4和6之间又定义了一个acquire内存序的栅栏5，那么如果操作2被操作5读取到了，它们就构成了一个同步关系，所有执行操作6时，就一定可以读到操作1执行后的数据，也就不会发生断言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//1 对x存储为true</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">//2 添加一个栅栏，执行了release的内存序</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">//4</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire); <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">//6</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-基于锁实现线程安全的栈"><a href="#4-基于锁实现线程安全的栈" class="headerlink" title="4. 基于锁实现线程安全的栈"></a>4. 基于锁实现线程安全的栈</h1><p>下面程序实现了基于锁控制push和pop操作的一个栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception         <span class="comment">//定义了员工异常的结构(类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;       <span class="comment">//出问题直接抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span>                    <span class="comment">//模板类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;                 <span class="comment">//存放T数据类型的员工栈</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;               <span class="comment">//互斥量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;              <span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)        <span class="comment">//拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;      <span class="comment">//先对other对象加锁，防止其它线程还在使用other对象</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;       <span class="comment">//栈不支持赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;       <span class="comment">//先加锁</span></span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));       <span class="comment">//1.用移动构造来push一个元素，这样就免去了再构造一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>          <span class="comment">//pop返回智能指针的版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;    <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();  <span class="comment">//2.判断栈是否为空，为空就抛出异常</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">//3.将栈顶元素取出来，构造了一个智能指针</span></span><br><span class="line">        data.<span class="built_in">pop</span>();                  <span class="comment">//4.弹出栈定元素</span></span><br><span class="line">        <span class="keyword">return</span> res;                  <span class="comment">//返回栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span>                  <span class="comment">//pop返回引用的版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">//5.直接移动操作即可,存到传进来的参数中</span></span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;      <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();                      <span class="comment">//返回栈是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码虽然不会出现线程安全问题，但依然存在着不足，比如说在操作2处，当栈为空的时候，也会抛出异常，这是不会合理的。下面程序是解决栈为空就抛出异常的一个问题优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack_waitable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    std::condition_variable cv;                 <span class="comment">//条件变量，当栈为空的时候，就挂起</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>() &#123;&#125;             <span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>(<span class="type">const</span> threadsafe_stack_waitable&amp; other)       <span class="comment">//拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;       <span class="comment">//先锁住other对象，防止其它线程再访问</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack_waitable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack_waitable&amp;) = <span class="keyword">delete</span>;   <span class="comment">//无拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">//1.通过移动构造的方式push一个元素</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();                    <span class="comment">//添加完一个元素后，唤醒通知其它线程栈里有元素了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span>      <span class="comment">//pop智能指针版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(data.<span class="built_in">empty</span>())       <span class="comment">//如果栈为空，返回fasle，就在这里挂起，释放锁，其它线程就可以往栈放数据</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//如果不为空，就返回true，继续往下执行(还是加锁状态)</span></span><br><span class="line">            &#125;); <span class="comment">//  ⇽-- - 2</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>            <span class="comment">//pop引用版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span>       <span class="comment">//pop引用的另一个版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span>     <span class="comment">//pop智能指针的另一个版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();     <span class="comment">//为空，就返回一个空的智能指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5-实现线程安全的查找表"><a href="#5-实现线程安全的查找表" class="headerlink" title="5. 实现线程安全的查找表"></a>5. 实现线程安全的查找表</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><p>下面实现了一个线程安全的查找结构，类似线程安全的map结构，但由于map基于红黑树的，实现难度就较大，而且需要加锁地方的粒度也不是很精细，所以这里就考虑用散列表实现。</p><p>散列表，它是根据键(Key)而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p><h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><p>在下面程序中，将查找表封装为<code>threadsafe_lookup_table</code>类，该类将hash值存入到一个vector容器中，每个hash值都又一个属于自己的桶,，因此vector容器里存了指定数量的桶，可以理解为一条链表。在<code>threadsafe_lookup_table</code>类中，又封装了一个桶的类<code>bucket_type</code>，它相当于是一条链表，用list容器存储，里面存储的类型是<code>pair&lt;Key,Value&gt;</code>。然后<code>bucket_type</code>类也实现了一系列的增删改查的功能(需要加锁)供外部调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个模板类，接受三个模板参数：键的类型(Key)、值的类型(value)、哈希函数类型，默认使用std::hash&lt;Key&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> bucket_type &#123;       <span class="comment">//桶</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lookup_table;    <span class="comment">//将threadsafe_lookup_table定义为bucket_type的友缘</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;      <span class="comment">//一个键值对别名，类型为 std::pair&lt;Key, Value&gt;。</span></span><br><span class="line">        <span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;     <span class="comment">//一个链表别名，用于存储键值对</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;     <span class="comment">//链表的迭代器类型别名</span></span><br><span class="line">        bucket_data data;          <span class="comment">//实际存储键值对的链表</span></span><br><span class="line">        <span class="keyword">mutable</span> std::shared_mutex mutex;        <span class="comment">//一个共享互斥锁，用于保证线程安全</span></span><br><span class="line">        <span class="comment">//在桶中查找键，返回迭代器。</span></span><br><span class="line">        <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从begin()开始找，找到end()，传递一个谓词(用lambda表示)</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="type">const</span>&amp; item) &#123;    <span class="comment">//从桶里面开始找</span></span><br><span class="line">                <span class="keyword">return</span> item.first == key;       <span class="comment">//在桶中等于key就返回</span></span><br><span class="line">                &#125;);         <span class="comment">//找到了就返回迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//查找key值，找到返回对应的value，未找到则返回默认值</span></span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; default_value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;   <span class="comment">//共享锁，都来查找的话，可以并发查找，不用造成互斥的效果</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);       <span class="comment">//返回一个迭代器，用auto也可以</span></span><br><span class="line">            <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value : found_entry-&gt;second;  <span class="comment">//如果找到了，就放回找到的结果value值，没有找到就返回默认值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加key和value，找到则更新，没找到则添加</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;           <span class="comment">//加锁</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>())                <span class="comment">//如果没有找到</span></span><br><span class="line">            &#123;</span><br><span class="line">                data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));    <span class="comment">//向data里面添加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                found_entry-&gt;second = value;        <span class="comment">//通过key找到了，就更新该key的value值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除对应的key</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;              <span class="comment">//加锁</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                data.<span class="built_in">erase</span>(found_entry);        <span class="comment">//找到了就直接通过迭代器来删除该key和value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets;    <span class="comment">//用vector存储桶类型，每个vector的值都是一个桶类型</span></span><br><span class="line">    Hash hasher;        <span class="comment">//hash&lt;Key&gt; 哈希表 用来根据key生成哈希值</span></span><br><span class="line">    <span class="comment">//根据key生成数字，并对桶的大小取余得到下标，根据下标返回对应的桶智能指针</span></span><br><span class="line">    <span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将key值传给hasher，它会自动计算，返回一个散列值，然后取余，让其映射在bucket上</span></span><br><span class="line">        std::<span class="type">size_t</span> <span class="type">const</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];      <span class="comment">//解引用，得到该下标对应的一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//桶的大小默认为19(最好取质数)；哈希也默认是系统提供的哈希，这些都可以外部自己指定</span></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(<span class="type">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="type">const</span>&amp; hasher_ = <span class="built_in">Hash</span>()) :<span class="built_in">buckets</span>(num_buckets), <span class="built_in">hasher</span>(hasher_) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);       <span class="comment">//创建好每一个桶  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(threadsafe_lookup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;         <span class="comment">//删除拷贝构造</span></span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(threadsafe_lookup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;   <span class="comment">//删除拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; default_value = Value())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value); <span class="comment">//提供key找到对应的桶，再在该桶下通过key找到对应的value。这里不需要加锁，因为value_for里有加锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);   <span class="comment">//往对应桶里面添加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span>           <span class="comment">//删除对应桶里的key和value</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将查找表里面的数据存储到map容器</span></span><br><span class="line">    <span class="function">std::map&lt;Key, Value&gt; <span class="title">get_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//里面查找表里面的数据时，需要对每一个桶都加锁</span></span><br><span class="line">            locks.<span class="built_in">push_back</span>(std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">        &#125;</span><br><span class="line">        std::map&lt;Key, Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)   <span class="comment">//遍历每一个桶</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需用typename告诉编译器bucket_type::bucket_iterator是一个类型，以后再实例化</span></span><br><span class="line">            <span class="comment">//当然此处可简写成auto it = buckets[i]-&gt;data.begin();</span></span><br><span class="line">            <span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (; it != buckets[i]-&gt;data.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(*it);    <span class="comment">//对于每一个桶，只要没有到最后一个元素，都往res里面存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       <span class="comment">//最后返回res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自定义了一个MyClass类，用来表示Value类型值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i) :_data(i) &#123;&#125;</span><br><span class="line">    <span class="comment">//重写了&lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> MyClass&amp; mc) &#123;</span><br><span class="line">        os &lt;&lt; mc._data;</span><br><span class="line">        <span class="keyword">return</span> os;    <span class="comment">//输出参数的值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用于测试的函数：创建了一个查找表，并定义了三个线程，线程1负责向查找表添加0到99；线程2负责从查找表删除0到99；线程3负责向从查找表添加100到199。三个线程并发执行，执行完后，通过removeSet打印删除的那些数据，和打印出查找表里还剩下的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThreadSafeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; removeSet;         <span class="comment">//用来存储移出的数据</span></span><br><span class="line">    <span class="comment">//创建模板类查找表，Key是int，Value是std::shared_ptr&lt;MyClass&gt;</span></span><br><span class="line">    threadsafe_lookup_table&lt;<span class="type">int</span>, std::shared_ptr&lt;MyClass&gt;&gt; table;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;         <span class="comment">//往查找表里加元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;                   <span class="comment">//从查找表里移出元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; )&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> find_res = table.value_for(i, <span class="literal">nullptr</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (find_res)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                table.remove_mapping(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                removeSet.insert(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//因为是多线程一起运行，所以也有可能删除比添加快，导致要删除的元素，还没有添加进来，所以就先睡眠一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;              <span class="comment">//往查找表里加元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt; <span class="number">200</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : removeSet)&#123;                  <span class="comment">//打印移出的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;remove data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> copy_map = table.<span class="built_in">get_map</span>();      <span class="comment">//将查找表里面的元素转为map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : copy_map)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy data is &quot;</span> &lt;&lt; *(i.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestThreadSafeHash</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-缺陷"><a href="#5-3-缺陷" class="headerlink" title="5.3 缺陷"></a>5.3 缺陷</h2><ol><li>首先我们的查找表可以支持并发读，并发写，并发读的时候不会阻塞其他线程。但是并发写的时候会卡住其他线程。基本的并发读写没有问题。 </li><li>但是对于bucket_type中链表的操作加锁精度并不精细，因为我们采用的是std提供的list容器，所以增删改查等操作都要加同一把锁，导致锁过于粗糙。</li></ol><h1 id="6-基于锁实现线程安全的链表"><a href="#6-基于锁实现线程安全的链表" class="headerlink" title="6. 基于锁实现线程安全的链表"></a>6. 基于锁实现线程安全的链表</h1><h2 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h2><p>对于做一个支持多线程并发访问的链表，首先想到的是用一个互斥量控制整个链表，达到多线程访问时串行的效果。但是这么做精度不够，需要分化互斥量的功能。所以下面让每个节点都维护一个互斥量，这样能保证多个线程操作不同节点时加不同的锁，减少耦合性。</p><p>首先需要将head独立为一个虚节点，即不存储数据，只做头部标记。这样每次从头部插入就只需要修将新的节点的next指针指向原来head的next指向的节点，再将head的next指针指向新的节点。具体图像如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_3.jpg"></p><h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><p>头节点函数：定义了一个智能指针指向的数据域和unique智能指针指向下一个节点的地址，同时定义了默认构造函数和拷贝构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typname T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    std::mutex m;                <span class="comment">//每个节点独有的互斥量</span></span><br><span class="line">    std::shared_ptr&lt;T&gt; data;     <span class="comment">//data为智能指针,存储的是T类型的数据域</span></span><br><span class="line">    std::unique_ptr&lt;node&gt; next;   <span class="comment">//unique类型的智能指针，存储的是下一个节点的地址</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">node</span>() :<span class="built_in">next</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; value):<span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value))&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义链表的函数：链表类中将拷贝构造和拷贝赋值函数删除，同时链表中初始状态包含了一个头节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex m;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">next</span>()&#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(T <span class="type">const</span>&amp; value):<span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value))&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head;          <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_list</span>()&#123;&#125;            <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">threadsafe_list</span>()&#123;&#125;           <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_list</span>(threadsafe_list <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;              <span class="comment">//删除拷贝构造</span></span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(threadsafe_list <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;   <span class="comment">//删除拷贝赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数：在remove_if函数中，将Predicate p中的p可以理解为一个lambda表达式或者是一个函数的功能，通过p来判断，如果p返回了true，说明满足条件，把满足条件的节点删除掉；如果p返回的是false，就不满足条件，就不删除该节点。而析构函数调用remove_if，p谓词就是一个lambda表达式，始终返回true，这样就可以保证删除链表所有的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;                   <span class="comment">//将head头节点(虚节点)赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;         <span class="comment">//对头节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())   <span class="comment">//循环取出当前节点的下一个节点(裸指针)，为空就不执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;   <span class="comment">//对下一个指针进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*next-&gt;data))   <span class="comment">//用谓词p操作下一个节点，判断是否为true，如果为true，则条件满足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将当前节点的下一个节点移动到old_next里，则其下一个节点已经失效</span></span><br><span class="line">            std::unique_ptr&lt;node&gt; old_next = std::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">            current-&gt;next = std::<span class="built_in">move</span>(next-&gt;next);   <span class="comment">//将当前节点的下一个的下一个节点赋值给当前节点</span></span><br><span class="line">            next_lk.<span class="built_in">unlock</span>();        <span class="comment">//将当前节点的下一个节点解锁(已经要删除)</span></span><br><span class="line">        &#125;        <span class="comment">//当局部作用域结束的时候，old_next就会被回收掉(unique_ptr类型)，这样就删除了该节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//如果为false，则条件不满足，不用删除，跳过当前节点</span></span><br><span class="line">            lk.<span class="built_in">unlock</span>();              <span class="comment">//将当前节点解锁</span></span><br><span class="line">            current = next;           <span class="comment">//将下一个节点赋值给当前节点(相当于当前节点向右移)</span></span><br><span class="line">            lk = std::<span class="built_in">move</span>(next_lk);    <span class="comment">//将下一个节点的锁移动给当前节点的锁，这样当前节点就可以保持一直锁着</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_if</span>([](node <span class="type">const</span>&amp;) &#123;<span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入节点函数：通过头插法的方式插入新的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T <span class="type">const</span>&amp; value)</span>             <span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;   <span class="comment">//创建了一个新节点</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;            <span class="comment">//锁住头部节点</span></span><br><span class="line">    new_node-&gt;next = std::<span class="built_in">move</span>(head.next);             <span class="comment">//将头部的下一个节点地址赋值给新节点的下一个节点</span></span><br><span class="line">    head.next = std::<span class="built_in">move</span>(new_node);                   <span class="comment">//头部节点的下一个节点地址改为新节点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找对应节点的函数：该函数是结合谓词p来在链表中一个一个寻找第一个满足条件的节点，找到了就直接返回该data的一个指针，没有找到就返回空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">find_first_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;           <span class="comment">//从头节点开始，赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;     <span class="comment">//当前节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())&#123;     <span class="comment">//循环取当前节点的下一个节点，为空则退出循环</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;   <span class="comment">//对当前节点的下一个节点加锁</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*next-&gt;data))&#123;    <span class="comment">//将next的数据域传给p，判断是否为true，为true就说明找到了，返回next的数据源data</span></span><br><span class="line">            <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果改节点不满足，继续判断下一个</span></span><br><span class="line">        current = next;     <span class="comment">//将下一个节点地址赋值给当前节点</span></span><br><span class="line">        lk = std::<span class="built_in">move</span>(next_lk);     <span class="comment">//next的锁也移动给当前节点，则lk永远锁定的是当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">//如果最后都没有找到对应的节点，就返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有节点函数：该函数是结合谓词函数f来完成的，从头节点开始遍历，到最后空时，就退出循环，停止遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;            <span class="comment">//从头节点开始，赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;      <span class="comment">//当前节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())&#123;    <span class="comment">//循环取当前节点的下一个节点，为空则退出循环</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;    <span class="comment">//把下一个节点加锁</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();                 <span class="comment">//当前节点解锁</span></span><br><span class="line">        <span class="built_in">f</span>(*next-&gt;data);              <span class="comment">//执行谓词函数f，</span></span><br><span class="line">        current = next;              <span class="comment">//把下一个节点更新为当前节点</span></span><br><span class="line">        lk = std::<span class="built_in">move</span>(next_lk);     <span class="comment">//把下一个节点的锁移动给当前节点的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-线程安全的无锁栈实现"><a href="#7-线程安全的无锁栈实现" class="headerlink" title="7. 线程安全的无锁栈实现"></a>7. 线程安全的无锁栈实现</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>之前通过锁的互斥机制实现了并发安全的栈，队列，查找表，以及链表等结构。接下来是通过无锁的原子变量的方式实现栈。</p><p>单线程情况下添加节点步骤：</p><ol><li>创建新节点</li><li>将元素入栈，将新节点的next指针指向现在的head节点。</li><li>将head节点更新为新节点的值。</li></ol><p>而在多线程情况下，假设线程1执行到第2步，即将元素入栈后，没来得及更新head节点的值为新节点的值。此时线程2也执行完第2步，将head更新为线程2插入的新节点，之后线程1又将head更新为线程1的新插入节点，那么此时head的位置就是错的。</p><p>单线程情况下删除节点步骤：</p><ol><li>取出头节点元素</li><li>更新head为下一个节点。</li><li>返回取出头节点元素的数据域。</li></ol><p>而在多线程情况下，第1，2步同样存在线程安全问题。此外我们返回节点数据域时会进行拷贝赋值，如果出现异常会造成数据丢失，这一点也要考虑。 </p><p>所以为了解决这些问题，可以通过原子变量的<code>compare_exchange</code>(比较交换操作)来控制更新head节点，以此来达到线程安全的目的。</p><h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><p>头节点函数：创建了一个模板类，在该类中，定义了一个T类型的数据域、node*类型的指针，指向下一个节点的地址和一个拷贝构造的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;              <span class="comment">//数据域</span></span><br><span class="line">    node* next;          <span class="comment">//下一个节点的地址</span></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_):<span class="built_in">data</span>(data_)&#123;&#125;     <span class="comment">//拷贝构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>无锁栈结构：下面程序定义了一个无锁栈的结构，结构中定义了一个采用原子变量表示的头部节点。需要注意的是，对于栈和队列，如果想要实现线程安全，都不能进行拷贝，不然管理不了。所以得删除拷贝构造和拷贝赋值，采用默认构造即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>(<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;                  <span class="comment">//删除拷贝构造</span></span><br><span class="line">    lock_free_stack&amp; <span class="keyword">operator</span> = (<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;     <span class="comment">//删除拷贝赋值</span></span><br><span class="line">    std::atomic&lt;node*&gt; head;       <span class="comment">//node*类型的原子变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入栈函数：在多线程情况下，当线程1创建新节点node1并指向了下一个头节点，但没有来得及更新head，这时线程2也创建了新节点node2执行到1处，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_4.png"></p><p>然后线程2更新了head节点，即head指向了node2。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_5.png"></p><p>当时间片回到线程1，线程1执行2处代码时，发现head的值与node1的next的值不一样，就将head的值赋值给node1的next，并返回false，继续执行循环，那么node1的next就指向了head节点(node2)，再执行2处代码时，head与node1-&gt;next值相等了，就将node1的值赋值给head了(head进行了更新)，然后返回ture，退出循环。如下图所示;</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_6.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value)              <span class="comment">//创建一个新的节点</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        new_node-&gt;next = head.<span class="built_in">load</span>();            <span class="comment">//1.将头节点的值赋值给新节点的next指针</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_strong</span>(new_node-&gt;next, new_node));  <span class="comment">//2.当返回false时就相当于执行了1处的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈函数：下面程序是一个单线程的版本，当线程1执行完1处时，即线程1的old_head指向了头节点，但还没有来得及执行2处代码，线程2就将它的old_head指向了头节点，并将头节点往下移动了，此时线程1再来执行2处代码时，就会出现问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">    head = head-&gt;next; <span class="comment">//2</span></span><br><span class="line">    value = old_head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以为了解决上面问题，对代码进行了改进，当线程2执行完2处代码后，即head指向了线程2<code>old_head</code>的next，此时线程1再执行到2处时，因为head指向的节点和线程1<code>old_head</code>指向的不一样了，就将线程1<code>old_head</code>指向head节点(修改删除节点)，当在执行2处代码时，就能取出当前head所值的节点(要弹出的节点)，并将head的指向往下移，退出线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        node* old_head = head.<span class="built_in">load</span>(); <span class="comment">//1. 将头部节点加载出来，old_head指向了头部节点</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//2</span></span><br><span class="line">    value = old_head-&gt;data; <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码存在的问题：</p><ol><li>未判断空栈的情况，当old_head为空时，在2处还有old_head-&gt;next操作，就很危险。</li><li>将数据域赋值给引用类型的value时存在拷贝赋值(3处)，我们都知道拷贝赋值会存在异常的情况，当异常发生时元素已经从栈定移除了，破坏了栈的结构，这一点和锁处理时不一样，锁处理的时候是先将元素数据域取出赋值再出栈，所以不会有问题，但是无锁的方式就会出现栈被破坏的情况。解决方式也比较简单，数据域不再存储T类型数据，而是存储<code>std::shared_ptr&lt;T&gt;</code>类型的数据。智能指针在赋值的时候不会产生异常。</li><li>未释放弹出的节点的内存。</li></ol><p>先解决未判断栈未空的问题，如下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;      <span class="comment">//用T类型的智能指针指向data</span></span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : <span class="comment">//⇽-- - 1</span></span><br><span class="line">            <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lock_free_stack</span>(<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_free_stack&amp; <span class="keyword">operator</span> = (<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    std::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node* old_head = <span class="literal">nullptr</span>; <span class="comment">//1        </span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            old_head = head.<span class="built_in">load</span>(); <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;      <span class="comment">//如果加载出来的节点是空节点，就返回空，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//3        </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> old_head-&gt;data;  <span class="comment">//4    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于资源回收问题，可以先实现一个简单的回收处理逻辑，通过临时智能指针与要删除的数据进行交换的方法来回收资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* old_head = <span class="literal">nullptr</span>;        </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_head = head.<span class="built_in">load</span>();     <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//2        </span></span><br><span class="line">    std::shared_ptr&lt;T&gt; res;   <span class="comment">//3 定义一个临时智能指针</span></span><br><span class="line">    res.<span class="built_in">swap</span>(old_head-&gt;data); <span class="comment">//4 将res与old_head的data做交换，这样old_head就会变成空指针</span></span><br><span class="line">    <span class="keyword">delete</span> old_head;  <span class="comment">//5 直接去除掉old_head</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">//6 返回删除的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序虽然解决了资源回收的问题，但还是存在很大的问题，当线程1走到1处时，时间片被分配到线程2，然后线程2直接执行到第5处，把old_head删除了，但此时线程1的old_head与线程2删除的old_head是一样的，这样就会导致线程1继续执行，到执行第2处时，取old_head的next时，就会导致系统崩溃。所以就不能把old_head直接删除，其实能不能删除old_head，取决于其它线程是否还用old_head，就像如果是单线程的，就完全可以删除。所以考虑多线程的情况，就需要引入延迟删除节点的机制来解决该问题。</p><p>设计思路：</p><ol><li>如果head已经被更新，且旧head不会被其他线程引用，那旧head就可以被删除。否则放入待删列表。</li><li>如果仅有一个线程执行pop操作，那么待删列表可以被删除，如果有多个线程执行pop操作，那么待删列表不可被删除。</li></ol><p>我们需要用一个原子变量threads_in_pop记录有几个线程执行pop操作。在pop结束后再减少threads_in_pop。 我们需要一个原子变量to_be_deleted记录待删列表的首节点。程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop;        <span class="comment">//1 计数器首先自增，然后才执行其他操作</span></span><br><span class="line">    node* old_head = <span class="literal">nullptr</span>;     </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//2 加载head节点给旧head存储</span></span><br><span class="line">        old_head = head.<span class="built_in">load</span>();  </span><br><span class="line">        <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            --threads_in_pop;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">// 3    </span></span><br><span class="line">    <span class="comment">//3处 比较更新head为旧head的下一个节点    </span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head)      <span class="comment">//old_head不为空，就执行下面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4 只要有可能，就回收已删除的节点数据</span></span><br><span class="line">        res.<span class="built_in">swap</span>(old_head-&gt;data);     <span class="comment">//将要删除的节点于res进行交换， </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5 从节点提取数据，而非复制指针</span></span><br><span class="line">    <span class="built_in">try_reclaim</span>(old_head);       <span class="comment">//old_head已经是空节点了，通过该函数来判断。old_head是否要删除</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threads_in_pop == <span class="number">1</span>)    <span class="comment">//1 原子变量判断仅有一个线程进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2 当前线程把待删列表取出</span></span><br><span class="line">        node* nodes_to_delete = to_be_deleted.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">//3 更新原子变量获取准确状态，判断pop是否仅仅正被当前线程唯一调用</span></span><br><span class="line">        <span class="keyword">if</span>(!--threads_in_pop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">delete_nodes</span>(nodes_to_delete);   <span class="comment">//4 如果唯一调用则将待删列表删除</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodes_to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5 如果pop还有其他线程调用且待删列表不为空，则将待删列表首节点更新给to_be_deleted</span></span><br><span class="line">            <span class="built_in">chain_pending_nodes</span>(nodes_to_delete);     <span class="comment">//将本地的待删列表还原成全局待删列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//多个线程pop会访问该节点(不会用该节点的数据，因为数据值已经通过交换删除了，但之前存该数据的节点没有删)</span></span><br><span class="line">        <span class="built_in">chain_pending_node</span>(old_head);      <span class="comment">//将其放入待删列表，此时不能删除old_head</span></span><br><span class="line">        --threads_in_pop;       <span class="comment">//线程用完了，计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delete_nodes</span><span class="params">(node* nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes)    <span class="comment">//遍历链表删除即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        node* next = nodes-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> nodes;</span><br><span class="line">        nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_node</span><span class="params">(node* n)</span></span>&#123;     <span class="comment">//将单个节点放入待删列表</span></span><br><span class="line">    <span class="built_in">chain_pending_nodes</span>(n, n);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* first, node* last)</span></span>&#123;  <span class="comment">//接受两个参数，分别为链表的头和尾</span></span><br><span class="line">    <span class="comment">//1 先将last的next节点更新为待删列表的首节点</span></span><br><span class="line">    last-&gt;next = to_be_deleted;    </span><br><span class="line">    <span class="comment">//2  借循环保证 last-&gt;next指向正确</span></span><br><span class="line">    <span class="comment">// 将待删列表的首节点更新为first节点</span></span><br><span class="line">    <span class="keyword">while</span> (!to_be_deleted.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">        last-&gt;next, first));     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* nodes)</span></span>&#123;    <span class="comment">//将nodes_to_delete为首的链表还原到待删列表中，接受一个参数为待还原的链表的首节点</span></span><br><span class="line">    node* last = nodes;</span><br><span class="line">    <span class="comment">//1 沿着next指针前进到链表末端</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = last-&gt;next)    </span><br><span class="line">    &#123;</span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 将链表放入待删链表中</span></span><br><span class="line">    <span class="built_in">chain_pending_nodes</span>(nodes, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-内存顺序和内存模型使用实现&quot;&gt;&lt;a href=&quot;#1-内存顺序和内存模型使用实现&quot; class=&quot;headerlink&quot; title=&quot;1. 内存顺序和内存模型使用实现&quot;&gt;&lt;/a&gt;1. 内存顺序和内存模型使用实现&lt;/h1&gt;&lt;h2 id=&quot;1-1-sequenc</summary>
      
    
    
    
    <category term="并发编程" scheme="https://lxx93.online/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="c++" scheme="https://lxx93.online/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>结合epoll和http实现B/S模式</title>
    <link href="https://lxx93.online/2024/07/26/%E7%BB%93%E5%90%88epoll%E5%92%8Chttp%E5%AE%9E%E7%8E%B0BS%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lxx93.online/2024/07/26/%E7%BB%93%E5%90%88epoll%E5%92%8Chttp%E5%AE%9E%E7%8E%B0BS%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-07-26T13:03:50.000Z</published>
    <updated>2024-07-27T15:58:30.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>epoll 是linux下的一个 I&#x2F;O 多路复用机制，用于高效地监听多个文件描述符上的 I&#x2F;O 事件。相较于 select 和 poll，epoll 在处理大量连接时具有更好的性能。而HTTP是应用层协议，同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。它也是基于B&#x2F;S架构进行通信的，下面就结合epoll来实现一个能够给浏览器提供服务，供用户借助浏览器访问服务器主机中文件的B&#x2F;S模式。</p><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h1><h2 id="2-1-主函数"><a href="#2-1-主函数" class="headerlink" title="2.1 主函数"></a>2.1 主函数</h2><p>主函数主要负责把启动程序时，传进来的参数用变量来接收，并检测，当传进来的参数不满3个时，就会报错，最后传入端口，来调用一个监听函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//命令行参数获取 端口和server提供的目录</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server port path\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取用户输入的端口</span></span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);  <span class="comment">//字符串转化为端口形式</span></span><br><span class="line">    <span class="comment">//改变进程工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">chdir</span>(argv[<span class="number">2</span>]);    <span class="comment">//将你要打开的文件路径作为工作目录，到时候遍历目录内容时就比较方便了</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动epoll监听</span></span><br><span class="line">    <span class="built_in">epoll_run</span>(port);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-核心函数"><a href="#2-2-核心函数" class="headerlink" title="2.2 核心函数"></a>2.2 核心函数</h2><p>这部分负责了小项目的大部分代码任务，监听连接、创建红黑树、向红黑树上添加监听描述符和通信描述符、以及建立连接后，对协议头的检查、创建发送协议头等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">epoll_run</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> all_events[MAXSIZE];</span><br><span class="line">    <span class="comment">//创建一个epoll红黑数根节点</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建监听描述符,并将其添加到红黑树上</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">init_listen_fd</span>(port, epfd);    <span class="comment">//这是一个自定义的函数，返回创建好的监听描述符(已添加到红黑树上)</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//监听节点对应事件 ---&gt;返回满足条件的事件个数</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd,all_events,MAXSIZE,<span class="number">-1</span>);   <span class="comment">//阻塞等待，有事件满足的文件描述符都在all_events数组里</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ret; i++)&#123;     <span class="comment">//开始遍历就绪的事件，一个一个处理</span></span><br><span class="line">            <span class="comment">//只处理读事件，其它事件默认不处理</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *pev = &amp;all_events[i];   <span class="comment">//取出每一个事件</span></span><br><span class="line">            <span class="keyword">if</span>(!(pev-&gt;events &amp; EPOLLIN))&#123;       <span class="comment">//不是读事件</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">//直接跳出该事件的处理继续下一个事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pev-&gt;data.fd == lfd)&#123;          <span class="comment">//是监听描述符的读事件，即有客户端请求连接</span></span><br><span class="line">                <span class="built_in">do_accept</span>(lfd,epfd);          <span class="comment">//自定义函数，建立连接客户端，并挂上红黑树epoll</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                            <span class="comment">//是通信描述符的读事件，对端有信息发来</span></span><br><span class="line">                <span class="built_in">do_read</span>(pev-&gt;data.fd, epfd);  <span class="comment">//自定义函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>init_listen_fd()</code>函数的实现，服务端绑定以及将监听的文件描述符挂到红黑数epoll上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_listen_fd</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> epfd)</span></span>&#123;            <span class="comment">//参数是端口和红黑树的根节点</span></span><br><span class="line">    <span class="comment">//创建监听的套接字lfd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建服务器地址结构ip+port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> srv_addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;srv_addr,<span class="built_in">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);   <span class="comment">//INADDR_ANY指的是本地的ip</span></span><br><span class="line">    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="built_in">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">//给lfd绑定地址结构</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;srv_addr,<span class="built_in">sizeof</span>(srv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置监听上限</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lfd添加到epoll数上，以监听连接的客户端信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;      <span class="comment">//设置读事件</span></span><br><span class="line">    ev.data.fd = lfd;         <span class="comment">//监听文件描述符</span></span><br><span class="line">    <span class="comment">//将监听描述符的读事件添加到了红黑树上</span></span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add lfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lfd;         <span class="comment">//返回监听描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理连接的函数：该函数负责与对端建立连接，由于是监听到有加内特描述符的读事件已就绪，所以执行该函数时，是不会阻塞的。与对端连接好连接后，就将与对端的通信描述符添加到epoll树上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_accept</span><span class="params">(<span class="type">int</span> lfd,<span class="type">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clt_addr_len = <span class="built_in">sizeof</span>(clt_addr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clt_addr, &amp;clt_addr_len);  <span class="comment">//与对端连接，这里不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印客户端ip+port</span></span><br><span class="line">    <span class="type">char</span> client_ip[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//打印客户端的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;New client ip: %s, port: %d, cfd = %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET,&amp;clt_addr.sin_addr.s_addr,client_ip,<span class="built_in">sizeof</span>(client_ip)), <span class="built_in">ntohs</span>(clt_addr.sin_port),cfd);</span><br><span class="line">    <span class="comment">//设置cfd阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd,F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(cfd,F_SETFL,flag);</span><br><span class="line">    <span class="comment">//将新节点cfd挂到epoll数上，来监听对端通信</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    <span class="comment">//边沿非阻塞模式</span></span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通信函数实现：该函数负责的就是与对端的通信，其中需要判断对端发来的是什么类型请求，过程有点复杂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//读取一行http协议，拆分，获取get 文件名 协议号</span></span><br><span class="line">    <span class="type">char</span> line[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">get_line</span>(cfd,line,<span class="built_in">sizeof</span>(line));   <span class="comment">//读http请求协议首行---&gt; GET 客户需要获取的文件 http的协议号</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器，检查到客户端关闭....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">disconnect</span>(cfd,epfd);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;      <span class="comment">//有数据可以读</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;================请求头================&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求行数据：%s&quot;</span>,line);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;      <span class="comment">//清除剩下的数据，下次传来信息，可以继续读第一行</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            len = <span class="built_in">get_line</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===============The end===============\n&quot;</span>);</span><br><span class="line">        <span class="comment">//判断啥类型请求</span></span><br><span class="line">        <span class="comment">//if(strncasecmp(method,&quot;GET&quot;,3) == 0)&#123;   //确定用户传来的是啥类型命令---&gt;这里是GET</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(<span class="string">&quot;get&quot;</span>, line, <span class="number">3</span>)==<span class="number">0</span>)&#123;       <span class="comment">//忽略大小写比较n个字符</span></span><br><span class="line">            <span class="built_in">http_request</span>(line, cfd);        <span class="comment">//处理http请求</span></span><br><span class="line">            <span class="comment">//关闭套接字，cfd从epoll上del</span></span><br><span class="line">            <span class="comment">//disconnect(cfd, epfd);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到对端传来的请求后，通过请求的第一行来查看对端需要的文件是什么类型，并检查看当前文件有无对端需要的文件，不同情况。采取不同处理方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理http请求，判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* request, <span class="type">int</span> cfd)</span></span>&#123;     <span class="comment">//请求http协议第一行；客户端fd</span></span><br><span class="line">    <span class="comment">//拆分http请求行</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">12</span>], path[<span class="number">1024</span>], protocol[<span class="number">12</span>];     <span class="comment">//三个字符数组分别装GET、文件名、HTTP协议号</span></span><br><span class="line">    <span class="built_in">sscanf</span>(request, <span class="string">&quot;%[^ ] %[^ ] %[^ ]&quot;</span>, method, path, protocol);       <span class="comment">//正则表达式的方式获取各类容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method = %s, path = %s, protocol = %s\n&quot;</span>, method, path, protocol);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转码 将不能识别的中文乱码 --&gt;中文</span></span><br><span class="line">    <span class="comment">//解码 将浏览器发来的文件名(unicode编码)转为中文，方便后台处理找到，后面回发给浏览器时，在对其进行编码</span></span><br><span class="line">    <span class="built_in">decode_str</span>(path,path);         <span class="comment">//参数1是存解码好的内容，参数2是要解码的内容</span></span><br><span class="line">    <span class="comment">//用户有请求是get /hello.txt HTTP1.1 ；无请求是get / HTTP1.1</span></span><br><span class="line">    <span class="type">char</span> *file = path + <span class="number">1</span>;     <span class="comment">//取出 客户端要访问的文件名---&gt;path是\video.mp4,而+1是为了移动下标位置，最前面的\不需要</span></span><br><span class="line">    <span class="comment">//如果没有指定访问的资源，默认就显示资源目录中的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path,<span class="string">&quot;/&quot;</span>)==<span class="number">0</span>)&#123;   <span class="comment">//如果是无请求，path就是/，file就是空 ---&gt;浏览器输入192.168.88.93:9527 ---&gt;就是这种情况，访问的是dir目录下的内容</span></span><br><span class="line">        file = <span class="string">&quot;./&quot;</span>;   <span class="comment">//设置file的值，资源目录的当前位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sbuf;</span><br><span class="line">    <span class="comment">//判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">stat</span>(file,&amp;sbuf);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;                      <span class="comment">//表示没有找到该文件</span></span><br><span class="line">        <span class="comment">//回发浏览器404错误页面</span></span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;No such file or direntry&quot;</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;错误页面啊----------------------------&quot;);</span></span><br><span class="line">        <span class="keyword">return</span>;                   <span class="comment">//不能exit(1);请求文件不存在，没有必要退出服务器，可以等待对方下一个请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是目录还是文件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(sbuf.st_mode))&#123;     <span class="comment">//是目录</span></span><br><span class="line">        <span class="comment">//发送头信息</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd, <span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(<span class="string">&quot;.html&quot;</span>), <span class="number">-1</span>);   <span class="comment">//-1表示系统自己获取文件大小</span></span><br><span class="line">        <span class="comment">//发送目录信息</span></span><br><span class="line">        <span class="built_in">send_dir</span>(cfd,file);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(sbuf.st_mode))&#123;         <span class="comment">//是一个普通文件</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(file), sbuf.st_size);</span><br><span class="line">        <span class="comment">//回发给客户端请求的文件内容</span></span><br><span class="line">        <span class="built_in">send_file</span>(cfd, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在得到对端请求文件的类型后，作为服务器，发送给对端内容，也需要创建一个响应头，其中下面程序就针对对端请求的文件类型，生成了对应的响应头，并先发送给对端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应答客户端协议头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_respond_head</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> no, <span class="type">const</span> <span class="type">char</span> *desp, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">long</span> len)</span></span>&#123;  <span class="comment">//客户端的fd；错误号；错误描述；回发文件类型；文&gt;件长度</span></span><br><span class="line">    <span class="comment">//拼接协议头</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, no, desp);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//信息报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, type);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%ld\r\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);     <span class="comment">//拼接好后存在buf里面，直接通过buf发给对端</span></span><br><span class="line">    <span class="comment">//空行</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送完响应头后，也知道了对端请求的是一个目录，而本地也存在该目录，接下来就是将该目录内容在满足http协议的前提下发送给对端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送服务器本地目录给浏览器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_dir</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* dirname)</span></span>&#123;     <span class="comment">//发送目录内容函数</span></span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="comment">//拼一个html页面&lt;table&gt;&lt;/table&gt;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4094</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&quot;</span>, dirname);   <span class="comment">//这一行是给网页取名</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;</span>, dirname);  <span class="comment">//---&gt;这一行是显示在页面上</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> enstr[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//后面将文件名编码后，存放的位置</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目录项二级指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>** ptr;      <span class="comment">//---&gt;结构体里面重要的两项是inode编号，和文件名</span></span><br><span class="line">    <span class="comment">//scandir是把dirname目录的下的目录项例出来</span></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">scandir</span>(dirname, &amp;ptr, <span class="literal">NULL</span>, alphasort);    <span class="comment">//要访问的文件目录名；目录项的字符指针数组(传出)；过滤器(没有用到)；内容按字符排序</span></span><br><span class="line">    <span class="comment">//得到dirname下的所有目录项存放在ptr字符数组中，num是返回该数组中的个数</span></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        <span class="type">char</span>* name = ptr[i]-&gt;d_name;</span><br><span class="line">        <span class="comment">//拼接文件的完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(path, <span class="string">&quot;%s/%s&quot;</span>, dirname, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;path = %s =================\n&quot;</span>, path);  <span class="comment">//---&gt;这一行输入是终端看的</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">        <span class="built_in">stat</span>(path,&amp;st);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编码生成 %E5 %E6之类的东西(在浏览器搜索哪里中文和某类编码是一一对应的，回发给浏览器，要将中文转编码)</span></span><br><span class="line">        <span class="built_in">encode_str</span>(enstr, <span class="built_in">sizeof</span>(enstr), name);    <span class="comment">//name是目录项下的文件名(传入)；enstr是传出，存放文件名编码后的unicode编码</span></span><br><span class="line">        <span class="comment">//如果是文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode))&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode))&#123;        <span class="comment">//如果是目录</span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);    <span class="comment">//将拼接好的内容发给对端</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));      <span class="comment">//清0，下一个循环继续用(一个目录下有多个子目录和子文件)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);  <span class="comment">//发送完对端请求目录下所有内容后，进行结尾拼接</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);               <span class="comment">//将结尾拼接的内容发给对端</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dir message send OK!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送完响应头后，也知道了对端请求的是一个具体文件，而本地也存在该文件，接下来服务器就是打开该文件读取，将文件内容在满足http协议的前提下发送给对端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送服务器本地文件给浏览器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_file</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span> *file)</span></span>&#123;     <span class="comment">//cfd是访问的客户端的socket；file是要访问的文件</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//打开的服务器本地文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file, O_RDONLY);      <span class="comment">//以只读打开用户需要的文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//打开文件失败，回发404错误页面</span></span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;No such file or direntry&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">send</span>(cfd, buf, n, <span class="number">0</span>);        <span class="comment">//从fd向buf写内容(用户需要的文件)</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;errno = %d\n&quot;</span>,errno);</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;                          <span class="comment">//不算错误，直接continue</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;----------------EAGAIN\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR)&#123;                     <span class="comment">//不算错误，直接continue</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---------------EINTR\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">4096</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;----------send ret: %d\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-辅助函数"><a href="#2-3-辅助函数" class="headerlink" title="2.3 辅助函数"></a>2.3 辅助函数</h2><p>断开连接的函数：当对端请求关闭时，会调用该函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断开链接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>&#123;            <span class="comment">//参数：要断开的描述符；红黑树根节点</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,cfd,<span class="literal">NULL</span>);   <span class="comment">//将cfd从红黑树上摘下</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl del cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);                 <span class="comment">//关闭该描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>404错误页面函数：当服务器在本地没有找到对端的请求目录文件时或服务器打开本地文件出错都会调用该函数，会发送给对端一个404页面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_error</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> status, <span class="type">char</span> *title, <span class="type">char</span> *text)</span></span>&#123;        <span class="comment">//错误页面404</span></span><br><span class="line">    <span class="comment">//应答协议的协议头</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);    <span class="comment">//http协议号；错误号；错误描述</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);    <span class="comment">//类型一定是html类型(固定的)---&gt;因为是错误页面</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%d\r\n&quot;</span>, <span class="number">-1</span>);           <span class="comment">//内容长度不晓得是多大就写-1</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Connection: close\r\n&quot;</span>);              <span class="comment">//http协议是：服务器完成一次与客户端的应答，就主动断开(不写这个也可&gt;以)</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);     <span class="comment">//拼接好后存在buf里面，直接通过buf发给对端</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);            <span class="comment">//应答协议头的结尾标记</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n&quot;</span>, status, title);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;body bgcolor=\&quot;#cc99cc\&quot;&gt;&lt;h4 align=\&quot;center\&quot;&gt;%d %s&lt;/h4&gt;\n&quot;</span>, status,title);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;%s\n&quot;</span>,text);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------错误页面啊----------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取协议第一行的函数：该函数是服务器在接收到对端发来的请求时，为了得到请求头的第一行而调用的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一行 http的内容结构末尾是以/r/n换行的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;size<span class="number">-1</span>) &amp;&amp; (c!=<span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">        n = <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,<span class="number">0</span>);    <span class="comment">//每次只读一个字符存到c中，有数据就读，没有数据就阻塞，读完就没有了</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">                n = <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,MSG_PEEK);</span><br><span class="line">                <span class="keyword">if</span>((n&gt;<span class="number">0</span>) &amp;&amp; (c==<span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">                    <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码和解码函数：编码是服务器将本地找到的文件目录(中文)转为浏览器的一些编码格式(unicode编码)，发给对端；而解码就是从对端(浏览器)请求中显示的文件(unicode编格式)转为中文，这样服务器在本地也方便搜索寻找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码：汉字--&gt;unicode码 -----&gt;服务端回发给浏览器时使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span></span>&#123;      <span class="comment">//from是传进来的，to是编码后传出去的</span></span><br><span class="line">    <span class="type">int</span> tolen;</span><br><span class="line">    <span class="keyword">for</span>(tolen = <span class="number">0</span>; *from != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; tolen+<span class="number">4</span> &lt; tosize; from++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalnum</span>(*from) || <span class="built_in">strchr</span>(<span class="string">&quot;/_.-~&quot;</span>, *from) != (<span class="type">char</span>*)<span class="number">0</span>)&#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">            to++;</span><br><span class="line">            tolen++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(to, <span class="string">&quot;%%%02x&quot;</span>,(<span class="type">int</span>) *from&amp;<span class="number">0xff</span>);</span><br><span class="line">            to += <span class="number">3</span>;</span><br><span class="line">            tolen += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码：unicode码--&gt;汉字 -----&gt;浏览器发给服务器时使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; *from != <span class="string">&#x27;\0&#x27;</span>; to++, from++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))&#123;</span><br><span class="line">            *to = <span class="built_in">hexit</span>(from[<span class="number">1</span>])*<span class="number">16</span> + <span class="built_in">hexit</span>(from[<span class="number">2</span>]);</span><br><span class="line">            from += <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制数转化为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexit</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件类型函数：通过对端请求头的请求文件，来得到该请求文件的文件类型(响应头需要文件的类型)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过文件名获取文件的类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *dot;</span><br><span class="line">    <span class="comment">//自右向左查找‘.’字符，如不存在返回NULL</span></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name,<span class="string">&#x27;.&#x27;</span>);      <span class="comment">//获取文件的类型。---&gt;.后面的就为文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(dot == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.html&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.htm&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.jpg&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.jpeg&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.gif&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.png&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.css&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.au&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.wav&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.avi&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mov&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.qt&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mpeg&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mpe&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.vrml&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.wrl&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.midi&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mid&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mp3&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.ogg&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.pac&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-执行效果"><a href="#3-执行效果" class="headerlink" title="3. 执行效果"></a>3. 执行效果</h1><p>这是服务器本地的一个文件，具体有这些文件内容：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_5.png"></p><p>当服务器启动后，在本地的浏览器输入服务器ip和设置的端口，就能得到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_6.png"></p><p>上面页面的所有内容都可以通过在浏览器端口后面输入对应的文件名或直接点击页面文件获得，如：</p><p>点击document3_文档就可以进入如下页面，当然，还可以再点击a.txt或b.txt，访问该txt文件里面的内容</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_7.png"></p><p>点击图片就会显示如下页面：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_8.png"></p><p>点击歌曲也可以播放：</p><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_9.png"></p><p>对于视频，因为这个centos系统没有下载对于的视频插件，所以不能播放。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;epoll 是linux下的一个 I&amp;#x2F;O 多路复用机制，用于高效地监听多个文件描述符上的 I&amp;#x2F;O 事</summary>
      
    
    
    
    <category term="小项目" scheme="https://lxx93.online/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="linux" scheme="https://lxx93.online/tags/linux/"/>
    
    <category term="epoll" scheme="https://lxx93.online/tags/epoll/"/>
    
    <category term="http" scheme="https://lxx93.online/tags/http/"/>
    
  </entry>
  
</feed>
