<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux基础知识</title>
    <url>/2024/07/03/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-Linux操作系统基础知识"><a href="#1-Linux操作系统基础知识" class="headerlink" title="1. Linux操作系统基础知识"></a>1. Linux操作系统基础知识</h1><h2 id="1-1-文本编译器vim"><a href="#1-1-文本编译器vim" class="headerlink" title="1.1 文本编译器vim"></a>1.1 文本编译器vim</h2><p>Vim文本编辑器，是由 vi 发展演变过来的文本编辑器，使用简单、功能强大、是 Linux众多发行版的默认文本编辑器。</p>
<p>1.vim的三种模式</p>
<ul>
<li><p>正常模式：以vim打开一个档案就直接进入了一般模式</p>
</li>
<li><p>插入模式：按下i、I、o、O、A、a、r、R等任何字母进入编辑模式</p>
</li>
<li><p>命令行模式：可以提供相关指令，完成读取、存盘、离开vim、显示行号等</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/1.png"></p>
<p>2.快捷键使用</p>
<ul>
<li><p>一般模式下，拷贝当前行 yy，拷贝当前行向下5行 5yy，粘贴 p</p>
</li>
<li><p>一般模式下，删除当前行 dd，删除当前行向下5行 5dd</p>
</li>
<li><p>在文件中找到某个单词，在命令行下输入 &#x2F;查找的关键字，然后回车即可，输入n继续查找下一个需要查找的关键字</p>
</li>
<li><p>设置文件的行号，取消文件的行号，分别为[命令行下:set nu 和:set nonu]</p>
</li>
<li><p>在一般模式下，使用快捷键到文档的最末尾 G，和最首行 gg</p>
</li>
<li><p>在一个文件中输入”hello”(编辑模式),在一般模式下，撤销这个动作 u</p>
</li>
<li><p>在一般模式下，将光标移动到 20 shift+g</p>
</li>
</ul>
<h2 id="1-2操作常识"><a href="#1-2操作常识" class="headerlink" title="1.2操作常识"></a>1.2操作常识</h2><p>1.关机&#x2F;重启命令</p>
<ul>
<li><p>立刻进行关机：shutdown  -h  now</p>
</li>
<li><p>1分钟后会关机：shutdown  -h  1</p>
</li>
<li><p>立刻重新启动计算机：shutdown  -r  now </p>
</li>
<li><p>关机，作用和上面一样：halt</p>
</li>
<li><p>立刻重新启动计算机：reboot</p>
</li>
<li><p>把内存数据同步到磁盘：sync</p>
</li>
</ul>
<p>2.用户登录或促销</p>
<ul>
<li><p>登录普通用户abc，登录后再用su - root 命令切换到系统管理员</p>
</li>
<li><p>再提示符下输入logout 即可注销用户(root下可退回到abc，abc下可退出系统)</p>
</li>
<li><p>logout只能在图形运行级别有效，在运行级别3下无效</p>
</li>
</ul>
<p>3.新建用户</p>
<ul>
<li>添加一个用户milan，默认该用户的家目录在&#x2F;home&#x2F;milan(创建成功后，会自动创建和用户同名的家目录)：useradd milan</li>
</ul>
<ul>
<li><p>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</p>
<ul>
<li>useradd -d &#x2F;home&#x2F;test&#x2F; king ：创建一个用户king，它的家目录在home的test下</li>
</ul>
</li>
<li><p>给用户设置&#x2F;修改密码(要用自己账号或root账号)：passwd 用户名</p>
</li>
<li><p>pwd：显示当前用户所在哪个目录下</p>
</li>
</ul>
<p>4.删除用户</p>
<ul>
<li><p>删除用户，但是保留家目录：userdel 用户名</p>
</li>
<li><p>删除用户以及家目录：userdel -r 用户名</p>
</li>
</ul>
<p>5.查询用户信息：id 用户名</p>
<p>6.切换用户名(高权限到低权限不用密码，低权限到高权限要密码)：su - 用户名</p>
<p>7.查看当前用户：who am i</p>
<p>8.组的介绍</p>
<ul>
<li><p>所有者：一般为文件的创建者，谁创建了该文件，就自然的成为了该文件的所有者</p>
<ul>
<li>查看文件下的所有者：ls -ahl</li>
</ul>
</li>
<li><p>组的创建</p>
<ul>
<li><p>创建一个组family：groupadd family</p>
</li>
<li><p>创建一个用户fox，并放入到family组里：useradd -g family fox</p>
</li>
</ul>
</li>
<li><p>修改文件所在组：chgrp 组名 文件名</p>
</li>
<li><p>改变用户所在组：usermod -g 新组名 用户名</p>
</li>
</ul>
<p>9.用户组(类似于角色，系统可以对共性&#x2F;权限的多个用户进行统一管理)</p>
<ul>
<li><p>新增组：groupadd 组名</p>
</li>
<li><p>删除组：groupdel 组名</p>
</li>
<li><p>增加用户时直接加上组：uesradd -g 用户组 用户名</p>
</li>
<li><p>修改用户的组：usermod -g 用户组 用户名</p>
</li>
</ul>
<p>10.用户和组相关文件</p>
<ul>
<li><p>&#x2F;etc&#x2F;passwd文件：用户的配置文件，记录用户的各种信息</p>
<ul>
<li>每一行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;shadow文件：口令的配置文件</p>
<ul>
<li>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;group文件：组的配置文件，记录Linux包含的组的信息</p>
<ul>
<li>每行含义：组名:口令：组标识符:组内用户列表</li>
</ul>
</li>
</ul>
<p>11.指令的运行级别</p>
<ul>
<li><p>运行级别说明：</p>
<ul>
<li><p>0：关机</p>
</li>
<li><p>1：单用户(找回丢失密码)</p>
</li>
<li><p>2：多用户状态没有网络服务</p>
</li>
<li><p>3：多用户状态有网络服务</p>
</li>
<li><p>4：系统未使用保留给用户</p>
</li>
<li><p>5：图形界面</p>
</li>
<li><p>6：系统重启</p>
</li>
</ul>
</li>
<li><p>切换不同的运行级别：init 数字</p>
</li>
<li><p>查看当前的运行级别：systemctl get-default</p>
</li>
<li><p>设置默认级别：systemctl set-default multi-user.target(3)或graphical.target(5)</p>
<ul>
<li>注：当在Xshell中将默认级别设置为3过后，进行reboot，那么在虚拟机中重启后将是级别3，而不是级别5</li>
</ul>
</li>
</ul>
<h1 id="2-命令指令"><a href="#2-命令指令" class="headerlink" title="2.命令指令"></a>2.命令指令</h1><h2 id="2-1帮助指令"><a href="#2-1帮助指令" class="headerlink" title="2.1帮助指令"></a>2.1帮助指令</h2><p>1.man：获得帮助信息——-&gt;用法：man ls(要退出的话直接输入q)</p>
<p>2.help：获得shell内置目录的帮助信息</p>
<p>注：在Linux下，隐藏文件是以.开头的，选项可以组合使用，如ls -al,或ls -al &#x2F;root</p>
<h2 id="2-2文件目录类指令"><a href="#2-2文件目录类指令" class="headerlink" title="2.2文件目录类指令"></a>2.2文件目录类指令</h2><p>1.pwd指令：显示当前工作目录的绝对路径</p>
<p>2.ls指令：显示目录和文件</p>
<ul>
<li><p>-a：显示当前目录所有的文件和目录，包括隐藏的；</p>
</li>
<li><p>-l：以列表的方式显示信息</p>
</li>
</ul>
<p>3.cd指令：切换到指定目录</p>
<ul>
<li><p>cd ~或者cd回到直接的家目录(root回到&#x2F;root)；</p>
</li>
<li><p>cd ..回到当前目录的上一级目录；</p>
</li>
</ul>
<p>4.mkdir指令：用于创建目录</p>
<ul>
<li><p>home下创建一个dog目录：mkdir &#x2F;home&#x2F;dog</p>
</li>
<li><p>home下创建多级目录：mkdir -p &#x2F;home&#x2F;animal&#x2F;tiger</p>
</li>
</ul>
<p>5.rmdir指令：删除目录</p>
<ul>
<li><p>删除home下的dog空目录：rmdir &#x2F;home&#x2F;dog</p>
</li>
<li><p>删除home下的animal非空目录：rm -rf &#x2F;home&#x2F;animal</p>
</li>
</ul>
<p>6.touch指令：创建空文件</p>
<ul>
<li>在home目录下，创建一个空文件hello.txt：touch &#x2F;home&#x2F;hello.txt</li>
</ul>
<p>7.cp指令：拷贝文件到指定目录</p>
<ul>
<li><p>将&#x2F;home&#x2F;hello.txt拷贝到&#x2F;home&#x2F;bbb目录下：cp &#x2F;home&#x2F;hello.txt &#x2F;home&#x2F;bbb</p>
</li>
<li><p>递归复制整个文件夹，如将&#x2F;home&#x2F;bbb整个目录，拷贝到&#x2F;opt：cp -r &#x2F;home&#x2F;bbb &#x2F;opt</p>
</li>
</ul>
<p>注：cp -r &#x2F;home&#x2F;bbb &#x2F;opt强制覆盖不提醒</p>
<p>8.rm指令：移除文件或目录</p>
<ul>
<li><p>-r：递归删除整个文件夹；</p>
</li>
<li><p>-f：强制删除不提示；</p>
<ul>
<li><p>将&#x2F;home&#x2F;hello.txt删除：rm &#x2F;home&#x2F;hello.txt</p>
</li>
<li><p>递归删除(不提示)整个文件夹&#x2F;home&#x2F;bbb：rm -rf &#x2F;home&#x2F;bbb</p>
</li>
</ul>
</li>
</ul>
<p>9.mv指令：移动文件与目录或重命名</p>
<ul>
<li><p>将&#x2F;home&#x2F;dog.txt文件重命名为pig.txt(同一个目录下)：mv &#x2F;home&#x2F;dog.txt &#x2F;home&#x2F;pig.txt</p>
</li>
<li><p>将&#x2F;home&#x2F;dog.txt文件移动到&#x2F;root目录下(不同目录下)：mv &#x2F;home&#x2F;dog.txt &#x2F;root</p>
</li>
<li><p>将&#x2F;home&#x2F;dog.txt文件移动到&#x2F;root目录下并重命名为pig.txt：mv &#x2F;home&#x2F;dog.txt &#x2F;root&#x2F;pig.txt</p>
</li>
<li><p>移动整个目录，如将 &#x2F;opt&#x2F;bbb移动到&#x2F;home下：mv &#x2F;opt&#x2F;bbb &#x2F;home</p>
</li>
</ul>
<p>10.cat指令：查看文件内容，但不能修改(-n可以显示行号)</p>
<ul>
<li>查看&#x2F;etc&#x2F;profile文件内容，并显示行号：cat -n &#x2F;etc&#x2F;profile</li>
</ul>
<p>注：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道指令|more进行交互</p>
<p>11.more指令</p>
<p>是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more有若干快捷键(交互的指令)，如空白健(向下翻一页)、Enter(向下翻一行)等</p>
<ul>
<li>浏览文件内容：more &#x2F;etc&#x2F;profile</li>
</ul>
<p>12.less指令：分屏查看文件内容，功能与more类似，但比more指令更强大，</p>
<ul>
<li>浏览文件内容：less &#x2F;opt&#x2F;杂文.txt</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/2.png"></p>
<p>12.echo指令：输出内容到控制台</p>
<ul>
<li>echo $PATH 或者echo $HOSTNAME<ul>
<li>输出hello：echo “hello”</li>
</ul>
</li>
</ul>
<p>13.head指令：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
<ul>
<li><p>查看&#x2F;etc&#x2F;profile文件的前10行：head &#x2F;etc&#x2F;profile</p>
</li>
<li><p>查看&#x2F;etc&#x2F;profile文件的前5行：head -n 5 &#x2F;etc&#x2F;profile</p>
</li>
</ul>
<p>14.tail：指令用于显示文件的尾部的内容，默认情况下head指令显示文件的尾10行内容</p>
<ul>
<li><p>查看&#x2F;etc&#x2F;profile文件的尾10行：tail &#x2F;etc&#x2F;profile</p>
</li>
<li><p>查看&#x2F;etc&#x2F;profile文件的尾5行：tail -n 5 &#x2F;etc&#x2F;profile</p>
</li>
<li><p>补：tail指令可以实时地追踪文档的所有变化：tail -f &#x2F;home&#x2F;hello.txt(Ctrl+c退出监控)</p>
</li>
</ul>
<p>15.&gt;指令和&gt;&gt;指令</p>
<ul>
<li><p>ls -l &gt;文件：列表的内容写入文件(a.txt)中—&gt;会覆盖</p>
</li>
<li><p>ls -al &gt;&gt;文件：列表的内容追加到文件(aa.txt)的末尾</p>
</li>
<li><p>cat 文件1 &gt;文件2：将文件1的内容覆盖到文件</p>
<ul>
<li><p>echo “内容”&gt;&gt;文件：追加</p>
</li>
<li><p>将&#x2F;home目录下的文件列表写入到&#x2F;home&#x2F;info.txt中(覆盖)：ls -l &#x2F;home &gt; &#x2F;home&#x2F;info.txt(如果没有该文件，会自动创建)</p>
</li>
<li><p>将当前日历信息追加到&#x2F;home&#x2F;mycal文件中：cal &gt;&gt; &#x2F;home&#x2F;mycal</p>
</li>
</ul>
</li>
</ul>
<p>16.ln指令：ln 命令用于创建链接。具体而言，ln 命令可以用来创建硬链接或符号链接(软链接)。软链接类似于windows里的快捷方式</p>
<ul>
<li><p>在&#x2F;home目录下创建一个软链接myroot，连接到&#x2F;root目录：ln -s &#x2F;root &#x2F;home&#x2F;myroot</p>
</li>
<li><p>删除软链接myroot：rm &#x2F;home&#x2F;myroot</p>
</li>
<li><p>创建硬链接：使用 ln 命令时，如果不指定任何选项，默认情况下会创建硬链接。硬链接是指多个文件名指向同一个索引节(inode)，它们在文件系统中实际上指向相同的数据块。</p>
</li>
<li><p>如：创建一个名为 b.c 的硬链接，指向与 a.c 相同的文件数据:ln a.c b.c</p>
</li>
</ul>
<p>17.history指令：查看已经执行过历史命令，也可以执行历史指令</p>
<ul>
<li><p>显示所有的历史指令：history</p>
</li>
<li><p>显示最近使用过的10个指令：history 10</p>
</li>
<li><p>执行历史编号为5的指令：!5</p>
</li>
</ul>
<h2 id="2-3时间日期类指令"><a href="#2-3时间日期类指令" class="headerlink" title="2.3时间日期类指令"></a>2.3时间日期类指令</h2><p>1.date指令：显示当前日期</p>
<ul>
<li><p>显示当前年份、月份、具体哪一天：date +%Y、date +%m、date +%d</p>
</li>
<li><p>显示年月日时分秒：date “+%Y-%m-%d %H:%M%S”</p>
</li>
</ul>
<p>2.cal指令：查看日历</p>
<ul>
<li><p>显示当前日历：cal</p>
</li>
<li><p>显示1999年日历：cal 1999</p>
</li>
</ul>
<h2 id="2-4搜索查找类指令"><a href="#2-4搜索查找类指令" class="headerlink" title="2.4搜索查找类指令"></a>2.4搜索查找类指令</h2><p>1.find指令：将从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录显示在终端</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/3.png"></p>
<ul>
<li><p>按文件名查找：根据名称查找&#x2F;home目录下的hello.txt：find &#x2F;home -name hello.txt</p>
</li>
<li><p>按拥有者查找：查找&#x2F;opt目录下，用户名称为nobody的文件：find &#x2F;opt -user nobody</p>
</li>
<li><p>按文件大小查找：查找整个linux系统下大于200M的文件(+n大于 -n小于 n等于，单位K,	M,G)：find &#x2F; -size +200M</p>
</li>
</ul>
<p>2.locate指令：可以快速定位文件路径，locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件(无需遍历整个文件系统)</p>
<p>注：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p>
<ul>
<li>利用locate指令快速定位hello.txt文件所在目录：locate hello.txt</li>
</ul>
<p>3.which指令：可以查看某个指令在哪个目录下，比如ls指令在哪个目录下(which ls)</p>
<p>4.grep指令和管道符号|：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理</p>
<ul>
<li>-n：显示匹配及其行号；-i：忽略字母大小写；<ul>
<li>在hello.txt文件中，查找”yes”所在行，并显示行号： cat &#x2F;home&#x2F;hello.txt | grep -n “yes” 或者 grep -n “yes” &#x2F;home&#x2F;hello.txt</li>
</ul>
</li>
</ul>
<h2 id="2-5压缩和解压类指令"><a href="#2-5压缩和解压类指令" class="headerlink" title="2.5压缩和解压类指令"></a>2.5压缩和解压类指令</h2><p>市面上有非常多的压缩格式</p>
<ul>
<li><p>zip格式：Linux、Windows、MacOS常用</p>
</li>
<li><p>7zip和rar：Windows常用</p>
</li>
<li><p>tar和gzip：Linux、MacOS常用</p>
</li>
</ul>
<p>1.gzip&#x2F;gunzip指令：gzip用于压缩文件，gunzip用于解压文件</p>
<ul>
<li><p>gzip压缩，将&#x2F;home下的hello.txt文件进行压缩：gzip &#x2F;home&#x2F;hello.txt</p>
</li>
<li><p>gunzip解压，将&#x2F;home下的hello.txt.gz文件进行解压：gunzip &#x2F;home&#x2F;hello.txt.gz</p>
</li>
</ul>
<p>2.zip&#x2F;unzip指令：zip用于压缩文件，unzip用于解压的。这个在项目打包发布中很有用</p>
<ul>
<li>-r：递归压缩，即压缩目录<ul>
<li>将&#x2F;home下的所有文件&#x2F;文件夹进行压缩成myhome.zip：zip -r myhome.zip &#x2F;home</li>
</ul>
</li>
<li>-d&lt;目录&gt;：指定解压后文件的存放目录<ul>
<li>将myhome.zip解压到&#x2F;opt&#x2F;tmp目录下：unzip -d &#x2F;opt&#x2F;tmp &#x2F;home&#x2F;myhome.zip</li>
</ul>
</li>
</ul>
<p>3.tar指令：是打包指令，最后打包后的文件是.tar.gz文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/4.png"></p>
<ul>
<li><p>压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz：tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt</p>
</li>
<li><p>将&#x2F;home的文件夹压缩成myhome.tar.gz：tar -zcvf myhome.tar.gz &#x2F;home</p>
</li>
<li><p>将pc.tar.gz解压到当前目录：tar -zxvf pc.tar.gz</p>
</li>
<li><p>将myhome.tar.gz解压到&#x2F;opt.tmp2目录下：tar -zxvf &#x2F;home&#x2F;myhome&#x2F;.tar.gz -C &#x2F;opt&#x2F;tmp2</p>
</li>
</ul>
<h1 id="3-Linux系统操作"><a href="#3-Linux系统操作" class="headerlink" title="3.Linux系统操作"></a>3.Linux系统操作</h1><h2 id="3-1权限"><a href="#3-1权限" class="headerlink" title="3.1权限"></a>3.1权限</h2><p>1.权限的基本介绍</p>
<ul>
<li><p>第0位确定文件的类型(d、-、l、c、b)</p>
<ul>
<li><p>d是目录，相当于windows的文件夹</p>
</li>
<li><p>-是普通文件</p>
</li>
<li><p>l是链接，相当于windows的快捷方式</p>
</li>
<li><p>c是字符设备文件、比如鼠标、键盘</p>
</li>
<li><p>b是块设备，比如硬盘</p>
</li>
</ul>
</li>
<li><p>第1-3位确定所有者拥有该文件的权限</p>
</li>
<li><p>第4-6位确定所属组拥有该文件的权限</p>
</li>
<li><p>第7-9位确定其他用户拥有该文件的权限</p>
</li>
</ul>
<p>2.rwx权限详解(难)</p>
<ul>
<li><p>rxw作用到文件</p>
<ul>
<li><p>r代表可读：可以读取，查看</p>
</li>
<li><p>w代表可写：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件</p>
</li>
<li><p>x代表可执行：可以被执行</p>
</li>
</ul>
</li>
<li><p>rwx作用到目录</p>
<ul>
<li><p>r代表可读：可以读取，ls查看目录内容</p>
</li>
<li><p>w代表可写：可以修改，对目录内创建创建+删除+重命名目录</p>
</li>
<li><p>x代表可执行：可以进入该目录</p>
</li>
</ul>
</li>
</ul>
<p>3.修改权限</p>
<p>chmod：可以修改文件或者目录的权限</p>
<ul>
<li><p>第1种方式：用+、-、&#x3D;变更权限，其中u是所有者、g是所有组、o是其他人、a是所有人(u、g、o的总和)</p>
<ul>
<li><p>给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx abc</p>
</li>
<li><p>给abc文件的所有者除去执行的权限，增加组写的权限：chmod u-x,g+w abc</p>
</li>
<li><p>给abc文件的所有用户添加读的权限：chmod a+r abc</p>
</li>
</ul>
</li>
<li><p>第2种方式：通过数字变更权限(r&#x3D;4,w&#x3D;2,x&#x3D;1)</p>
<ul>
<li><p>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名  相当于  chmod 751 文件目录名</p>
</li>
<li><p>将&#x2F;home&#x2F;abc.txt文件的权限修改成rwxr-xr-x，使用给数字的方式实现：chmod 755 &#x2F;home&#x2F;abc.txt</p>
</li>
</ul>
</li>
</ul>
<p>4.修改所有者和所在组</p>
<ul>
<li><p>修改文件&#x2F;目录所有者：chown 用户名 文件名</p>
<ul>
<li>将hello.txt文件的所有者从root改为lxx：chown lxx &#x2F;home&#x2F;hello.txt</li>
</ul>
</li>
<li><p>修改文件&#x2F;目录 改变所有者和所在主：chown 用户名:所在主 文件名</p>
<ul>
<li><p>-R：如果是目录，则使其下所有子文件或目录递归生效</p>
</li>
<li><p>将&#x2F;home&#x2F;test目录下所有的文件和目录的所有者都修改成tom：chown -R tom &#x2F;home&#x2F;test</p>
</li>
</ul>
</li>
<li><p>修改文件所在组：chgrp 组名 文件&#x2F;目录</p>
<ul>
<li><p>将&#x2F;home&#x2F;abc.txt文件的所在组修改成shaolin：chgrp shaolin &#x2F;home&#x2F;abc.txt</p>
</li>
<li><p>将&#x2F;home&#x2F;test.txt目录下所有的文件和目录的所在组都修改成shaolin：chgrp -R shaolin &#x2F;home&#x2F;test</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2crond任务调度"><a href="#3-2crond任务调度" class="headerlink" title="3.2crond任务调度"></a>3.2crond任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p>
<ul>
<li><p>-e：编辑crontab定时任务</p>
</li>
<li><p>-l：查询crontab任务</p>
</li>
<li><p>-r：删除当前用户所有的crontab任务</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/6.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/7.png"></p>
<p>1.将&#x2F;etc下的文件每各一分钟打印一次，到&#x2F;home&#x2F;to.txt文件中：</p>
<ul>
<li><p>crontab -e：进入编辑任务的页面，然后按i进入编辑模式</p>
</li>
<li><p>*&#x2F;1 * * * * ls -l &#x2F;etc &gt; &#x2F;home&#x2F;to.txt：在编辑模式下输入指令，按esc退出编辑模式，输入:wq保存退出</p>
</li>
</ul>
<p>2.每隔1分钟，将当前日期和日历都追加到&#x2F;home&#x2F;mycal文件中：</p>
<ul>
<li><p>a:输入vim &#x2F;home&#x2F;my.sh ，写入内容date &gt;&gt; &#x2F;home&#x2F;mycal和cal &gt;&gt; &#x2F;home&#x2F;mycal；</p>
</li>
<li><p>b:给my.sh增加执行权限，chmod u+x &#x2F;home&#x2F;my.sh；</p>
</li>
<li><p>c:crontab -e 写入*&#x2F;1 * * * * &#x2F;home&#x2F;my.sh；</p>
</li>
</ul>
<p>3.每天凌晨2点将mysql数据库testdb，备份到文件中：</p>
<ul>
<li>0 2 * * * mysqldump -u root -p密码 数据库 &gt; &#x2F;home&#x2F;db.bak</li>
</ul>
<p>4.crond相关指令</p>
<ul>
<li><p>crontab -r：终止任务调度</p>
</li>
<li><p>crontab -l：列出当前有哪些任务调度</p>
</li>
<li><p>service crond restart：重启任务调度</p>
</li>
</ul>
<h2 id="3-3at定时任务"><a href="#3-3at定时任务" class="headerlink" title="3.3at定时任务"></a>3.3at定时任务</h2><p>1.注意事项：</p>
<ul>
<li><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行；</p>
</li>
<li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</p>
</li>
<li><p>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了；</p>
</li>
<li><p>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/8.png"></p>
<p>2.表示方式</p>
<ul>
<li><p>ps -ef | grep atd：可以检测atd是否在</p>
</li>
<li><p>at命令格式：at 选项 时间</p>
</li>
<li><p>Ctrl + D：结束at命令的输入</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/9.png"></p>
<ul>
<li><p>2天后的下午5点执行&#x2F;bin&#x2F;ls &#x2F;home：at 5pm + 2days 回车，输入&#x2F;bin&#x2F;ls &#x2F;home ctrl+d(2次)</p>
</li>
<li><p>查看系统中还没有执行的工作任务：atq</p>
</li>
<li><p>明天17点钟，输出时间到指定文件内&#x2F;root&#x2F;date100.log：at 5pm tomorrow 回车，date &gt; &#x2F;root&#x2F;date100.log ctrl+d(2次)</p>
</li>
<li><p>2分钟后，输出时间到指定文件内&#x2F;root&#x2F;date200.log：at now + 2minutes 回车，date &gt; &#x2F;root&#x2F;date200.log  ctrl+d(2次)</p>
</li>
<li><p>删除已经设置好的案例：atrm 编号</p>
</li>
</ul>
<h2 id="3-4Linux分区"><a href="#3-4Linux分区" class="headerlink" title="3.4Linux分区"></a>3.4Linux分区</h2><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘。对于IDE硬盘，驱动器标识符为hdx~，hd表明分区所在设备的类型，波浪线代表分区。如hda3表示为第一个IDE硬盘上的第三个主分区；hdb2表示为第二个IDE硬盘上的第二个主分区。(1到4表示主分区或扩展分区，从5开始就是逻辑分区)</p>
<p>对于SCSI硬盘，标识符为sdx~，sd来表示分区所在设备的类型，其余和IDE硬盘一样。</p>
<ul>
<li>查看所有设备的挂载情况：lsblk或者lsblk -f</li>
</ul>
<p>1.虚拟机增加硬盘后挂载</p>
<ul>
<li><p>分区命令：fdisk &#x2F;dev&#x2F;sdb</p>
</li>
<li><p>涉及m 的相关命令列表</p>
<ul>
<li><p>p显示磁盘分区 同 fdisk -l</p>
</li>
<li><p>n 新增分区</p>
</li>
<li><p>d 删除分区</p>
</li>
<li><p>w 写入并退出</p>
</li>
</ul>
</li>
</ul>
<p>2.步骤(对sdb进行分区)：</p>
<ul>
<li><p>在虚拟机菜单中，选择[设置]，然后设备列表下面点[添加]，选择[硬盘]，然后一路下一步，完成后需要重启系统</p>
</li>
<li><p>对sdb分区，输入fdisk &#x2F;dev&#x2F;sdb —-&gt; 获取指令，输入m —–&gt; 添加一个新的分区，输入n —–&gt;按主分区来分，输入p —-&gt; 选择分区数，输入1 —–&gt; 然后2次回车 —-&gt; 相当于保存并退出，输入w(q表示上述操作不保存)</p>
</li>
<li><p>格式化磁盘：mkfs -t ext4 &#x2F;dev&#x2F;sdb1    (其中ext4是分区类型)</p>
</li>
<li><p>挂载：将一个分区与一个目录联系起来</p>
</li>
</ul>
<p>3.mount 设备名称 挂载目录</p>
<ul>
<li>如sdb1挂载到根目录下的newdisk：mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk</li>
</ul>
<p>4.取消挂载点：umount 设备名称&#x2F;挂载目录</p>
<ul>
<li>如取消sdb1在目录newdisk上的挂载点：umount &#x2F;dev&#x2F;sdb1  或者  umount &#x2F;newdisk</li>
</ul>
<p>注：用命令行进行挂载，重启后会失效</p>
<p>5.永久挂载：通过修改&#x2F;etc&#x2F;fstab实现挂载，添加完成后 执行mount -a 即刻生效(不需要重启)</p>
<p>6.磁盘情况查询</p>
<ul>
<li><p>-s：指定目录占用大小汇总</p>
</li>
<li><p>-h：带计量单位</p>
</li>
<li><p>-a：含文件(目录)</p>
</li>
<li><p>–max-depth&#x3D;1：子目录深度</p>
</li>
<li><p>-c：列出明细的同时，增加汇总值</p>
<ul>
<li><p>如查询&#x2F;opt目录下的磁盘占用情况，深度为1：du -h –max-depth&#x3D;1 &#x2F;opt</p>
</li>
<li><p>查询系统整体磁盘使用情况：df -h</p>
</li>
<li><p>查询指定目录的磁盘占用情况(默认为当前目录)：du -h</p>
</li>
</ul>
</li>
</ul>
<p>7.磁盘情况-工作实用指令</p>
<ul>
<li><p>统计&#x2F;opt文件夹下文件的个数：ls -l &#x2F;opt | grep “^-” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下目录的个数：ls -l &#x2F;opt | grep “^d” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下文件的个数，包括子文件夹里的：ls -lR &#x2F;opt | grep “^-” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下目录的个数，包括子文件夹里的：ls -lR &#x2F;opt | grep “^d” | wc -l</p>
</li>
<li><p>以树状显示目录结构tree目录，注意，如果没有tree，则使用yum install tree安装：tree 文件名</p>
</li>
</ul>
<h1 id="4-网路配置"><a href="#4-网路配置" class="headerlink" title="4.网路配置"></a>4.网路配置</h1><h2 id="4-1环境配置"><a href="#4-1环境配置" class="headerlink" title="4.1环境配置"></a>4.1环境配置</h2><p>1.ping测试当前服务器是否可以连接目的主机：ping ip(目的主机IP)</p>
<p>2、wget是非交互式的文件下载器，可以在命令行内下载网络文件</p>
<ul>
<li><p>-b是可选，表示后台下载，并将日志写入到当前工作目录的wget-log文件</p>
</li>
<li><p>url是下载链接</p>
<ul>
<li>语法：wget -b url</li>
</ul>
</li>
</ul>
<p>3、linux网络环境配置</p>
<p>第1种方法(自动获取)</p>
<ul>
<li>说明：登录后，通过界面的来设置自动获取ip；特点：linux启动后会自动获取ip；缺点：每次自动获取的ip地址可能不一样；</li>
</ul>
<p>第2种方法(指定ip)</p>
<ul>
<li>说明：直接修改配置文件来指定IP，并可以连接到外网(程序员推荐)</li>
<li>编辑：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</li>
<li>要求：将ip地址配置为静态的，比如：ip地址为192.168.93.39</li>
</ul>
<p>修改后需要停止和启动网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop network</span><br><span class="line">systemctl start network</span><br></pre></td></tr></table></figure>

<p>4.设置主机名和hosts映射</p>
<p>为了方便记忆，可以给linux系统设置主机名，也可以根据需要修改主机名</p>
<ul>
<li><p>方法1：修改文件在&#x2F;etc&#x2F;hostname，终端输入：vim &#x2F;etc&#x2F;hostname 回车打开文件后在里面修改主机名即可。修改后，重启生效</p>
</li>
<li><p>方法·2：直接终端输入：hostnamectl set-hostname 修改主机名 回车完成后重启</p>
</li>
<li><p>查看主机名指令：hostname</p>
</li>
</ul>
<p>2.设置hosts映射</p>
<p>windows系统：</p>
<ul>
<li><p>在C:\Windows\System32\drivers\etc\hosts文件(该文件是记录主机与ip映射的文件)指定即可：</p>
<ul>
<li><p>如：192.168.88.93  lxx</p>
</li>
<li><p>完成后就可以在windows下通过ping lxx来ping通</p>
</li>
</ul>
</li>
<li><p>如果因为权限问题遇到hosts文件不能打开解决办法：</p>
<ul>
<li><p>1.可以先拖到桌面，修改后再拖回etc下</p>
</li>
<li><p>2.可以通过管理员身份打开记事本，然后再记事本里面找到该文件，可以直接修改。</p>
</li>
</ul>
</li>
</ul>
<p>linux系统：</p>
<ul>
<li>在&#x2F;etc&#x2F;hosts文件指定：<ul>
<li>如：vim &#x2F;etc&#x2F;hosts 回车打开该文件</li>
<li>192.168.200.1(vmnet8的ip) windows的主机名</li>
</ul>
</li>
</ul>
<p>完成后就可以在linux下通过 ping windows主机名 来ping通</p>
<p>3.主机名解析过程分析(hosts、DNS)</p>
<p>hosts是一个文本文件，用来记录IP和主机名的映射关系；DNS就是domain name system的缩写，翻译过来就是域名系统；是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>
<p>应用实例1：用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></p>
<ul>
<li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存(本地的)，如果有就直接返回IP完成解析。这两个缓存可以理解为本地解析器缓存；</p>
</li>
<li><p>如果本地解析器缓存没有找到对应的映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回；</p>
</li>
<li><p>如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS(互联网的)进行解析域；</p>
</li>
</ul>
<p>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存它的IP地址(DNS解析记录)。在cmd窗口可以输入</p>
<p>应用实例2：访问<a href="http://www.baidu.com的流程如下：">www.baidu.com的流程如下：</a></p>
<ul>
<li><p>先查看本机的记录(私人地址本)，Windows看：C:\Windows\System32\drivers\etc\hosts；Linux看：&#x2F;etc&#x2F;hosts</p>
</li>
<li><p>没有找到的话，再联网去DNS服务器(如114.114.114.114，8.8.8.8)寻找&#x2F;访问</p>
</li>
</ul>
<p>在windows系统</p>
<ul>
<li><p>查看DNS解析器缓存(本地的)：ipconfig &#x2F;displaydns</p>
</li>
<li><p>手动清理DNS缓存：ipconfig &#x2F;flushdns</p>
</li>
</ul>
<p>在hosts文件夹下如果被人修改，当访问百度网站时，会跳入到别人的ip地址</p>
<h1 id="5-网络知识"><a href="#5-网络知识" class="headerlink" title="5.网络知识"></a>5.网络知识</h1><h2 id="5-1进程基本介绍"><a href="#5-1进程基本介绍" class="headerlink" title="5.1进程基本介绍"></a>5.1进程基本介绍</h2><p>在Linux中，每个执行的程序都称为一个进程，每一个进程都分配一个ID号(pid,进程号)。每个进程都可能以两种方式存在的，前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的(占用屏幕，直到退出才能进行其他操作)；后台进程则是实际在操作，但由于屏幕上无法看到的进程。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</p>
<p>1.程序与进程的关系：程序在没有运行的时候就是一段代码，一旦运行了，就会被加载到内存，然后它就是进程了</p>
<p>2.ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况(可以不加任何参数，也可以混合使用)</p>
<ul>
<li><p>ps -a：显示当前终端的所有进程信息；</p>
</li>
<li><p>ps -u：以用户的格式显示进程信息；</p>
</li>
<li><p>ps -x：显示后台进程运行的参数；</p>
</li>
<li><p>查看系统正在执行进程的状况：ps -aux</p>
</li>
</ul>
<p>3.对ps指令的一些指标介绍</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/10.png"></p>
<p>USER：进程执行用户；PID：进程号；%CPU：占用cpu的百分比；%MEM：占用物理内存的百分比；VSZ：占用虚拟内存的大小；RSS：占用物理内存的大小；TTY：终端机号；STAT：运行状态；START：执行的开始时间；TIME：占用的cpu时间；COMMAND：进程名，启动该进程所用的命令和参数，如果过长会被截断显示</p>
<p>例如：查看有没有sshd服务：ps -aux | grep sshd ———–&gt; 回车后只看第一条</p>
<p>在STAT进程状态中，其中S-表示睡眠，s-表示该进程是会活的先导进程，N-表示进程拥有比普通进程优先级更低的优先级，R-表示正在运行，D-表示短期等待，Z-表示僵死进程(进程已经死掉，但内存未被释放，需要定时进行清除)，T-表示被跟踪或者被停止等等</p>
<p>4.终止进程kill和killall</p>
<p>若是某个进程执行一半需要停止时，或是已消耗了很大的系统资源时，此时可以考虑停止该进程。使用kill或killall命令来完成此项任务</p>
<ul>
<li><p>通过进程号杀死\终止进程：kill 进程号</p>
</li>
<li><p>通过进程名杀死\终止进程：killall 进程名</p>
<ul>
<li>注意：这种方式会杀掉下面所有的子进程</li>
</ul>
</li>
<li><p>-9：表示强迫进程立即停止(有些情况下，因为系统保护机制下，会忽略kill和killall)</p>
</li>
</ul>
<p>例如：当远程通过fox用户连接linux系统后</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/11.png"></p>
<ul>
<li>踢掉fox非法登录用户：kill 5024</li>
</ul>
<p>小例子：</p>
<ul>
<li><p>终止远程登录服务sshd(其它设备就连不上linux系统了)：kill 1433</p>
</li>
<li><p>重启sshd服务：&#x2F;bin&#x2F;systemctl start sshd.servic</p>
</li>
<li><p>终止多个gedit(打开两个文件夹)：killall gedit 回车后会关闭打开的文件夹</p>
</li>
<li><p>强制杀掉一个终端： 先通过ps -aux | grep bash 查看要杀掉的终端进程号；然后终端输入：kill -9 bash对应的进程号</p>
</li>
</ul>
<p>5.查看进程树pstree(只输入pstree，查看得不清楚)</p>
<p>-p：显示进程的PID(进程号)；-u：显示进程的所属用户；</p>
<p>案例1：以树状的形式显示进程的pid：pstree -p</p>
<p>案例2：以树状的形式显示进程的用户：pstree -u</p>
<h1 id="6-服务-service-管理"><a href="#6-服务-service-管理" class="headerlink" title="6.服务(service)管理"></a>6.服务(service)管理</h1><p>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如(mysqld,sshd,防火墙等)，因此又称为守护进程，是linux中非常重要的知识点</p>
<p>1.service管理指令</p>
<p>service 服务名 [start|stop|restart|reload|status]</p>
<ul>
<li>案例：使用service指令关闭和启动network：service network stop；service network start</li>
</ul>
<p>2.chkconfig指令</p>
<p>通过chkconfig命令可以给服务的各个运行级别设置自 启动&#x2F;关闭</p>
<p>查看服务：chkconfig –list    需要过滤的话可以在后面加|grep xxx</p>
<p>修改运行级别是自 启动&#x2F;关闭：chkconfig –level 3 network on&#x2F;off</p>
<p>案例：把network在3运行级别，关闭自启动以及开启：</p>
<ul>
<li><p>chkconfig –level 3 network off</p>
</li>
<li><p>chkconfig –level 3 network on</p>
</li>
</ul>
<p>使用细节：chkconfig重新设置服务后自启动或关闭，需要重启机器reboot生效。</p>
<p>3.systemctl管理指令</p>
<ul>
<li><p>查看及修改某个服务状态：systemctl [start|stop|restart|reload|status] 服务名(这种方式修改的状态是临时生效，当重启系统后，还是回归以前对系统的设置)</p>
</li>
<li><p>systemctl指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看</p>
</li>
<li><p>查看服务开机启动状态，grep可以进行过滤：systemctl list-unit-files [| grep 服务名]</p>
</li>
</ul>
<p>设置服务开机启动：systemctl enable 服务名(永久生效)</p>
<p>关闭服务开机启动：systemctl disable 服务名(永久生效)</p>
<p>查询某个服务是否是自启动的：systemctl is-enabled 服务名</p>
<p>查看当前防火墙状况，关闭防火墙和重启防火墙：</p>
<ul>
<li>systemctl status firewalld；systemctl stop firewalld</li>
</ul>
<p>4、打开或者关闭指定端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/12.png"></p>
<p>在真正的生成环境，往往需要将防火墙打开，但问题来了，如果把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定端口，比如80、22、8080等。</p>
<p>查看端口号对应的协议：netstat -anp</p>
<p>5.firewall指令</p>
<p>打开端口：firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</p>
<p>关闭端口：firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</p>
<p>完成后，重新载入才能生效：firewall-cmd –reload</p>
<p>查询端口是否开放：firewall-cmd –query-port&#x3D;端口号&#x2F;协议</p>
<p>namp可以查看端口占用情况(yum -y install nmap)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/13.png"></p>
<p>可以看到：本机(127.0.0.1)上有4个端口现在被程序占用</p>
<p>6.动态监控进程</p>
<p>top与ps命令很相似，它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的进程</p>
<p>基本语法：top [选项]</p>
<ul>
<li><p>-d 秒数：指定top命令每隔几秒更新，默认是3秒</p>
</li>
<li><p>-i：使top不显示任何闲置或者僵死进程</p>
</li>
<li><p>-p：通过指定监控进程ID来仅仅监控某个进程的状态</p>
</li>
</ul>
<p>案例：指定top命令每隔5秒更新：top -d 5</p>
<p>7.交互操作说明(在top界面使用)</p>
<ul>
<li><p>P：以cpu使用率排序，，默认就是此项</p>
</li>
<li><p>M：以内存的使用率排序</p>
</li>
<li><p>N：以PID排序</p>
</li>
<li><p>q：退出top</p>
</li>
</ul>
<p>案例：监视特定用户，比如我们监控fox用户：</p>
<ul>
<li>在top(查看执行进程的)界面，按u，然后输入用户名，回车；</li>
</ul>
<p>案例：终止指定的进程，比如结束fox登录：</p>
<ul>
<li>在top(查看执行进程的)界面，按k，输入要结束进程的PID号(fox登录后，bash进程的PID号)，最后输入9，表示强制结束；</li>
</ul>
<p>8.netstat查看系统网络情况</p>
<p>基本语法：netstat [选项]</p>
<ul>
<li>-an：按一定顺序排列输出</li>
<li>-p：显示对应的进程</li>
</ul>
<p>案例：查看服务名为sshd的服务信息：netstat -anp | grep sshd</p>
<p>检测主机连接命令ping：是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障；</p>
<p>环境变量PATH：在前面提出的问题中，我们说无论当前的工作目录是什么，都能执行&#x2F;user&#x2F;bin&#x2F;cd这个程序，这个就是借助环境变量中，PATH这个项目的值来做的</p>
<h1 id="7-下载包"><a href="#7-下载包" class="headerlink" title="7.下载包"></a>7.下载包</h1><p>1.rpm包的管理</p>
<p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager(RedHat软件包管理工具)的缩写，类似windows的setup.exe。</p>
<p>查询已安装的rpm列表： rpm -qa | grep xxx</p>
<ul>
<li>举例：查看当前系统，是否已经安装了firefox：rpm -qa | grep firefox 或 rpm -q firefox</li>
</ul>
<p>查询软件包信息：rpm -qi 软件包名</p>
<ul>
<li>举例：查询火狐信息：rpm -qi firefox</li>
</ul>
<p>查询软件包的位置及其包含的文件：rpm -ql 软件包名</p>
<ul>
<li>举例：查询火狐的位置及其包含的文件：rpm -ql firefox</li>
</ul>
<p>查询文件所属的软件包：rpm -qf 文件全路径名</p>
<ul>
<li>举例：查询&#x2F;etc&#x2F;passwd所属的软件包：rpm -qf &#x2F;etc&#x2F;passwd</li>
</ul>
<p>卸载rpm包：rpm -e RPM包的名称</p>
<ul>
<li><p>案例：删除firefox包：rpm -e firefox</p>
</li>
<li><p>注意：有些包卸载后会对其它依赖的包产生错误信息，删除时系统会提醒，强制删除可以加–nodeps；如rpm -e –nodeps 软件包名</p>
</li>
</ul>
<p>安装rpm包：rpm -ivh RPM包全路径名称</p>
<ul>
<li>i&#x3D;install：安装</li>
<li>v&#x3D;verbose：提示</li>
<li>h&#x3D;hash：进度条</li>
</ul>
<p>2.yum</p>
<p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所以依赖的软件包</p>
<ul>
<li><p>查询yum服务器是否有需要安装的软件：yum list | grep 软件名</p>
</li>
<li><p>安装指定的yum包：yum install 软件名</p>
</li>
</ul>
<p>案例：使用yum的方式来安装firefox：yum list | grep firefox ; yum install firefox</p>
<h1 id="8-日志"><a href="#8-日志" class="headerlink" title="8.日志"></a>8.日志</h1><h2 id="8-1日志介绍"><a href="#8-1日志介绍" class="headerlink" title="8.1日志介绍"></a>8.1日志介绍</h2><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等</p>
<p>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。可以这样理解，日志是用来记录重大事件的工具</p>
<p>1.&#x2F;var&#x2F;log 目录就是系统日志文件的保存位置，系统常用的日志(一般用cat来查看)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/14.png"></p>
<p>案例：使用root用户通过xshell登录，第一次使用错误的密码，第二次使用正确的密码登录，看看在日志文件&#x2F;var&#x2F;log&#x2F;secure里有没有记录相关信息。</p>
<ul>
<li><p>先清空secure文件里的内容，后面查看更方便(在log目录下)：echo ‘’ &gt; secure</p>
</li>
<li><p>退出输入错误密码，再输入正确密码后：cat secure</p>
</li>
</ul>
<p>2.日志管理服务</p>
<p>在配置文件&#x2F;etc&#x2F;rsyslog.conf里面记录了我们的日志服务程序rsyslogd管理或者维护的相关日志以及放在哪个文件里。日志管理很重要，需要保证Linux的rsyslogd服务是启动状态以及是自启动</p>
<p>案例：查询Linux中的rsyslogd服务是否启动：pa aux | grep “rsyslog” | grep -v “grep”</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/15.png"></p>
<p>注意：-v表示不包含后面括号里面的那一行(反向匹配)</p>
<p>案例：查询rsyslogd服务的自启动状态：systemctl list-unit-files | grep rsyslog</p>
<p>3.配置文件(重要)：&#x2F;etc&#x2F;rsyslog.conf</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/16.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/17.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/18.png"></p>
<p>案例：查看一下&#x2F;var&#x2F;log&#x2F;secure日志，这个日志中记录的是用户验证和授权方面的信息，来分析如何查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/19.png"></p>
<p>案例(自定义一个日志)：在&#x2F;etc&#x2F;rsyslog.conf中添加一个日志文件&#x2F;var&#x2F;log&#x2F;hsp.log，当有事件发送时(比如sshd服务相关事件)，该文件会接收到信息并保存</p>
<ul>
<li>vim &#x2F;etc&#x2F;rsyslog.conf  ——————–&gt;打开配置文件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/20.png"></p>
<p>&gt; &#x2F;var&#x2F;log&#x2F;hsp.log  ———————–&gt;创建文件hsp.log</p>
<p>重启后：cat &#x2F;var&#x2F;log&#x2F;hsp.log | grep sshd  —————–&gt;打开这个文件只查看sshd服务的</p>
<p>注意：上面的*.*表示所有类型的日志以及所有类型的级别</p>
<p>4.日志轮替</p>
<p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。&#x2F;etc&#x2F;logrotate.conf：是全局的日志轮替策略&#x2F;规则，当然可以单独给某个日志文件指定策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/21.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/22.png"></p>
<p>说明：也可以把某个日志文件的轮替规则，写到&#x2F;etc&#x2F;logrotate.d目录下，比如bootlog</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/23.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/24.png"></p>
<p>案例：在&#x2F;etc&#x2F;logrotate.conf进行配置，或者直接在&#x2F;etc&#x2F;logrotate.d下创建&#x2F;var&#x2F;log&#x2F;hsp.log日志的轮替文件hsplog编写boot.log日志的轮替文件中内容</p>
<ul>
<li>vim &#x2F;etc&#x2F;logrotate.d&#x2F;hsplog ———&gt;建立日志的轮替文件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/25.png"></p>
<p>5.日志轮替的机制</p>
<p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在&#x2F;etc&#x2F;cron.daily目录，就会发现这个目录中是有logrotate文件(可执行)，logrotate通过这个文件依赖定时任务执行的</p>
<p>crond后台程序每天都执行logrotate程序，logrotate程序会去读取我们写好的策略(&#x2F;etc&#x2F;logrotate.conf里面的轮替策或&#x2F;etc&#x2F;logrotate.d目录下的轮替规则)。rsyslogd只管写日志，不管轮替，轮替工作是由logrotate完成，当满足轮替规则时，进行移动、改名或删除。</p>
<p>6、内存日志</p>
<p>在Linux里面，有一部分日志是先写在内存里面的，还没有写到文件里面。如内核相关的日志是写在内存的。</p>
<p>特定：当重新启动的时候，内存日志就会被清空。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/26.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/27.png"></p>
]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(下)</title>
    <url>/2024/07/19/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="1-beast网络库搭建http服务器"><a href="#1-beast网络库搭建http服务器" class="headerlink" title="1. beast网络库搭建http服务器"></a>1. beast网络库搭建http服务器</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>通过asio来实现http服务器也需要严格服从http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。一个标准的HTTP报文头通常由<strong>请求头</strong>和<strong>响应头</strong>两部分组成。</p>
<p>http请求头格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span>     <span class="comment">//包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</span></span><br><span class="line">Host: www.example.com        <span class="comment">//指定被请求资源的主机名或IP地址和端口号。</span></span><br><span class="line">Accept: text/html, application/xhtml+xml    <span class="comment">//指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">123.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">123.0</span>    <span class="comment">//客户端使用的浏览器类型和版本号，供服务器统计用户代理信息</span></span><br><span class="line">Cookie: sessionid=abcdefg1234567    <span class="comment">//如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要持久连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<p>http响应头格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK            <span class="comment">//包含协议版本、状态码和状态消息</span></span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span>    <span class="comment">//响应体的MIME类型</span></span><br><span class="line">Content-Length: <span class="number">1024</span>       <span class="comment">//响应体的字节数</span></span><br><span class="line">Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/      <span class="comment">//服务器向客户端发送cookie信息时使用该字段</span></span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.32</span> (Unix) mod_ssl/<span class="number">2.2</span><span class="number">.32</span> OpenSSL/<span class="number">1.0</span><span class="number">.1</span>e-fips mod_bwlimited/<span class="number">1.4</span>  <span class="comment">//服务器类型和版本号</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要保持长连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-http服务器实现"><a href="#1-2-http服务器实现" class="headerlink" title="1.2 http服务器实现"></a>1.2 http服务器实现</h2><p>首先需要重新定义boost库的命名空间，并且创建了两个函数，方便后面对程序进行检测。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = beast::http;</span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名一个作用域，程序的声明</span></span><br><span class="line"><span class="keyword">namespace</span> my_program_state &#123;    <span class="comment">//定义了两个全局函数</span></span><br><span class="line">    <span class="comment">//统计对端请求的次数</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">request_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>;  <span class="comment">//这个值初始化一次，之后访问都是之前的数据</span></span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到现在的时间戳</span></span><br><span class="line">    <span class="function">std::<span class="type">time_t</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：负责初始化ip和端口的初始化，启动上下文服务轮询</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> address = net::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);   <span class="comment">//static_cast是静态转换类型</span></span><br><span class="line">        net::io_context ioc&#123; <span class="number">1</span> &#125;;   <span class="comment">//初始化一个io_context,最多支持一个线程去调度</span></span><br><span class="line">        tcp::acceptor acceptor&#123; ioc,&#123;address,port&#125; &#125;;</span><br><span class="line">        tcp::socket socket&#123; ioc &#125;;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);    <span class="comment">//调用http_server函数，进行http连接</span></span><br><span class="line">        ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_server函数实现：http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建<code>http_connection</code>类型的智能指针,并且启动服务，新连接监听对端接收和发送数据。然后http_server继续监听对端的新连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(tcp::acceptor&amp; acceptor, tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">start</span>();  <span class="comment">//创建一个http_connection的共享指针，创建好就直接启动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);   <span class="comment">//继续监听连接请求</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_connection连接类的实现：负责读取对端发来数据的请求头，并且设置响应头，通过异步方式发送回给对端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传入一个socket，构造连接,初始化socket_是通过移动构造完成的</span></span><br><span class="line">    <span class="built_in">http_connection</span>(tcp::socket socket):<span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读请求</span></span><br><span class="line">        <span class="built_in">read_request</span>();</span><br><span class="line">        <span class="comment">//判断超时，保证一个链接不要处理太长时间</span></span><br><span class="line">        <span class="built_in">check_deadline</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tcp::socket socket_;</span><br><span class="line">    beast::flat_buffer buffer_&#123; <span class="number">8192</span> &#125;;     <span class="comment">//接收数据的缓存</span></span><br><span class="line">    http::request&lt;http::dynamic_body&gt;request_;    <span class="comment">//定义一个请求</span></span><br><span class="line">    http::response&lt;http::dynamic_body&gt;response_;  <span class="comment">//定义一个回应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//steady_timer是boost提供的一种定时器类型</span></span><br><span class="line">    net::steady_timer deadline_&#123;</span><br><span class="line">        <span class="comment">//初始化调度器</span></span><br><span class="line">        socket_.<span class="built_in">get_executor</span>(), std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>)  <span class="comment">//初始化一个时钟，60秒调度一次</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;  <span class="comment">//读请求函数实现</span></span><br><span class="line">        <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>(); <span class="comment">//不能用make_shared创建，因为通过这种方法创建出来的http_connection不与外面使用的共享引用计数</span></span><br><span class="line">        <span class="comment">//read_request() 函数中的 http::async_read 调用是为了从套接字 socket_ 中异步读取数据到 buffer_ 中，然后解析这些数据到request_对象中。request_ 通常是一个HTTP请求解析器对象，用于解析HTTP请求。</span></span><br><span class="line">        <span class="comment">//参数：当前HTTP连接的套接字；存储读取的数据的缓冲区；回调函数，当异步读取操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_read</span>(socket_, buffer_, request_, [self](beast::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;  <span class="comment">//用作async_read的回调函数，参数：错误码；传输的字节数</span></span><br><span class="line">                boost::<span class="built_in">ignore_unused</span>(bytes_transferred); <span class="comment">//使用Boost库中的ignore_unused宏来告诉编译器忽略未使用的bytes_transferred变量，避免编译警告</span></span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    self-&gt;<span class="built_in">process_request</span>();    <span class="comment">//处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测定时器，判断该定时器有无超时，超时就关闭socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();   <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="comment">//异步等待，60秒后，会执行匿名函数</span></span><br><span class="line">        deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                self-&gt;socket_.<span class="built_in">close</span>(ec);  <span class="comment">//捕获的智能指针self，保证该匿名函数执行期间，http_connection没有被停止掉</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());   <span class="comment">//回应的版本，response_是回应头，回应的版本是响应头使用的版本</span></span><br><span class="line">        response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);       <span class="comment">//false表示短连接，true表示长连接</span></span><br><span class="line">        <span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;   <span class="comment">//检测请求类型</span></span><br><span class="line">        <span class="keyword">case</span> http::verb::get:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_response</span>();     <span class="comment">//创建get类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> http::verb::post:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_post_response</span>();   <span class="comment">//创建post类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::bad_request);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//回复的是纯文本类型content_type</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;Invalid request-method&#x27;&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无论请求是哪种，最后都需要回应请求</span></span><br><span class="line">        <span class="built_in">write_response</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;   <span class="comment">//如果路由是/count，就进行统计</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Request count &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;There have been &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;requests so far.&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;  <span class="comment">//如果路由是/time，就获取当前的时间戳</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Cyrrent time &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;seconds since the epoch..&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">//没有找到路由(路径地址)</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于异步发送HTTP响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());  <span class="comment">//设置HTTP响应的Content-Length 头部字段。这个字段告诉客户端响应体的大小</span></span><br><span class="line">        <span class="comment">//启动一个异步写操作，将HTTP响应发送到客户端。参数：当前HTTP连接的套接字；包含HTTP响应的HTTP消息对象；回调函数，当异步写操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_write</span>(socket_, response_, [self](beast::error_code ec, std::<span class="type">size_t</span>) &#123;</span><br><span class="line">            self-&gt;socket_.<span class="built_in">shutdown</span>(tcp::socket::shutdown_send);  <span class="comment">//首先调用 shutdown 方法关闭套接字的发送部分。参数表示关闭发送方向，但不关闭接收方向</span></span><br><span class="line">            self-&gt;deadline_.<span class="built_in">cancel</span>();    <span class="comment">//取消任何设置的超时</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();         <span class="comment">//获取HTTP请求的主体部分。</span></span><br><span class="line">            <span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());   <span class="comment">//将请求主体的缓冲区数据转换为字符串</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/json&quot;</span>);  <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/json&quot;</span></span><br><span class="line">            Json::Value root;         <span class="comment">//创建一个JSON值对象 root，用于构建响应的JSON结构</span></span><br><span class="line">            Json::Reader reader;      <span class="comment">//创建一个JSON读取器对象 reader</span></span><br><span class="line">            Json::Value src_root;     <span class="comment">//创建一个源JSON值对象 src_root，用于存储解析后的JSON数据</span></span><br><span class="line">            <span class="comment">//使用 reader 解析请求主体字符串 body_str 到 src_root，并将解析成功与否存储在 parse_success 变量中</span></span><br><span class="line">            <span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">            <span class="keyword">if</span> (!parse_success) &#123;    <span class="comment">//如果解析失败</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Failed to parse Json data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;    <span class="comment">//在响应的JSON对象中设置错误代码</span></span><br><span class="line">                std::string jsonstr = root.<span class="built_in">toStyledString</span>();    <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">                beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;    <span class="comment">//将JSON字符串写入响应主体</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果解析成功，从解析后的JSON对象中获取 &quot;email&quot; 字段的值</span></span><br><span class="line">            <span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line">            root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;                     <span class="comment">//在响应的JSON对象中设置错误代码为0，表示成功</span></span><br><span class="line">            root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];     <span class="comment">//将电子邮件地址添加到响应的JSON对象中</span></span><br><span class="line">            root[<span class="string">&quot;mag&quot;</span>] = <span class="string">&quot;receive email post success&quot;</span>;   <span class="comment">//添加一条消息到响应的JSON对象中</span></span><br><span class="line">            std::string jsonstr = root.<span class="built_in">toStyledString</span>();   <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;   <span class="comment">////将JSON字符串写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">//如果请求的目标不是 &quot;/email&quot;</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);   <span class="comment">//设置HTTP响应的状态为 404 Not Found。</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/plain</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;    <span class="comment">//将 &quot;File not found&quot; 消息写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后启动http的服务器，如果本地浏览器输入<code>127.0.0.1:8080/count</code>，进入界面后不断刷新，就可以看到严格计数的效果；如果在本地浏览器输入<code>127.0.0.1:8080/time</code>，也可以获得当前的时间戳；对于实现的post类型请求，需要结合软件完成检测。</p>
<h1 id="2-beast网络库实现websocket服务器"><a href="#2-beast网络库实现websocket服务器" class="headerlink" title="2. beast网络库实现websocket服务器"></a>2. beast网络库实现websocket服务器</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>对于如何使用Beast库实现一个WebSocket服务器，以及如何处理不同类型的请求。具体来说，这句话包含了以下几个要点：</p>
<ul>
<li><p><strong>WebSocket协议和HTTP协议的关系</strong>：WebSocket是一种长连接协议，允许服务器和客户端之间进行双向通信。虽然它是在HTTP协议之上建立的，但它在建立连接后升级为WebSocket协议。</p>
</li>
<li><p><strong>请求的区分</strong>：当在浏览器中输入一个以<code>ws://</code>开头的URL（例如<code>ws://127.0.0.1:9501</code>），浏览器会发起一个WebSocket请求，目标是本地服务器的9501端口。</p>
</li>
<li><p><strong>Beast库的作用</strong>：Beast库提供了处理WebSocket协议的功能。它允许我们在一个HTTP服务器的基础上，通过协议升级的方式来处理WebSocket请求。</p>
</li>
<li><p><strong>请求处理逻辑</strong>：当服务器收到一个请求时，需要判断该请求是普通的HTTP请求还是WebSocket请求。如果是WebSocket请求，服务器将升级协议并处理该请求；如果是普通的HTTP请求，则按HTTP请求处理。</p>
</li>
</ul>
<h2 id="2-2-websocket服务器实现"><a href="#2-2-websocket服务器实现" class="headerlink" title="2.2 websocket服务器实现"></a>2.2 websocket服务器实现</h2><p>主函数实现：负责初始化工作任务需要的内容，并启动上下文服务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	net::io_context ioc;    <span class="comment">//初始化一个上下文</span></span><br><span class="line">	<span class="function">WebSocketServer <span class="title">server</span><span class="params">(ioc, <span class="number">10086</span>)</span></span>;    <span class="comment">//通过该ioc构建一个server,端口是10086</span></span><br><span class="line">	server.<span class="built_in">StartAccept</span>();   <span class="comment">//执行WebSocketServer的StartAccept()函数，server接收新的连接</span></span><br><span class="line">	ioc.<span class="built_in">run</span>();    <span class="comment">//ioc跑起来，启动事件服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管理类ConnectionMgr实现：在类中创建了一个无序的map容器<code>_map_cons</code>，key值是转化为字符串的uuid值，value值是对应的Connection类型的智能指针。并且定义了两个函数，对容器<code>_map_cons</code>对连接进行加入和删除操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------头文件-------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> ConnectionMgr&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;     <span class="comment">//实现单例模式</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span></span>;   <span class="comment">//加入连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RmvConnection</span><span class="params">(std::string)</span></span>;                         <span class="comment">//移出连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ConnectionMgr</span>(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;             <span class="comment">//去除拷贝构造函数</span></span><br><span class="line">	ConnectionMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;  <span class="comment">//去除赋值构造函数</span></span><br><span class="line">	<span class="built_in">ConnectionMgr</span>();</span><br><span class="line">	boost::unordered_map&lt;std::string, std::shared_ptr&lt;Connection&gt;&gt;_map_cons;   <span class="comment">//无序map,管理连接</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------------------函数初始化---------------------------</span></span><br><span class="line"><span class="function">ConnectionMgr&amp; <span class="title">ConnectionMgr::GetInstance</span><span class="params">()</span> </span>&#123;   <span class="comment">//C++11以上的版本，通过这种方式实现单例模式</span></span><br><span class="line">	<span class="type">static</span> ConnectionMgr instance;    <span class="comment">//定义一个局部变量</span></span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span> </span>&#123;</span><br><span class="line">	_map_cons[conptr-&gt;<span class="built_in">GetUid</span>()] = conptr;     <span class="comment">//将连接的uid和对应的连接通过map来进行管理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::RmvConnection</span><span class="params">(std::string id)</span> </span>&#123;</span><br><span class="line">	_map_cons.<span class="built_in">erase</span>(id);     <span class="comment">//通过id来删除</span></span><br><span class="line">&#125;</span><br><span class="line">ConnectionMgr::<span class="built_in">ConnectionMgr</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSocketServer类实现：负责不断监听对端的连接，当与对端建立连接后，就调用Connection类的AsyncAccept函数，将协议升级为了websocket。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------头文件----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WebSocketServer</span>(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;     <span class="comment">//去除拷贝构造</span></span><br><span class="line">	WebSocketServer&amp; <span class="keyword">operator</span> = (<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除赋值构造</span></span><br><span class="line">	<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;          <span class="comment">//接收连接，是TCP上的接收连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	net::ip::tcp::acceptor _acceptor;    <span class="comment">//接收连接的一个接收器</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------------------函数实现-------------------------------------</span></span><br><span class="line">WebSocketServer::<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) :_ioc(ioc),</span><br><span class="line">_acceptor(ioc, net::ip::tcp::<span class="built_in">endpoint</span>(net::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;   <span class="comment">//开始连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebSocketServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> con_ptr = std::<span class="built_in">make_shared</span>&lt;Connection&gt;(_ioc);        <span class="comment">//创建一个Connection类型的智能指针</span></span><br><span class="line">	<span class="comment">//接收连接</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(con_ptr-&gt;<span class="built_in">GetSocket</span>(), [<span class="keyword">this</span>, con_ptr](error_code err) &#123; <span class="comment">//GetSocket()返回的是connection最低层的socket(tcp的socket)</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;     <span class="comment">//没有错误</span></span><br><span class="line">				con_ptr-&gt;<span class="built_in">AsyncAccept</span>();    <span class="comment">//相当于升级了，将协议升级为了websocket</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;acceptor async_accept failed, err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;  <span class="comment">//连接失败，打印原因</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">StartAccept</span>();    <span class="comment">//server接收新的连接</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;async_accept error is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Connection类实现：负责将协议生成websocketm，当与对端建立成功后，异步接收数据和异步发送数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------头文件-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;Connection&gt; &#123;  <span class="comment">//连接通过智能指针去管理，允许从内部去构造智能指针，并且与外部使用的智能指针共享引用计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(net::io_context&amp; ioc);</span><br><span class="line">	<span class="function">std::string <span class="title">GetUid</span><span class="params">()</span></span>;                <span class="comment">//返回uid</span></span><br><span class="line">	<span class="comment">//connect内部是管理websocket，而websocket底层是通过tcp来实现的，所以它底层有一个socket</span></span><br><span class="line">	net::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;   <span class="comment">//该函数返回该底层的socket(外面可能会用到)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncAccept</span><span class="params">()</span></span>;    <span class="comment">//在tcp层面建立好连接后，还要在websocket层面做一个升级，升级就可以调用这个异步的连接函数进行升级</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;           <span class="comment">//接收对端的数据的，进行收发的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncSend</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::unique_ptr&lt;stream&lt;tcp_stream&gt;&gt;_ws_ptr;   <span class="comment">//用unique_ptr管理外部websocket</span></span><br><span class="line">	std::string _uuid;      <span class="comment">//有唯一的id</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">	flat_buffer _recv_buffer;        <span class="comment">//存储接收的数据</span></span><br><span class="line">	std::queue&lt;std::string&gt;_send_que;    <span class="comment">//发送队列</span></span><br><span class="line">	std::mutex _send_mtx;      <span class="comment">//发送的一个锁</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------函数实现--------------------------------------</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>(net::io_context&amp; ioc):_ioc(ioc),</span><br><span class="line">_ws_ptr(std::make_unique&lt;stream&lt;tcp_stream&gt;&gt;(<span class="built_in">make_strand</span>(ioc)))  <span class="comment">//构造一个stream&lt;tcp_stream&gt;类型的智能指针。通过上下文构造一个strand执行器，则这里的执行器与上下文的执行器就是同一个了</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成唯一的uuid</span></span><br><span class="line">	boost::uuids::random_generator generator;   <span class="comment">//生成generator</span></span><br><span class="line">	boost::uuids::uuid uuid = <span class="built_in">generator</span>();      <span class="comment">//通过generator来生成唯一的uuid</span></span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(uuid);      <span class="comment">//为了存储该uuid,需要转换为string类型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Connection::GetUid</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">Connection::GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//socket()是会返回websocket内部管理的最底层的socket的引用，只要的wensocke不被释放，返回的socket也不会被释放</span></span><br><span class="line">	<span class="keyword">return</span> boost::beast::<span class="built_in">get_lowest_layer</span>(*_ws_ptr).<span class="built_in">socket</span>();  <span class="comment">//返回智能指针_ws_ptr所指向的websocket的最底层(是tcp类型的socket)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步的接收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//生成一个自己的智能指针，通过这种方式生成的智能指针和其它的共享指针共享引用计数</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();    <span class="comment">//其它智能指针可能也在管理connection，为了不与它们同步引用计数，所以需要shared_from_this</span></span><br><span class="line">	<span class="comment">//websocket异步接收连接,结果相当于是在tcp的基础上，将协议生成websocket</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_accept</span>([self](boost::system::error_code err) &#123;  <span class="comment">//防止回调函数在没有调用之前，connection被智能指针释放掉，所以需要它的引用计数+1</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;   <span class="comment">//没有错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">AddConnection</span>(self); <span class="comment">//添加连接，将self智能指针加到管理类来管理</span></span><br><span class="line">				self-&gt;<span class="built_in">Start</span>();             <span class="comment">//接收读写</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket accept failed,err is&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket async accept exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//异步读</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_read</span>(_recv_buffer, [self](error_code err, std::<span class="type">size_t</span> buffer_bytes) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket async read error is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			self-&gt;_ws_ptr-&gt;<span class="built_in">text</span>(self-&gt;_ws_ptr-&gt;<span class="built_in">got_text</span>());   <span class="comment">//设置传输的类型，默认是对方发什么，就回什么类型</span></span><br><span class="line">			std::string recv_data = boost::beast::<span class="built_in">buffers_to_string</span>(self-&gt;_recv_buffer.<span class="built_in">data</span>()); <span class="comment">//存储收到的数据，并将收到的buffer类型数据转成string类型</span></span><br><span class="line">			self-&gt;_recv_buffer.<span class="built_in">consume</span>(self-&gt;_recv_buffer.<span class="built_in">size</span>());    <span class="comment">//清空_recv_buffer，为下次接收准备</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket recvive msg is &quot;</span> &lt;&lt; recv_data &lt;&lt; std::endl;      <span class="comment">//打印接收的数据</span></span><br><span class="line">			<span class="comment">//发送操作</span></span><br><span class="line">			self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(recv_data));   <span class="comment">//异步发送，为了减少拷贝，用move()操作</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();        <span class="comment">//发送完，就继续监听对方发送数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;    <span class="comment">//接收异常</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;    <span class="comment">//打印错误信息</span></span><br><span class="line">			ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncSend</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(_send_mtx);    <span class="comment">//对队列加锁</span></span><br><span class="line">		<span class="type">int</span> que_len = _send_que.<span class="built_in">size</span>();            <span class="comment">//取出队列的长度</span></span><br><span class="line">		_send_que.<span class="built_in">push</span>(msg);                       <span class="comment">//往队列添加发送的数据</span></span><br><span class="line">		<span class="keyword">if</span> (que_len &gt; <span class="number">0</span>) &#123;             <span class="comment">//如果没有放入队列之前，队列长度&gt;0，说明之前数据没有发送完，直接退出</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;    <span class="comment">//执行到这里的时候，进行析构，自动解锁</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    <span class="comment">//创建一个buffer，参数是消息的首地址，长度和lambda表达式(捕获发送对方的结果)</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_write</span>(boost::asio::<span class="built_in">buffer</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()), [self](error_code err, std::<span class="type">size_t</span> nsize) &#123;   <span class="comment">//错误码 和 没有发生错误情况下，发送了多少</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (err) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;async_send err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">					ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());     <span class="comment">//通过uid移出连接</span></span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				std::string send_msg;</span><br><span class="line">				&#123;   <span class="comment">//局部作用域</span></span><br><span class="line">					std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(self-&gt;_send_mtx);   <span class="comment">//对队列加锁</span></span><br><span class="line">					self-&gt;_send_que.<span class="built_in">pop</span>();        <span class="comment">//弹出队列首元素(上面的异步发送，是发送完成才回执行到这里)，队首的元素就是刚刚发送完毕的</span></span><br><span class="line">					<span class="keyword">if</span> (self-&gt;_send_que.<span class="built_in">empty</span>()) &#123;     <span class="comment">//再判断队列是否为空</span></span><br><span class="line">						<span class="keyword">return</span>;       <span class="comment">//为空就返回</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//不为空，说明还有数据，需要继续发送</span></span><br><span class="line">					send_msg = self-&gt;_send_que.<span class="built_in">front</span>();     <span class="comment">//把队首元素进行一个拷贝</span></span><br><span class="line">				&#125;  <span class="comment">//自动解锁</span></span><br><span class="line">				self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(send_msg)); <span class="comment">//异步发送，这里的移动操作字符串对于系统来说，差别不大，如果是结构体，用move效果会明显一点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;async_send exception is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;_uuid);     <span class="comment">//通过uid将异常连接移出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-执行效果"><a href="#2-3-执行效果" class="headerlink" title="2.3 执行效果"></a>2.3 执行效果</h2><p>1.启动服务器后，会跳出如下页面，这也表示服务器开始监听对端发来的连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_7.png"></p>
<p>2.在WebSocket的一个在线测试网站进行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_8.png"></p>
<p>3.点击发送，接收服务器发送来的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_9.png"></p>
<p>4.服务器终端情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_10.png"></p>
<h1 id="3-windows配置和使用grpc"><a href="#3-windows配置和使用grpc" class="headerlink" title="3. windows配置和使用grpc"></a>3. windows配置和使用grpc</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>当在windows环境配置好grpc，接下来是使用visual studio配置grpc，可以将之前编译好的库配置到项目中来完成grpc通信。</p>
<h2 id="3-2-项目配置"><a href="#3-2-项目配置" class="headerlink" title="3.2 项目配置"></a>3.2 项目配置</h2><p>1.创建Grpc-Server项目，在项目的根目录下创建一个名字为<code>demo.proto</code>的文件，编写程序如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span>(HelloReply)</span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在<code>demo.proto</code>所在文件打开Powershell窗口(终端好像也可)，然后利用grpc编译后生成的<code>proc.exe</code>生成proto的头文件和源文件，即执行如下命令生成<code>demo.grpc.pb.h</code>和<code>demo.grpc.pb.cc</code>文件(这两个文件是为grpc服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe  <span class="literal">-I</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--grpc_out</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--plugin</span>=protoc<span class="literal">-gen-grpc</span>=<span class="string">&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</span> <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li><p><code>C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe</code>：是存放protoc.exe所在的路径，也可以将其配置到环境变量，然后直接使用protoc.exe就行</p>
</li>
<li><p><code>-I=&quot;.&quot;</code> ：指定 <code>demo.proto</code>所在的路径为当前路径</p>
</li>
<li><p><code>--grpc_out=&quot;.&quot;</code> ：表示生成的pb.h和pb.cc文件的输出位置为当前目录</p>
</li>
<li><p><code>--plugin=protoc-gen-grpc=&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</code>：表示要用到的插件是<code>protoc-gen-grpc</code>，位置在<code>C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe</code></p>
</li>
<li><p><code>&quot;demo.proto&quot;</code>：要编译的proto文件</p>
</li>
</ul>
<p>3.因为要序列化数据，所以需要生成grpc类需要的pb文件，即在demo.proto所在目录下打开powershell窗口，执行如下命令，就会生成demo.pb.h和demo.pb.cc文件(这两个文件是为消息服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe <span class="literal">--cpp_out</span>=. <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>4.为项目中配置grpc库的包含目录和库目录。先配置Debug版本，方便调试。</p>
<p>右键vs里面的项目，选择：属性 —&gt; c&#x2F;c++ — &gt; 常规 —&gt; 附加包含目录 —&gt; 编辑</p>
<p><img src="/.online//Users\PC\Desktop\3_11.png"></p>
<p>点击编辑后，在弹出的窗口中添加如下文件目录(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\include</span><br><span class="line">C:\cppsoft\grpc\third_party\protobuf\src</span><br><span class="line">C:\cppsoft\grpc\third_party\abseil-cpp</span><br><span class="line">C:\cppsoft\grpc\third_party\address_sorting\include</span><br><span class="line">C:\cppsoft\grpc\third_party\re2</span><br></pre></td></tr></table></figure>

<p>5.再配置库路径, 选择：链接器 —&gt; 常规 —&gt; 附加库目录 —&gt; 编辑</p>
<p><img src="/.online//Users\PC\Desktop\3_12.png"></p>
<p>点击编辑后，在弹出的窗口添加以下路径(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\re2\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\types\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\synchronization\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\status\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\random\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\flags\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\debugging\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\container\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\hash\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\boringssl-with-bazel\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\numeric\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\time\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\base\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\strings\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\zlib\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\cares\cares\lib\Debug</span><br></pre></td></tr></table></figure>

<p>6.配置好库目录后，还要将要使用的库链接到项目。选择：链接器 —&gt; 输入 —&gt; 附加依赖项 —&gt; 编辑</p>
<p><img src="/.online//Users\PC\Desktop\3_13.png"></p>
<p>点击编辑后，在弹出的窗口添加依赖的库名字(以下)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libprotobufd.lib</span><br><span class="line">gpr.lib</span><br><span class="line">grpc.lib</span><br><span class="line">grpc++.lib</span><br><span class="line">grpc++_reflection.lib</span><br><span class="line">address_sorting.lib</span><br><span class="line">ws2_32.lib</span><br><span class="line">cares.lib</span><br><span class="line">zlibstaticd.lib</span><br><span class="line">upb.lib</span><br><span class="line">ssl.lib</span><br><span class="line">crypto.lib</span><br><span class="line">absl_bad_any_cast_impl.lib</span><br><span class="line">absl_bad_optional_access.lib</span><br><span class="line">absl_bad_variant_access.lib</span><br><span class="line">absl_base.lib</span><br><span class="line">absl_city.lib</span><br><span class="line">absl_civil_time.lib</span><br><span class="line">absl_cord.lib</span><br><span class="line">absl_debugging_internal.lib</span><br><span class="line">absl_demangle_internal.lib</span><br><span class="line">absl_examine_stack.lib</span><br><span class="line">absl_exponential_biased.lib</span><br><span class="line">absl_failure_signal_handler.lib</span><br><span class="line">absl_flags.lib</span><br><span class="line">absl_flags_config.lib</span><br><span class="line">absl_flags_internal.lib</span><br><span class="line">absl_flags_marshalling.lib</span><br><span class="line">absl_flags_parse.lib</span><br><span class="line">absl_flags_program_name.lib</span><br><span class="line">absl_flags_usage.lib</span><br><span class="line">absl_flags_usage_internal.lib</span><br><span class="line">absl_graphcycles_internal.lib</span><br><span class="line">absl_hash.lib</span><br><span class="line">absl_hashtablez_sampler.lib</span><br><span class="line">absl_int128.lib</span><br><span class="line">absl_leak_check.lib</span><br><span class="line">absl_leak_check_disable.lib</span><br><span class="line">absl_log_severity.lib</span><br><span class="line">absl_malloc_internal.lib</span><br><span class="line">absl_periodic_sampler.lib</span><br><span class="line">absl_random_distributions.lib</span><br><span class="line">absl_random_internal_distribution_test_util.lib</span><br><span class="line">absl_random_internal_pool_urbg.lib</span><br><span class="line">absl_random_internal_randen.lib</span><br><span class="line">absl_random_internal_randen_hwaes.lib</span><br><span class="line">absl_random_internal_randen_hwaes_impl.lib</span><br><span class="line">absl_random_internal_randen_slow.lib</span><br><span class="line">absl_random_internal_seed_material.lib</span><br><span class="line">absl_random_seed_gen_exception.lib</span><br><span class="line">absl_random_seed_sequences.lib</span><br><span class="line">absl_raw_hash_set.lib</span><br><span class="line">absl_raw_logging_internal.lib</span><br><span class="line">absl_scoped_set_env.lib</span><br><span class="line">absl_spinlock_wait.lib</span><br><span class="line">absl_stacktrace.lib</span><br><span class="line">absl_status.lib</span><br><span class="line">absl_strings.lib</span><br><span class="line">absl_strings_internal.lib</span><br><span class="line">absl_str_format_internal.lib</span><br><span class="line">absl_symbolize.lib</span><br><span class="line">absl_synchronization.lib</span><br><span class="line">absl_throw_delegate.lib</span><br><span class="line">absl_time.lib</span><br><span class="line">absl_time_zone.lib</span><br><span class="line">absl_statusor.lib</span><br><span class="line">re2.lib</span><br></pre></td></tr></table></figure>

<p>当完成这些配置，就可以通过grpc来进行服务器和客户端的通信了。</p>
<h1 id="4-grpc通信"><a href="#4-grpc通信" class="headerlink" title="4. grpc通信"></a>4. grpc通信</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>gRPC(Remote Procedure Call)是一种高性能、开源的远程过程调用(RPC)框架。它能够在不同的环境中进行跨语言的通信，并且使用HTTP&#x2F;2作为其传输协议，提供诸如负载均衡、跟踪、健康检查和认证等功能。</p>
<p>gRPC通信过程包括服务器端和客户端的代码，其中通过协议定义文件(proto文件)来定义消息格式和服务接口。</p>
<h2 id="4-2-proto文件"><a href="#4-2-proto文件" class="headerlink" title="4.2 proto文件"></a>4.2 proto文件</h2><p>proto文件定义了通信协议的消息格式和服务接口。在这里的proto文件定义了一个名为<code>hello</code>的包，包含一个<code>Greeter</code>服务和两个消息类型<code>HelloRequest</code>和<code>HelloReply</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line">service Greeter&#123;</span><br><span class="line">	<span class="function">rpc <span class="title">SayHello</span><span class="params">(HelloRequest)</span> <span class="title">returns</span><span class="params">(HelloReply)</span></span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">	string message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line">message HelloReply&#123;</span><br><span class="line">	string message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-服务器实现"><a href="#4-3-服务器实现" class="headerlink" title="4.3 服务器实现"></a>4.3 服务器实现</h2><p>服务器代码实现了proto文件中定义的<code>Greeter</code>服务。服务器启动后，监听指定的端口，等待客户端的请求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用grpc的一些作用域</span></span><br><span class="line"><span class="keyword">using</span> grpc::Server;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerBuilder;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerContext;      <span class="comment">//server上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> hello::Greeter;   <span class="comment">//要用到的一个服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final表示终极的继承，GreeterServicelmpl继承public Greeter::Service后，其它的类就不能再继承了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreeterServicelmpl</span> <span class="keyword">final</span> :<span class="keyword">public</span> Greeter::Service &#123;</span><br><span class="line">    <span class="comment">//Status是返回的一个状态，grpc服务给别人提供调用的接口，都会返回一个状态</span></span><br><span class="line">    ::<span class="function">grpc::Status <span class="title">SayHello</span><span class="params">(::grpc::ServerContext* ccontext, <span class="type">const</span>::hello::HelloRequest* request, ::hello::HelloReply* response)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">prefix</span><span class="params">(<span class="string">&quot;llfc grpc server has received:&quot;</span>)</span></span>;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(prefix + request-&gt;<span class="built_in">message</span>());    <span class="comment">//修改一下回应(进行拼接)</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;     <span class="comment">//返回一个状态</span></span><br><span class="line">    &#125;  <span class="comment">//重写了父类Greeter的一个Service函数接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    GreeterServicelmpl service;</span><br><span class="line">    ServerBuilder builder;    <span class="comment">//创建服务的时候，需要ServerBuilder(规则)</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());   <span class="comment">//绑定端口。</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);     <span class="comment">//注册服务，将该服务注册给builder。服务就可以在后台执行了</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Server&gt;<span class="built_in">server</span>(builder.<span class="built_in">BuildAndStart</span>());   <span class="comment">//将端口和服务都绑定好的builder传递给server，</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();    <span class="comment">//阻塞，底层轮询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RunServer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补：<code>127.0.0.1</code>和<code>0.0.0.0</code>的区别：<code>127.0.0.0</code>是本地回路地址，不能网络，如果是本地客户端请求本地服务器，是可以的，但其它客户端访问不到。</p>
<h2 id="4-4-客户端实现"><a href="#4-4-客户端实现" class="headerlink" title="4.4 客户端实现"></a>4.4 客户端实现</h2><p>客户端代码创建一个与服务器通信的通道，通过这个通道，客户端可以调用服务器提供的服务(如<code>SayHello</code>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> grpc::ClientContext;     <span class="comment">//Clinent的上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;         <span class="comment">//发送消息，需要通道，通过该通道与服务器通信</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端不用继承服务，直接写即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//参数是通道类型，利用通道与服务端通信</span></span><br><span class="line">    <span class="built_in">FCClient</span>(std::shared_ptr&lt;Channel&gt;channel) :<span class="built_in">stub_</span>(Greeter::<span class="built_in">NewStub</span>(channel)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">SayHello</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        ClientContext context;       <span class="comment">//构造客户端的上下文</span></span><br><span class="line">        HelloReply reply;            <span class="comment">//回复</span></span><br><span class="line">        HelloRequest request;        <span class="comment">//请求</span></span><br><span class="line">        request.<span class="built_in">set_message</span>(name);     <span class="comment">//设置消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置好请求，下面是发过去</span></span><br><span class="line">        <span class="comment">//客户端发送消息，把request字符串通过protobuf序列化发送给服务器，服务器把数据修改好后，传回来，客户端收到数据后存到reply里</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">SayHello</span>(&amp;context, request, &amp;reply);   <span class="comment">//调用的是服务端的SayHello,对reply进行了修改，所以这里第三个参数传的是地址</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> reply.<span class="built_in">message</span>();    <span class="comment">//收到对方回应，如果是正常的就返回字符串即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;failure &quot;</span> + status.<span class="built_in">error_message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Greeter::Stub&gt;stub_;    <span class="comment">//stub_可以理解为客户端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行通信就必须创建channel管道，相当于是asio里面的端点，与谁通信</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;127.0.0.1:50051&quot;</span>, grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="function">FCClient <span class="title">client</span><span class="params">(channel)</span></span>;</span><br><span class="line">    <span class="comment">//客户端调用了SayHello函数，把参数(字符串消息)传给了服务器，返回服务器的发过来的数据</span></span><br><span class="line">    std::string result = client.<span class="built_in">SayHello</span>(<span class="string">&quot;hello lxx93.online!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get result [%s]\n&quot;</span>, result.<span class="built_in">c_str</span>());   <span class="comment">//打印获取的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-通信过程"><a href="#4-5-通信过程" class="headerlink" title="4.5 通信过程"></a>4.5 通信过程</h2><p>1.定义服务接口和消息格式</p>
<ul>
<li>在proto文件中，定义了一个名为<code>Greeter</code>的服务，包含一个RPC方法<code>SayHello</code>，该方法接受一个<code>HelloRequest</code>消息并返回一个<code>HelloReply</code>消息。</li>
</ul>
<p>2.生成代码</p>
<ul>
<li>使用protoc编译器从proto文件生成C++代码，包括消息类(如<code>HelloRequest</code>和<code>HelloReply</code>)和服务接口类(如<code>Greeter::Service</code>)</li>
</ul>
<p>3.实现服务器逻辑</p>
<ul>
<li>在服务器端，继承生成的<code>Greeter::Service</code>类，并实现<code>SayHello</code>方法。这个方法接收客户端的请求(<code>HelloRequest</code>)，处理后返回响应(<code>HelloReply</code>)。</li>
</ul>
<p>4.启动服务器</p>
<ul>
<li>服务器代码使用<code>ServerBuilder</code>配置和启动gRPC服务器，并在指定端口上监听客户端请求。</li>
</ul>
<p>5.客户端调用</p>
<ul>
<li>客户端创建一个通道，通过这个通道与服务器通信。客户端创建一个<code>Greeter::Stub</code>对象，这是一个客户端代理，通过它调用服务器端的<code>SayHello</code>方法。</li>
</ul>
<ul>
<li>在客户端调用<code>SayHello</code>方法时，客户端将<code>HelloRequest</code>消息序列化并发送给服务器。服务器接收请求后，处理并返回<code>HelloReply</code>消息。客户端接收响应并解码得到结果。</li>
</ul>
<h2 id="4-6-为什么客户端可以调用服务端的函数"><a href="#4-6-为什么客户端可以调用服务端的函数" class="headerlink" title="4.6 为什么客户端可以调用服务端的函数"></a>4.6 为什么客户端可以调用服务端的函数</h2><p>客户端并不直接调用服务端的函数，而是通过gRPC框架生成的客户端存根(stub)来间接调用。客户端调用存根的<code>SayHello</code>方法，gRPC框架负责处理网络通信，将请求发送到服务器，并接收服务器的响应。</p>
<p>步骤如下(结合上面编写的服务器和客户端)：</p>
<ol>
<li><p>客户端构建请求：创建并填充<code>HelloRequest</code>消息。</p>
</li>
<li><p>发送请求：通过调用<code>stub_-&gt;SayHello</code>将请求发送到服务器。</p>
</li>
<li><p>服务器处理请求：服务器接收请求，调用<code>GreeterServiceImpl::SayHello</code>方法进行处理，并构建<code>HelloReply</code>响应。</p>
</li>
<li><p>发送响应：服务器将响应发送回客户端。</p>
</li>
<li><p>客户端接收响应：客户端接收并解析<code>HelloReply</code>消息，从而得到服务器处理后的结果</p>
</li>
</ol>
]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>IOServicePool</tag>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(上)</title>
    <url>/2024/07/08/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="1-boost库"><a href="#1-boost库" class="headerlink" title="1. boost库"></a>1. boost库</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>网络编程是现代软件开发中无可替代的一环，无论是构建庞大的分布式系统还是小型的桌面应用，都离不开网络的支持。Boost.Asio起源于Boost库，是一款专为网络I&#x2F;O、定时器、串行端口通信设计的库，提供了同步和异步的编程模型，用以简化网络和低级I&#x2F;O的操作。它的设计初衷是提供一套简洁、一致且功能全面的接口，以满足开发者在多样化网络编程场景下的需求。</p>
<h2 id="1-2-库的特性与优势"><a href="#1-2-库的特性与优势" class="headerlink" title="1.2 库的特性与优势"></a>1.2 库的特性与优势</h2><p> Boost.Asio是一款功能全面的库，其主要特性与优势如下：</p>
<ul>
<li><p>异步编程模型：它通过异步操作和回调机制，允许程序在等待I&#x2F;O操作完成时继续执行其他任务，从而提高了程序的效率和响应速度</p>
</li>
<li><p>多协议支持： 它支持TCP、UDP、SSL等多种协议，可以帮助开发者快速实现各种网络应用</p>
</li>
<li><p>跨平台兼容性： Boost.Asio可以运行在Windows、Linux、macOS等多个平台上，保证了代码的可移植性和可维护性</p>
</li>
<li><p>可扩展性： 开发者可以基于Boost.Asio轻松实现自定义协议和服务，实现特定的业务逻辑</p>
</li>
<li><p>高性能： Boost.Asio的设计充分考虑了性能因素，尤其在高并发环境下表现出色</p>
</li>
</ul>
<h1 id="2-主要函数的创建"><a href="#2-主要函数的创建" class="headerlink" title="2. 主要函数的创建"></a>2. 主要函数的创建</h1><h2 id="2-1-终端节点的创建"><a href="#2-1-终端节点的创建" class="headerlink" title="2.1 终端节点的创建"></a>2.1 终端节点的创建</h2><p>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其它节点可以连接这个终端节点做通信。</p>
<p>客户端构造终端节点：通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;     <span class="comment">//对端(服务端)的地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;                   <span class="comment">//对端(服务端)的端口号</span></span><br><span class="line">    </span><br><span class="line">    boost::system::error_code ec;                     <span class="comment">//定义一个错误关键字</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address::<span class="built_in">from_string</span>(raw_ip_address, ec);  <span class="comment">//将字符串形式的IP地址转换为 asio::ip::address 类型的对象</span></span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;                            <span class="comment">//如果转换失败，打印错误码和错误描述</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();                            <span class="comment">//转换失败直接退出返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;   <span class="comment">//转换成功就生成端点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端构造终端端点：则只需根据本地地址绑定就可以生成endpoint</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;             <span class="comment">//用于指定网络服务监听的端口</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address_v6::<span class="built_in">any</span>(); <span class="comment">//表示它将接受发送到服务器上任何 IPv6 地址的数据。</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;       <span class="comment">//生成服务器的端点节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-创建socket"><a href="#2-2-创建socket" class="headerlink" title="2.2 创建socket"></a>2.2 创建socket</h2><p>客户端创建socket分为4步，创建上下文iocontext、选择协议、生成socket、打开socket。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建和配置一个 TCP 套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 asio::io_context 对象 ioc，它是 Asio 库中的核心组件，用于管理 I/O 操作和执行异步任务(上下文服务)</span></span><br><span class="line">    asio::io_context ioc;</span><br><span class="line">    <span class="comment">//创建了一个 asio::ip::tcp 协议的实例 protocol，使用 v4() 指定使用 IPv4 协议</span></span><br><span class="line">    asio::ip::tcp protocol = asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line">    <span class="comment">//创建了一个asio::ip::tcp::socket 对象 sock，它是一个 TCP 套接字，与 ioc 关联以进行 I/O 操作</span></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">    <span class="comment">//声明了一个 boost::system::error_code 对象 ec，用于接收可能发生的错误代码</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">//调用open方法打开套接字，使用之前创建的protocol对象指定协议,如果操作成功，ec将不会被设置；如果发生错误，ec将包含错误代码</span></span><br><span class="line">    sock.<span class="built_in">open</span>(protocol, ec); </span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;           <span class="comment">//检查 ec 是否包含错误代码。如果 ec.value() 不等于 0，表示发生了错误。</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();           <span class="comment">//发生错误，返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端创建socket，需要生成一个acceptor的socket，用来接收新的连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="comment">//下面表示服务端接收连接，只接收ipv4的连接，并且是发往本地ip,端口3333的</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">a</span><span class="params">(ios, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), <span class="number">3333</span>))</span></span>; <span class="comment">//生成一个asio::ip::tcp::acceptor对象a，是v4的协议</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-绑定acceptor"><a href="#2-3-绑定acceptor" class="headerlink" title="2.3 绑定acceptor"></a>2.3 绑定acceptor</h2><p>服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_accept_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;         <span class="comment">//定义端口号</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(), port_num)</span></span>;  <span class="comment">//生成端点，接收任何地址的连接</span></span><br><span class="line">    asio::io_context ios;                  <span class="comment">//创建服务，让服务器知道accepter是绑定在哪个服务上的</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;    <span class="comment">//生成accepter</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    acceptor.<span class="built_in">bind</span>(ep, ec);     <span class="comment">//绑定(生成的acceptor,绑定了一个端点，端点是本地的任何一个地址和端口号9527)</span></span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;           <span class="comment">//检查 ec 是否包含错误代码。如果 ec.value() 不等于 0，表示发生了错误。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();           <span class="comment">//发生错误，返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接指定的端点，作为客户端可以连接服务器指定的端点进行连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;              <span class="comment">//服务器的地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;                            <span class="comment">//服务器的端口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;  <span class="comment">//生成了一个端点</span></span><br><span class="line">        asio::io_context ios;</span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;   <span class="comment">//创建了个socket，这个sock是绑定在ios这个服务上的，并且它的协议是ep.protocol()</span></span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);                         <span class="comment">//连接到端点，这样就连接到服务器了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器接收连接，当有客户端连接时，服务器需要接收连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BACKLOG_SIZE = <span class="number">30</span>;                  <span class="comment">//监听队列的大小为30</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(), port_num)</span></span>;  <span class="comment">//创建一个端点，可以接收任意ipv4的地址，自己绑定的本地地址</span></span><br><span class="line">    asio::io_context ios;      <span class="comment">//创建一个服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;  <span class="comment">//生成一个socketor接收器,第一个参数是服务，第二个参数是服务器要处理的协议(ipv4)</span></span><br><span class="line">        acceptor.<span class="built_in">bind</span>(ep);                  <span class="comment">//接收器进行一个绑定，绑定这个端口</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>(BACKLOG_SIZE);      <span class="comment">//服务器进行监听操作</span></span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;    <span class="comment">//再创建一个socket，这个是与客户端通信用的</span></span><br><span class="line">        acceptor.<span class="built_in">accept</span>(sock);              <span class="comment">//接收到的新连接，交给sock来处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-同步读写"><a href="#3-同步读写" class="headerlink" title="3. 同步读写"></a>3. 同步读写</h1><h2 id="3-1-同步写write-some"><a href="#3-1-同步写write-some" class="headerlink" title="3.1 同步写write_some"></a>3.1 同步写write_some</h2><p>boost::asio提供了几种同步写的api，write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写这一部分，返回写入的字节数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_socket</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">	std::string buf = <span class="string">&quot;Hello World&quot;</span>;         <span class="comment">//定义要发送的字符串</span></span><br><span class="line">	std::<span class="type">size_t</span> total_bytes_written = <span class="number">0</span>;     <span class="comment">//记录成功发送数据的字节数</span></span><br><span class="line">	<span class="comment">//循环发送</span></span><br><span class="line">	<span class="comment">//write_som返回每次写入的字节数</span></span><br><span class="line">	<span class="keyword">while</span> (total_bytes_written != buf.<span class="built_in">length</span>()) &#123;    <span class="comment">//write_some()函数不能一次性传完</span></span><br><span class="line">		total_bytes_written += sock.<span class="built_in">write_some</span>(asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>() + total_bytes_written, buf.<span class="built_in">length</span>() - total_bytes_written));  <span class="comment">//write_some的第一个参数是buffer类型首地址，第二个参数是未发送的字节数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-同步写send"><a href="#3-2-同步写send" class="headerlink" title="3.2 同步写send"></a>3.2 同步写send</h2><p>write_some使用起来比较麻烦，需要多次调用，asio提供了send函数。send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_data_by_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个服务端终端节点</span></span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		<span class="comment">//asio::io_service ios;     //老版本</span></span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接对端</span></span><br><span class="line">		std::string buf = <span class="string">&quot;HEllo world&quot;</span>;</span><br><span class="line">		<span class="type">int</span> send_length = sock.<span class="built_in">send</span>(asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));    <span class="comment">//send函数是tcp没有发完指定数据就阻塞在这里，直到发完</span></span><br><span class="line">		<span class="keyword">if</span> (send_length &lt;= <span class="number">0</span>) &#123;              <span class="comment">//表示发送失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-同步写write"><a href="#3-3-同步写write" class="headerlink" title="3.3 同步写write"></a>3.3 同步写write</h2><p>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_data_by_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接对端</span></span><br><span class="line">		std::string buf = <span class="string">&quot;HEllo world&quot;</span>;</span><br><span class="line">		<span class="type">int</span> send_length = asio::<span class="built_in">write</span>(sock, asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));    <span class="comment">//write函数是tcp没有发完指定数据就阻塞在这里，直到发完</span></span><br><span class="line">		<span class="keyword">if</span> (send_length &lt;= <span class="number">0</span>) &#123;              <span class="comment">//表示发送失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-同步读read-some"><a href="#3-4-同步读read-some" class="headerlink" title="3.4 同步读read_some"></a>3.4 同步读read_some</h2><p>同步读和同步写类似，提供了读取指定字节数的接口read_some，需要多次调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">read_from_socket</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> MESSAGE_SIZE = <span class="number">7</span>;       <span class="comment">//要求读的长度</span></span><br><span class="line">	<span class="type">char</span> buf[MESSAGE_SIZE];</span><br><span class="line">	std::<span class="type">size_t</span> total_bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;</span><br><span class="line">		total_bytes_read += sock.<span class="built_in">read_some</span>(asio::<span class="built_in">buffer</span>(buf + total_bytes_read, MESSAGE_SIZE - total_bytes_read));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">string</span>(buf, total_bytes_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-同步读receive"><a href="#3-5-同步读receive" class="headerlink" title="3.5 同步读receive"></a>3.5 同步读receive</h2><p>可以一次性同步接收对方发送的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接到对端上</span></span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">		<span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">		<span class="type">char</span> receive_length = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));   <span class="comment">//receive函数是发送完指定数据，不然tcp不返回，阻塞</span></span><br><span class="line">		<span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-同步读read"><a href="#3-6-同步读read" class="headerlink" title="3.6 同步读read"></a>3.6 同步读read</h2><p>可以一次性同步读取对方发送的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端连接到对端上</span></span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">		<span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">		<span class="type">char</span> receive_length = asio::<span class="built_in">read</span>(sock,asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));   <span class="comment">//read函数是发送完指定数据，不然tcp不返回，阻塞</span></span><br><span class="line">		<span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-同步读写客户端和服务端"><a href="#4-同步读写客户端和服务端" class="headerlink" title="4. 同步读写客户端和服务端"></a>4. 同步读写客户端和服务端</h1><h2 id="4-1-客户端设计"><a href="#4-1-客户端设计" class="headerlink" title="4.1 客户端设计"></a>4.1 客户端设计</h2><p>基本思路：根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建上下文服务</span></span><br><span class="line">		boost::asio::io_context ioc;</span><br><span class="line">		<span class="comment">//构造endpoint</span></span><br><span class="line">		<span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;192.168.100.100&quot;</span>), <span class="number">9527</span>)</span></span>;     <span class="comment">//构造服务端的端点</span></span><br><span class="line">		<span class="comment">//创建socket</span></span><br><span class="line">		<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;    <span class="comment">//第一个参数是服务ioc,第二个参数可以不写</span></span><br><span class="line">		boost::system::error_code error = boost::asio::error::host_not_found; <span class="comment">//创建一个错误码，先赋值一个初值</span></span><br><span class="line">		<span class="comment">//请求连接对端</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;             <span class="comment">//连接失败执行下面</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;connect failed, code is&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;error msg is&quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接成功</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter message:&quot;</span>;</span><br><span class="line">		<span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">		std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);     <span class="comment">//每输入完一次按回车，就将信息存到request里面</span></span><br><span class="line">		<span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);   <span class="comment">//获取request里面的长度</span></span><br><span class="line">		boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length)); <span class="comment">//向服务端发送request里面的信息(转换成buffer类型才能发送)</span></span><br><span class="line">		<span class="type">char</span> reply[MAX_LENGTH];               <span class="comment">//用来存放服务端传过来的信息</span></span><br><span class="line">		<span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length)); <span class="comment">//接收从服务端发来的信息(转换成buffer类型才能接收)</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Reply is:&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">write</span>(reply, reply_length);        <span class="comment">//输出到终端</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-服务端设计"><a href="#4-2-服务端设计" class="headerlink" title="4.2 服务端设计"></a>4.2 服务端设计</h2><p>server函数作用：根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session</p>
<p>session函数作用：该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数，类似于回调函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt;socket_ptr;      <span class="comment">//定义指向socket的智能指针类型重命名为socket_ptr</span></span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt;thread_set;    <span class="comment">//线程集合，元素是指向线程的智能指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;       <span class="comment">//参数是与客户端之间进行通信的通信描述符(sock智能指针)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">char</span> data[max_length];                       <span class="comment">//接收数据的数组</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);              <span class="comment">//将该数组清空为0</span></span><br><span class="line">            boost::system::error_code error;             <span class="comment">//创建一个错误码</span></span><br><span class="line">            <span class="comment">//size_t length = boost::asio::read(sockaddr_size, boost::asio::buffer(data, max_length), error); //读客户端发来的数据，要读到max_length才返回</span></span><br><span class="line">            <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error); <span class="comment">//读到多少，返回多少</span></span><br><span class="line">            <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;               <span class="comment">//eof表示对端关闭</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;                              <span class="comment">//其它错误较严重，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印对端的ip地址(转为字符串打印出来)</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; endl;  <span class="comment">//sock-&gt;remote_endpoint()是对端的端点</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive message is&quot;</span> &lt;&lt; data &lt;&lt; endl;                 <span class="comment">//打印对端发来的数据</span></span><br><span class="line">            <span class="comment">//这里简单处理，直接将接收到的数据传给对端</span></span><br><span class="line">            boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in thread:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个accepter,是用来服务器接收客户端的连接的</span></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), port))</span></span>;   <span class="comment">//第一个参数是上下文，第二个参数是用ipv4的地址绑定本地服务器的地址---&gt;最终是端点形式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">socket_ptr <span class="title">socket</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>; <span class="comment">//创建了一个socket，智能指针指向它，并且初始化好了</span></span><br><span class="line">        <span class="comment">//调用了 tcp::acceptor 对象 a 的 accept 方法，这个方法会阻塞等待直到有一个新的TCP连接请求到达。一旦有客户端发起连接请求，accept 方法就会接受这个连接，并将新连接的套接字信息赋给 *socket，即 socket_ptr 智能指针所指向的 tcp::socket 对象</span></span><br><span class="line">        a.<span class="built_in">accept</span>(*socket);             <span class="comment">//连接成功后，此时的socket智能指针就相当于是通信描述符了</span></span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, socket);  <span class="comment">//创建一个线程，并指向session函数</span></span><br><span class="line">        thread_set.<span class="built_in">insert</span>(t); <span class="comment">//将新创建的线程 t 插入到一个线程集合 thread_set 中，为了后续对线程进行管理或监控</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;         <span class="comment">//定义一个服务，用于处理I/O操作，如网络连接和文件操作</span></span><br><span class="line">        <span class="built_in">server</span>(ioc, <span class="number">10086</span>);                  <span class="comment">//将服务和端口传递给server函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : thread_set) &#123;         <span class="comment">//遍历线程回收，这样主线程就是最后退出的</span></span><br><span class="line">            t-&gt;<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-同步读写的优劣"><a href="#4-3-同步读写的优劣" class="headerlink" title="4.3 同步读写的优劣"></a>4.3 同步读写的优劣</h2><p>1.缺点：</p>
<ul>
<li>同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态</li>
<li>可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多</li>
<li>该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开</li>
<li>该服务器和客户端未考虑粘包处理</li>
</ul>
<p>2.优点：当客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式，这样能简化编码难度</p>
<h1 id="5-异步读写"><a href="#5-异步读写" class="headerlink" title="5. 异步读写"></a>5. 异步读写</h1><p>这里先封装一个Node信息结构体，用来管理要发送和接收的数据，该结构包含数据域首地址，数据的总长度，以及已经处理的长度(已读的长度或者已写的长度)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//发送结点时的构造方式</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len):_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;  <span class="comment">//参数：一个字符串的首地址(字符串);长度。这里初始化了发送数据的总长度，以及当前发送的字节数为0</span></span><br><span class="line">		_msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];      <span class="comment">//开辟了一块要发送数据长度的空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_msg, msg, total_len);    <span class="comment">//直接将原来的内容copy到_msg中,现在_msg里面解释要发送的数据了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//接受结点时的构造方式</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;  <span class="comment">//参数就是读取数据的长度。这里初始化了要读取数据的总长度，以及当前读取的字节数为0</span></span><br><span class="line">		_msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];    <span class="comment">////开辟了一块要读取数据长度的空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _msg;                <span class="comment">//析构掉手动创建的空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> _total_len;            <span class="comment">//消息总长度</span></span><br><span class="line">	<span class="type">int</span> _cur_len;              <span class="comment">//当前接收或发送的字节数</span></span><br><span class="line">	<span class="type">char</span>* _msg;                <span class="comment">//消息的首地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而Session类负责完成异步读和异步写的工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(std::shared_ptr&lt;asio::ip::tcp::socket&gt;socket);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadFromSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadAllFromSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue; <span class="comment">//定义一个队列，里面的元素是指向信息结构体的智能指针</span></span><br><span class="line">	std::shared_ptr&lt;asio::ip::tcp::socket&gt;_socket;    <span class="comment">//定义一个指向socket智能指针</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt;_send_node;   <span class="comment">//定义一个指向信息结构体的智能指针(发送数据类型的)</span></span><br><span class="line">	<span class="type">bool</span> _send_pending;                   <span class="comment">//是否还有未发送完的数据</span></span><br><span class="line"></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_node;  <span class="comment">//定义一个指向信息结构体的智能指针(接收数据类型的)</span></span><br><span class="line">	<span class="type">bool</span> _recv_pending;                   <span class="comment">//是否还有未接收完的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-异步写async-write-some"><a href="#5-1-异步写async-write-some" class="headerlink" title="5.1 异步写async_write_some"></a>5.1 异步写async_write_some</h2><p>该方法可能会多次调用回调函数，比如说我们要求这个_total_len发送12个字节数据，那么调用的回调函数为什么一直返回5个字节勒？这个是因为我们要求它发多长，但是tcp它有一个发送缓冲区，跟我们用户缓冲区是不一致的，tcp的发送缓冲区实际上空闲的空间比我们要求发送的总长度要小，所以它实际发送的长度要比我们要求的少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span> </span>&#123;      <span class="comment">//参数是要发送的数据</span></span><br><span class="line">	<span class="comment">//构造一个发送数据结构体结点，存放buf数据(要发送的)，插入到队列里面(就算因为还有数据未发送完，但也已经插入到队列，这些数据迟早也会发送的)</span></span><br><span class="line">	_send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line">	<span class="keyword">if</span> (_send_pending) &#123;   <span class="comment">//如果有未发送完的数据，直接返回，就不要再调用异步发送了，因为多次调用异步发送会出问题</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没有数据，就调用异步的发送队列</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(buf),std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));  <span class="comment">//发送完不确定数据长度后，才会调用回调函数</span></span><br><span class="line">	_send_pending = <span class="literal">true</span>;         <span class="comment">//设为true，表示数据没有发送完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是错误码和才发送完的数据长度(WriteCallBack函数是已经发送完bytes_transferred长度数据后才被调用的)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;              <span class="comment">//有错误，打印错误码和错误信息，然后直接退出</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error,code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();   <span class="comment">//取出第一个元素(发送消息结构体)出来，因为第一个是我们正在发送的数据</span></span><br><span class="line">	send_data-&gt;_cur_len += bytes_transferred; <span class="comment">//正在发送的数据，它的当前发送长度+传回来这次已经发送的长度---&gt;更新成当前长度了</span></span><br><span class="line">	<span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;  <span class="comment">//更新后当前已发送的长度 &lt; 要求发送的长度，就继续发送</span></span><br><span class="line">        <span class="comment">//buffer里面要做偏移，接下来要发送的位置是数据首地址+已经发送完的数据量；剩余数据量是总的数据量-已经发送数据量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有执行上面if，就说明队列首元素消息结构体数据已经发送完毕了</span></span><br><span class="line">	_send_queue.<span class="built_in">pop</span>();            <span class="comment">//就从队列中抛出这个结点(每个结点都有它的任务，即要发送的数据)</span></span><br><span class="line">	<span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;    <span class="comment">//如果这个结点队列为空了，说明发送完了</span></span><br><span class="line">		_send_pending = <span class="literal">false</span>;    <span class="comment">//将这个变量置为假，以后有数据要发送，就可以直接放入队列，马上执行异步发送的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;         <span class="comment">//如果结点队列还有，就继续发送队列当前首元素的信息结构体里面的信息</span></span><br><span class="line">		<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();      <span class="comment">//再次取出队列的第一个元素发出</span></span><br><span class="line">        <span class="comment">//第一次发送send_data-&gt;_cur_len为0，但也要写上好一点，因为该变量是会更新的，后面调用就不一定是0了</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-异步写async-send"><a href="#5-2-异步写async-send" class="headerlink" title="5.2 异步写async_send"></a>5.2 异步写async_send</h2><p>socket里面还有另一个异步发送的函数async_sned，它是boost::asio帮我们封装的，它是把数据全部发送完毕，才会调用回调函数。表面上是只做了一次回调，但它底层会多次调用async_write_some函数来帮我们完成数据的读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span> </span>&#123;       <span class="comment">//参数是要发送的数据</span></span><br><span class="line">	<span class="comment">//构造一个发送消息结构体结点，存放buf数据(要发送的)，插入到队列里面</span></span><br><span class="line">	_send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line">	<span class="keyword">if</span> (_send_pending) &#123;    <span class="comment">//如果有未发送完的数据，直接返回，就不要再调用异步发送了，因为多次调用异步发送会出问题</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证只调用一次回调，这次回调出来的长度就是我们要求发送的长度</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_send</span>(asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));   <span class="comment">//参数：我们要发送的数据，绑定函数(回调函数，该函数所属的对象，占位符)</span></span><br><span class="line">	_send_pending = <span class="literal">true</span>;            <span class="comment">//置为真，表示有数据在发送</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当发送完指定的数据后，就会调用回调函数WriteAllCallBack(不会多次回调，只会发送完指定数据，才执行回调函数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;              <span class="comment">//有错误，直接退出</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error,code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有错误，就说明整条数据发送完毕,因为async_send调用一次回调函数就可以发送完要求发送的数据</span></span><br><span class="line">	_send_queue.<span class="built_in">pop</span>();              <span class="comment">//把队首元素抛出来</span></span><br><span class="line">	<span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;      <span class="comment">//如果队列为空，说明数据都发送完了，把判断的状态置为空</span></span><br><span class="line">		_send_pending = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;      <span class="comment">//说明还有结点的数据可以发送</span></span><br><span class="line">		<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();     <span class="comment">//取出对头元素，继续发送</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_send</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));   <span class="comment">//参数：我们要发送的数据，绑定函数(回调函数，该函数所属的对象，占位符)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-异步读async-read-some"><a href="#5-3-异步读async-read-some" class="headerlink" title="5.3 异步读async_read_some"></a>5.3 异步读async_read_some</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_recv_pending) &#123;     <span class="comment">//服务器端处于接受状态，其它的应用层调用该函数，就直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个接收结点</span></span><br><span class="line">	_recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line">	<span class="comment">//异步的读函数，读完后，如果数据读好后，会调用传递给它的回调函数,_total_len定义的长度是1024</span></span><br><span class="line">	_socket-&gt;<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), <span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	_recv_pending = <span class="literal">true</span>;       <span class="comment">//置为true，只要回调被执行完后，给它置为false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	_recv_node-&gt;_cur_len += bytes_transferred;       <span class="comment">//对读取的数据长度进行更新</span></span><br><span class="line">	<span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;    <span class="comment">//如果当前读完的长度 &lt; 要求长度</span></span><br><span class="line">		_socket-&gt;<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len, _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), <span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没有执行上面if，说明读完了</span></span><br><span class="line">	_recv_pending = <span class="literal">false</span>;</span><br><span class="line">	_recv_node = <span class="literal">nullptr</span>;        <span class="comment">//不写这行也可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-异步读async-receive"><a href="#5-4-异步读async-receive" class="headerlink" title="5.4 异步读async_receive"></a>5.4 异步读async_receive</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_recv_pending) &#123;       <span class="comment">//服务器端处于接受状态，其它的应用层调用该函数，就直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);   <span class="comment">//创建一个接收结点</span></span><br><span class="line">	<span class="comment">//async_receive是异步的接收，能一次性保证数据接收到我们要求的长度，只触发一次回调函数</span></span><br><span class="line">	_socket-&gt;<span class="built_in">async_receive</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	_recv_pending = <span class="literal">true</span>;    <span class="comment">//判断状态只为true。虽然是异步，但通过同步的方式去控制它</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为async_receive是读完所有数据才执行回调，所以执行回调的时候，数据已经读取完了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	_recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">	_recv_node = <span class="literal">nullptr</span>;            <span class="comment">//不置为空也可以</span></span><br><span class="line">	_recv_pending = <span class="literal">false</span>;  <span class="comment">//表示这个数据已经接收完，不存在阻塞状态，已经触发回调函数，回调函数已经处理完，下一次又可以创建新的结点进行接收了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：读和写都是一样，发送数据推荐async_send，读数据推荐async_read_some。总结如下：<br>async_receive和async_read_some不能混着用，因为async_receive内部也是多次调用async_read_some，那么它也会多次触发<br>ReadCallBack回调函数，也会多次去发送我们要发送的数据。如果混着用，在boost::asio底层就不会去考虑顺序性，读到的数据就可能是乱的了。</p>
<h1 id="6-异步服务端实现"><a href="#6-异步服务端实现" class="headerlink" title="6. 异步服务端实现"></a>6. 异步服务端实现</h1><h2 id="6-1-头文件"><a href="#6-1-头文件" class="headerlink" title="6.1 头文件"></a>6.1 头文件</h2><p>Session类是用于处理与客户端通信的工作；Server类是用于处理与客户端建立连接的任务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :_socket(ioc) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;               <span class="comment">//获取socket变量的函数</span></span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred)</span></span>; <span class="comment">//错误码；读到的数据数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	<span class="keyword">enum</span> &#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line">	<span class="type">char</span> _data[max_length];        <span class="comment">//存放数据的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port);   <span class="comment">//初始化时，传入ioc和监听的端口号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	boost::asio::io_context&amp; _ioc;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-主要函数"><a href="#6-2-主要函数" class="headerlink" title="6.2 主要函数"></a>6.2 主要函数</h2><p>当有客户端发数据过来的时候，因为这里通过async_read_some监听了读事件，当读事件就绪的时候，会触发读的回调函数，在start函数里，为session绑定了一个读事件，_socket.async_read_some在boost::asio底层就会把这个_socket的读事件添加到epoll表里，这样当_socke有读事件就绪的时候(_socket它的tcp缓冲区由空变成有数据)，就会触发回调函数handle_read，在回调函数里就可以把数据读出来。<br>至于为什么data会自动把新的数据拷贝到data里？因为asio帮我们做的，就是说我们把_data传给异步读函数async_read_some的时候，asio自动的把数据读到了_data里，所以handle_read函数里就直接读出_data的数据即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;     <span class="comment">//定义一个服务</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(ioc, <span class="number">9527</span>)</span></span>;</span><br><span class="line">        ioc.<span class="built_in">run</span>();             <span class="comment">//底层是让模型在它的线程里去做一个循环的轮询操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数，传了两个参数(上下文，端口)，后面_ioc因为是类成员变量，所以进行了初始化，_acceptor是用来负责接收连接的描述符，给_acceptor传递的参数：上下文、端点(它要绑定的端口)---&gt;匹配本机地址---&gt;_acceptor监听本地地址的port端口号的，只要客户端往这个端口去连接，都会被_acceptor捕获</span></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port) :_ioc(ioc), _acceptor(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Server start success, on part:&quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();   <span class="comment">//服务端算是搭建成功了，等待客户端来连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先创建一个new_session，然后用_acceptor去接收连接，当有连接到来的时候，这个new_session就绑定到这个函数(handle_accept)里,然后这个new_session就专门处理对端的连接信息了，对端发数据、写数据都交给new_session处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);        <span class="comment">//创建一个Session</span></span><br><span class="line">	<span class="comment">//把这个Session的socket传进去，这样accept才能根据这个socket给我们返回一个新的连接</span></span><br><span class="line">	<span class="comment">//参入的参数：socket(这个socket负责服务与对端的通信)；绑定的函数(new_session是绑定函数的第一个参数，而占位符是占位error位置)</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, placeholders::_1));    <span class="comment">//如果与客户端建立成功，就会执行handle_accept回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;        <span class="comment">//是0的话，就表示成功了</span></span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();       <span class="comment">//让它去接收客户端的收发信息了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">delete</span> new_session;        <span class="comment">//失败就delete掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面就处理完一个连接了，_acceptor还要去接收新的连接</span></span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);       <span class="comment">//将存放数据的_data清空置0</span></span><br><span class="line">    <span class="comment">//buffer参数是：首地址；长度</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2)); <span class="comment">//因为handle_read有两个参数，需要两个占位符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读的回调函数，就是客户端发数据过来，就调用该函数(调用该函数时，数据已经读到了_data中)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;   <span class="comment">//如果没有错，打印客户端发来的数据</span></span><br><span class="line">        <span class="comment">//同读一样，把_socket通过async_write绑定一个写事件，写的数据是_data,写的多少是bytes_transferred。如果异步调用了该写函数，而tcp的发送缓冲区现在又没有可用的空间，它是不会回调async_write函数的；只有当tcp的发送缓冲区给我们的数据发出去后，它就会调用async_write函数了，然后把刚刚收到的数据发送过去。发送数据时，asio就会知道，它会调用我们新绑定的函数对象，把参数传给placeholders::_1所占的位置</span></span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, placeholders::_1));   <span class="comment">//绑定发送的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                <span class="comment">//如果有错误(对端关闭也属于错误，会执行下面)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;                      <span class="comment">//有错误，直接销毁掉Session，就说明这个连接断开了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用了async_write回调函数时，先将data清除一下(因为已经发送成功)，接下来就直接往这个data里面读数据即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2)); <span class="comment">//因为handle_read有两个参数，需要两个占位符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                       <span class="comment">//如果有错误</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;            <span class="comment">//有错误，直接销毁掉Session，就说明这个连接断开了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面需要了解的是：用户态跟tcp的缓冲区的联系，什么能造成写就绪事件，什么能造成读就绪事件，也就是什么时候能触发写回调，什么时候能触发读回调。触发读回调是因为tcp的缓冲区有数据；触发写回调是因为tcp缓冲区有空闲空间，那么就可用从用户态将信息拷贝到tcp缓冲区，然后tcp再发出去，这时候就能触发写回调。</p>
<h2 id="6-3-伪闭包延长连接生命周期"><a href="#6-3-伪闭包延长连接生命周期" class="headerlink" title="6.3 伪闭包延长连接生命周期"></a>6.3 伪闭包延长连接生命周期</h2><p>上面异步代码在某些情况下，会出现一些隐患，比如说这个服务器将要发送数据给客户端，也就是读到数据后，将要调用async_write去发数据，如果这个时候客户端断掉了，而写事件已经就绪，写事件在写的时候，会触发写回调handle_write，它也会发现对端断掉了，所以它在handle_write函数里面会执行错误处理代码段，因此就会回收数据(delete this)。但是因为对端关闭了，它还会触发一次读回调，而读回调也会捕获到对端关闭了，那么它也会去执行delete this代码。所以这样的话，两次的delete this就会造成内存的二次释放，系统就会崩溃。</p>
<p>上面的情况可以理解为：读到数据过后，在发送数据给对端之前，把连接断掉。</p>
<blockquote>
<p>解决办法：因为c++里面没有闭包的机制，所以这里就用c++11的特性里面的智能指针。因为智能指针是有引用计数的，如果把智能指针传给一个函数对象，这个函数对象不被释放掉，那么这个智能指针就不会被释放掉。如果我们把智能指针传给回调函数(假设它会被放到一个回调的队列里)，那么回调函数就是一个函数对象，这个函数对象没有被调用，没有被释放之前，智能指针也不会被释放。所以我们可以把智能指针作为参数传递给回调函数，函数内部再使用智能指针，智能指针就不会被释放掉了。</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt;  <span class="comment">//继承一个模板类，需要什么样的类型，传入什么</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context&amp; ioc, Server* server) :_socket(ioc), _server(server) &#123;</span><br><span class="line">		<span class="comment">//定义一个uuid(通过自定义生成器,它的构造函数生成一个函数对象，函数对象再调用它函数)</span></span><br><span class="line">		boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">		_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);    <span class="comment">//把生成的uuid经过转换就能生成唯一的_uuid了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;          <span class="comment">//获取socket变量的函数</span></span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, shared_ptr&lt;Session&gt; _self_shared)</span></span>;   <span class="comment">//错误码；读到的数据数；接收一个指向当前 Session 对象的shared_ptr</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;Session&gt; _self_shared)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	<span class="keyword">enum</span> &#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line">	<span class="type">char</span> _data[max_length];</span><br><span class="line">	Server* _server;                 <span class="comment">//Server成员变量</span></span><br><span class="line">	std::string _uuid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	boost::asio::io_context&amp; _ioc;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, shared_ptr&lt;Session&gt;&gt;_sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数是ioc和端口号，往这个端口去连接，都会被_acceptor捕获</span></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port) :_ioc(ioc), _acceptor(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Server start success, on part:&quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shared_ptr&lt;Session&gt; new_session = <span class="built_in">make_shared</span>&lt;Session&gt;(_ioc, <span class="keyword">this</span>);   <span class="comment">//用智能指针的形式创建</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;        <span class="comment">//是0的话，就表示成功了</span></span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();              <span class="comment">//让它去接收客户端的收发信息了</span></span><br><span class="line">		_sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));   <span class="comment">//_sessions就可以管理这些连接了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面就处理完一个连接了，_acceptor还要去接收新的连接</span></span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	_sessions.<span class="built_in">erase</span>(uuid);           <span class="comment">//从_sessions里将它移除就可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);              <span class="comment">//将存放数据的_data清空置0</span></span><br><span class="line">    <span class="comment">//shared_from_this()是创建了一个指向当前Session对象的shared_ptr。这个shared_ptr被传递给异步操作的回调函数，以确保在异步操作完成时，Session 对象仍然有效。这通常用于确保在异步操作的回调函数执行期间，对象不会被销毁。</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读的回调函数，就是客户端发数据过来，就调用该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> bytes_transferred, shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;</span><br><span class="line">		boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, placeholders::_1, _self_shared));   <span class="comment">//绑定发送的回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;         <span class="comment">//如果有错误(对端关闭也属于错误，会执行下面)</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果handle_read函数进入了错误处理，调用它的ClearSession函数，传入自己_uuid即可,这样该session就会从server中移除</span></span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">Session::GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用了async_write回调函数时，先将data清除一下(因为已经发送成功)，接下来就直接往这个data里面读数据即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">		_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, _self_shared));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪闭包延长连接声明周期原理：把智能指针作为参数传递给bind函数，bind是按值的方式去绑定的，它绑定一个智能指针的值给新生成的一个函数对象，新生成的函数对象会使用这个智能指针(以值的方式来使用)，也就增加了智能指针的引用计数。我们使用的智能指针引用计数不为0，所以智能指针就不会被释放，则session就不会被释放(智能指针是session类型的)，所以说该智能指针session它的声明周期就和新生成的函数对象的声明周期延长了，延长到和这个新生成的函数对象声明周期一致。因为我们既绑定了读的回调，也绑定了写的回调，所以说这个session，它的引用计数在这里每绑定一次，就会加1。也就不会出现新生成的函数对象被调用之前，这个session就被释放掉的情况(避免了释放已经释放的内存)。</p>
<h2 id="6-4-添加发送队列"><a href="#6-4-添加发送队列" class="headerlink" title="6.4 添加发送队列"></a>6.4 添加发送队列</h2><p>上面介绍了通过智能指针实现伪闭包的方式延长了session的生命周期，而实际使用的服务器并不是应答式，而是全双工通信方式，服务器是一直监听写事件，接收对端数据的，那么当服务器发送数据给对端时，就不能保证数据的有序性。</p>
<blockquote>
<p>解决办法：设计一个数据结点，首先在CSession类里新增一个队列存储要发送的数据，因为我们不能保证每次调用发送接口的时候上一次数据已经发送完(如果上一次没有发送完，而恰巧我们又调用了一次接口，那么boost.asio底层不知道是要发送上一次没有发送完的数据，还是发送新一次调用的数据。所以勒，这样就能造成数据的混乱)，所以就要把要发送的数据放入队列中，通过回调函数不断地发送。而且我们不能保证发送的接口和回调函数的接口在一个线程，所以要增加一个锁保证发送队列安全性。</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">int</span> max_len) &#123;  <span class="comment">//参数：数据的首地址；数据的长度</span></span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[max_len];      <span class="comment">//通过长度new处理一片空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data, msg, max_len);    <span class="comment">//把原数据拷贝到现在的成员变量里，保证数据是一个深拷贝，以后操作这个数据即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _data;                 <span class="comment">//在析构的时候，直接delete掉</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _cur_len;                       <span class="comment">//表示当前已经处理的长度</span></span><br><span class="line">	<span class="type">int</span> _max_len;                       <span class="comment">//表示数据的总长度</span></span><br><span class="line">	<span class="type">char</span>* _data;                        <span class="comment">//数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code &amp; error)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">	boost::asio::io_context &amp;_io_context;</span><br><span class="line">	<span class="type">short</span> _port;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">	~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Ssession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">	CServer* _server;</span><br><span class="line">	std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;     <span class="comment">//队列</span></span><br><span class="line">	std::mutex _send_lock;                          <span class="comment">//锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port),</span><br><span class="line">_acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;      <span class="comment">//建立连接的函数</span></span><br><span class="line">	shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>); <span class="comment">//当前的server也传进去了</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与客户端连接传给后执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();    <span class="comment">//没有问题，直接去执行读写操作</span></span><br><span class="line">		_sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//插入map，方便管理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartAccept</span>();    <span class="comment">//连接成功一个后，继续去监听连接，等待其它客户端连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	_sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">	_socket(io_context), _server(server)&#123;</span><br><span class="line">	boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------下面是开始执行通信的操作---------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    <span class="comment">//读取客户端发来的信息</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当获取到到客户发送的数据后，会执行该回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//全双工的方式，收到数据后，就继续监听</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;   <span class="comment">//收到数据会回调HandleRead函数，直接读出来</span></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);       <span class="comment">//把收到的数据给对端发回去</span></span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);        <span class="comment">//发完了把data清掉，方便下一次接收</span></span><br><span class="line">        <span class="comment">//下面又绑定它的接收事件，继续读取客户端发来的数据</span></span><br><span class="line">        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is end &quot;</span> &lt;&lt; endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);    <span class="comment">//如果出错，就直接通过_uuid清除掉对应的Session</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;   <span class="comment">//接收到数据后，回应对端的函数，参数是发发送的数据和长度</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>; <span class="comment">//先默认将该变量设为false(表示上一次的数据已经发完了),为true表示当前的发送列表里有数据，表示上一次的数据没有发完</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;     <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">if</span> (_send_que.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;   <span class="comment">//判断队列是否为空，不为空，说明上一次发送的数据没有发完，将该变量设为true</span></span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个MsgNode节点，把要发送的数据拷贝到该节点，并将该节点放到队列里(用了深拷贝，数据都存放在自己的空间了)</span></span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;     <span class="comment">//再一次判断是否为true，如果为true，说明有数据没有发完，直接返回(已经把要发送的数据放到队列了)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果为false，说明之前队列是为空的，但刚刚将要发送的数据添加到了队列，所以这一次必须是调用要发送的接口了(因为之前的数据发完了，</span></span><br><span class="line">    <span class="comment">// 必须手动的再调用一次接口，调用一下异步发送，这样我们通过回调函数来处理我们发送的结果)</span></span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msg, max_length), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该回调函数是指定数据都发送完了，才会被调用。当被调用的时候，也说明发送完一个节点的数据，所以下面代码可以直接取出一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;   <span class="comment">//加锁</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();    <span class="comment">//取出队列首结点，刚刚发送的就是该结点。该函数被调用时，就说明队列的首元素已经发送完了</span></span><br><span class="line">        <span class="comment">//判断发送队列是否为空，为空则发送完，否则不断取出队列数据调用async_write发送，直到队列为空。</span></span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;       <span class="comment">//不为空，就取出队列的首元素，再次调用异步的发送函数</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-粘包处理"><a href="#6-5-粘包处理" class="headerlink" title="6.5 粘包处理"></a>6.5 粘包处理</h2><p>1.粘包问题</p>
<p>粘包问题是服务器收发数据常遇到的一个现象，比如说当客户端发送两个Hello World！给服务器，服务器TCP接收缓冲区接收了两次，一次是Hello World!Hello, 第二次是World！</p>
<p>2.粘包原因</p>
<p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！</p>
<p>3.产生粘包问题其它原因</p>
<ul>
<li>客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！</li>
<li>tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法</li>
<li>再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连</li>
</ul>
<blockquote>
<p>解决办法：处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span>         <span class="comment">//存放数据的节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//发送时使用的构造函数。参数：一个字符串的首地址；该字符串的长度。初始化数据的总长度(数据+头)，初始化当前发送长度为0</span></span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="number">0</span>)&#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len+<span class="number">1</span>]();  <span class="comment">//自己开辟了一块空间存数据，空间大小是总长度+1 ---&gt;最后面多加一个\0</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);  <span class="comment">//头节点存有效字符串数据的长度max_len</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len); <span class="comment">//偏移两个字节存有效数据字符串</span></span><br><span class="line">        _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;                  <span class="comment">//最后一个字节空间存\0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收时使用的构造函数。参数：接收数据的长度</span></span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len),_cur_len(<span class="number">0</span>) &#123;  <span class="comment">//初始化了总长度和当前长度为0</span></span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len +<span class="number">1</span>]();         <span class="comment">//开辟了一块空间，存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;         <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _cur_len;     <span class="comment">//当前发送或接收数据长度</span></span><br><span class="line">    <span class="type">short</span> _total_len;   <span class="comment">//要发送或接受的数据长度</span></span><br><span class="line">    <span class="type">char</span>* _data;        <span class="comment">//存放数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">    ~<span class="built_in">CSession</span>();</span><br><span class="line">    <span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">int</span> max_length)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    tcp::socket _socket;</span><br><span class="line">    std::string _uuid;</span><br><span class="line">    <span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">    CServer* _server;</span><br><span class="line">    <span class="type">bool</span> _b_close;</span><br><span class="line">    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;</span><br><span class="line">    std::mutex _send_lock;</span><br><span class="line">    <span class="comment">//收到的消息结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;  <span class="comment">//用来存储接收到的有效数据消息体</span></span><br><span class="line">    <span class="type">bool</span> _b_head_parse;                       <span class="comment">//表示头部是否解析完成</span></span><br><span class="line">    <span class="comment">//收到的头部结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_head_node; <span class="comment">//用来存储接收到头部消息体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code &amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context &amp;_io_context;</span><br><span class="line">    <span class="type">short</span> _port;</span><br><span class="line">    tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数传入ioc和监听的端口号，该函数进行初始化成员变量和建立了服务端的终端端点(开始监听连接)</span></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port), _acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>); <span class="comment">//创建一个session，并初始化</span></span><br><span class="line">    <span class="comment">//异步连接，阻塞监听客户端，当与客户端建立连接成功后，执行绑定的回调函数HandleAccept</span></span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();     <span class="comment">//如果连接没有问题，开始通信</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//将该session添加到map里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">//连接失败，打印错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();    <span class="comment">//继续监听客户端释放发来连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;   <span class="comment">//当出错或断开连接时，将对应的session移出map</span></span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------下面是通信的代码------------------------------</span></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):_socket(io_context), _server(server), _b_close(<span class="literal">false</span>),_b_head_parse(<span class="literal">false</span>)&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;    <span class="comment">//获取socket</span></span><br><span class="line">    <span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;      <span class="comment">//获取uuid</span></span><br><span class="line">    <span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;           <span class="comment">//开始通信函数</span></span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())); <span class="comment">//异步读数据，读成功执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_send_que.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _socket.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="built_in">front</span>()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;   <span class="comment">//读了数据长度bytes_transferred，执行的该函数，数据放到_data中的</span></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;       <span class="comment">//如果读取数据没有出错</span></span><br><span class="line">        <span class="comment">//已经移动的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred&gt;<span class="number">0</span>) &#123;   <span class="comment">//只要读取的数据大于0，执行下面函数</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;     <span class="comment">//头部数据是否处理完，如果没有处理完，执行下面</span></span><br><span class="line">                <span class="comment">//如果这次读的字节数+之前处理完的字节数 &lt; 头部应该收到字节数 ---&gt;这种情况说明这次读到的数据全部头部数据，且头部数据还没有读完</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+ copy_len, bytes_transferred); <span class="comment">//直接将这次读的全部数据作为头部数据存到_recv_head_node节点</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred; <span class="comment">//更新头部数据读到的位置</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);  <span class="comment">//将_data清0，下一次继续往这里面存读到的数据</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;  <span class="comment">//1.这种情况就退出，下次读回调触发，继续读头部数据。因为头部数据都没有接收到完毕，就没有必要继续执行下去</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据+已经处理的头部数据&gt;头部数据，说明这次收到的数据一部分是头部数据，一部分是真实信息数据</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;  <span class="comment">//获取头部剩余未复制的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain);   <span class="comment">//将头部剩余未处理的字节数全部存到_recv_head_node头节点</span></span><br><span class="line">                copy_len += head_remain;      <span class="comment">//更新已处理的长度</span></span><br><span class="line">                bytes_transferred -= head_remain;   <span class="comment">//更新剩余未处理的长度，剩余就是真实数据的内容一部分</span></span><br><span class="line">                <span class="comment">//获取头部数据(也就是真实数据的长度)</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;   <span class="comment">//打印真实数据的长度</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;      <span class="comment">//判断真实数据的长度是否超出规定长度</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);    <span class="comment">//如果超出规定长度，则直接将其移出map</span></span><br><span class="line">                    <span class="keyword">return</span>;   <span class="comment">//不合法直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果合法，定义一个存放真实数据的MsgNode节点</span></span><br><span class="line">                _recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">				<span class="comment">//处理完头部数据后，剩余消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//这种情况是剩余未处理的bytes_transferred全部是真实数据的一部分，所以全部copy</span></span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;   <span class="comment">//更新数据节点的当前处理长度</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//将_data清0，继续存放下一次读取的数据</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;  <span class="comment">//虽然有效数据长度未处理完成，但头部结点处理完成，设未true</span></span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">//2.这种情况退出后，下次继续执行HandleRead函数，读剩余真实数据(注意：此时_b_head_parse = true;)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完头部数据后，剩余消息的长度大于等于头部规定的长度，说明真实数据收全 或 收全全还出现粘包</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);  <span class="comment">//这种情况，直接将真实数据长度，全部copy到存放数据的节点_recv_msg_node</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;    <span class="comment">//更新当前处理长度</span></span><br><span class="line">                copy_len += data_len;            <span class="comment">//更新读到的数据_data里面处理的长度</span></span><br><span class="line">                bytes_transferred -= data_len;   <span class="comment">//更新_data还剩未处理的数据长度</span></span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">//真实数据读完，后面加&#x27;\0&#x27;</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;  <span class="comment">//打印真实数据内容(客户端真实数据的内容)</span></span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);  <span class="comment">//发送给客户端</span></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;  <span class="comment">//处理完一个，继续下一个，将该变量设为false，表示头部未处理</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();  <span class="comment">//把头部结点进行清除，下一次发送用</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;  <span class="comment">//这种情况是没有粘包(刚刚好真实数据读完，_data就无数据要处理了)</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//下面继续挂起读</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//还有数据，出现粘包情况，退出当前循环，执行下一次循环，继续读(包括从头部数据处理开始)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是已经处理完头部(_b_head_parse为真，没有执行上面的if)，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//获取真实数据还未处理的长度</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;  <span class="comment">//如果读到的数据仍小于剩余未处理的长度，说明下次还要继续读真实数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//这次读的全部数据长度bytes_transferred都是真实数据的一部分</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;  <span class="comment">//更新当前真实数据处理长度</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);    <span class="comment">//清0，存放下一次读的数据</span></span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;      <span class="comment">//退出，真实数据还没有读完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读到的数据大于等于剩余未处理的长度，说明真实数据读完了 或 读完了并且粘包</span></span><br><span class="line">            <span class="comment">//下面直接先将真实数据未处理的长度处理完</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;  <span class="comment">//更新真实数据当前处理长度</span></span><br><span class="line">            bytes_transferred -= remain_msg;   <span class="comment">//更新_data处理好真实数据后，还剩余处理长度</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//真实数据处理完，加&#x27;\0&#x27;</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;   <span class="comment">//打印客户端发来的内容</span></span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);   <span class="comment">//发送给客户端</span></span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;    <span class="comment">//处理完真实数据后，将该变量设未false,下一次继续从头节点开始处理</span></span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;    <span class="comment">//这种情况是没有出现粘包</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//清0，继续挂起读</span></span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;    <span class="comment">//直接退出，挂起了继续读</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">//还有数据，出现粘包情况，退出当前循环，执行下一次循环，继续读(包括从头部数据处理开始)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>boost</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(中)</title>
    <url>/2024/07/11/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="1-asio的通信流程"><a href="#1-asio的通信流程" class="headerlink" title="1. asio的通信流程"></a>1. asio的通信流程</h1><p>首先是在应用层调用async_read()函数，就相当于是往io_context里面注册读事件，并且注册读回调函数。然后io_context会把对应的读事件、socket和回调都写到epoll模型或iocp模型里，即注册给这两个模型。而在应用层调用io_context.run的时候，实际上是一个死循环，它会调用linux的epoll模型或windows的iocp模型，以死循环的方式不断的轮询，不断的去检测我们注册的那些socket那些就绪了</p>
<p>如果有socket就绪了，比如说我们注册了一个socket监听对端的一个发送事件，对端发送过来了，我们这个读事件就会就绪了。读事件就绪的话，就会把读事件对应的回调函数写到就绪的队列里。如果是单线程的话，这些事件的回调函数放到就绪的队列里，系统直接就会把就绪队列里的回调函数一个一个取出来，按顺序来给我们回调，顺序就是我们在底层去轮询，发现哪个socket回调函数先就绪了，就先放到就绪队列里。如果是写的事件，它也会被放到该就绪队列里，最后由asio统一派发。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_1.png"></p>
<h1 id="2-字节序处理"><a href="#2-字节序处理" class="headerlink" title="2. 字节序处理"></a>2. 字节序处理</h1><h2 id="2-1-字节序的问题"><a href="#2-1-字节序的问题" class="headerlink" title="2.1 字节序的问题"></a>2.1 字节序的问题</h2><p>在计算机网络中，由于不同的计算机使用的 CPU 架构和字节顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。具体来说，计算机内部存储数据的方式有两种：大端序和小端序。在大端序中，高位字节存储在低地址处，而低位字节存储在高地址处；在小端序中，高位字节存储在高地址处，而低位字节存储在低地址处。</p>
<p>在网络通信过程中，通常使用的是大端序。这是因为早期的网络硬件大多采用了 Motorola 处理器，而 Motorola 处理器使用的是大端序。此外，大多数网络协议规定了网络字节序必须为大端序。因此，在进行网络编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转换为大端序。可以使用诸如 htonl、htons、ntohl 和 ntohs 等函数来实现字节序转换操作。</p>
<p>综上所述，网络字节序的主要作用是统一不同计算机间的数据表示方式，以保证数据在网络中的正确传输和解析。</p>
<p>判断当前本机的字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前系统的字节序是大端序还是小端序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span>*)&amp;num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前系统为小端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前系统为大端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-服务器中使用字节序"><a href="#2-2-服务器中使用字节序" class="headerlink" title="2.2 服务器中使用字节序"></a>2.2 服务器中使用字节序</h2><p>1.主机字节序转换为网络字节序</p>
<ul>
<li><p>boost::asio::detail::socket_ops::host_to_network_long() ：将一个32位无符号整数从主机字节序转换为网络字节序</p>
</li>
<li><p>boost::asio::detail::socket_ops::host_to_network_short() ：将一个16位无符号整数从主机字节序转换为网络字节序</p>
</li>
</ul>
<p>2.网络字节序转换为主机字节序</p>
<ul>
<li><p>boost::asio::detail::socket_ops::network_to_host_short()：将网络字节序转换为16位无符号整数主机字节序</p>
</li>
<li><p>boost::asio::detail::socket_ops::network_to_host_long()：将网络字节序转换为32位无符号整数主机字节序</p>
</li>
</ul>
<p>在异步处理的服务器中，当接受客户端发来的数据时，需要将其进行转换，从网络字节序转换为本地字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> data_len = <span class="number">0</span>;            <span class="comment">//存放转换后的结果</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH); <span class="comment">//将头部数据内容copy到data_len，此时还是网络字节序</span></span><br><span class="line"><span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">data_len=boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(data_len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="number">0</span>)&#123;  <span class="comment">//发送数据节点</span></span><br><span class="line">    _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len+<span class="number">1</span>]();      <span class="comment">//开辟一块存发送数据的空间</span></span><br><span class="line">    <span class="comment">//转为网络字节序</span></span><br><span class="line">    <span class="type">int</span> max_len_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data, &amp;max_len_host, HEAD_LENGTH);    <span class="comment">//将转换的结果存到_data头部(前面)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);     <span class="comment">//继续往_data后面存储真实数据</span></span><br><span class="line">    _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//最后加上&#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-asio处理粘包的另一种方式"><a href="#3-asio处理粘包的另一种方式" class="headerlink" title="3. asio处理粘包的另一种方式"></a>3. asio处理粘包的另一种方式</h1><p>我们之前使用的一种方式是通过async_read_some函数监听读事件，并且绑定了读事件的回调函数HandleRead。async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接收的字节数，接收的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来很复杂。</p>
<p>所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用async_read函数，这个函数指定读取指定字节数，只有完全读完才会触发回调函数。</p>
<h2 id="3-1-获取头部数据"><a href="#3-1-获取头部数据" class="headerlink" title="3.1 获取头部数据"></a>3.1 获取头部数据</h2><p>当服务器与客户端建立完毕，进入通信工作，先就绪读头部数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _recv_head_node-&gt;<span class="built_in">Clear</span>();    <span class="comment">//将存头部数据的节点_data清0，当前处理长度设为0</span></span><br><span class="line">    <span class="comment">//先读头部的两个字节数据，一次性读完的，只有读完才会触发HandleReadHead回调函数</span></span><br><span class="line">    boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    <span class="comment">//SharedSelf()是通过自己再生成应该智能指针，这个智能指针与其它的智能指针共享引用计数，保证Session不被异常释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对端发来指定大小HEAD_LENGTH数据，并存到_recv_head_node-&gt;_data时，触发回调函数HandleReadHead。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadHead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;    <span class="comment">//如果没有报错</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_transferred &lt; HEAD_LENGTH) &#123;     <span class="comment">//这种情况也是不正常的，因为指定读HEAD_LENGTH长度数据，却没有读完</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read head length error&quot;</span>;</span><br><span class="line">            <span class="built_in">Close</span>();   <span class="comment">//这里是把socket关闭掉，会关闭socket的事件处理机制。底层asio会把socket从它监听的epoll事件里面移出，socket就不会触发改回调函数</span></span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);          <span class="comment">//将其session移出，减少它的引用计数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有问题情况下，bytes_transferred一定是等于头部长度的</span></span><br><span class="line">        <span class="comment">//头部收全，解析头部</span></span><br><span class="line">        <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);    <span class="comment">//获取真实数据的大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data len is&quot;</span> &lt;&lt; data_len &lt;&lt; endl;                 <span class="comment">//打印真实数据的大小</span></span><br><span class="line">        <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;               <span class="comment">//如果真实数据大于规定的最大值，说明不合法</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;invalid data length is&quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);                          <span class="comment">//将其session移出map</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果正常，就读取真实数据</span></span><br><span class="line">        _recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);   <span class="comment">//下面开始读真实数据，读真实数据总长度_total_len，存到改数据节点中</span></span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadMsg, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;       <span class="comment">//出错了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read head failed,error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();                       <span class="comment">//关闭socket</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);  <span class="comment">//减少session的引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-获取信息体"><a href="#3-2-获取信息体" class="headerlink" title="3.2 获取信息体"></a>3.2 获取信息体</h2><p>当获取完头部数据后，就可以在其回调函数里执行异步读async_read，直接获取信息数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadMsg</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">//数据都读到了数据节点，再最后面加上&#x27;\0&#x27;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;  <span class="comment">//打印接收的数据</span></span><br><span class="line">        <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);      <span class="comment">//发送接收的数据给客户端</span></span><br><span class="line">        <span class="comment">//再次接收头部数据</span></span><br><span class="line">        _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;       <span class="comment">//出错了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read Msg failed,error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();                 <span class="comment">//关闭socket</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);  <span class="comment">//减少session的引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-结合Json实现粘包处理tlv"><a href="#4-结合Json实现粘包处理tlv" class="headerlink" title="4. 结合Json实现粘包处理tlv"></a>4. 结合Json实现粘包处理tlv</h1><p>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_2.png"></p>
<p>为了减少耦合和歧义，这里重新设计消息节点。</p>
<ul>
<li><code>MsgNode</code>表示消息节点的基类，头部的消息用这个结构存储</li>
<li><code>RecvNode</code>表示接收消息的节点</li>
<li><code>SendNode</code>表示发送消息的节点</li>
</ul>
<h2 id="4-1-信息节点类"><a href="#4-1-信息节点类" class="headerlink" title="4.1 信息节点类"></a>4.1 信息节点类</h2><p>MsgNode.h头文件定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">        _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">short</span> _cur_len;       <span class="comment">//当前处理的长度(接收或发送)</span></span><br><span class="line">    <span class="type">short</span> _total_len;     <span class="comment">//要处理的总长度</span></span><br><span class="line">    <span class="type">char</span>* _data;          <span class="comment">//存放数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//接收数据的节点类定义，继承了MsgNode类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);  <span class="comment">//传入数据的长度和信息id</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送数据的节点类定义，继承了MsgNode类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span>:<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg,<span class="type">short</span> max_len, <span class="type">short</span> msg_id);   <span class="comment">//传入发送数据，数据长度和信息id</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接受数据节点和发送数据节点初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收数据节点类初始化，将传进去的max_len用来给MsgNode类初始化，msg_id给id初始化</span></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len),_msg_id(msg_id)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据节点类初始化，数据长度+头节点长度=总长度</span></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN), _msg_id(msg_id)&#123;</span><br><span class="line">    <span class="comment">//先发送id, 转为网络字节序</span></span><br><span class="line">    <span class="type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data, &amp;msg_id_host, HEAD_ID_LEN);    <span class="comment">//将转换好的id存到_data第一部分</span></span><br><span class="line">    <span class="comment">//转为网络字节序</span></span><br><span class="line">    <span class="type">short</span> max_len_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN);   <span class="comment">//将转换好的数据长度存到_data第二部分</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);   <span class="comment">//将真实数据存到_data第三部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Session类"><a href="#4-2-Session类" class="headerlink" title="4.2 Session类"></a>4.2 Session类</h2><p>Session类头节点如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">    ~<span class="built_in">CSession</span>();</span><br><span class="line">    <span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;    <span class="comment">//获取socket函数</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;      <span class="comment">//获取uuid函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;                <span class="comment">//开始通信函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span></span>;  <span class="comment">//发送数据send</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;               <span class="comment">//接收数据send</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                <span class="comment">//关闭socket函数</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;   <span class="comment">//添加智能指针引用计数的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    tcp::socket _socket;</span><br><span class="line">    std::string _uuid;</span><br><span class="line">    <span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">    CServer* _server;</span><br><span class="line">    <span class="type">bool</span> _b_close;</span><br><span class="line">    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;</span><br><span class="line">    std::mutex _send_lock;</span><br><span class="line">    <span class="comment">//收到的消息结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line">    <span class="type">bool</span> _b_head_parse;        <span class="comment">//头部节点释放读取完毕</span></span><br><span class="line">    <span class="comment">//收到的头部结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Session类实现功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):_socket(io_context), _server(server), _b_close(<span class="literal">false</span>),_b_head_parse(<span class="literal">false</span>)&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;     <span class="comment">//获取socket函数实现</span></span><br><span class="line">    <span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;       <span class="comment">//获取uuid函数实现</span></span><br><span class="line">    <span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;                 <span class="comment">//与客户端通信开始函数</span></span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    <span class="comment">//异步读async_read_some，将读到的数据放到了_data,读完后，并触发回调函数HandleRead</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msgid));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _socket.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//增加异常处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span></span><br><span class="line">            _send_que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">                boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当异步读，读到数据后触发该回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;            <span class="comment">//如果没有出错</span></span><br><span class="line">            <span class="type">int</span> copy_len = <span class="number">0</span>;    <span class="comment">//已经移动的字符数</span></span><br><span class="line">            <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;    <span class="comment">//如果bytes_transferred大于0</span></span><br><span class="line">                <span class="keyword">if</span> (!_b_head_parse) &#123;          <span class="comment">//如果头部数据还没有处理完</span></span><br><span class="line">                    <span class="comment">//这次收到的数据不足头部大小，则这次收到的bytes_transferred长度数据都是头部数据，HEAD_TOTAL_LEN=4(id占2，数据长度占2)</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LEN) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//将这次读到的全部数据全部存到头部节点</span></span><br><span class="line">                        _recv_head_node-&gt;_cur_len += bytes_transferred;  <span class="comment">//更新头部节点的当前处理位置</span></span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//清0，继续读，存放下一次读到的数据</span></span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        <span class="keyword">return</span>;   <span class="comment">//这种情况直接退出，继续读数据(头部)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//收到的数据比头部多(没有执行上面if),说明这次读到的数据一部分是头部数据，一部分是真实数据</span></span><br><span class="line">                    <span class="type">int</span> head_remain = HEAD_TOTAL_LEN - _recv_head_node-&gt;_cur_len; <span class="comment">//头部剩余未处理的长度</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);    <span class="comment">//将头部剩余未处理的长度，全部处理完(存到头部节点)</span></span><br><span class="line">                    <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                    copy_len += head_remain;</span><br><span class="line">                    bytes_transferred -= head_remain;</span><br><span class="line">                    <span class="comment">//获取头部MSGID数据</span></span><br><span class="line">                    <span class="type">short</span> msg_id = <span class="number">0</span>;     <span class="comment">//用来存放信息id</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN); <span class="comment">//从头部数据获取id</span></span><br><span class="line">                    <span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">                    msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;    <span class="comment">//如果id非法</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;</span><br><span class="line">                        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);   <span class="comment">//从map移出对应uuid，减少该session的引用计数</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果id合法，继续读取信息长度</span></span><br><span class="line">                    <span class="type">short</span> msg_len = <span class="number">0</span>;    <span class="comment">//用来存真实信息长度</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data+HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">                    <span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">                    msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;     <span class="comment">//如果真实数据长度非法</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;</span><br><span class="line">                        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);   <span class="comment">//从map移出对应uuid，减少该session的引用计数</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _recv_msg_node = <span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);   <span class="comment">//存放真实数据内容节点</span></span><br><span class="line">                    <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &lt; msg_len) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                        _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        _b_head_parse = <span class="literal">true</span>;   <span class="comment">//头部处理完成，将该变量设为true</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果读到数据&gt;=头部读到的真实数据长度，说明可能出现粘包情况</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);    <span class="comment">//这时就处理头部节点读到的真实数据长度</span></span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += msg_len;</span><br><span class="line">                    copy_len += msg_len;</span><br><span class="line">                    bytes_transferred -= msg_len;   <span class="comment">//先减去真实数据长度</span></span><br><span class="line">                    _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//结尾加结束符</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    Json::Value root;      <span class="comment">//用来存放反序列化的值</span></span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;    <span class="comment">//反序列化后，读取客户端发来的值</span></span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">                    std::string return_str = root.<span class="built_in">toStyledString</span>();   <span class="comment">//又将root的值序列化</span></span><br><span class="line">                    <span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());    <span class="comment">//发送给客户端</span></span><br><span class="line">                    <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                    _b_head_parse = <span class="literal">false</span>;  <span class="comment">//因为上面已经处理完一个节点数据，又要从头节点开始处理</span></span><br><span class="line">                    _recv_head_node-&gt;<span class="built_in">Clear</span>();       <span class="comment">//清理头节点，为下一次读做准备</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;   <span class="comment">//如果bytes_transferred已经&lt;=0,说明没有出现粘包情况</span></span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//清理_data,继续挂起读</span></span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//出现粘包情况，就不执行下面了，_b_head_parse已经为false，可以重新循环执行下一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已经处理完头部，处理上次未接受完的真实消息数据</span></span><br><span class="line">                <span class="comment">//接收的数据仍不足剩余未处理的</span></span><br><span class="line">                <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;    <span class="comment">//这种情况是真实数据还未处理完，退出继续读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这次接收的数据&gt;=真实数据未处理的长度，可能出现粘包情况</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">                bytes_transferred -= remain_msg;</span><br><span class="line">                copy_len += remain_msg;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                Json::Reader reader;</span><br><span class="line">                Json::Value root;</span><br><span class="line">                reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">                root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">                std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">                <span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;  <span class="comment">//处理完一个节点，将该变量设为false</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;   <span class="comment">//这种情况是没有出现粘包</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;   <span class="comment">//挂起读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;    <span class="comment">//出现粘包，就继续循环,因为bytes_transferred还大于0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于server类，没有出现其它变化，与之前代码差不多。</p>
<h1 id="5-asio多线程模型IOServicePool"><a href="#5-asio多线程模型IOServicePool" class="headerlink" title="5. asio多线程模型IOServicePool"></a>5. asio多线程模型IOServicePool</h1><p>前面的设计，我们对asio的使用都是单线程模式，为了提升网络io并发处理的效率，这一次我们设计多线程模式下asio的使用方式。总体来说asio有两种多线程模型，第一个是启动多个线程，每个线程管理一个iocontext；第二种是只启动一个iocontext，被多个线程共享。这里主要使用第一种模式，多个线程，每个线程管理独立的iocontext服务。</p>
<p>下面先介绍多线程的第一种模式：一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。为避免线程安全问题，我们将网络数据封装为逻辑包投递给逻辑系统，逻辑系统有一个单独线程处理，这样将网络IO和逻辑处理解耦合，极大的提高了服务器IO层面的吞吐率。</p>
<h2 id="5-1-单线程与多线程"><a href="#5-1-单线程与多线程" class="headerlink" title="5.1 单线程与多线程"></a>5.1 单线程与多线程</h2><p>之前使用的单线程模型如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_3.png"></p>
<p>IOServicePool类型的多线程模型如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_4.png"></p>
<p>IOServicePool多线程模式特点：</p>
<ul>
<li><p>每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</p>
</li>
<li><p>但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</p>
</li>
<li><p>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</p>
</li>
</ul>
<h2 id="5-2-服务端实现"><a href="#5-2-服务端实现" class="headerlink" title="5.2 服务端实现"></a>5.2 服务端实现</h2><p>主函数：先初始化服务池，创建一个负责监听的io_context，通过asio提供的异步等待函数和线程来完成信号的捕捉，当触发SIGINT和SIGTERM信号时，停止io服务，即不在监听处理客户端发来的请求连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();     <span class="comment">//先将服务池初始化好</span></span><br><span class="line">        boost::asio::io_context io_context;  <span class="comment">//该io_context只负责监听，监听客户端是否请求发来连接</span></span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//初始化一个信号集，将要捕获的信号SIGINT, SIGTERM注册到服务io里</span></span><br><span class="line">        <span class="comment">//异步等待，等待信号被触发，触发了会执行回调函数(匿名函数表示)，io_context是用引用方式来捕获，auto：几个参数，就写几个auto</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123; <span class="comment">//信号集异步等待，信号集里面的信号触发了，就会执行这个回调函数(匿名函数)</span></span><br><span class="line">            io_context.<span class="built_in">stop</span>();        <span class="comment">//停止io服务</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//上面因为是异步等待，所以不会阻塞，如果回调函数没有触发，会继续执行后面的代码</span></span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();     <span class="comment">//轮询</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CServer类实现：这部分负责实现监听客户端的连接和获取服务池的io_context。每与客户端建立成功一次，就从服务池中获取一个io_context来负责处理与连接的客户端的一些业务，实现了一个线程一个io_context的多线程模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port),</span><br><span class="line">_acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该函数初始化了_acceptor，里面的参数io_context是单独创建的，就负责用来监听客户端	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();    <span class="comment">//处理连接的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当有客户端发来请求连接时，就从服务池里面取出一个io_context来负责这次连接的业务处理</span></span><br><span class="line">    <span class="comment">//GetIOService()函数实现的是从下标为0开始获取io_context，获取完一次，下标进行+1，当达到服务池里面提供的io_context的个数时，又从下标为0的io_context开始获取，所以当客户端连接的数量过多时，可能是多个客户端同时拥有同一个io_context</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetIOService</span>();</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));  <span class="comment">//异步连接，域客户端成功连接后，执行回调函数HandleAccept()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();   <span class="comment">//去session执行通信的业务</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//连接成功将对应的信息存入到map,方便管理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsioIOServicePool类服务池的头文件实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AsioIOServicePool就形成了单例模式，因为他继承了Singleton&lt;AsioIOServicePool&gt;模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span>:<span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> Singleton&lt;AsioIOServicePool&gt;;  <span class="comment">//这样Singleton&lt;AsioIOServicePool&gt;就可以访问AsioIOServicePool的构造函数(私有)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;    <span class="comment">//IOServer是io_context的别名</span></span><br><span class="line">    <span class="keyword">using</span> Work = boost::asio::io_context::work;   <span class="comment">//work是防止io_context在没有注册事件的时候退出(因为对于多线程我们需要先创建多个io_context)</span></span><br><span class="line">    <span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;       <span class="comment">//Work是上面io_context::work的别名。这里是让Work不被拷贝，只能移动，从头用到尾</span></span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;   <span class="comment">//取消拷贝构造，拷贝构造时，里面加了canst后要加&amp;，不然会造成递归构造的危险</span></span><br><span class="line">    AsioIOServicePool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;    <span class="comment">//赋值操作也取消掉</span></span><br><span class="line">    <span class="comment">//使用round-robin的方式返回一个io_context</span></span><br><span class="line">    boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;     <span class="comment">//返回一个io_context</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>());  <span class="comment">//hardware_concurrency()获取cpu的核数，一般是电脑有几个核，就开几个io_context</span></span><br><span class="line">    std::vector&lt;IOService&gt;_ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt;_works;</span><br><span class="line">    std::vector&lt;std::thread&gt;_threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOService;         <span class="comment">//记录的下标索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AsioIOServicePool类服务池的功能实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AsioIOServicePool默认传的是cpu的核数，也可以自己指定，并初始化size个io_context，size个指针(默认是空指针)，下标索初始化为0</span></span><br><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(std::<span class="type">size_t</span> size) :_ioServices(size), _works(size), _nextIOService(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//works初始化分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//将左值赋值给unique_ptr是不行的，而作为右值去赋值是可以的</span></span><br><span class="line">        _works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioServices[i]));    <span class="comment">//work是绑定io_context的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历多个ioservice，创建多个线程，每个线程内部启动ioservice</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _ioServices.<span class="built_in">size</span>(); i++) &#123;       <span class="comment">//装线程的_threads开始默认大小为0</span></span><br><span class="line">        <span class="comment">//方法：通过遍历的方式，每次都为_threads插入一个线程。用push_back是以右值的形式将其挪进来，而用emplace_back是直接传入线程</span></span><br><span class="line">        <span class="comment">//执行插入操作，就默认调用了线程的回调函数了，下面emplace_back相当于是给线程插入了一个回调函数，就直接跑起来了</span></span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;<span class="comment">//这是是快速构造，防止拷贝造成的开销。emplace_back传入的是匿名函数，第一个先绑定this(io_service)，</span></span><br><span class="line">            _ioServices[i].<span class="built_in">run</span>();</span><br><span class="line">        &#125;); <span class="comment">//这样，该线程就跑起来了。c11的标准，只要定义了一个线程，线程就跑起来了</span></span><br><span class="line">        <span class="comment">/*    //其它方式创建线程，但存在问题</span></span><br><span class="line"><span class="comment">        thread t([this, i]() &#123;        //先初始化一个线程</span></span><br><span class="line"><span class="comment">        	_ioService[i].run();</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        _threads.push_back(t); //又拷贝了一个线程，这种情况是线程初始化时就跑起来了，现在又push进来，会造成开销，而且跑了两个线程</span></span><br><span class="line"><span class="comment">        _threads.push_back(move(t)); //这种情况是相当于把上面t的生命周期进行一个接管，原来线程就失效了，但不能保证它能停下来，除非用stop销毁它    */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取io_Service函数(io_Service是io_context的别名)</span></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioIOServicePool::GetIOService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; service = _ioServices[_nextIOService++];       <span class="comment">//从0下标开始取</span></span><br><span class="line">    <span class="keyword">if</span> (_nextIOService == _ioServices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _nextIOService = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;   <span class="comment">//要让每一个io_context都停止，就需要把绑定在它们身上的work reset掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Work : _works) &#123;</span><br><span class="line">        Work.<span class="built_in">reset</span>();        <span class="comment">//这相当于把work智能指针释放掉，智能指针一旦释放掉，就会析构WorkPtr,而WorkPtr绑定的就是work(unique_ptr类型)，</span></span><br><span class="line">        <span class="comment">//所以就会调用work的析构，work就会把绑定的所有东西解除，从而保证io_context退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要等所有线程都结束了(io_service.run运行完)，该函数才退出，所以调用了这个函数，不会立即执行完</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于监听客户端是否发来连接用的是刚开始初始化的io_context，后面与客户端的读写事件监听用的是服务池里面的io_context，所以当与客户端建立成功后，之后处理监听读写事件的io_context就需要从服务池里面去取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多线程服务池模式：当有客户端发来请求连接时，就从服务池里面取出一个io_context来负责这次连接的业务处理</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetIOService</span>();</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-客户端实现"><a href="#5-3-客户端实现" class="headerlink" title="5.3 客户端实现"></a>5.3 客户端实现</h2><p>客户端实现的是创建100个线程，每个线程都通过json序列化一个信息包发送给服务端，并将从服务器接收的信息包反序列化，这样重复500次。测试一下等所有线程都执行完，并且都被回收所需要花费的时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;thread&gt; vec_threads;    <span class="comment">//定义一个存放连接线程的容器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();  <span class="comment">//获取现在开始时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;        <span class="comment">//循环100次，可以理解为向服务器发送建立了100次连接</span></span><br><span class="line">        vec_threads.<span class="built_in">emplace_back</span>([]() &#123;    <span class="comment">//将回调函数(线程需要执行)通过emplace_back放入容器</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建上下文服务</span></span><br><span class="line">                boost::asio::io_context ioc;</span><br><span class="line">                <span class="comment">//构造服务器的endpoint信息</span></span><br><span class="line">                tcp::endpoint <span class="built_in">remote_ep</span>(address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">                tcp::socket <span class="built_in">sock</span>(ioc);   <span class="comment">//创建一个socket</span></span><br><span class="line">                boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">                sock.<span class="built_in">connect</span>(remote_ep, error);    <span class="comment">//向服务器发送连接请求</span></span><br><span class="line">                <span class="keyword">if</span> (error) &#123;    <span class="comment">//连接失效，直接退出</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//连接成功执行下面，向服务器发送和接收各500次</span></span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">500</span>) &#123;      <span class="comment">//发500次内容</span></span><br><span class="line">                    Json::Value root;</span><br><span class="line">                    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;    <span class="comment">//消息id</span></span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">                    std::string request = root.<span class="built_in">toStyledString</span>();  <span class="comment">//序列化为字符串形式</span></span><br><span class="line">                    <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();    <span class="comment">//获取序列化后的字符串长度</span></span><br><span class="line">                    <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> msgid = <span class="number">1001</span>;</span><br><span class="line">                    <span class="comment">//将信息id转换为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> msgid_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msgid);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data, &amp;msgid_host, <span class="number">2</span>);  <span class="comment">//存放到发送节点</span></span><br><span class="line">                    <span class="comment">//序列化后的数据长度转为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, &amp;request_host_length, <span class="number">2</span>);  <span class="comment">//存放到发送节点</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">4</span>, request.<span class="built_in">c_str</span>(), request_length); <span class="comment">//最后就是存放序列化后的数据</span></span><br><span class="line">                    <span class="comment">//将信息序列化后，以包的形式发送给服务器</span></span><br><span class="line">                    boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">4</span>));</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;  <span class="comment">//下面开始接收</span></span><br><span class="line">                    <span class="type">char</span> reply_head[HEAD_TOTAL];</span><br><span class="line">                    <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_TOTAL));</span><br><span class="line">                    msgid = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msgid, reply_head, HEAD_LENGTH);</span><br><span class="line">                    <span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msglen, reply_head + <span class="number">2</span>, HEAD_LENGTH);</span><br><span class="line">                    <span class="comment">//转为本地字节序</span></span><br><span class="line">                    msglen = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msglen);</span><br><span class="line">                    msgid = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msgid);</span><br><span class="line">                    <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(msg, msg_length), root);  <span class="comment">//将反序列化后的信息皴法哦root</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>] &lt;&lt; endl;</span><br><span class="line">                    i++;   <span class="comment">//发送一个包和接收完一个包后，i++。说明一个线程要完成发送和接收，共1000个包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Exception：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">//不能一直创线程建立连接，每创建一个线程连接就睡一秒，不然就是一直向服务器发送请求连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vec_threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();    <span class="comment">//等全部线程结束回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();   <span class="comment">//执行完后，获取结束时的时间</span></span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);   <span class="comment">//获取时间差，并转换为微妙</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time spent:&quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-asio多线程模式IOThreadPool"><a href="#6-asio多线程模式IOThreadPool" class="headerlink" title="6. asio多线程模式IOThreadPool"></a>6. asio多线程模式IOThreadPool</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><p>下面介绍多线程实现的第二种模式，即多线程模式IOThreadPool，我们只初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让<code>iocontext.run</code>在多个线程中调用，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。</p>
<p>线程池模式的多线程模型调度结构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_5.png"></p>
<p>构造函数中实现了一个线程池，线程池里每个线程都会运行<code>_service.run</code>函数，<code>_service.run</code>函数内部就是从iocp或者epoll获取就绪描述符和绑定的回调函数，进而调用回调函数，因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。<br><code>_service.run</code> 内部在Linux环境下调用的是<code>epoll_wait</code>返回所有就绪的描述符列表，在windows上会循环调用<code>GetQueuedCompletionStatus</code>函数返回就绪的描述符，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。</p>
<p>iocp的流程：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">IOCP的使用主要分为以下几步：</span><br><span class="line">1 创建完成端口(iocp)对象</span><br><span class="line">2 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求</span><br><span class="line">3 Socket关联iocp对象，在Socket上投递网络事件</span><br><span class="line">4 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理</span><br></pre></td></tr></table></figure>

<p>epoll的流程：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1 调用epoll_creat在内核中创建一张epoll表</span><br><span class="line">2 开辟一片包含n个epoll_event大小的连续空间</span><br><span class="line">3 将要监听的socket注册到epoll表里</span><br><span class="line">4 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，epoll会将就绪的socket信息写入我们之前开辟的连续空间</span><br></pre></td></tr></table></figure>

<p>所以IOThreadPool模式有一个隐患，同一个socket的就绪后，触发的回调函数可能在不同的线程里，比如第一次是在线程1，第二次是在线程3，如果这两次触发间隔时间不大，那么很可能出现不同线程并发访问数据的情况，比如在处理读事件时，第一次回调触发后我们从socket的接收缓冲区读数据出来，第二次回调触发，还是从socket的接收缓冲区读数据，就会造成两个线程同时从socket中读数据的情况，会造成数据混乱。</p>
<h2 id="6-2-利用strand改进"><a href="#6-2-利用strand改进" class="headerlink" title="6.2 利用strand改进"></a>6.2 利用strand改进</h2><p>对于多线程触发回调函数的情况，我们可以利用asio提供的串行类strand封装一下，这样就可以被串行调用了，其基本原理就是在线程各自调用函数时取消了直接调用的方式，而是利用一个strand类型的对象将要调用的函数投递到strand管理的队列中，再由一个统一的线程调用回调函数，调用是串行的，解决了线程并发带来的安全问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_6.png"></p>
<p>上面结构图中当socket就绪后并不是由多个线程调用每个socket注册的回调函数，而是将回调函数投递给strand管理的队列，再由strand统一调度派发。</p>
<h2 id="6-3-相关代码"><a href="#6-3-相关代码" class="headerlink" title="6.3 相关代码"></a>6.3 相关代码</h2><p>主函数实现：通过signals.async_wait异步等待，创建了一个子线程负责监听退出信号，当退出信号长生，就会触发该子线程执行，它会停止io_context和线程池，并唤醒阻塞在主线程的锁。主线程就是负责也客户端的一系列监听事件，并阻塞在条件变量cond_quit。等待退出子线程唤醒后，主线程退出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mutex_quit;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioThreadPool::<span class="built_in">GetInstance</span>();        <span class="comment">//先将线程池初始化好</span></span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//初始化一个信号集，将要捕获的信号SIGINT, SIGTERM注册到服务io里</span></span><br><span class="line">        <span class="comment">//异步等待，等待信号被触发，触发了会执行回调函数(匿名函数表示)，io_context是用引用方式来捕获，auto是几个参数，就写几个auto</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([pool, &amp;io_context](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;   <span class="comment">//信号集异步等待，信号集里面的信号触发了，就会执行这个回调函数(匿名函数)</span></span><br><span class="line">            io_context.<span class="built_in">stop</span>();        <span class="comment">//停止io服务</span></span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();       <span class="comment">//停止线程池</span></span><br><span class="line">            std::unique_lock&lt;std::mutex&gt;<span class="built_in">lock</span>(mutex_quit);    <span class="comment">//加锁，对bstop进行修改</span></span><br><span class="line">            bstop = <span class="literal">true</span>;</span><br><span class="line">            cond_quit.<span class="built_in">notify_one</span>();   <span class="comment">//通知退出(唤醒)</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//上面因为是异步等待，所以不会阻塞，如果回调函数没有触发，会继续执行后面的代码</span></span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(pool-&gt;GetIOService(), <span class="number">10086</span>)</span></span>;</span><br><span class="line">        &#123;   <span class="comment">//这个括号的代码是为了不让主线程直接退出，等子线程退出，主线程再退出</span></span><br><span class="line">            std::unique_lock&lt;std::mutex&gt;<span class="built_in">lock</span>(mutex_quit);</span><br><span class="line">            <span class="keyword">while</span> (!bstop) &#123;</span><br><span class="line">                cond_quit.<span class="built_in">wait</span>(lock);    <span class="comment">//没有结束之前，会阻塞在这里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsioThreadPool类头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsioThreadPool</span>:<span class="keyword">public</span> Singleton&lt;AsioThreadPool&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioThreadPool&gt;;   <span class="comment">//使其基类Singleton&lt;AsioThreadPool&gt;可以访问它的私有函数</span></span><br><span class="line">    ~<span class="built_in">AsioThreadPool</span>() &#123;&#125;</span><br><span class="line">    AsioThreadPool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;   <span class="comment">//取消赋值构造</span></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;      <span class="comment">//取消拷贝构造</span></span><br><span class="line">    boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;      <span class="comment">//获取io_context</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;      <span class="comment">//停止该线程池类，友好退出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">int</span> threadNum = std::thread::<span class="built_in">hardware_concurrency</span>());  <span class="comment">//hardware_concurrency()是硬件允许的并行数</span></span><br><span class="line">    boost::asio::io_context _service;</span><br><span class="line">    std::unique_ptr&lt;boost::asio::io_context::work&gt;_work;  <span class="comment">//因为不注册读事件和写事件，_service调用.run就会退出，_work负责防止这种情况退出</span></span><br><span class="line">    std::vector&lt;std::thread&gt;_threads;  <span class="comment">//装线程的容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AsioThreadPool类初始化：用c11特性，直接定义了线程，线程就可以执行。则将线程放到threads容器，线程就可以开始执行了。通过emplace_back插入一个回调函数，表示线程启动后要执行的内容。emplace_back是直接减少一层构造函数的开销，直接调用thread原始的构造函数，即直接传入一个回调函数即可，继而构造成一个线程，插入到_threads里面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AsioThreadPool::<span class="built_in">AsioThreadPool</span>(<span class="type">int</span> threadNum):_work(<span class="keyword">new</span> boost::asio::io_context::<span class="built_in">work</span>(_service)) &#123;</span><br><span class="line">    <span class="comment">//开辟threadNum个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123; <span class="comment">//下面用到的_service是AsioThreadPool的成员，匿名函数只有对器进行捕获了，才能使用</span></span><br><span class="line">            _service.<span class="built_in">run</span>(); <span class="comment">//this-&gt;_service.run();也可以。_service.run()返回了就说明结束了，该线程也就会退出</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioThreadPool::GetIOService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioThreadPool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _work.<span class="built_in">reset</span>();    <span class="comment">//表示把unique_ptr类型的指针work释放掉，则就会调用_work的析构函数，那么_work开辟的空间就会被回收掉，</span></span><br><span class="line">    <span class="comment">//则_service就没有_work去管理它，这时候，如果没有事件到来，_service就会stop了，这种情况就是_service.run会直接返回，不在一直轮询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : _threads) &#123;  <span class="comment">//等待所有线程退出，一个一个回收</span></span><br><span class="line">        t.<span class="built_in">join</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立连接函数：由于监听客户端是否发来连接用的是刚开始初始化的io_context，后面与客户端的读写事件监听也是用的同一个io_context，所以当与客户端建立成功后，之后的监听读写事件读由该io_context来处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多线程线程池模式：不需要有多个io_context，统一使用刚开始传进来的io_context</span></span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Session类中添加一个成员变量_strand，如下所示。strand是个模板，需要声明它的类型。strand他有一个执行类型，要求这个执行类型是上下文的执行类型，也就是跟io_context匹配的执行类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::strand&lt;boost::asio::io_context::executor_type&gt;_strand;</span><br></pre></td></tr></table></figure>

<p>为了让回调函数被派发到strand的队列，我们只需要在注册回调函数时加一层strand的包装即可。</p>
<p>因为在asio中无论iocontext还是strand，底层都是通过executor调度的，可以将他理解为调度器，如果多个iocontext和strand的调度器是一个，那他们的消息派发统一由这个调度器执行。所以我们利用iocontext的调度器构造strand，这样他们统一由一个调度器管理。在绑定回调函数的调度器时，我们选择strand绑定即可。</p>
<p>比如我们在Start函数里添加读事件绑定 ，将回调函数的调用者绑定为_strand。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    <span class="comment">//生成一个新的执行器，告诉asio底层，读事件就绪的时候，会调用执行器bind_executor来执行。该执行器会调用_strand队列里的线程，来派发该回调函数。</span></span><br><span class="line">    <span class="comment">//也就是说将_strand和回调处理进行绑定生成一个新的执行者，该执行者来派发所有的消息。</span></span><br><span class="line">    <span class="comment">//该执行者是唯一的，因为它是通过_stand来绑定的，而_strand只有一个调度器，这个调度器和对应的回调函数绑定起来</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写事件绑定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self)));</span><br></pre></td></tr></table></figure>

<p>如果不绑定执行器bind_executor，这个回调函数会默认让线程来调用。而绑定到_strand上，就由_strand来调用。底层是通过_strand的独立线程来调用。其次还有好处就是，各个线程的回调函数就绪的时候，会自动投递到stran队列里。</p>
<h2 id="6-4-多线程模式使用建议"><a href="#6-4-多线程模式使用建议" class="headerlink" title="6.4 多线程模式使用建议"></a>6.4 多线程模式使用建议</h2><p>实际的生产和开发中，我们尽可能利用C++特性，使用多核的优势，将iocontext分布在不同的线程中效率更可取一点，但也要防止线程过多导致cpu切换带来的时间片开销，所以尽量让开辟的线程数小于或等于cpu的核数，从而利用多核优势。</p>
<h1 id="7-asio协程实现并发服务器"><a href="#7-asio协程实现并发服务器" class="headerlink" title="7. asio协程实现并发服务器"></a>7. asio协程实现并发服务器</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p><strong>ASIO协程</strong>是一种编程技术，‌它允许程序员以更简洁和直观的方式编写异步代码，‌特别是在处理网络编程时。‌ASIO协程通过提供一种无栈协程(stackless coroutine)的方式，‌简化了异步编程的复杂性，‌尤其是在内存管理方面。‌这种技术通过提供一种更高级别的抽象，‌使得程序员可以更加专注于业务逻辑的实现，‌而不是陷入底层细节的处理中。‌</p>
<p>利用协程实现并发程序有两个好处：</p>
<ul>
<li>将回调函数改写为顺序调用，提高开发效率。</li>
<li>协程调度比线程调度更轻量化，因为协程是运行在用户空间的，线程切换需要在用户空间和内核空间切换。</li>
</ul>
<h2 id="7-2-协程的简单实现"><a href="#7-2-协程的简单实现" class="headerlink" title="7.2 协程的简单实现"></a>7.2 协程的简单实现</h2><p>在下面的协程实现中：</p>
<ul>
<li>awaitable<void>表示声明了一个函数，那么这个函数就变为可等待的函数了，比如<code>listener</code>被添加<code>awaitable&lt;void&gt;</code>之后，就可以被协程调用和等待了。</void></li>
<li><code>co_spawn</code>表示启动一个协程，参数分别为调度器，执行的函数，以及启动方式, 比如我们启动了一个协程，deatched表示将协程对象分离出来，这种启动方式可以启动多个协程，他们都是独立的，如何调度取决于调度器，在用户的感知上更像是线程调度的模式，类似于并发运行，其实底层都是串行的。</li>
<li>当<code>acceptor</code>接收到连接后，继续调用<code>co_spawn</code>启动一个协程，用来执行echo逻辑。echo逻辑里也是通过co_wait的方式接收和发送数据的，如果对端不发数据，执行echo的协程就会挂起，另一个协程启动，继续接收新的连接。当没有连接到来，接收新连接的协程挂起，如果所有协程都挂起，则等待新的就绪事件(对端发数据，或者新连接)到来唤醒。</li>
</ul>
<p>服务端实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> boost::asio::awaitable;    <span class="comment">//异步等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::co_spawn;</span><br><span class="line"><span class="keyword">using</span> boost::asio::detached;    <span class="comment">//让协程与主线程分离(协程独立启动)</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::use_awaitable;</span><br><span class="line"><span class="keyword">namespace</span> this_coro = boost::asio::this_coro;   <span class="comment">//返回当前协程可执行的环境</span></span><br><span class="line"><span class="comment">//负责通信协程的执行函数</span></span><br><span class="line">awaitable &lt;<span class="type">void</span>&gt;<span class="built_in">echo</span>(tcp::socket socket) &#123;  <span class="comment">//传过来与对端连接的socket</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//将异步变成同步，变成可等待的，通过协程的方式来使用。co_await表示阻塞时会释放占有的资源，交个iqt协程和主线程</span></span><br><span class="line">            std::<span class="type">size_t</span> n = <span class="keyword">co_await</span> socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), use_awaitable); </span><br><span class="line">            <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, boost::asio::buffer(data, n), use_awaitable)</span></span>; <span class="comment">//同步的发送给对端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;echo exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//负责监听对端连接协程的执行函数</span></span><br><span class="line">awaitable &lt;<span class="type">void</span>&gt; <span class="built_in">listener</span>() &#123;  <span class="comment">//awaitable是可等待的。协程就可以直接执行这个函数了,返回一个可执行对象</span></span><br><span class="line">    <span class="comment">//获取一个调度器</span></span><br><span class="line">    <span class="keyword">auto</span> executor = <span class="keyword">co_await</span> this_coro::executor; <span class="comment">//返回一个协程的调度器。co_await表示异步的去查询调度器，一直找不到，就先挂起，把使用权交给主线程和其它协程</span></span><br><span class="line">    <span class="comment">//监听对端的连接，acceptor调度是用的执行器executor，该执行器是协程的执行器，而协程执行器是主函数co_spawn里面的io_context</span></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(executor, &#123; tcp::v4(),<span class="number">10086</span> &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//acceptor.async_accept是我们之前的异步处理，后面需要传递一个回调函数。因为这是异步的，不能阻塞的去等待，asio底层是通过回调函数来通知我们的。但使用协程，加上co_await关键字后，就可以写成这种同步式的代码，即可以阻塞等待接收，但这是协程内部的阻塞，他会通过co_await来释放使用权，把协程占用的资源都释放出来(看起来是阻塞，但不会影响主线程向下的执行)</span></span><br><span class="line">        tcp::socket socket = <span class="keyword">co_await</span> acceptor.<span class="built_in">async_accept</span>(use_awaitable); <span class="comment">//当收到对端的连接，就返回一个socket。use_awaitable是在使用异步函数的时候，告诉asio，通过协程的方式来使用(即将异步函数变成可等待的函数)</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;connect is successful&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="comment">//建立连接成功，再启动一个协程，负责通信</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(executor, <span class="built_in">echo</span>(std::<span class="built_in">move</span>(socket)), detached); <span class="comment">//执行器；要执行的函数；分离。socket通过移动操作传过去，这边的socket就不能用了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::<span class="function">asio::io_context <span class="title">io_context</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//将使用一个工作线程来执行所有的异步操作</span></span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//创建了一个信号集，绑定在上下文服务上，信号集处理的信号是 SIGINT、SIGTERM</span></span><br><span class="line">        <span class="comment">//异步等待。捕获引用，把前面所有到的变量都用引用捕获。()里面是要处理的参数，几个信号，就传几个参数</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();     <span class="comment">//收到两个信号，就服务停止</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">//启动协程。将上下文里面的调度器与协程绑定起来(协程的调度是交给io_context内部的调度器来调度的)，并且协程要执行listener()</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(io_context, <span class="built_in">listener</span>(), detached);   <span class="comment">//detached可以理解为分离出来，严谨地说是先让协程独立运行，不会阻塞在这里</span></span><br><span class="line">        io_context.<span class="built_in">run</span>(); <span class="comment">//io_context在没有绑定任何事件的时候，会直接退出，这程序就会执行完(退出)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>)</span></span>; <span class="comment">//传入回送地址，也是可以理解为本地地址</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">        boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">        sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;    <span class="comment">//不为0，就说明报错了</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;error msg is&quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter message:&quot;</span>;  <span class="comment">//终端打印提示信息</span></span><br><span class="line">        <span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">        std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);    <span class="comment">//读取终端输入的信息，存到request</span></span><br><span class="line">        <span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);  <span class="comment">//获取输入信息长度</span></span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length));  <span class="comment">//同步发送给服务器</span></span><br><span class="line">        <span class="type">char</span> reply[MAX_LENGTH];</span><br><span class="line">        <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length));  <span class="comment">//同步接收服务器的信息</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;reply is &quot;</span> &lt;&lt; <span class="built_in">string</span>(reply, reply_length) &lt;&lt; endl;   <span class="comment">//打印出服务端发来的信息</span></span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;EXception is&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-协程改进服务器"><a href="#7-3-协程改进服务器" class="headerlink" title="7.3 协程改进服务器"></a>7.3 协程改进服务器</h2><p>我们可以通过协程改进服务器编码流程，用一个iocontext管理绑定acceptor用来接收对端新的连接，再从服务池IOServicePool里取其它的io_contex来管理连接的收发操作，将之前服务器中每个连接的接收数据操作改为启动一个协程，通过顺序的方式读取收到的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//start开始，后面就需要结合协程来完成了</span></span><br><span class="line">    <span class="keyword">auto</span> shared_this = <span class="built_in">shared_from_this</span>();  <span class="comment">//防止协程的智能指针被意外的释放，引用计数+1</span></span><br><span class="line">    <span class="comment">//开启协程接收</span></span><br><span class="line">    <span class="comment">//[=]表示以值的方式去捕获局部变量，捕获的局部变量引用计数可以加+；-&gt;awaitable&lt;void&gt;表示匿名函数要返回的类型</span></span><br><span class="line">    boost::asio::<span class="built_in">co_spawn</span>(_io_context, [=]()-&gt;boost::asio::awaitable&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; !_b_close;) &#123;    <span class="comment">//当变量_b_close置为true时，会退出该协程</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();    <span class="comment">//先初始化头部节点(清0，方便存下一次的数据)</span></span><br><span class="line">                <span class="comment">//先读头部数据，异步变成同步了。只有读到指定长度HEAD_DATA_LEN数据才返回，读不到该协程就挂起，让出使用权,给其它协程或主线程</span></span><br><span class="line">                std::<span class="type">size_t</span> n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_DATA_LEN), boost::asio::use_awaitable);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">//接收长度为0，说明对端关闭了</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;    <span class="comment">//使用协程内部的一个返回函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取头部MSGID数据</span></span><br><span class="line">                <span class="type">short</span> msg_id = <span class="number">0</span>;    <span class="comment">//存的头部数据的id</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);<span class="comment">//将读到头部数据的前2个字节(id)存到变量里</span></span><br><span class="line">                msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);   <span class="comment">//将id转为本地字节序</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;   <span class="comment">//如果读到的id超过规定的id范围，则是异常</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid msg id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始读数据长度</span></span><br><span class="line">                <span class="type">short</span> msg_len = <span class="number">0</span>;   <span class="comment">//存放数据长度变量</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">                msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len); <span class="comment">//将数据长度转为本地字节序</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;msg len is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;   <span class="comment">//如果读到的数据长度超过规定的最大长度，则是异常</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid msg len is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//异步读出包体</span></span><br><span class="line">                n == <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), boost::asio::use_awaitable);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">//对端关闭</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;    <span class="comment">//使用协程内部的一个返回函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">//在数据最后面加上一个结尾符</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//投递到逻辑线程处理</span></span><br><span class="line">                LogicSystem::<span class="built_in">GetInstance</span>().<span class="built_in">PostMsgToQue</span>(std::<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, boost::asio::detached);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其它部分，和之前的服务器逻辑一样，出于性能的考虑，没有把服务器的接收数据和发送数据都通过协程来完成，而只是将接收数据通过协程来完成，发送数据还是通过异步写的形式来完成的。</p>
]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>IOServicePool</tag>
        <tag>协程</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly主题美化</title>
    <url>/2024/07/19/butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-页面底部footer跳动的心"><a href="#1-页面底部footer跳动的心" class="headerlink" title="1. 页面底部footer跳动的心"></a>1. 页面底部footer跳动的心</h1><h2 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h2><p>编辑C:\blog\themes\Butterfly\layout\includes\footer.pug文件</p>
<p>1.将以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125; By $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;theme.footer.owner.since&#125; - $&#123;nowYear + &#x27; &#x27;&#125; <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">&quot;heartbeat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>2.将以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;nowYear&#125; By $&#123;config.author&#125; </span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;nowYear + &#x27; &#x27;&#125; <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">&quot;heartbeat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>3.将以下内容添加到footer.pug文件的最后一行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-效果图"><a href="#1-2-效果图" class="headerlink" title="1.2 效果图"></a>1.2 效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_1.png"></p>
<h1 id="2-修改标题样式"><a href="#2-修改标题样式" class="headerlink" title="2. 修改标题样式"></a>2. 修改标题样式</h1><h2 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h2><p>1.在C:\blog\source\css文件下新建 css 文件，并命名为 custom.css(文件名没有严格要求)，将以下代码复制到新建的custom.css中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#article-container h1:before,</span><br><span class="line">#article-container h2:before,</span><br><span class="line">#article-container h3:before,</span><br><span class="line">#article-container h4:before,</span><br><span class="line">#article-container h5:before,</span><br><span class="line">#article-container h6:before,</span><br><span class="line">#post .post-outdate-notice:before,</span><br><span class="line">.fontawesomeIcon,</span><br><span class="line">.note:not(.no-icon)::before,</span><br><span class="line">hr:before &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    font-weight: 600;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-variant: normal;</span><br><span class="line">    font-family: &#x27;Font Awesome 5 Free&#x27;;</span><br><span class="line">    text-rendering: auto;</span><br><span class="line">    -webkit-font-smoothing: antialiased</span><br><span class="line">&#125;</span><br><span class="line">#article-container h1:before,</span><br><span class="line">#article-container h2:before,</span><br><span class="line">#article-container h3:before,</span><br><span class="line">#article-container h4:before,</span><br><span class="line">#article-container h5:before,</span><br><span class="line">#article-container h6:before &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    color: #f47466;</span><br><span class="line">    /* 回形针 */</span><br><span class="line">    content: &#x27;\f0c1&#x27;;  </span><br><span class="line">    line-height: 1;</span><br><span class="line">    -webkit-transition: all .2s ease-out;</span><br><span class="line">    -moz-transition: all .2s ease-out;</span><br><span class="line">    -o-transition: all .2s ease-out;</span><br><span class="line">    -ms-transition: all .2s ease-out;</span><br><span class="line">    transition: all .2s ease-out;</span><br><span class="line">    /* 若要使用风车效果，请去掉下面的注释 */</span><br><span class="line">    /* content: &#x27;\f863&#x27;; </span><br><span class="line">    animation: avatar_turn_around 1s linear infinite; */</span><br><span class="line">&#125;</span><br><span class="line">#article-container h1 &#123;</span><br><span class="line">    padding-left: 1.4rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1 code &#123;</span><br><span class="line">    font-size: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1:before &#123;</span><br><span class="line">    margin-left: -1.3rem;</span><br><span class="line">    top: calc(50% - .5rem);</span><br><span class="line">    font-size: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1:hover &#123;</span><br><span class="line">    padding-left: 1.6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2 &#123;</span><br><span class="line">    padding-left: 1.3rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2 code &#123;</span><br><span class="line">    font-size: .9rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2:before &#123;</span><br><span class="line">    margin-left: -1.4rem;</span><br><span class="line">    top: calc(50% - .45rem);</span><br><span class="line">    font-size: .9rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2:hover &#123;</span><br><span class="line">    padding-left: 1.5rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3 &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3 code &#123;</span><br><span class="line">    font-size: .8rem;</span><br><span class="line">    top: calc(50% - .4rem);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3:before &#123;</span><br><span class="line">    margin-left: -1.2rem;</span><br><span class="line">    top: calc(50% - .4rem);</span><br><span class="line">    font-size: .8rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3:hover &#123;</span><br><span class="line">    padding-left: 1.4rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4 &#123;</span><br><span class="line">    padding-left: 1.1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4 code &#123;</span><br><span class="line">    font-size: .7rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4:before &#123;</span><br><span class="line">    margin-left: -1rem;</span><br><span class="line">    top: calc(50% - .35rem);</span><br><span class="line">    font-size: .7rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4:hover &#123;</span><br><span class="line">    padding-left: 1.3rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5 &#123;</span><br><span class="line">    padding-left: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5 code &#123;</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5:before &#123;</span><br><span class="line">    margin-left: -.8rem;</span><br><span class="line">    top: calc(50% - .3rem);</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5:hover &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6 &#123;</span><br><span class="line">    padding-left: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6 code &#123;</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6:before &#123;</span><br><span class="line">    margin-left: -.8rem;</span><br><span class="line">    top: calc(50% - .3rem);</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6:hover &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在主题配置文件_config.butterfly.yml中的以下位置引入刚刚创建的css文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom.css&quot;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-效果"><a href="#2-2-效果" class="headerlink" title="2.2 效果"></a>2.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_2.png"></p>
<h1 id="3-哔哩哔哩番剧页面插件"><a href="#3-哔哩哔哩番剧页面插件" class="headerlink" title="3. 哔哩哔哩番剧页面插件"></a>3. 哔哩哔哩番剧页面插件</h1><h2 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1 步骤"></a>3.1 步骤</h2><p>1.安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-bilibili-bangumi --save</span><br></pre></td></tr></table></figure>

<p>2.修改站点配置文件_config.yml，添加如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">bangumi: # 追番设置</span></span><br><span class="line">  enable: true</span><br><span class="line">  path:</span><br><span class="line">  vmid: 483341512</span><br><span class="line">  title: &#x27;生命不息，追番不止！&#x27;</span><br><span class="line">  quote: &#x27;Where there is life, there is life.&#x27;</span><br><span class="line">  show: 1</span><br><span class="line">  lazyload: false</span><br><span class="line">  loading:</span><br><span class="line">  metaColor:</span><br><span class="line">  color:</span><br><span class="line">  webp:</span><br><span class="line">  progress:</span><br><span class="line">  extra_options:</span><br><span class="line">    key: value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li>enable: 是否启用</li>
<li>vmid: 哔哩哔哩番剧页面的 vmid(uid), 如何获取？</li>
<li>title: 该页面的标题</li>
<li>quote: 写在页面开头的一段话，支持 html 语法</li>
<li>show: 初始显示页面：0: 想看 , 1: 在看 , 2: 看过，默认为 1</li>
<li>loading: 图片加载完成前的 loading 图片</li>
</ul>
<p>其中，vmid需要配置自己b站的一个uid，登录哔哩哔哩后前往 <a href="https://space.bilibili.com/xxx">https://space.bilibili.com/xxx</a>，网址最后的一串数字就是你的uid。</p>
<p>3.刷新追番页</p>
<p>每次在hexo g之后，就可以执行<code>hexo bangumi -u</code>对追番页进行刷新</p>
<h2 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_3.png"></p>
<h1 id="4-主页冒泡特效"><a href="#4-主页冒泡特效" class="headerlink" title="4. 主页冒泡特效"></a>4. 主页冒泡特效</h1><h2 id="4-1-步骤"><a href="#4-1-步骤" class="headerlink" title="4.1 步骤"></a>4.1 步骤</h2><p>1.在C:\blog\themes\Butterfly\source\js目录下创建一个chocolate.js文件，直接添加一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: tzy1997</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 气泡</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bubble</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#page-header&#x27;</span>).<span class="title function_">circleMagic</span>(&#123;</span><br><span class="line">            <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">density</span>: <span class="number">.2</span>,</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;rgba(255,255,255,.4)&#x27;</span>,</span><br><span class="line">            <span class="attr">clearOffset</span>: <span class="number">0.99</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;! <span class="keyword">function</span>(<span class="params">p</span>) &#123;</span><br><span class="line">        p.<span class="property">fn</span>.<span class="property">circleMagic</span> = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> o, a, n, r, e = !<span class="number">0</span>,</span><br><span class="line">                i = [],</span><br><span class="line">                d = p.<span class="title function_">extend</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;rgba(255,0,0,.5)&quot;</span>, <span class="attr">radius</span>: <span class="number">10</span>, <span class="attr">density</span>: <span class="number">.3</span>, <span class="attr">clearOffset</span>: <span class="number">.2</span> &#125;, t),</span><br><span class="line">                l = <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123; e = !(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> &gt; a) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123; o = l.<span class="property">clientWidth</span>, a = l.<span class="property">clientHeight</span>, l.<span class="property">height</span> = a <span class="string">&quot;px&quot;</span>, n.<span class="property">width</span> = o, n.<span class="property">height</span> = a &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, o, a), i) i[t].<span class="title function_">draw</span>();</span><br><span class="line">                <span class="title function_">requestAnimationFrame</span>(h)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> t = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">function</span> <span class="title function_">e</span>(<span class="params"></span>) &#123; t.<span class="property">pos</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>() * o, t.<span class="property">pos</span>.<span class="property">y</span> = a <span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(), t.<span class="property">alpha</span> = <span class="number">.1</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() * d.<span class="property">clearOffset</span>, t.<span class="property">scale</span> = <span class="number">.1</span> <span class="number">.3</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(), t.<span class="property">speed</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>(), <span class="string">&quot;random&quot;</span> === d.<span class="property">color</span> ? t.<span class="property">color</span> = <span class="string">&quot;rgba(&quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">0</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">0</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toPrecision</span>(<span class="number">2</span>) <span class="string">&quot;)&quot;</span> : t.<span class="property">color</span> = d.<span class="property">color</span> &#125;</span><br><span class="line">                t.<span class="property">pos</span> = &#123;&#125;, <span class="title function_">e</span>(), <span class="variable language_">this</span>.<span class="property">draw</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; t.<span class="property">alpha</span> &lt;= <span class="number">0</span> &amp;&amp; <span class="title function_">e</span>(), t.<span class="property">pos</span>.<span class="property">y</span> -= t.<span class="property">speed</span>, t.<span class="property">alpha</span> -= <span class="number">5e-4</span>, r.<span class="title function_">beginPath</span>(), r.<span class="title function_">arc</span>(t.<span class="property">pos</span>.<span class="property">x</span>, t.<span class="property">pos</span>.<span class="property">y</span>, t.<span class="property">scale</span> * d.<span class="property">radius</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, !<span class="number">1</span>), r.<span class="property">fillStyle</span> = t.<span class="property">color</span>, r.<span class="title function_">fill</span>(), r.<span class="title function_">closePath</span>() &#125;</span><br><span class="line">            &#125;! <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                o = l.<span class="property">offsetWidth</span>, a = l.<span class="property">offsetHeight</span>,</span><br><span class="line">                    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> t = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">                        t.<span class="property">id</span> = <span class="string">&quot;canvas&quot;</span>, t.<span class="property">style</span>.<span class="property">top</span> = <span class="number">0</span>, t.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="number">0</span>, t.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;absolute&quot;</span>, l.<span class="title function_">appendChild</span>(t), t.<span class="property">parentElement</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&quot;hidden&quot;</span></span><br><span class="line">                    &#125;(), (n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>)).<span class="property">width</span> = o, n.<span class="property">height</span> = a, r = n.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; o * d.<span class="property">density</span>; t++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> e = <span class="keyword">new</span> f;</span><br><span class="line">                    i.<span class="title function_">push</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">h</span>()</span><br><span class="line">            &#125;(), <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, c, !<span class="number">1</span>), <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, s, !<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(jQuery);</span><br><span class="line">    <span class="comment">// 调用气泡方法</span></span><br><span class="line">    <span class="title function_">bubble</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.在主题配置文件_config.butterfly.yml中，添加jquery.min.js和chocolate.js，代码如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">inject:</span></span><br><span class="line">  head:</span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script defer src=<span class="string">&quot;https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    - &lt;script data-pjax defer src=<span class="string">&quot;https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-效果"><a href="#4-2-效果" class="headerlink" title="4.2 效果"></a>4.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_4.png"></p>
<h1 id="5-全局吸底APlayer"><a href="#5-全局吸底APlayer" class="headerlink" title="5. 全局吸底APlayer"></a>5. 全局吸底APlayer</h1><h2 id="5-1-步骤"><a href="#5-1-步骤" class="headerlink" title="5.1 步骤"></a>5.1 步骤</h2><p>1.在博客根目录，打开cmd命令窗口，在终端执行以下命令，下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>2.修改站点配置文件_config.yml，配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>3.修改主题配置文件_config.butterfly.yml，将enable和per_page都设为true，因为全局(每个页面)都插入 aplayer 和 meting 资源，所以需要防止重复加载。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayerInject:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>4.在主题配置文件_config.butterfly.yml中加入如下代码，在下面代码中，需要修改的是data-id和data-server。data-server&#x3D;”netease”表示使用的播放器是网易云音乐；data-id&#x3D;”12221117397”的12221117397是我的网易云音乐的一个歌单id。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">	<span class="comment">#载入音乐aplayer</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;12221117397&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span>   <span class="string">data-order=&quot;list&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-preload=&quot;auto&quot;</span> <span class="string">data-autoplay=&quot;false&quot;</span> <span class="string">data-mutex=&quot;true&quot;</span> <span class="string">&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.如果你想切换页面时，音乐不会中断。可将主题配置文件_config.butterfly.yml的 “pjax” 设为 “true” 。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-效果"><a href="#5-2-效果" class="headerlink" title="5.2 效果"></a>5.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_5.png"></p>
<h1 id="6-音乐背景"><a href="#6-音乐背景" class="headerlink" title="6. 音乐背景"></a>6. 音乐背景</h1><h2 id="6-1-步骤"><a href="#6-1-步骤" class="headerlink" title="6.1 步骤"></a>6.1 步骤</h2><p>1.创建音乐界面，在blog的根目录下打开终端，执行hexo n music，在C:\blog\source\music\index.md文件里添加如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">title: music</span></span><br><span class="line"><span class="section">date: 2024-07-17 22:29:18</span></span><br><span class="line"><span class="section">type: &quot;music&quot;</span></span><br><span class="line"><span class="section">top_img: false</span></span><br><span class="line"><span class="section">aplayer: true</span></span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">aside: false</span></span><br></pre></td></tr></table></figure>

<p>2.创建页面，在文件夹<code>C:\blog\themes\Butterfly\layout\includes\page</code>下新建music.pug文件，这样方便后续可以使用 css 将页面(page)本身的样式给去除。其中id可以填写自己的歌单id，server是对应的音乐平台。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#anMusic-page</span></span><br><span class="line">  <span class="string">meting-js(id=&quot;12221117397&quot;</span> <span class="string">server=&quot;netease&quot;</span> <span class="string">type=&quot;playlist&quot;</span> <span class="string">mutex=&quot;true&quot;</span> <span class="string">preload=&quot;auto&quot;</span> <span class="string">theme=&quot;var(--anzhiyu-main)&quot;</span> <span class="string">order=&quot;list&quot;)</span></span><br></pre></td></tr></table></figure>

<p>3.修改<code>blog\themes\Butterfly\layout\page.pug</code>文件夹内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#page</span></span><br><span class="line">	<span class="string">if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span>  <span class="string">-----&gt;</span> <span class="string">删除这行</span></span><br><span class="line">    <span class="string">if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span> <span class="string">&amp;&amp;</span> <span class="string">page.type</span> <span class="type">!=</span> <span class="string">&#x27;music&#x27;</span>  <span class="string">-----&gt;</span> <span class="string">添加这行</span></span><br><span class="line">      <span class="string">h1.page-title=</span> <span class="string">page.title</span></span><br><span class="line"></span><br><span class="line">    <span class="string">case</span> <span class="string">page.type</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;tags&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/tags.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;link&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/flink.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;categories&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/categories.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;music&#x27;</span>  <span class="string">-----添加这行</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/music.pug</span>  <span class="string">-----&gt;</span> <span class="string">添加这行</span></span><br><span class="line">      <span class="string">default</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/default-page.pug</span></span><br><span class="line"></span><br><span class="line">    <span class="string">if</span> <span class="string">page.comments</span> <span class="type">!==</span> <span class="literal">false</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments.use</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">var</span> <span class="string">commentsJsLoad</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">      <span class="type">!=partial(&#x27;includes/third</span><span class="string">-party/comments/index&#x27;,</span> &#123;&#125;<span class="string">,</span> &#123;<span class="attr">cache:</span> <span class="literal">true</span>&#125;<span class="string">)</span></span><br></pre></td></tr></table></figure>

<p>4.创建背景元素，修改<code>blog\themes\Butterfly\layout\includes\layout.pug</code>文件内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">body</span></span><br><span class="line">    <span class="string">if</span> <span class="string">theme.background</span></span><br><span class="line">      <span class="comment">#web_bg</span></span><br><span class="line">      <span class="comment">#an_music_bg  -----&gt; 添加这行</span></span><br></pre></td></tr></table></figure>

<p>5.在文件<code>blog\source\js\anzhiyu.js</code>中添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anzhiyu = &#123;</span><br><span class="line">  <span class="comment">// 音乐节目切换背景</span></span><br><span class="line">  <span class="attr">changeMusicBg</span>: <span class="keyword">function</span> (<span class="params">isChangeBg = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> != <span class="string">&quot;/music/&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> anMusicBg = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;an_music_bg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isChangeBg) &#123;</span><br><span class="line">      <span class="comment">// player listswitch 会进入此处</span></span><br><span class="line">      <span class="keyword">const</span> musiccover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#anMusic-page .aplayer-pic&quot;</span>);</span><br><span class="line">      anMusicBg.<span class="property">style</span>.<span class="property">backgroundImage</span> = musiccover.<span class="property">style</span>.<span class="property">backgroundImage</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次进入，绑定事件，改背景</span></span><br><span class="line">      <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> musiccover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#anMusic-page .aplayer-pic&quot;</span>);</span><br><span class="line">        <span class="comment">// 确保player加载完成</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(anMusicBg);</span><br><span class="line">        <span class="keyword">if</span> (musiccover) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          anMusicBg.<span class="property">style</span>.<span class="property">backgroundImage</span> = musiccover.<span class="property">style</span>.<span class="property">backgroundImage</span>;</span><br><span class="line">          <span class="comment">// 绑定事件</span></span><br><span class="line">          anzhiyu.<span class="title function_">addEventListenerChangeMusicBg</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 暂停nav的音乐</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#nav-music meting-js&quot;</span>).<span class="property">aplayer</span> &amp;&amp;</span><br><span class="line">            !<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#nav-music meting-js&quot;</span>).<span class="property">aplayer</span>.<span class="property">audio</span>.<span class="property">paused</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            anzhiyu.<span class="title function_">musicToggle</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">addEventListenerChangeMusicBg</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> anMusicPage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;anMusic-page&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> aplayerIconMenu = anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;.aplayer-info .aplayer-time .aplayer-icon-menu&quot;</span>);</span><br><span class="line"></span><br><span class="line">    anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;meting-js&quot;</span>).<span class="property">aplayer</span>.<span class="title function_">on</span>(<span class="string">&quot;loadeddata&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      anzhiyu.<span class="title function_">changeMusicBg</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;player loadeddata&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    aplayerIconMenu.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="property">style</span>.<span class="property">animation</span> = <span class="string">&quot;0.5s ease 0s 1 normal none running to_show&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> != <span class="string">&quot;/music/&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">      anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;.aplayer-list&quot;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;aplayer-list-hide&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anzhiyu.<span class="title function_">changeMusicBg</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>6.在文件<code>blog\source\css\music.css</code>中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局样式*/</span></span><br><span class="line"><span class="selector-id">#page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;     <span class="comment">/* 移除页面的边框 */</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;             <span class="comment">/* 移除页面的阴影 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;                           <span class="comment">/* 移除页面的内边距 */</span></span><br><span class="line">  <span class="attribute">background</span>: transparent <span class="meta">!important</span>;     <span class="comment">/* 将页面背景设为透明 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*背景样式*/</span></span><br><span class="line"><span class="selector-id">#an_music_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;          <span class="comment">/* 默认隐藏背景 */</span></span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">63px</span>);      <span class="comment">/* 添加模糊效果 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;              <span class="comment">/* 设置背景的不透明度 */</span></span><br><span class="line">  <span class="attribute">position</span>: fixed;         <span class="comment">/* 使背景固定 */</span></span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">999</span>;            <span class="comment">/* 将背景放置在最底层 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: local;            <span class="comment">/* 背景附着在本地视口 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;       <span class="comment">/* 背景图居中对齐 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                          <span class="comment">/* 背景图覆盖整个容器 */</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;             <span class="comment">/* 背景图不重复 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;                                              <span class="comment">/* 背景宽度设为原来的两倍 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;                                              <span class="comment">/* 背景高度设为原来的两倍 */</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50%</span>;                                                   <span class="comment">/* 背景从顶部开始偏移 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50%</span>;                                                   <span class="comment">/* 背景从左侧开始偏移 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);                           <span class="comment">/* 不旋转背景 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#an_music_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;                               <span class="comment">/* 包含 #anMusic-page 时显示背景 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">198</span>,<span class="number">115</span>);      <span class="comment">/* 包含 #anMusic-page 时设置背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*APlayer 样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> meting-js <span class="selector-class">.aplayer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;                                <span class="comment">/* 使播放器使用 Flexbox 布局 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse;       <span class="comment">/* 元素按行反向排列 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);     <span class="comment">/* 设置背景为透明 */</span></span><br><span class="line">  <span class="attribute">border</span>: none;                               <span class="comment">/* 移除边框 */</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: none;                     <span class="comment">/* 移除阴影 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#web_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#footer</span>,</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#nav-music</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                        <span class="comment">/* 隐藏网页背景、页脚和导航音乐 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*APlayer 详细样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;                <span class="comment">/* 设置播放器主体的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">75vh</span>;              <span class="comment">/* 设置播放器主体的高度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffffff33</span>;       <span class="comment">/* 悬停时设置项目背景色 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;            <span class="comment">/* 设置圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-pic</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: none;                        <span class="comment">/* 不浮动 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">180px</span>;                     <span class="comment">/* 设置封面宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">180px</span>;                   <span class="comment">/* 设置封面高度 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;         <span class="comment">/* 设置封面圆角 */</span></span><br><span class="line">  <span class="attribute">margin</span>: auto;                    <span class="comment">/* 设置居中对齐 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                 <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;                               <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;          <span class="comment">/* 设置信息区域的外边距 */</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: none;          <span class="comment">/* 移除下边框 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;                    <span class="comment">/* 设置文字居中对齐 */</span></span><br><span class="line">  <span class="attribute">height</span>: auto;                             <span class="comment">/* 高度自适应 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span>;                            <span class="comment">/* 设置外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> <span class="selector-class">.aplayer-author</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> <span class="selector-class">.aplayer-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;                  <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;                <span class="comment">/* 设置字体粗细 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;                            <span class="comment">/* 设置字体颜色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800%</span>;                               <span class="comment">/* 设置歌词区域高度 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">80px</span>;                       <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">  <span class="attribute">mask-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#0000</span>, <span class="number">#0000</span>);    <span class="comment">/* 设置渐变遮罩 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;                  <span class="comment">/* 设置歌词字体大小 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;                           <span class="comment">/* 设置歌词字体颜色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                     <span class="comment">/* 隐藏伪元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制器样式 */</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;                 <span class="comment">/* 固定位置 */</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1500px</span>;          <span class="comment">/* 设置最大宽度 */</span></span><br><span class="line">  <span class="attribute">margin</span>: auto;                    <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;                              <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50px</span>;                   <span class="comment">/* 设置底部外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-bar-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">160px</span> <span class="number">0</span> <span class="number">150px</span>;       <span class="comment">/* 设置进度条包裹元素的外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-played</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--anzhiyu-white) <span class="meta">!important</span>;       <span class="comment">/* 设置已播放部分的背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-thumb</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: none;          <span class="comment">/* 取消缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: none;                          <span class="comment">/* 取消缩放 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span> <span class="meta">!important</span>;     <span class="comment">/* 设置背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;                <span class="comment">/* 显示图标 */</span></span><br><span class="line">  <span class="attribute">position</span>: fixed;               <span class="comment">/* 固定位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;        <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;                   <span class="comment">/* 设置宽度 */</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">21px</span>;                <span class="comment">/* 设置底部外边距 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;                        <span class="comment">/* 设置高度 */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;                  <span class="comment">/* 使用 Flexbox 布局 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;        <span class="comment">/* 右对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">18px</span>;         <span class="comment">/* 设置右外边距 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">8px</span>;           <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;            <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;              <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">40px</span>;                              <span class="comment">/* 左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;               <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">80px</span>;                                <span class="comment">/* 左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;                          <span class="comment">/* 设置图标宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;                        <span class="comment">/* 设置图标高度 */</span></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">15px</span>;                 <span class="comment">/* 设置左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-menu</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                        <span class="comment">/* 隐藏菜单图标 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span> path &#123;</span><br><span class="line">  fill: <span class="built_in">var</span>(--anzhiyu-white);        <span class="comment">/* 设置图标路径的填充色 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;                              <span class="comment">/* 设置透明度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*歌曲列表样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60%</span>;                                      <span class="comment">/* 设置列表宽度 */</span></span><br><span class="line">  <span class="attribute">max-height</span>: none <span class="meta">!important</span>;       <span class="comment">/* 取消最大高度限制 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;                                   <span class="comment">/* 设置列表高度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">75vh</span> <span class="meta">!important</span>;       <span class="comment">/* 设置最大高度 */</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">25px</span>;                      <span class="comment">/* 设置右内边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid transparent;     <span class="comment">/* 设置项目的顶部边框 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;                                      <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">255</span> <span class="number">255</span> <span class="number">255</span> / <span class="number">20%</span>);      <span class="comment">/* 设置背景色 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;                       <span class="comment">/* 设置圆角*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white);       <span class="comment">/* 设置列表项中的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-class">.aplayer-list-cur</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;         <span class="comment">/* 隐藏当前播放的标记 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;            <span class="comment">/* 设置作者名的透明度为 60% */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏样式 */</span></span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#nav</span> &#123;</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: none <span class="meta">!important</span>;       <span class="comment">/* 取消背景滤镜 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">0</span> <span class="number">0</span> <span class="meta">!important</span>;                 <span class="comment">/* 取消背景颜色 */</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: none <span class="meta">!important</span>;       <span class="comment">/* 移除底部边框 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span><span class="selector-class">.not-top-img</span> <span class="selector-id">#nav</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span> <span class="selector-id">#nav</span> <span class="selector-class">.back-home-button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white);             <span class="comment">/* 设置导航栏链接和返回首页按钮的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-class">.s-sticker</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white) <span class="meta">!important</span>;       <span class="comment">/* 设置 .s-sticker 中 div 元素的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span><span class="selector-class">.aplayer-icon-loop</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">15px</span>;          <span class="comment">/* 设置循环图标的右边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;      <span class="comment">/* 设置暗色主题下页面头部的伪元素背景颜色为透明 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* **** 移动端样式 ***** */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#rightside</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;                <span class="comment">/* 在移动端隐藏右侧侧边栏 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#content-inner</span>,</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: auto;               <span class="comment">/* 设置内容和页面的 z-index 为自动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 歌曲列表 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;            <span class="comment">/* 固定位置 */</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1002</span>;              <span class="comment">/* 设置 z-index 为 1002，以便在其他元素之上 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                <span class="comment">/* 宽度为 100% */</span></span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">76%</span>;             <span class="comment">/* 设置底部位置偏移 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                            <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--sidebar-bg);         <span class="comment">/* 设置背景色为自定义侧边栏背景色 */</span></span><br><span class="line">    <span class="attribute">height</span>: auto;                                          <span class="comment">/* 高度自动调整 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="number">0px</span>;       <span class="comment">/* 设置圆角 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;                                <span class="comment">/* 设置内边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span><span class="selector-class">.aplayer-list-hide</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0%</span> <span class="meta">!important</span>;                   <span class="comment">/* 隐藏列表时将底部位置调整为 0% */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">60vh</span> <span class="meta">!important</span>;            <span class="comment">/* 设置最大高度为视口高度的 60% */</span></span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;                            <span class="comment">/* 移除右侧内边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;                                         <span class="comment">/* 使用 Flexbox 布局 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;                                    <span class="comment">/* 设置左右外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);                      <span class="comment">/* 设置列表项文本颜色为自定义的字体颜色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-title</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;                                           <span class="comment">/* 设置标题宽度为 30% */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#33a673</span>;                        <span class="comment">/* 设置选中列表项的背景色 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">20px</span>;                             <span class="comment">/* 设置内边距 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;                          <span class="comment">/* 设置圆角 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;                                          <span class="comment">/* 设置选中列表项的文本颜色为白色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-title</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">55%</span>;                     <span class="comment">/* 设置标题最大宽度 */</span></span><br><span class="line">    <span class="attribute">width</span>: auto;                             <span class="comment">/* 宽度自动调整 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;             <span class="comment">/* 使用 WebKit 特有的 Flexbox 布局 */</span></span><br><span class="line">    -webkit-line-clamp: <span class="number">1</span>;            <span class="comment">/* 限制文本为一行 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;                    <span class="comment">/* 隐藏超出的文本 */</span></span><br><span class="line">    -webkit-box-orient: vertical;      <span class="comment">/* 设置盒子布局方向为纵向 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;                  <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;                               <span class="comment">/* 设置右边距 */</span></span><br><span class="line">    <span class="attribute">width</span>: auto;                              <span class="comment">/* 宽度自动调整 */</span></span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">35%</span>;                      <span class="comment">/* 设置最大宽度 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;               <span class="comment">/* 使用 WebKit 特有的 Flexbox 布局 */</span></span><br><span class="line">    -webkit-line-clamp: <span class="number">1</span>;             <span class="comment">/* 限制文本为一行 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;                     <span class="comment">/* 隐藏超出的文本 */</span></span><br><span class="line">    -webkit-box-orient: vertical;    <span class="comment">/* 设置盒子布局方向为纵向 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">15px</span>;                              <span class="comment">/* 调整选中列表项中作者名的右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 歌词信息 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                             <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">position</span>: fixed;                          <span class="comment">/* 固定位置 */</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;                            <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                          <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;                      <span class="comment">/* 设置顶部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;             <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">    <span class="attribute">height</span>: auto;                      <span class="comment">/* 高度自动调整 */</span></span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">200%</span>;            <span class="comment">/* 设置最大高度为 200% */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;             <span class="comment">/* 设置最小高度为 100% */</span></span><br><span class="line">    <span class="attribute">mask-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#0000</span>, <span class="number">#0000</span>);  * 设置渐变遮罩 */</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> <span class="selector-tag">p</span><span class="selector-class">.aplayer-lrc-current</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#33a673</span>;               <span class="comment">/* 设置当前歌词的颜色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 控制按键和进度条 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">100px</span>;           <span class="comment">/* 设置底部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-bar-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">30px</span>;              <span class="comment">/* 设置左右外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">40px</span>;              <span class="comment">/* 设置底部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;            <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                       <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0</span>;                  <span class="comment">/* 移除右边距 */</span></span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">33px</span>;            <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> <span class="selector-class">.aplayer-dtime</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;              <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">30px</span>;                           <span class="comment">/* 设置右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> <span class="selector-class">.aplayer-ptime</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;             <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35px</span>;                             <span class="comment">/* 设置左边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                      <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">110px</span>;                         <span class="comment">/* 设置右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                      <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                                <span class="comment">/* 设置右边距为 0 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 设置左边距为 0 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                 <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">110px</span>;                     <span class="comment">/* 设置左边距 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                           <span class="comment">/* 设置右边距为 0 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-order</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;         <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">22px</span>;                         <span class="comment">/* 距离左侧 22 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-loop</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;       <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">25px</span>;                    <span class="comment">/* 距离右侧 25 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-menu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;               <span class="comment">/* 设置元素为行内元素，使其在同一行内显示 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;      <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">25px</span>;                   <span class="comment">/* 距离右侧 25 像素 */</span></span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">90px</span>;                    <span class="comment">/* 距离顶部 -90 像素，这里使用负值使其向上移动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-volume-bar-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0px</span>;                <span class="comment">/* 距离底部 0 像素 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">7px</span>;                     <span class="comment">/* 距离右侧 7 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-volume-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">66px</span>;                     <span class="comment">/* 距离左侧 -66 像素，这里使用负值使其向左移动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.将上面写的css和js文件引入主题配置文件。在这条配置文件_config.butterfly.yml中添加如下代码，其中我们使用的是meting2 的版本，为了不与设置的全局吸底APlayer冲突，就在这里引入<code>https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js</code>，而不是在最后面的CDN-option-meting_js:处引入。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/js/anzhiyu.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/music.css&quot;&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt;</span> <span class="comment">#为了与全局吸底不产生冲突</span></span><br></pre></td></tr></table></figure>

<h1 id="7-悬挂灯笼"><a href="#7-悬挂灯笼" class="headerlink" title="7. 悬挂灯笼"></a>7. 悬挂灯笼</h1><h2 id="7-1-步骤"><a href="#7-1-步骤" class="headerlink" title="7.1 步骤"></a>7.1 步骤</h2><p>1.在<code>blog\themes\Butterfly\source\css</code>文件夹下新建lantern.css文件，并在lantern.css文件中添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 灯笼 Start */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 移动端显示/隐藏 /none/block，可自定义显示一个 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">970px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.d-box1</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.dengl</span> <span class="selector-class">.d-box</span> &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">40px</span>;</span><br><span class="line">        <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dengl</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .d-box,.d-box1&#123;</span></span><br><span class="line"><span class="comment">    z-index: 9;</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的位置 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">85px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的位置 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改灯笼的字体 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;虎年大吉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;万事顺遂&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f01f1a</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的阴影 */</span></span><br><span class="line">    <span class="comment">/* box-shadow: 0 5px 61px rgba(255, 240, 29, 0.88); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d2</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f01f1a</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的阴影 */</span></span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">61px</span> <span class="number">#ff1d1d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">82px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">animation</span>: swing <span class="number">4s</span> linear infinite;</span><br><span class="line">    <span class="attribute">transform-origin</span>: top center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">80px</span>/<span class="number">49px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">123px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">62px</span>/<span class="number">52px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">69px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">41px</span>/<span class="number">49px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">84px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">49px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">2.5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">3.5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">47px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">19px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">128px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">199px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">128px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">61px</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">122px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">98px</span>/<span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">143px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">69px</span>/<span class="number">67px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义背景图片 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">51px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">57px</span>/<span class="number">89px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">https://bu.dusays.com/2021/02/03/7e1a77cf800cf.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">92px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">123px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">68px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">19px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">121px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">53px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">3px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">59px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">53px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">9px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">21px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> swing &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">25%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">13deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">75%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">13deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 灯笼 END */</span></span><br></pre></td></tr></table></figure>

<p>2.在<code>blog\themes\Butterfly\layout\includes</code>文件夹下新建lantern.pug文件，并添加以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.dengl</span></span><br><span class="line">  <span class="string">.d-box</span></span><br><span class="line">    <span class="string">.d1</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">    <span class="string">.d2</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">  <span class="string">.d-box1</span></span><br><span class="line">    <span class="string">.d1</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">    <span class="string">.d2</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>   </span><br></pre></td></tr></table></figure>

<p>3.在<code>blog\themes\Butterfly\layout\includes\layout.pug</code>文件中引入lantern.pug文件，参考如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">head</span></span><br><span class="line">    <span class="string">include</span> <span class="string">./head.pug</span></span><br><span class="line">    <span class="string">include</span> <span class="string">./lantern.pug</span>  <span class="string">-----&gt;</span> <span class="string">添加这一行</span></span><br></pre></td></tr></table></figure>

<p>4.在主题配置文件_config.butterfly.yml中，inject的head下面引入刚刚添加的lantern.css文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/lantern.css&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-效果"><a href="#7-2-效果" class="headerlink" title="7.2 效果"></a>7.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_6.png"></p>
]]></content>
      <categories>
        <category>魔改美化</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc在windows环境下的配置与编译</title>
    <url>/2024/07/22/grpc%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>gRPC(全称为<strong>gRPC Remote Procedure Call</strong>)是一种高性能、开源的远程过程调用(RPC)框架。由Google开发，gRPC基于HTTP&#x2F;2协议，并使用Protocol Buffers(Protobufs)作为接口描述语言。以下是gRPC的一些关键特性和优势：</p>
<ul>
<li><p><strong>高性能</strong>：gRPC利用HTTP&#x2F;2的特性，例如多路复用和二进制协议，提高了传输效率和性能。</p>
</li>
<li><p><strong>多语言支持</strong>：gRPC支持多种编程语言，包括C++、Java、Python、Go、Ruby、C#等，使得开发人员可以在不同的编程环境中使用它。</p>
</li>
<li><p><strong>简化开发</strong>：通过使用Protobufs，gRPC提供了一种简洁和高效的方式来定义服务接口和消息结构。</p>
</li>
<li><p><strong>双向流</strong>：gRPC支持客户端和服务器之间的双向流通信，使得它在需要实时通信的应用场景中表现尤为出色。</p>
</li>
<li><p><strong>负载均衡和命名解析</strong>：gRPC内置了负载均衡和命名解析功能，使其更易于在分布式系统中使用。</p>
</li>
</ul>
<h2 id="1-1-主要组成部分"><a href="#1-1-主要组成部分" class="headerlink" title="1.1 主要组成部分"></a>1.1 主要组成部分</h2><ol>
<li><p><strong>服务定义</strong>：开发者使用Protobufs定义服务和消息。</p>
</li>
<li><p><strong>客户端和服务器代码生成</strong>：gRPC使用Protobufs定义生成相应的客户端和服务器代码。</p>
</li>
<li><p><strong>传输层</strong>：基于HTTP&#x2F;2协议进行高效的数据传输。</p>
</li>
</ol>
<h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ol>
<li><p><strong>微服务架构</strong>：在微服务架构中，gRPC常被用来实现服务间的高效通信。</p>
</li>
<li><p><strong>实时通信应用</strong>：由于支持双向流，gRPC非常适用于需要实时通信的应用，例如聊天应用、视频流应用等。</p>
</li>
<li><p><strong>跨语言服务</strong>：gRPC的多语言支持使得它非常适合跨语言的服务调用场景。</p>
</li>
</ol>
<h1 id="2-grpc配置"><a href="#2-grpc配置" class="headerlink" title="2. grpc配置"></a>2. grpc配置</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h2><p>由于国内环境，grpc下载极其困难的。目前在Gitee上只能找到gRPC依赖的部分”官方”镜像仓库，而网上提供的镜像仓库较旧，所以这里我构造的是v1.34.0版本。通过下面代码，选择一个稳定的分支进行克隆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.34.0 https://gitee.com/mirrors/grpc-framework.git grpc</span><br></pre></td></tr></table></figure>

<p>选择一个存放grpc项目的文件，按下Shift+鼠标右键，就会弹出如下目录，点击<code>Open Git Bash here</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_1.png"></p>
<p>弹出bash终端，输入上述代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_2.png"></p>
<p>下载完成后，在你选择的目录下出现一个grpc的文件夹，就表示克隆完成。</p>
<h2 id="2-2-修改文件内容"><a href="#2-2-修改文件内容" class="headerlink" title="2.2 修改文件内容"></a>2.2 修改文件内容</h2><p>在克隆下来的grpc文件中，有一个.gitmodules文件，里面存放的是我们需要的grpc子模块的网址，一般方式是访问不了的，所以需要修改成我们能够访问的国内的gitee上仓库的地址。这里直接将下面代码复制去替换.gitmodules文件里面的内容。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/zlib&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/zlib</span></span><br><span class="line">    <span class="comment">#url = https://github.com/madler/zlib</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/zlib.git</span></span><br><span class="line">    <span class="comment"># When using CMake to build, the zlib submodule ends up with a</span></span><br><span class="line">    <span class="comment"># generated file that makes Git consider the submodule dirty. This</span></span><br><span class="line">    <span class="comment"># state can be ignored for day-to-day development on gRPC.</span></span><br><span class="line">    <span class="string">ignore</span> <span class="string">=</span> <span class="string">dirty</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/protobuf&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/protobuf</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/protobuf.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/protobuf.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/googletest&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/googletest</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/googletest.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/googletest.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/benchmark&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/benchmark</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/benchmark</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/google-benchmark.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/boringssl-with-bazel&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/boringssl-with-bazel</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/boringssl.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/boringssl.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/re2&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/re2</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/re2.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/re2.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/cares/cares&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/cares/cares</span></span><br><span class="line">    <span class="comment">#url = https://github.com/c-ares/c-ares.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/c-ares.git</span></span><br><span class="line">    <span class="string">branch</span> <span class="string">=</span> <span class="string">cares-1_12_0</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/bloaty&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/bloaty</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/bloaty.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/bloaty.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/abseil-cpp&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/abseil-cpp</span></span><br><span class="line">    <span class="comment">#url = https://github.com/abseil/abseil-cpp.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/abseil-cpp.git</span></span><br><span class="line">    <span class="string">branch</span> <span class="string">=</span> <span class="string">lts_2020_02_25</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/envoy-api&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/envoy-api</span></span><br><span class="line">    <span class="comment">#url = https://github.com/envoyproxy/data-plane-api.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/data-plane-api.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/googleapis&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/googleapis</span></span><br><span class="line">    <span class="comment">#url = https://github.com/googleapis/googleapis.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/googleapis.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/protoc-gen-validate&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/protoc-gen-validate</span></span><br><span class="line">    <span class="comment">#url = https://github.com/envoyproxy/protoc-gen-validate.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/protoc-gen-validate.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/udpa&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/udpa</span></span><br><span class="line">    <span class="comment">#url = https://github.com/cncf/udpa.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/udpa.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/libuv&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/libuv</span></span><br><span class="line">    <span class="comment">#url = https://github.com/libuv/libuv.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/libuv.git</span></span><br></pre></td></tr></table></figure>

<p>然后使用如下指令更新gRPC所有依赖：在grpc目录下点击<code>Open Git Bash here</code>，在弹出的bash终端输入下面指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a>3. 编译</h1><h2 id="3-1-创建存放生成的vs项目位置"><a href="#3-1-创建存放生成的vs项目位置" class="headerlink" title="3.1 创建存放生成的vs项目位置"></a>3.1 创建存放生成的vs项目位置</h2><p>在grpc目录下创建一个visualpro文件夹，用于存放生成的windows所用的项目。</p>
<h2 id="3-2-启动CMake"><a href="#3-2-启动CMake" class="headerlink" title="3.2 启动CMake"></a>3.2 启动CMake</h2><p>启动CMake后，会出现下面界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_3.png"></p>
<p>点击Configure后，出现以下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_4.png"></p>
<p>点击Finish后，等待编译，完成后就得到以下界面，不需要修改，直接点击Configure，生成配置。**(到这里可以先完成go和NASM的安装，因为不确定在接下来的grpc编译和生成中会不会需要它们)**</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_5.png"></p>
<p>配置完成后，点击Generate直接生成。生成成功后，在visualpro目录下会出现生成的文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_10.png"></p>
<p>其中grpc.sln是创建的工程的路径，点击打开，出现以下界面，找到ALL_BUILD，右键选择重新生成(时间有点长)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_11.png"></p>
<p>上面生成的是Debug版本，下面在重新生成Release的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_12.png"></p>
<p>当visualpro目录下出现Debug和Release文件时，说明生成完毕！</p>
<h2 id="3-3-下载并配置NASM"><a href="#3-3-下载并配置NASM" class="headerlink" title="3.3 下载并配置NASM"></a>3.3 下载并配置NASM</h2><p>编译grpc需要准备nasm，下载网址为<a href="https://www.nasm.us/">https://www.nasm.us/</a>，点击网址后进入NASM官网，点击右上角的DOWNLOAD，选择版本2.16，选择系统Win64，然后下载NASM的可执行文件<code>nasm-2.16-installer-x64.exe</code>，下载好后得到以下可执行文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_6.png"></p>
<p>然后点击该可执行文件，安装步骤是一直next即可。</p>
<p>找到刚刚安装的目录，复制该路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_7.png"></p>
<p>将该路径配置到环境变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_8.png"></p>
<h1 id="4-安装go"><a href="#4-安装go" class="headerlink" title="4. 安装go"></a>4. 安装go</h1><p>windows环境下下载go，安装地址：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a>。根据自己系统下载，什么版本都可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_9.png"></p>
<p>下载好后，进行安装，一直next即可，安装好后go会自动写入我们的环境变量。然后打开终端，执行<code>go version</code>，出现对应的go版本，就表示安装成功。</p>
<p>替换代理，在终端执行以下代码，换成国内网络直连的模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>配置与编译</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本编程</title>
    <url>/2024/07/06/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Shell脚本入门"><a href="#1-Shell脚本入门" class="headerlink" title="1. Shell脚本入门"></a>1. Shell脚本入门</h1><h2 id="1-1-脚本格式要求"><a href="#1-1-脚本格式要求" class="headerlink" title="1.1 脚本格式要求"></a>1.1 脚本格式要求</h2><ol>
<li><p>脚本以#!&#x2F;bin&#x2F;bash开头</p>
</li>
<li><p>脚本需要有执行权限</p>
</li>
</ol>
<h2 id="1-2-shell脚本的执行方式"><a href="#1-2-shell脚本的执行方式" class="headerlink" title="1.2 shell脚本的执行方式"></a>1.2 shell脚本的执行方式</h2><ol>
<li><p>输入脚本的绝对路径或相对路径</p>
<ul>
<li>需要对脚本+x权限，再执行脚本</li>
</ul>
</li>
<li><p>sh + 脚本</p>
<ul>
<li>不需要对脚本+x权限，直接执行即可</li>
</ul>
</li>
</ol>
<p>案例：创建一个shell脚本，输出hello,world：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/shcode              #创建一个写shell脚本的文件夹</span><br><span class="line">vim hello.sh                    #在shcode目录下以vim文本编辑器编辑脚本</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入内容如下：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo “hello,world”              #保存退出 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一种方式执行(终端输入)</span></span><br><span class="line">chmod u+x hello.sh             #让该用户对文件有执行的权限</span><br><span class="line">./hello.sh                     #1相对路径执行</span><br><span class="line">/root/shcode/hello.sh          #2绝对路径执行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二种方式执行(不需要权限,终端直接输入)</span></span><br><span class="line">sh hello.sh                    #1相对路径执行</span><br><span class="line">sh /root/shcode/hello.sh       #2绝对路径执行</span><br></pre></td></tr></table></figure>

<h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><h2 id="2-1-shell变量"><a href="#2-1-shell变量" class="headerlink" title="2.1 shell变量"></a>2.1 shell变量</h2><blockquote>
<p>Linux shell中的变量分为，系统和用户自定义变量</p>
</blockquote>
<ol>
<li><p>系统变量：$HOME、$PWD、$SHELL、$USER等等，比如echo $HOME</p>
<ul>
<li>显示当前shell中所有变量：set</li>
</ul>
</li>
<li><p>shell变量的定义（自定义变量）</p>
<ul>
<li><p>定义变量：变量名&#x3D;值</p>
</li>
<li><p>撤销变量：unset 变量</p>
</li>
<li><p>声明静态变量，声明后不能unset：readonly 变量</p>
</li>
</ul>
</li>
<li><p>定义变量的规则</p>
<ul>
<li><p>变量名可以由字母、数字和下划线组成，但是不能以数字开头，</p>
</li>
<li><p>等号两侧不能有空格，如：A&#x3D;100</p>
</li>
<li><p>变量名称一般习惯为大写，这是一个规范</p>
</li>
</ul>
</li>
<li><p>将命令的返回值赋给变量</p>
<ul>
<li><p>A&#x3D;’date’反引号(键盘左上角第二颗键)，运行里面的命令，并把结果返回给变量A</p>
</li>
<li><p>A&#x3D;$(date)等价于反引号</p>
</li>
</ul>
</li>
</ol>
<p>案例：在var.sh里自定义变量、撤销变量、声明静态变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：定义变量</span></span><br><span class="line">A=100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出变量需要加上$</span></span><br><span class="line">echo A=$A                  #第1种方法输出变量A</span><br><span class="line">echo &quot;A=$A&quot;                #第2种方法输出变量A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：撤销变量A</span></span><br><span class="line">unset A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销后输出不会报错，但会无结果</span></span><br><span class="line">echo &quot;A=$A&quot;                #输出无结果</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3：声明静态的变量B=2，不能<span class="built_in">unset</span></span></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B                  #输出变量B</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销静态变量会报错</span></span><br><span class="line">unset B                    #报错</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将指令返回的结果赋给变量</span></span><br><span class="line">C=`date`                   #第1种方式将命令的返回值赋给变量</span><br><span class="line">D=$(date)                  #第2种方式将命令的返回值赋给变量</span><br><span class="line">echo C=$C</span><br><span class="line">echo &quot;D=$D&quot; </span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/1.png"></p>
<h2 id="2-2-设置环境变量"><a href="#2-2-设置环境变量" class="headerlink" title="2.2 设置环境变量"></a>2.2 设置环境变量</h2><ol>
<li>将shell变量输出为环境变量&#x2F;全局变量(&#x2F;etc&#x2F;profile文件夹)</li>
</ol>
<ul>
<li>export 变量名&#x3D;变量值</li>
</ul>
<ol start="2">
<li>配置文件，让修改后的配置信息立即生效(终端输入)</li>
</ol>
<ul>
<li>source</li>
</ul>
<ol start="3">
<li>查询环境变量的值</li>
</ol>
<ul>
<li>echo $变量名</li>
</ul>
<p>案例：在&#x2F;etc&#x2F;profile文件中定义TOMCAT_HOME环境变量，并查询其环境变量值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以vim文本编辑器形式打开文件profile</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最后一行输入这条命令，保存并退出</span></span><br><span class="line">export TOMCAT_HOME=/opt/tomcat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">令修改的信息立即生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后就可以在shell程序中使用了</span></span><br><span class="line">echo $TOMCAT_HOME</span><br></pre></td></tr></table></figure>

<p>补：shell脚本的多行注释：:&lt;&lt;! 内容 !   ——-&gt;后面的!需要单独起行</p>
<h2 id="2-3-位置参数变量"><a href="#2-3-位置参数变量" class="headerlink" title="2.3 位置参数变量"></a>2.3 位置参数变量</h2><blockquote>
<p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。比如：.&#x2F;myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息。</p>
</blockquote>
<ul>
<li><p>$n：n为数字，$n代表本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}；</p>
</li>
<li><p>$*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整数</p>
</li>
<li><p>$@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p>
</li>
<li><p>$#：这个变量代表命令行中所有参数的个数</p>
</li>
</ul>
<p>案例：编写一个shell脚本position.sh，在脚本中获取到命令行的各个参数信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以vim文本编辑器打开</span></span><br><span class="line">vim /root/shcode/myshell.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内容代码</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;0=$0 1=$1 2=$2&quot;     #打印第0、1、2位置的参数</span><br><span class="line">echo &quot;所有的参数=$*&quot;        #输出所有参数，不包括$0</span><br><span class="line">echo &quot;$@&quot;                 #输出所有参数，不包括$0</span><br><span class="line">echo &quot;参数的个数=$#&quot;        #输出参数的个数</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/2.png"></p>
<h2 id="2-4-预定义变量"><a href="#2-4-预定义变量" class="headerlink" title="2.4 预定义变量"></a>2.4 预定义变量</h2><blockquote>
<p>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
</blockquote>
<ul>
<li><p>$$：当前进程的进程好PID；</p>
</li>
<li><p>$!：后台运行的最后一个进程的进程号PID；</p>
</li>
<li><p>$?：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，有命令自己来决定)，则证明上一个命令执行不正确。</p>
</li>
</ul>
<p>案例：在一个shell脚本中简单使用一下预定义变量preVar.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前执行的进程id=$$&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以后台方式运行一个脚本，并获取它的进程号</span></span><br><span class="line">/root/shcode/myshell.sh &amp;</span><br><span class="line">echo &quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="line">echo &quot;执行的结果是=$?&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/3.png"></p>
<h2 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h2><ol>
<li><p>$((运算符))或$[运算符]或者expr m 运算符 n</p>
</li>
<li><p>注意expr运算符间要有空格，如果希望将expr的结果赋给某个变量，使用&#96;&#96;(左上角键)</p>
</li>
<li><p>expr m 运算符 n 方式下的运算符</p>
<ul>
<li>expr *，&#x2F;，%  ———–&gt;乘，除，取余</li>
</ul>
</li>
</ol>
<p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：计算(2+3)*4的值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第1种方式:</span></span><br><span class="line">res1=$(((2+3)*4))</span><br><span class="line">echo &quot;res1=$res1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第2种方式:</span></span><br><span class="line">res2=$[(2+3)*4]</span><br><span class="line">echo res2=$res2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第3种方式(数字之间要要空格):</span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES3=`expr $TEMP \* 4`</span><br><span class="line">echo res3=$RES3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2:请求出命令行的前两个参数的和(20+50)</span></span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo sum=$SUM</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/4.png"></p>
<h1 id="3-shell进阶"><a href="#3-shell进阶" class="headerlink" title="3. shell进阶"></a>3. shell进阶</h1><h2 id="3-1-条件判断"><a href="#3-1-条件判断" class="headerlink" title="3.1 条件判断"></a>3.1 条件判断</h2><p>基本语法：</p>
<ul>
<li>[ condition ]  括号非空返回true,可以使用$?验证</li>
<li>[ condition ] &amp;&amp; echo ok || echo notok  条件满足，执行后面的语句</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/5.png"></p>
<p>应用实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：23是否大于等于22</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;大于等于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3：/root/shcode/aaa.txt 文件是否存在</span></span><br><span class="line">if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;存在&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例4：测试空</span></span><br><span class="line">if [ lxx ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;hello world&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/6.png"></p>
<h2 id="3-2-流程控制"><a href="#3-2-流程控制" class="headerlink" title="3.2 流程控制"></a>3.2 流程控制</h2><blockquote>
<p>1.多分支</p>
<p>if [ 条件判断式 ]</p>
<p>then</p>
<p>​	代码</p>
<p>elif [ 条件判断式 ]</p>
<p>then</p>
<p>​	代码</p>
<p>fi</p>
</blockquote>
<p>注：[ 条件判断式 ]，中括号和条件判断式之间必须有空格，fi表示结束</p>
<p>案例：请编写一个shell程序，如果输入的参数。大于等于60，则输出”及格了”，如果小于60，则输出”不及格”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;不及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/7.png"></p>
<blockquote>
<p>2.case语句</p>
<p>case $变量名 in</p>
<p>“值1”)</p>
<p>如果变量的值等于1，则执行程序1</p>
<p>;;</p>
<p>“值2”)</p>
<p>如果变量的值等于2，则执行程序2</p>
<p>;;</p>
<p>….省略其他分支…</p>
<p>*)</p>
<p>如果变量的值都不是以上的值，则执行此程序</p>
<p>;;</p>
<p>esac</p>
</blockquote>
<p>案例：当命令行参数是1时，输出”周一”，是2时，就输出”周二”，其他情况输出”other”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other...&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/8.png"></p>
<blockquote>
<p>3.for循环(第1种)</p>
<p>for 变量 in 值1 值2 值3</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>案例：打印命令行输入的参数[这里可以看出$*和$@的区别]：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意 $*是把输出的参数，当作一个整体，所以只会输出一句</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="variable">$@</span>来获取输入的参数，注意，这时是分别对待，所以有几个参数，就输出几句</span></span><br><span class="line">echo &quot;------------------------------&quot;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;num is $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/9.png"></p>
<blockquote>
<p>4.for循环(第2种)</p>
<p>for((初始值;循环控制条件;变量变化))</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>案例：从1加到100的值输出显示(若想将1001变为一个变量，可以将100改为$1)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0                  #定义一个变量SUM</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">写业务代码</span></span><br><span class="line">	SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;总和SUM=$SUM&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/10.png"></p>
<blockquote>
<p>5.while循环</p>
<p>while [ 条件判断式 ]</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>注意：while和[有空格，条件判断式和[也有空格</p>
<p>案例：从命令行输入一个数n，统计从1+…+n的值是多少</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0;                    #定义一个变量SUM</span><br><span class="line">i=0;</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">写业务代码</span></span><br><span class="line">	SUM=$[$SUM+$i]</span><br><span class="line">	i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;执行结果=$SUM&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/11.png"></p>
<h1 id="4-read读取控制台输入"><a href="#4-read读取控制台输入" class="headerlink" title="4. read读取控制台输入"></a>4. read读取控制台输入</h1><p>基本语法：read (选项) (参数)</p>
<p>选项：</p>
<ul>
<li><p>-p：指定读取值时的提示符；</p>
</li>
<li><p>-t：指定读取值时等待的时间(秒)，如果没有在指定的时间内输入，就不再等待了；</p>
</li>
</ul>
<p>参数：</p>
<ul>
<li>指定读取值的变量名</li>
</ul>
<p>案例：读取控制台输入一个NUM1值；读取控制台输入一个NUM2值，在10秒内输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取控制台输入一个NUM1</span></span><br><span class="line">read -p &quot;请输入一个NUM1=&quot; NUM1</span><br><span class="line">echo &quot;您输入的NUM1=$NUM1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取控制台输入一个NUM2，并要求在10秒内输入</span></span><br><span class="line">read -t 10 -p &quot;请输入一个数NUM2=&quot; NUM2</span><br><span class="line">echo &quot;您输入的NUM2=$NUM2&quot;</span><br></pre></td></tr></table></figure>

<p>输出的结果如下(第一次是在10秒内输入了93，第二次是没有在10秒内输入数据)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/12.png"></p>
<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h1><p>shell编程和其他编程语言一样，有系统函数，也可以有自定义函数，下面介绍2个</p>
<h2 id="5-1-系统函数"><a href="#5-1-系统函数" class="headerlink" title="5.1 系统函数"></a>5.1 系统函数</h2><ul>
<li><p>basename：返回完整路径最后&#x2F;的部分，常用于获取文件名</p>
</li>
<li><p>dirname：返回完整路径最后&#x2F;的前面的部分，常用于返回路径部分</p>
</li>
</ul>
<p>案例：请返回&#x2F;home&#x2F;aaa&#x2F;test.txt的test.txt部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/13.png"></p>
<p>案例：请返回&#x2F;home&#x2F;aaa&#x2F;test.txt的&#x2F;home&#x2F;aaa部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/14.png"></p>
<h2 id="5-2-自定义函数"><a href="#5-2-自定义函数" class="headerlink" title="5.2 自定义函数"></a>5.2 自定义函数</h2><p>案例：计算输入两个参数的和(动态获取)getSum</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function getSum()&#123;</span><br><span class="line">	SUM=$[$n1+$n2]</span><br><span class="line">	echo &quot;和是=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入两个值</span></span><br><span class="line">read -p &quot;请输入一个数n1=&quot; n1</span><br><span class="line">read -p &quot;请输入一个数n2=&quot; n2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用自定义函数</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/15.png"></p>
]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2024/07/04/makefile/</url>
    <content><![CDATA[<p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Visual C++的nmake，QtCreator的qmake等。</p>
<p>makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>makefile文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会被加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中</p>
<h1 id="1-gcc工作流程"><a href="#1-gcc工作流程" class="headerlink" title="1. gcc工作流程"></a>1. gcc工作流程</h1><blockquote>
<p>GCC编译器对程序的编译下图所示，分为4个阶段：预处理(预编译)、编译和优化、汇编和链接。GCC的编译器可以将这4个步骤合并成一个。</p>
</blockquote>
<ul>
<li><p>预处理：在这个阶段主要做了三件事：展开头文件、宏替换、求掉注释行。这个阶段需要GCC调用预处理器来完成，最终得到的还是源文件，文本格式。</p>
</li>
<li><p>这个阶段需要GCC调用编译器对文件进行编译，最终得到一个汇编文件。</p>
</li>
<li><p>这个阶段需要GCC调用汇编器对文件进行汇编，最终得到一个二进制文件。</p>
</li>
<li><p>这个阶段需要GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">文件名后缀</th>
<th align="center">说明</th>
<th align="center">gcc参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.c</td>
<td align="center">源文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">.i</td>
<td align="center">预处理后的c文件</td>
<td align="center">-E</td>
</tr>
<tr>
<td align="center">.s</td>
<td align="center">编译之后得到的汇编语言的源文件</td>
<td align="center">-S</td>
</tr>
<tr>
<td align="center">.o</td>
<td align="center">汇编后得到的二进制文件</td>
<td align="center">-C</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编程：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法1:</span></span><br><span class="line">gcc -E mycode1.c -o mycode1.i   #生成预处理文件</span><br><span class="line">gcc -S mycode1.i -o mycode1.s   #生成汇编文件</span><br><span class="line">gcc -c mycode1.s -o mycode1.o   #生成二进制文件</span><br><span class="line">gcc mycode1.o -o mycode1        #链接，生成可执行文件</span><br><span class="line">./mycode1                       #执行可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法2</span></span><br><span class="line">gcc mycode1.c -o aa            #直接生成可执行文件</span><br><span class="line">./aa                           #执行可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法3</span></span><br><span class="line">gcc mycode1.c                  #默认会生成a.out这个文件</span><br><span class="line">./a.out                        #执行可执行文件</span><br></pre></td></tr></table></figure>

<h1 id="2-gcc参数与g"><a href="#2-gcc参数与g" class="headerlink" title="2. gcc参数与g++"></a>2. gcc参数与g++</h1><blockquote>
<p>下面的表格中列出了常用的一些gcc参数, 这些参数在 gcc命令中没有位置要求，只需要编译程序的时候将需要的参数指定出来即可</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">gcc编译选项</th>
<th align="center">选项的意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-E</td>
<td align="center">预处理指定的源文件，不进行编译</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">编译指定的源文件，但是不进行汇编</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">编译、汇编指定的源文件，但是不进行链接</td>
</tr>
<tr>
<td align="center">-I directory (大写的i)</td>
<td align="center">指定 include 包含文件的搜索目录</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">在编译的时候，生成调试信息，该程序可以被调试器调试</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">在程序编译的时候，指定一个宏</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">不生成任何警告信息, 不建议使用, 有些时候警告就是错误</td>
</tr>
<tr>
<td align="center">-L</td>
<td align="center">指定编译的时候，搜索的库的路径</td>
</tr>
<tr>
<td align="center">-fPIC&#x2F;fpic</td>
<td align="center">生成与位置无关的代码</td>
</tr>
<tr>
<td align="center">-shared</td>
<td align="center">生成共享目标文件。通常用在建立共享库时</td>
</tr>
<tr>
<td align="center">-std</td>
<td align="center">指定C方言，如:-std&#x3D;c99，gcc默认的方言是GNU C</td>
</tr>
</tbody></table>
<blockquote>
<p>关于对gcc和g++的理解，下边从三个方面介绍一下二者的区别：</p>
</blockquote>
<ol>
<li><p>在代码编译阶段(第二个阶段)：</p>
<ul>
<li><p>后缀为 .c 的，gcc 把它当作是C程序，而 g++ 当作是 C++ 程序</p>
</li>
<li><p>后缀为.cpp的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些</p>
</li>
<li><p>g++会调用gcc，对于C++代码，两者是等价的, 也就是说 gcc 和 g++ 都可以编译 C&#x2F;C++代码</p>
</li>
</ul>
</li>
<li><p>在链接阶段(最后一个阶段)</p>
</li>
</ol>
<ul>
<li>gcc 和 g++ 都可以自动链接到标准C库</li>
<li>g++ 可以自动链接到标准C++库, gcc如果要链接到标准C++库需要加参数 -lstdc++</li>
</ul>
<blockquote>
<p>综上所述：</p>
<ul>
<li>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同</li>
<li>g++可以直接编译C++程序， gcc 编译 C++程序需要添加额外参数 -lstdc++</li>
</ul>
</blockquote>
<h1 id="3-makefile规则语法格式"><a href="#3-makefile规则语法格式" class="headerlink" title="3. makefile规则语法格式"></a>3. makefile规则语法格式</h1><blockquote>
<p>每条规则由三个部分组成分别是目标，依赖和命令。下面通过一个例子来阐述一下:</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例1: 假设有源文件a.c、b.c、c.c和head.h, 现在需要生成可执行程序test1</span></span><br><span class="line"><span class="comment"># 有一个目标，多个依赖，一条命令</span></span><br><span class="line"><span class="comment">################# 例1 #################</span></span><br><span class="line"><span class="section">test1:a.c b.c c.c</span></span><br><span class="line">	gcc a.c b.c c.c -o test1</span><br><span class="line"></span><br><span class="line"><span class="comment">################# 例2 #################</span></span><br><span class="line"><span class="comment"># 举例2: 假设有源文件a.c、b.c、c.c和d.c, 现在需要生成可执行程序test1,test2</span></span><br><span class="line"><span class="comment"># 有多个目标, 多个依赖, 多个命令</span></span><br><span class="line"><span class="section">test1,test2:a.c b.c c.c d.c</span></span><br><span class="line">	gcc a.c b.c -o test1</span><br><span class="line">	gcc c.c d.c -o test2</span><br><span class="line">	</span><br><span class="line"><span class="comment">################# 例3 #################	</span></span><br><span class="line"><span class="comment"># 举例3: 假设有源文件a.c、b.c、c.c和head.h, 现在需要生成可执行程序test1</span></span><br><span class="line"><span class="comment"># 有一个目标，多个依赖，多条命令</span></span><br><span class="line"><span class="section">test1:a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o test1</span><br><span class="line"><span class="comment"># a.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">a.o:a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"><span class="comment"># b.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">b.o:b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"><span class="comment"># c.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">c.o:c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>

<h1 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4. 工作原理"></a>4. 工作原理</h1><p>在调用make命令编辑程序的时候，make会首先找到该目录下的makefile文件中的第一条规则，分析并执行相关操作，但需要注意的是，好多时候要执行的动作(命令)中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p>
<p>对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p>
<p>这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make的任务也就完成了。</p>
<h2 id="4-1-目标文件的更新"><a href="#4-1-目标文件的更新" class="headerlink" title="4.1 目标文件的更新"></a>4.1 目标文件的更新</h2><ol>
<li><p>依赖文件存在，目标文件不存在，make就会根据依赖来生成目标文件</p>
</li>
<li><p>依赖和目标都是存在的：</p>
<ul>
<li><p>目标的时间大于依赖的时间，此时不更新目标文件；</p>
</li>
<li><p>目标的时间小于依赖的时间，此时make会根据依赖更新目标文件；</p>
</li>
</ul>
</li>
</ol>
<h2 id="4-2-自动推导"><a href="#4-2-自动推导" class="headerlink" title="4.2 自动推导"></a>4.2 自动推导</h2><blockquote>
<p>虽然make需要根据makefile中指定的规则来完成源文件的编译，但是我们会发现当漏写一些构建规则时，程序还是会被编译成功，这是因为make有自动推导的能力，不会完全依赖makefile。</p>
</blockquote>
<p>注意：命令行前面是一个tab健距离；</p>
<h2 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h2><blockquote>
<p>使用makefile进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile中的变量分为三种：自定义变量、预定义变量和自动变量。</p>
</blockquote>
<ol>
<li><p>自定义变量：用makefile进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。</p>
</li>
<li><p>预定义变量：在makefile中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">含义</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AR</td>
<td align="center">生成静态库库文件的程序名称</td>
<td align="center">ar</td>
</tr>
<tr>
<td align="center">AS</td>
<td align="center">汇编编译器的名称</td>
<td align="center">as</td>
</tr>
<tr>
<td align="center">CC</td>
<td align="center">C 语言编译器的名称</td>
<td align="center">cc</td>
</tr>
<tr>
<td align="center">CPP</td>
<td align="center">C 语言预编译器的名称</td>
<td align="center">$(CC) -E</td>
</tr>
<tr>
<td align="center">CXX</td>
<td align="center">C++语言编译器的名称</td>
<td align="center">g++</td>
</tr>
<tr>
<td align="center">FC</td>
<td align="center">FORTRAN 语言编译器的名称</td>
<td align="center">f77</td>
</tr>
<tr>
<td align="center">RM</td>
<td align="center">删除文件程序的名称</td>
<td align="center">rm -f</td>
</tr>
<tr>
<td align="center">ARFLAGS</td>
<td align="center">生成静态库库文件程序的选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">ASFLAGS</td>
<td align="center">汇编语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CFLAGS</td>
<td align="center">C 语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CPPFLAGS</td>
<td align="center">C 语言预编译的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CXXFLAGS</td>
<td align="center">C++语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">FFLAGS</td>
<td align="center">FORTRAN 语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个规则，普通写法</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量和预定义变量</span></span><br><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line">CFLAGS=-O3 <span class="comment"># 代码优化</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        <span class="variable">$(CC)</span>  <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自动变量：自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$*</td>
<td align="center">表示目标文件的名称，不包含目标文件的扩展名</td>
</tr>
<tr>
<td align="center">$+</td>
<td align="center">表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件</td>
</tr>
<tr>
<td align="center">$&lt;</td>
<td align="center">表示依赖项中第一个依赖文件的名称</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">表示目标文件的名称，包含文件扩展名</td>
</tr>
<tr>
<td align="center">$^</td>
<td align="center">依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *****************#例1********************</span></span><br><span class="line">target=calc</span><br><span class="line">obj=add.o div.o main.o mult.o sub.o</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="comment">#简化后的代码：$&lt;和-c互换位置也可以</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"><span class="comment"># ****************************************</span></span><br><span class="line"><span class="comment"># *****************#例2********************</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc  </span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量</span></span><br><span class="line"><span class="comment"># 使用自动变量, 替换相关的内容</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> 			<span class="comment"># 自动变量只能在规则的命令中使用</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-wildcard函数"><a href="#4-4-wildcard函数" class="headerlink" title="4.4 wildcard函数"></a>4.4 wildcard函数</h2><blockquote>
<p>这个函数的主要作用是获取指定目录下指定类型的文件名，器返回值是以空格分割的、指定目录下的所有符合条件的文件列表。</p>
</blockquote>
<p>使用：$(wildcard,参数,参数,…..)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>

<h2 id="4-5-patsubst函数"><a href="#4-5-patsubst函数" class="headerlink" title="4.5 patsubst函数"></a>4.5 patsubst函数</h2><p>这个函数的功能是按照指定的模式替换指定文件名的后缀。</p>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp              <span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span>       <span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**************修改后的代码*********************</span></span><br><span class="line"></span><br><span class="line">target=calc</span><br><span class="line"><span class="comment">#搜索当前目录下的源文件</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment">#后缀的替换</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> .c</span><br><span class="line"><span class="comment">#构建伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span>     <span class="comment">#添加伪目标后，以后可以直接通过make clean方便第删除*.p和calc文件</span></span><br></pre></td></tr></table></figure>

<p>补：在命令前面加上-，当该命令不能执行时，也可以继续执行下面的的命令(-mkdir &#x2F;abc)</p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>makefile</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>图床实现(通过百度智能云、七牛云、PicGo软件完成)</title>
    <url>/2024/07/03/%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="1-给域名添加新的解析"><a href="#1-给域名添加新的解析" class="headerlink" title="1.给域名添加新的解析"></a>1.给域名添加新的解析</h1><p>进入百度智能云官网：<a href="https://cloud.baidu.com/">https://cloud.baidu.com/</a>，点击右上角的控制台</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/1.png"></p>
<p>找到域名服务，点击域名管理，这里有你之前买的域名(没有买的最好买一个，很便宜)，下面要为域名添加一共新的解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/2.png"></p>
<p>在添加解析记录的界面中，主机记录可以随便填，例如填image，记录类型选择CNAME记录，记录值先随便乱填(后期会改)，填写完上面内容后，点击确定，完成添加解析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/3.png"></p>
<h1 id="2-创建存储图片的空间"><a href="#2-创建存储图片的空间" class="headerlink" title="2.创建存储图片的空间"></a>2.创建存储图片的空间</h1><p>进入七牛云官网：<a href="https://marketing.qiniu.com/">https://marketing.qiniu.com/</a>，点击右上角的控制台</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/4.png"></p>
<p>点击左上角的菜单，选择对象存储</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/5.png"></p>
<p>进入后，选择空间管理，然后新建空间，存储空间的名称可以随便填，存储区域建议选择亚太-新加坡，访问控制选择公开，最好点击确定，完成空间建立</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/6.png"></p>
<p>建立完成后，点击创建的空间名称，进入图床控制面板，选择域名管理，绑定域名</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/7.png"></p>
<p>进入后，在添加域名的界面，其中加速域名是之前添加解析记录时填写的主机记录，而且后缀要加上你的域名(我因为之前填写过改域名，所以会提示创建过)。使用场景选择图片小文件，然后下面点击使用推荐配置，点击创建即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/8.png"></p>
<p>绑定完成后，复制图上箭头所指的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/9.png"></p>
<p>然后对刚刚在百度智能云上添加的解析进行修改，将复制的内容粘贴到记录值，点击确定即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/10.png"></p>
<h1 id="3-完成连接"><a href="#3-完成连接" class="headerlink" title="3.完成连接"></a>3.完成连接</h1><p>通过该网址下载PicGo：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p>
<p>下载完后，进入该软件，点击图床设置，选择七牛云</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/11.png"></p>
<p>这样就进入了七牛云设置，首先是图库配置名，这里随便填；其次是AK和SK，这里需要填写七牛云米密匙管理中的AK和SK；然后设定Bucket这里填之前创建的空间名称；设定访问网址填写的是我们刚才填写的加速域名，这里前面要加http:&#x2F;&#x2F;；而设定存储区域这里是填as0（这里仅限刚刚与我选择的区域一样的情况，如果选择的区域不是亚太-新加坡则不是填这个）；最后是设定存储路径，这里可以先在七牛云的中创建存储图片的目录，然后这里就填写该目录名即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/12.png"></p>
<p>点击了密匙管理就进入下面页面，然后分别复制AK和SK到PicGo对应位置，这里需要注意的是SK复制时，必须要打开显示复制，如果不打开显示复制，后面会出现问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/13.png"></p>
<p>PicGo软件中七牛云设置填写完毕后，点击确定即可，这样就完成了图床的配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/14.png"></p>
<p>完成配置后，在上传区，直接添加你要上传的本地图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/15.png"></p>
<p>上传完成后，然后到七牛云的空间管理中，点击picture目录就可以看见刚刚上传的图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/16.png"></p>
<p>这样，以后要在博客或者其它平台上要用到的这些图片时，可以直接用下面图中箭头指的地方的图片网址或者七牛云中上传图片的外链即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/17.png"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>七牛云</tag>
        <tag>域名</tag>
        <tag>PicGo</tag>
        <tag>解析</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2024/07/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h1><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p>
<h2 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h2><p>1.典型的协议</p>
<ul>
<li><p>传输层：常见协议有TCP&#x2F;UDP协议</p>
</li>
<li><p>应用层：常见的协议有HTTP协议、FTP协议</p>
</li>
<li><p>网络层：常见的协议有IP协议、ICMP协议、IGMP协议</p>
</li>
<li><p>网络接口层：常见的协议有ARP协议、RARP协议</p>
</li>
</ul>
<p>2.分层模型结构</p>
<ul>
<li><p>OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
</li>
<li><p>TCP&#x2F;IP四层模型：网络接口层(链路层)、网路层、传输层、应用层</p>
</li>
</ul>
<p>3.网络传输流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_1.png"></p>
<p>注意：数据没有封装之前，是不能在网络中传递的。</p>
<p>4.ARP协议</p>
<blockquote>
<p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用，源主机发出ARP协议，询问IP地址是192.168.0.1的主机的硬件地址是多少，并将这个请求广播到本地网段，目的主机接收到广播ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_2.png"></p>
<p>ARP协议：根据IP地址获取mac地址</p>
<p>以太网帧协议：根据mac地址，完成数据包传输</p>
<p>5.IP协议：</p>
<ul>
<li><p>版本：IPv4、IPv6</p>
</li>
<li><p>TTL:time to live。设置数据包在路由节点中的跳转上限，每经过一个路由节点，该值-1，减为0的路由，有义务将该数据包丢弃</p>
</li>
<li><p>源IP&#x2F;目的IP：32位—&gt;4字节</p>
</li>
</ul>
<p>补：IP地址：可以在网络环境中，唯一标识一台主机</p>
<p>端口号：可以网络的一台主机上，唯一标识一个进程</p>
<p>IP地址+端口号：可以在网络环境中，唯一标识一个进程</p>
<h2 id="1-2-C-S模型与B-S模型"><a href="#1-2-C-S模型与B-S模型" class="headerlink" title="1.2 C&#x2F;S模型与B&#x2F;S模型"></a>1.2 C&#x2F;S模型与B&#x2F;S模型</h2><p>1.C&#x2F;S模型(client-server)</p>
<ul>
<li><p>优点：缓存大量数据、协议选择灵活、速度快</p>
</li>
<li><p>缺点：安全性低、不能跨平台、开发工作量较大</p>
</li>
</ul>
<p>2.B&#x2F;S模型</p>
<ul>
<li><p>优点：安全性高、跨平台、开发工作量较小</p>
</li>
<li><p>缺点：不能缓存大量数据、严格遵守HTTP</p>
</li>
</ul>
<h1 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h1><h2 id="2-1-网络套接字socket"><a href="#2-1-网络套接字socket" class="headerlink" title="2.1 网络套接字socket"></a>2.1 网络套接字socket</h2><blockquote>
<p>一个文件描述符指向一个套接字(该套接字内部由内核借助两个缓冲区实现)。在通信过程中，套接字一定是成对出现的。</p>
</blockquote>
<p>1.网络字节序</p>
<ul>
<li><p>小端法(pc本地地址)：高位存高位地址，低位存低位地址</p>
</li>
<li><p>大端法(网络存储)：高位存低位地址，低位存高位地址</p>
</li>
</ul>
<p>2.转换函数</p>
<ul>
<li><p>htonl：本地(IP) ——–&gt; 网络(IP)</p>
</li>
<li><p>htons：本地(port) ——-&gt; 网络(port)</p>
</li>
<li><p>ntohl：网络(IP) ——–&gt; 本地(IP)</p>
</li>
<li><p>ntohs：网络(port) ——-&gt; 本地(port)</p>
</li>
</ul>
<p>3.IP地址转换函数</p>
<p>本地字节序(string IP) ——-&gt; 网络字节序</p>
<p><code>int inet_pton(int af , const char *src , void *dst);</code></p>
<ul>
<li><p>参1：AF_INET、AF_INET6</p>
</li>
<li><p>参2：传入参数，IP地址(点分十进制)</p>
</li>
<li><p>参3：传出参数，转换后的网络字节序的IP地址</p>
</li>
<li><p>返回值：成功(1)；异常(0，说明src指向的不是一个有效的ip地址)；失败(-1)</p>
</li>
</ul>
<p>网络字节序—&gt;本地字节序(string IP)</p>
<p><code>const char *inet_ntop(int af , const void *src , char *dst , socklen_t size);</code></p>
<ul>
<li><p>参1：AF_INET、AF_INET6</p>
</li>
<li><p>参2：网络字节序IP地址</p>
</li>
<li><p>参3：本地字节序(string IP)</p>
</li>
<li><p>参4：参3的大小</p>
</li>
<li><p>返回值：成功(参3)；失败(NULL)；</p>
</li>
</ul>
<p>4.sockaddr地址结构(查看：man 7 ip)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET/AF_INET6</span><br><span class="line">addr.sin_port = htons(<span class="number">9527</span>);                <span class="comment">//端口号</span></span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);   <span class="comment">//取出系统中有效的任意IP地址(获取默认本地IP地址)，二进制类型</span></span><br><span class="line">bind(fd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,size);     <span class="comment">//进行绑定，需要转换成sockaddr</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-网络相关函数"><a href="#2-2-网络相关函数" class="headerlink" title="2.2 网络相关函数"></a>2.2 网络相关函数</h2><p>1.创建一个套接字</p>
<p>头文件：#include &lt;sys&#x2F;socket.h&gt;</p>
<p><code>int socket(int domain , int type , int protocol); </code></p>
<ul>
<li><p>参1：AF_INET(IPV4)、AF_INET6(IPV6)、AF_UNIX(本地套接字)</p>
</li>
<li><p>参2：SOCK_STREAM(流式协议)、SOCK_DGRAM(报式协议)</p>
</li>
<li><p>参3：0即可</p>
</li>
<li><p>返回值：成功(新套接字所对应文件描述符)；失败(-1)</p>
</li>
</ul>
<p>2.给socket绑定一个地址结构(IP+port)</p>
<p>头文件：include &lt;arpa&#x2F;inet.h&gt;</p>
<p><code>int bind(int sockfd , const struct sockaddr *addr , socklen_t addrlen);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传入参数，自己的地址结构(IP+port)</p>
</li>
<li><p>参3：地址结构的大小</p>
</li>
<li><p>返回值：成功(0)，失败(-1)</p>
</li>
</ul>
<p>3.设置同时与服务器建立连接的上限数(同时进行三次握手的客户端数量)</p>
<p><code>int listen(int socket , int backlog);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：上限数值。最大值为128</p>
</li>
<li><p>返回值：成功(0)；失败(-1)</p>
</li>
</ul>
<p>4.阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符</p>
<p><code>int accept(int sockfd , struct sockaddr *addr , socklen_t *addrlen);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传出参数，得到成功与服务器建立连接的那个客户端的地址结构</p>
</li>
<li><p>参3：传入传出参数，传入参2的大小，传出客户端地址结构实际大小</p>
</li>
<li><p>返回值：成功(能与服务器进行数据通信的socket对应的文件描述符)；失败(-1)</p>
</li>
</ul>
<p>5.使用现有的socket与服务器建立连接</p>
<p><code>int connect(int sockfd , const struct sockaddr *addr , socklen_t addrlen)</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传入参数，服务器的地址结构</p>
</li>
<li><p>参3：服务器的地址结构的大小</p>
</li>
<li><p>返回值：成功(0)；失败(-1)</p>
</li>
</ul>
<p>补：如果不使用bind绑定客户端地址结构，系统采用“隐式绑定”。</p>
<p>服务端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527                         <span class="comment">//固定一个端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;                 <span class="comment">//打印错误信息函数</span></span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> ret ,i;</span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;</span><br><span class="line">    <span class="comment">//服务端结点信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);       <span class="comment">//得到一个监听描述符</span></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//与本地进行绑定</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);                          <span class="comment">//设置一次性最大监听数128</span></span><br><span class="line">    clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">    cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clit_addr,&amp;clit_addr_len);   <span class="comment">//监听连接客户端，连接成功得到一个它们之间通信的描述符</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印建立连接的客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip:%s port:%d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),</span><br><span class="line">           ntohs(clit_addr.sin_port));    <span class="comment">//打印客户端的地址结构信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//将客户端发来的信息存到buf</span></span><br><span class="line">        write(STDOUT_FILENO,buf,ret);      <span class="comment">//打印在屏蔽上</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ret; i++)&#123;          <span class="comment">//将得到的字母转为大写</span></span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd,buf,ret);                <span class="comment">//发送给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);                            <span class="comment">//关闭监听描述符</span></span><br><span class="line">    close(cfd);                            <span class="comment">//关闭通信描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527                 <span class="comment">//定义一个要连接的服务端的端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;         <span class="comment">//打印错误信息</span></span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> cfd;</span><br><span class="line">        <span class="type">int</span> conter = <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//服务器地址结构</span></span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);      <span class="comment">//要连接服务端的端口</span></span><br><span class="line">        inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;serv_addr.sin_addr.s_addr);   <span class="comment">//要连接服务端的ip地址</span></span><br><span class="line">        cfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);        <span class="comment">//得到一个通信描述符</span></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = connect(cfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//连接服务端</span></span><br><span class="line">        <span class="keyword">while</span>(--conter)&#123;</span><br><span class="line">                write(cfd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);           <span class="comment">//向服务端发送信息</span></span><br><span class="line">                ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//读取服务端发来的信息，存到buf</span></span><br><span class="line">                write(STDOUT_FILENO,buf,ret);     <span class="comment">//将buf的信息打印到终端屏幕</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);              <span class="comment">//关闭通信描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-三次握手和四次挥手"><a href="#2-3-三次握手和四次挥手" class="headerlink" title="2.3 三次握手和四次挥手"></a>2.3 三次握手和四次挥手</h2><p>1.三次握手</p>
<ul>
<li><p>主动发起连接请求端：发送SYN标志位，请求建立连接。携带序号号、数据字节数(0)、滑动窗口大小win。</p>
</li>
<li><p>被动接受连接请求端：发送ACK(应答)标志位，同时携带SYN请求标志位。携带序号、确认序号、数据字节数(0)、滑动窗口大小win。</p>
</li>
<li><p>主动发起连接请求端：发送ACK标志位，应答服务器连接请求，携带确认序号。</p>
</li>
</ul>
<p>2.四次挥手</p>
<ul>
<li><p>主动关闭连接请求端：发送FIN标志位</p>
</li>
<li><p>被动关闭连接请求端：应答ACK标志位  —&gt;半关闭完成</p>
</li>
<li><p>被动关闭连接请求端：发送FIN标志位</p>
</li>
<li><p>主动关闭连接请求端：应答ACK标志位  —&gt;连接全部关闭</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_3.png"></p>
<p>3.滑动窗口：发送给连接的对端，本端的缓冲区大小(实时)，保证数据不会丢失。</p>
<p>4.read函数的返回值：</p>
<ul>
<li><p>大于0：实际读到的字节数</p>
</li>
<li><p>等于0：已经读到结尾(对端已经关闭)</p>
</li>
<li><p>-1：应进一步判断errno的值</p>
</li>
<li><p>errno&#x3D;EAGAIM or EWOULDBLOCK：设置了非阻塞方式读，但没有数据到</p>
</li>
<li><p>errno&#x3D;EINTR：慢速系统调用被中断</p>
</li>
<li><p>errno&#x3D;”其他情况”：异常</p>
</li>
</ul>
<h2 id="2-3-多进程多线程的并发服务器"><a href="#2-3-多进程多线程的并发服务器" class="headerlink" title="2.3 多进程多线程的并发服务器"></a>2.3 多进程多线程的并发服务器</h2><p>案例：多进程并发服务器实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,WNOHANG)&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);      <span class="comment">//得到一个监听的描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span>                  <span class="comment">//存服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));            <span class="comment">//将地址结构清0</span></span><br><span class="line">        srv_addr.sin_family = AF_INET;</span><br><span class="line">        srv_addr.sin_port = htons(<span class="number">9527</span>);              <span class="comment">//定义端口</span></span><br><span class="line">        srv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//使用本地ip地址</span></span><br><span class="line">        Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));    <span class="comment">//绑定</span></span><br><span class="line">        Listen(lfd,<span class="number">128</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clit_addr</span>;</span>              <span class="comment">//存放连接客户端信息的结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> clit_len;</span><br><span class="line">        clit_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">        <span class="type">pid_t</span> pid;        <span class="comment">//进程id</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> cfd;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                cfd = Accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clit_addr,&amp;clit_len);   <span class="comment">//监听连接</span></span><br><span class="line">                pid = fork();        <span class="comment">//建立连接成功才创建子线程，这样父子进程使用的文件描述符底层是同一套</span></span><br><span class="line">                <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;     <span class="comment">//子线程负责通信</span></span><br><span class="line">                        close(lfd);   <span class="comment">//父进程集合子进程都有lfd和cfd，在子进程中，lfd没有什么作用，可以直接关闭，因为子进程只完成任务，不需要监听连接</span></span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//跳出外面做，也可以全部写在这里面    </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                <span class="comment">//父进程负责回收线程</span></span><br><span class="line">                        close(cfd);   <span class="comment">//在父进程中，父进程负责监听连接客户端，所以通信描述符cfd在父进程中没有用</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                        act.sa_handler = catch_child;    <span class="comment">//捕抓函数</span></span><br><span class="line">                        sigemptyset(&amp;act.sa_mask);       <span class="comment">//将阻塞信号集置为0</span></span><br><span class="line">                        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">                        <span class="type">int</span> ret = sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);   <span class="comment">//当子进程状态发送变化，就触发捕捉函数</span></span><br><span class="line">                        <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">                                perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;     <span class="comment">//下面是子进程负责通信</span></span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                        <span class="type">int</span> ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//读取客户端发来的信息</span></span><br><span class="line">                        <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;    <span class="comment">//说明客户端那边请求断开</span></span><br><span class="line">                                close(cfd);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ret;i++)&#123;</span><br><span class="line">                                buf[i]=<span class="built_in">toupper</span>(buf[i]);     <span class="comment">//小写转大写</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        write(cfd,buf,ret);                 <span class="comment">//将转换好的发送给客户端</span></span><br><span class="line">                        write(STDOUT_FILENO,buf,ret);       <span class="comment">//将转换好的发送到屏幕</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4多线程并发服务器实现"><a href="#2-4多线程并发服务器实现" class="headerlink" title="2.4多线程并发服务器实现"></a>2.4多线程并发服务器实现</h2><p>案例：多线程并发服务器实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span>&#123;</span>     <span class="comment">//定义一个结构体，作为参数传给回调函数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">do_work</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n,i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> =</span> (<span class="keyword">struct</span> s_info*)arg;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">char</span> clie_ip[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                n = read(ts-&gt;connfd,buf,<span class="number">1024</span>);    <span class="comment">//读客户端发送来的信息存到buf</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;the client %d closed ....\n&quot;</span>,ts-&gt;connfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="comment">//打印客户端的信息</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                        inet_ntop(AF_INET,&amp;(*ts).cliaddr.sin_addr.s_addr,clie_ip,<span class="keyword">sizeof</span>(clie_ip)),</span><br><span class="line">                        ntohs((*ts).cliaddr.sin_port));   <span class="comment">//打印客户端信息</span></span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);    <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,buf,n);  <span class="comment">//写到屏幕上</span></span><br><span class="line">                write(ts-&gt;connfd,buf,n);     <span class="comment">//写给客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(ts-&gt;connfd);    <span class="comment">//跳出循环，说明客户端端口了连接，关闭于客户端的通信描述符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;   <span class="comment">//函数返回，相当于子线程结束，这里等价与pthread_exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);       <span class="comment">//得到监听描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>                        <span class="comment">//存放服务端信息结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));                  <span class="comment">//对结构体清0</span></span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = htons(<span class="number">9527</span>);                              <span class="comment">//指定端口号</span></span><br><span class="line">        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);                 <span class="comment">//指定本地任意IP</span></span><br><span class="line">        Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));     <span class="comment">//绑定</span></span><br><span class="line">        Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept client connect ....\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>                 <span class="comment">//存放客户端信息结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span>                   <span class="comment">//定义一个结构体数组，用来存放每一个子线程信息</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">pthread_t</span> tid;     <span class="comment">//定义一个线程变量</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;cliaddr_len); <span class="comment">//阻塞监听客户端连接请求</span></span><br><span class="line">                ts[i].cliaddr = cliaddr;     <span class="comment">//将客户端结构体信息存放在管理结构体中</span></span><br><span class="line">                ts[i].connfd = connfd;       <span class="comment">//将与客户端通信描述符存放在管理结构体中</span></span><br><span class="line">                pthread_create(&amp;tid,<span class="literal">NULL</span>,do_work,(<span class="type">void</span> *)&amp;ts[i]);    <span class="comment">//创建线程，执行回调函数</span></span><br><span class="line">                pthread_detach(tid);        <span class="comment">//分离子线程，父线程不会阻塞在这里等待子线程结束，而是由内核释放子线程</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-TCP状态转换"><a href="#2-5-TCP状态转换" class="headerlink" title="2.5 TCP状态转换"></a>2.5 TCP状态转换</h2><p>1.查看网络状态</p>
<ul>
<li><p>netstat -apn</p>
</li>
<li><p>netstat -apn | grep client ———-&gt; 查看对应进程(client也可以写成对应端口号)</p>
</li>
</ul>
<p>2.TCP状态转换图</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_4.png"></p>
<ul>
<li><p>主动发送请求连接端：CLOSED —– 发送SYN —– SYN_SEND —– 接收ACK、SYN —– SYN_SEND —– 发送ACK —– ESTABLISHED(数据通信态)</p>
</li>
<li><p>主动关闭请求连接端：ESTABLISHED(数据通信态) —– 发送FIN —– FIN_WAIT_1 —– 接收ACK —– FIN_WAIT_2(半关闭) —– 接收对端发送FIN —– FIN_WAIT_2(半关闭) —– 回发ACK —– TIME_WAIT(只有主动关闭连接方，会经历该状态) —– 等2MSL时长(40秒) —–CLOSED</p>
</li>
<li><p>被动接收连接请求端：CLOSK —– LISTEN —– 接收SYN —– LISTEN —– 发送ACK、SYN(对方收到) —– SYN_RCVD —– 接收ACK —– ESTABLISHED(数据通信态)</p>
</li>
<li><p>被动关闭连接请求端：ESTABLISHED(数据通信态)—–接收FIN —– ESTABLISHED —– 发送ACK —– CLOSE_WAIT(说明主动连接端处于半关闭状态) —– 发送FIN —– LAST_ACK —– 接收ACK —– CLOSED</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_5.png" alt="1_5"></p>
<p>注意：如果是客户端先关闭，服务端后关闭，则客户端会TIME_WAIT，服务端不会，所以又可以马上对服务端进行开启；如果是服务端先关闭，客户端后关闭，则服务端会进入TIME_WAIT状态，此时还没有进入完全关闭状态，会占用端口40秒，所以你这段时间内又开服务端会失败，因为端口号还被占用着。</p>
<p>补：2 MSL时长：一定出现在主动关闭连接请求端(TIME_WAIT)；保证最后一个ACK能成功被对端接收(等待期间，对端没收到我发的ACK，对端会再次发送FIN请求)。</p>
<p>3.端口复用</p>
<blockquote>
<p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为TCP连接没有完全断开指的是connfd没有完全断开，而我们重新的是listenfd，虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p>
</blockquote>
<p>在server.c代码的socket()和bind()调用之间插入如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int opt = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br></pre></td></tr></table></figure>

<p>4.半关闭</p>
<p>通信双方中，只有一端关闭通信。———&gt; FIN_WAIT_2</p>
<p>close(fd);</p>
<p>shutdown(int fd,int how);</p>
<ul>
<li>参2：SHUT_RD(关读端)；SHUT_WR(关写端)；SHUT_RDWR(关读写端)；</li>
</ul>
<p>注意：shutdown在关闭多个文件描述符应用的文件时(dup2重定向，多个文件描述符指向一个文件)，采用全关闭方法(关闭一个相当于关闭了全部)；close只关闭一个文件描述符，其他指向该文件的文件描述符还可以使用</p>
<h1 id="3-多路IO转接服务器"><a href="#3-多路IO转接服务器" class="headerlink" title="3. 多路IO转接服务器"></a>3. 多路IO转接服务器</h1><blockquote>
<p>多路IO转接服务器也叫多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接取而代之由内核应用程序监视文件。主要使用的方法有三种：select、epoll、poll。</p>
<p>服务端accept客户端的三种方式：阻塞、非阻塞忙轮询、响应式(多路IO转接)</p>
</blockquote>
<h2 id="3-1-select多路IO转接"><a href="#3-1-select多路IO转接" class="headerlink" title="3.1 select多路IO转接"></a>3.1 select多路IO转接</h2><p>原理：借助内核，select来监听客户端连接、数据通信事件。</p>
<p>1.清空一个文件描述符集合</p>
<ul>
<li><code>void FD_ZERO(fd_set *set);</code><ul>
<li>使用：fd_set rset;  FD_ZERO(&amp;rset);</li>
</ul>
</li>
</ul>
<p>2.将待监听的文件描述符，添加到监听集合中</p>
<ul>
<li><code>void FD_SET(int fd, fd_set *set); </code><ul>
<li>使用：FD_SET(3,&amp;rset);   FD_SET(5,&amp;rset);  FD_SET(6,&amp;rset);</li>
</ul>
</li>
</ul>
<p>3.将一个文件描述符从监听集合中移除</p>
<ul>
<li><code>void FD_CLR(int fd, fd_set *set);</code> <ul>
<li>使用：FD_CLR(4, &amp;rset);</li>
</ul>
</li>
</ul>
<p>4.判断一个文件描述符是否在监听集合中</p>
<ul>
<li><p><code>int FD_ISSET(int fd, fd_set *set); </code></p>
<ul>
<li><p>使用：FD_ISSET(4, &amp;rset);</p>
</li>
<li><p>+返回值：在(1)；不在(0)；</p>
</li>
</ul>
</li>
</ul>
<p>5.select监听</p>
<ul>
<li><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p>
<ul>
<li><p>参1：监听的所有文件描述符中，最大文件描述符+1；</p>
</li>
<li><p>参2：读文件描述符监听集合(传入传出参数)；</p>
</li>
<li><p>参3：写文件描述符监听集合(传入传出参数)； —&gt;不用就NULL</p>
</li>
<li><p>参4：异常文件描述符监听集合(传入传出参数)； —&gt;不用就NULL</p>
</li>
<li><p>参5：大于0(设置监听超时时长)；NULL(阻塞监听)；0(非阻塞监听，轮询)；</p>
</li>
<li><p>返回值：</p>
<ul>
<li><p>大于0：所有监听集合(3个)中，即读集合、写集合、异常集合，满足对应事件的总数</p>
</li>
<li><p>等于0：没有满足监听条件的文件描述符</p>
</li>
<li><p>等于-1：errno</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>6.select优缺点：</p>
<ul>
<li><p>缺点：(a)监听上限受文件描述符限制，最大1024；(b)检测满足条件的fd，只有自己添加业务逻辑提高效率，提高了编码难度</p>
</li>
<li><p>优点：跨平台。Windows、linux、macOS、Unix、类Unix、mips</p>
</li>
</ul>
<p>案例：使用select完成服务端的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);           <span class="comment">//得到监听连接的文件描述符</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));  <span class="comment">//实现端口复用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                           <span class="comment">//定义一个存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));                    <span class="comment">//将该结构体清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体的信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);        <span class="comment">//使用本地ip</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);                     <span class="comment">//端口使用9527</span></span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//服务端绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    fd_set rset,allset;                     <span class="comment">//定义读集合，备份集合allset</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i,j,n;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span>          <span class="comment">//定义一个存放客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> maxfd = listenfd;                  <span class="comment">//将最大fd定义伪监听的fd(刚开始)</span></span><br><span class="line">    FD_ZERO(&amp;allset);                      <span class="comment">//清空监听集合</span></span><br><span class="line">    FD_SET(listenfd,&amp;allset);              <span class="comment">//将监听fd添加到监听集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rset = allset;                 <span class="comment">//备份需要监听的fd集合</span></span><br><span class="line">        <span class="comment">//使用select监听，得到的传出rset集合里面都是就绪的文件描述符(需要处理的)，得到的ret是该集合的个数(满足处理的个数)</span></span><br><span class="line">        ret = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(listenfd,&amp;rset))&#123;      <span class="comment">//判断listenfd监听描述符是否满足监听的读事件</span></span><br><span class="line">            <span class="comment">//如果满足，说明有客户端发送来了请求连接</span></span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,&amp;clie_addr_len);  <span class="comment">//建立连接，不会阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建连接成功connfd = %d\n&quot;</span>,connfd);</span><br><span class="line">            FD_SET(connfd,&amp;allset);           <span class="comment">//将新产生的通信文件描述符fd添加到监听集合中(下一论监听)</span></span><br><span class="line">            <span class="keyword">if</span>(maxfd&lt;connfd)&#123;                 <span class="comment">//修改最大文件描述符</span></span><br><span class="line">                maxfd = connfd;           </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">1</span>)&#123;    <span class="comment">//说明select只返回一个，并且是listenfd，后续执行无须执行</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=listenfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123;         <span class="comment">//处理满足读事件的通信文件描述符</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;              <span class="comment">//找到满足读事件的那个通信文件描述符</span></span><br><span class="line">                n = read(i,buf,<span class="keyword">sizeof</span>(buf));    <span class="comment">//接收它发来的数据</span></span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;                       <span class="comment">//检测到客户端是否已经关闭连接</span></span><br><span class="line">                    close(i);               </span><br><span class="line">                    FD_CLR(i,&amp;allset);         <span class="comment">//将关闭的fd移除监听集合</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read error&quot;</span>);      <span class="comment">//处于异常</span></span><br><span class="line">                &#125;       </span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    buf[j] = <span class="built_in">toupper</span>(buf[j]);  <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;       </span><br><span class="line">                write(i,buf,n);                <span class="comment">//通过通信描述符，发送处理好的信息给客户端</span></span><br><span class="line">                write(STDOUT_FILENO,buf,n);    <span class="comment">//将处理的信息打印到终端</span></span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;       </span><br><span class="line">    close(listenfd);         <span class="comment">//关闭监听描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-poll多路IO转接"><a href="#3-2-poll多路IO转接" class="headerlink" title="3.2 poll多路IO转接"></a>3.2 poll多路IO转接</h2><p>1.poll监听函数</p>
<p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></p>
<ul>
<li><p>参1：监听的文件描述符(数组)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> fd;         <span class="comment">//待监听的文件描述</span></span><br><span class="line">	<span class="type">short</span> events;   <span class="comment">//监听对应的事件(POLLIN、POLLOUT、POLLERR)</span></span><br><span class="line">	<span class="type">short</span> revnets;  <span class="comment">//传入时给0，则返回满足对应事件POLLIN、//POLLOUT、POLLERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参2：监听结构体数组的实际有效监听个数(刚开始为1，只有监听描述符)</p>
</li>
<li><p>参3：大于0(超时时长，单位：毫秒)；等于-1(阻塞等待)；等于0(不阻塞)。</p>
</li>
<li><p>返回值：返回满足对应监听事件的文件描述符总个数</p>
</li>
</ul>
<p>2.poll的优缺点</p>
<ul>
<li><p>优点：自带数组结构，可以将监听事件集合和返回事件集合分离；拓展监听上限；可以突破1024。</p>
</li>
<li><p>缺点：不能跨平台，只能 inux系统；无法直接定位满足监听事件的文件描述符，编码难度较大。</p>
</li>
</ul>
<p>3.突破1024文件描述符限制(对select不管用)</p>
<ul>
<li><p>cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max  ——-&gt;当前计算机所能打开的最大文件个数，受硬件影响</p>
</li>
<li><p>ulimit -a   ——–&gt;查看当前用户下的进程默认打开文件描述符个数(不改为1024)</p>
</li>
</ul>
<p>修改：打开vim &#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<p>写入： </p>
<ul>
<li><em>soft nofile 65536  ———-&gt;设置默认值，可以直接借助命令修改</em></li>
<li>hard nofile 100000 ———–&gt;命令修改上限</li>
</ul>
<p>修改后需要注销用户，使其生效，相当于重新启动</p>
<p>案例：使用poll实现多路IO转接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);         <span class="comment">//得到监听描述符</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                  <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));           <span class="comment">//清0</span></span><br><span class="line">    <span class="comment">//初始化服务端的结构体信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//服务端绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[1024];</span>    <span class="comment">//定义一个文件描述符的结构体(还包含其他内容)</span></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;       <span class="comment">//要监听的第一个文件描述符存入client[0]位置</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;     <span class="comment">//监听listenfd文件描述符的读事件</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1024</span>;i++)&#123;    <span class="comment">//因为listenfd文件描述符已经占了0位置，所以从1位置开始</span></span><br><span class="line">        client[i].fd = <span class="number">-1</span>;     <span class="comment">//初始化文件描述符结构体数组，fd=-1意味着该位置未被占用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">0</span>;        <span class="comment">//初始化client[]数组有效元素中最大元素下标(刚开始只有listenfd文件描述符结构体)</span></span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>  <span class="comment">//存放客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line">    <span class="type">char</span> client_ip[<span class="number">16</span>];    <span class="comment">//客户端的ip地址(一般在要打印客户端信息时，才会用到)</span></span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        nready = poll(client,maxi+<span class="number">1</span>,<span class="number">-1</span>);   <span class="comment">//监听是否有客户端连接请求。结构体数组；有效文件描述符个数；阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)&#123;    <span class="comment">//为真，说明listenfd有读事件就绪(客户端有连接请求)</span></span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;clilen);  <span class="comment">//接收客户端请求，不会阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                   inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,client_ip,<span class="keyword">sizeof</span>(client_ip)),</span><br><span class="line">                   ntohs(cliaddr.sin_port));</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(client[i].fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    client[i].fd = connfd;  <span class="comment">//找到client[]中空闲的位置，存放通信描述符connfd</span></span><br><span class="line">                    <span class="keyword">break</span>;    <span class="comment">//找到后直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1024</span>)&#123;      <span class="comment">//检测client是否满了</span></span><br><span class="line">                perror(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            client[i].events = POLLIN;    <span class="comment">//将刚刚得到的通信文件描述符设为检测读事件</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;maxi)&#123;</span><br><span class="line">                maxi = i;   <span class="comment">//设置client文件描述符结构体数组的最大有效下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--nready&lt;=<span class="number">0</span>)&#123; <span class="comment">//当只有一个就绪事件时，这个事件必为监听文件描述符的，所以就没有通信描述符的就绪事件，就不用执行下面，继续回到poll</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//开始通信文件描述符</span></span><br><span class="line">       <span class="type">int</span> sockfd;</span><br><span class="line">       <span class="type">int</span> i,j,n;</span><br><span class="line">       <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxi;i++)&#123; <span class="comment">//前面的if没有满足，说明有通信文件描述符满足读事件就绪，检测client[]，看是哪个connfd就绪</span></span><br><span class="line">           <span class="keyword">if</span>((sockfd = client[i].fd)&lt;<span class="number">0</span>)&#123;  <span class="comment">//从通信文件描述符第一个找到最后，如果是&lt;0,说明对应通信描述符没有收到客户端的信息，</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(client[i].revents &amp; POLLIN)&#123;</span><br><span class="line">               <span class="keyword">if</span>((n=read(sockfd,buf,<span class="number">1024</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(errno==ECONNRESET)&#123;   <span class="comment">//收到RST标志</span></span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>,i);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;   <span class="comment">//还有其他情况的错误，这里就统一这种了，没有一一列出来</span></span><br><span class="line">                       perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   close(sockfd);</span><br><span class="line">                   client[i].fd = <span class="number">-1</span>;  <span class="comment">//poll中不监控该文件描述符，直接置为-1即可，不用像select中那样移除</span></span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>,i);  <span class="comment">//客户端断开连接</span></span><br><span class="line">                   close(sockfd);</span><br><span class="line">                   client[i].fd = <span class="number">-1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                       buf[j] = <span class="built_in">toupper</span>(buf[j]);   <span class="comment">//小写转大写</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   write(sockfd,buf,n);</span><br><span class="line">                   write(STDOUT_FILENO,buf,n);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(--nready&lt;=<span class="number">0</span>)&#123;   <span class="comment">//每次执行完通信描述符，都--了，当为0的时候，说明就没有了，直接跳出循环，不用再找了</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-epoll多路IO转接"><a href="#3-3-epoll多路IO转接" class="headerlink" title="3.3 epoll多路IO转接"></a>3.3 epoll多路IO转接</h2><p>1.<code>int epoll_create(int size);</code></p>
<ul>
<li><p>参数：创建的红黑树的监听节点数量。(仅供内核参考)</p>
</li>
<li><p>返回值：成功(指向新创建的红黑树的根节点的fd)；失败(-1,errno)</p>
</li>
</ul>
<p>2.<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p>
<ul>
<li><p>参1：epoll_create函数的返回值</p>
</li>
<li><p>参2：对该监听红黑树所做的操作</p>
<ul>
<li>EPOLL_CTL_ADD：添加fd到监听红黑树</li>
<li>EPOLL_CTL_MOD：修改fd在监听红黑树上的监听事件</li>
<li>EPOLL_CTL_DEL：将一个fd从监听红黑树上摘下(取消监听)</li>
</ul>
</li>
<li><p>参3：待监听的fd</p>
</li>
<li><p>参4：本质是struct epoll_event结构体地址。结构体内有events包括EPOLLIN、EPOLLOUT、EPOLLERR；有data，它是共用体，包括fd，(void *)ptr等。</p>
</li>
</ul>
<p>3.<code>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</code></p>
<ul>
<li><p>参1：epoll_create函数的返回值</p>
</li>
<li><p>参2：传出参数，是数组，满足监听条件的哪些fd结构体</p>
</li>
<li><p>参3：数组元素的总个数</p>
</li>
<li><p>参4：等于-1(阻塞)；等于0(不阻塞)；大于0：超时时间(毫秒)</p>
</li>
<li><p>返回值：大于0(满足监听的总个数，可以用作循环上限)；等于0(没有fd满足监听事件)；等于-1(失败，errno)；</p>
</li>
</ul>
<p>案例：使用epoll实现多路IO转接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);           <span class="comment">//得到监听描述符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listenfd = %d\n&quot;</span>,listenfd);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));      <span class="comment">//端口复用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                      <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));               <span class="comment">//清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));     <span class="comment">//绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    <span class="type">int</span> efd = epoll_create(<span class="number">39</span>);   <span class="comment">//创建epoll模型，efd指向红黑树的根节点。参数为设定又几个红黑树(大于0即可)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;efd = %d\n&quot;</span>,efd);</span><br><span class="line">    <span class="keyword">if</span>(efd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>,<span class="title">ep</span>[1024];</span>    <span class="comment">//tep为epoll_ctl的参数，ep[]为epoll_wait的参数</span></span><br><span class="line">    tep.events = EPOLLIN;         <span class="comment">//读监听事件</span></span><br><span class="line">    tep.data.fd = listenfd; <span class="comment">//指定了listenfd的监听事件为读</span></span><br><span class="line">    <span class="type">int</span> res = epoll_ctl(efd,EPOLL_CTL_ADD,listenfd,&amp;tep);   <span class="comment">//epoll_create返回值；是添加(选项)；添加的描述符；添加的ifd所对应的事件(结构体类型);</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>  <span class="comment">//装客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">//epoll为server阻塞监听事件，ep为struct epoll_event类型数组(传出参数，返回满足监听的那些描述符)；参数3为数组容量；-1表示永久阻塞</span></span><br><span class="line">        <span class="type">int</span> nready = epoll_wait(efd,ep,<span class="number">1024</span>,<span class="number">-1</span>);  <span class="comment">//返回的是所有就绪的描述符的个数，与ep数组里面的个数一样</span></span><br><span class="line">        <span class="keyword">if</span>(nready == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ep[i].data.fd == listenfd)&#123;  <span class="comment">//如果成立，说明是监听事件</span></span><br><span class="line">                clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">char</span> client_ip[<span class="number">16</span>];</span><br><span class="line">                <span class="type">int</span> connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;clilen);  <span class="comment">//与客户端建立连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,client_ip,<span class="keyword">sizeof</span>(client_ip)),ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cfd %d----client %d\n&quot;</span>,connfd,++num);</span><br><span class="line">                tep.events = EPOLLIN;      <span class="comment">//往红黑树上添加新的结点</span></span><br><span class="line">                tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd,EPOLL_CTL_ADD,connfd,&amp;tep);  <span class="comment">//将新产生的通信描述符加入到红黑树</span></span><br><span class="line">                <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl_error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果不是监听描述符就绪，就是通信描述符</span></span><br><span class="line">                <span class="type">int</span> sockfd = ep[i].data.fd;</span><br><span class="line">                <span class="type">int</span> n = read(sockfd,buf,<span class="number">1024</span>);     <span class="comment">//读取从客户端发来的信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;         <span class="comment">//客户端请求断开</span></span><br><span class="line">                    res = epoll_ctl(efd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);  <span class="comment">//将该文件描述符从红黑树摘除</span></span><br><span class="line">                    <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>,sockfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;        <span class="comment">//出现异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read n&lt;0 error:&quot;</span>);</span><br><span class="line">                    res = epoll_ctl(efd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);  <span class="comment">//摘除节点</span></span><br><span class="line">                    close(sockfd);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> j;</span><br><span class="line">                    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);    <span class="comment">//转大写</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    write(STDOUT_FILENO,buf,n);    <span class="comment">//将处理的信息打印到终端</span></span><br><span class="line">                    write(sockfd,buf,n);           <span class="comment">//将处理的信息发送给客户端</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);         <span class="comment">//关闭监听描述符</span></span><br><span class="line">    close(efd);              <span class="comment">//关闭红黑树的根结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.epoll事件模式</p>
<p>ET模式：边沿触发，缓冲区剩余未读尽的数据不会导致epoll_wait返回。新的事件满足，才会触发。</p>
<p>FT模式：水平触发(默认模式)，缓冲区剩余未读尽的数据会导致epoll_wait返回。</p>
<p>注意：像select和epoll它们监听的都是文件描述符，不是套接字，所以可以结合管道来使用。</p>
<p>比较：FT是缺省的工作方式，并且同时支持阻塞和非阻塞；ET是高速工作方式，只支持非阻塞(所以ET常与非阻塞一起用)–&gt;非阻塞通常搭配忙轮询。</p>
<p>结论：epoll的ET模式，高效模式，但是只支持非阻塞模式(no black)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;event);</span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(cfd,F_SETFL,flg);</span><br></pre></td></tr></table></figure>

<p>5.epoll的优缺点</p>
<ul>
<li><p>epoll优点：高效，突破1024文件描述符</p>
</li>
<li><p>epoll缺点：不能跨平台，只能linux系统</p>
</li>
</ul>
<p>案例：通过epoll和管道测试ET和FT模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> efd,i;</span><br><span class="line">        <span class="type">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;       <span class="comment">//定义一个进程变量</span></span><br><span class="line">        <span class="type">char</span> buf[MAXLINE],ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pipe(pfd);       <span class="comment">//创建一个管道</span></span><br><span class="line">        pid = fork();    <span class="comment">//创建一个子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;                             <span class="comment">//子进程负责写端</span></span><br><span class="line">                close(pfd[<span class="number">0</span>]);                  <span class="comment">//关闭读端</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXLINE/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                                buf[i] = ch;</span><br><span class="line">                        &#125;                      <span class="comment">//这时为aaaaa</span></span><br><span class="line">                        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">//为aaaa\n</span></span><br><span class="line">                        ch++;                  <span class="comment">//ch变为b</span></span><br><span class="line">                        <span class="keyword">for</span>(;i&lt;MAXLINE;i++)&#123;   <span class="comment">//i从5开始继续循环</span></span><br><span class="line">                                buf[i] = ch;</span><br><span class="line">                        &#125;                     <span class="comment">//这时为aaaa\nbbbbb</span></span><br><span class="line">                        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">//为aaaa\nbbbb\n</span></span><br><span class="line">                        ch++;                    <span class="comment">//ch变为c</span></span><br><span class="line">                        write(pfd[<span class="number">1</span>],buf,<span class="keyword">sizeof</span>(buf));     <span class="comment">//将buf里面的内容写到管道的写端</span></span><br><span class="line">                        sleep(<span class="number">5</span>);         <span class="comment">//睡眠5秒后，继续上面循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                close(pfd[<span class="number">1</span>]);               <span class="comment">//执行完后，关闭写端</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;         <span class="comment">//父进程负责读</span></span><br><span class="line">                <span class="keyword">struct</span> epoll_event event;              <span class="comment">//定义一个epoll_event的结构体</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span>       <span class="comment">//定义一个epoll_event的结构体数组</span></span><br><span class="line">                <span class="type">int</span> res ,len;</span><br><span class="line">                close(pfd[<span class="number">1</span>]);                        <span class="comment">//关闭写端</span></span><br><span class="line">                efd = epoll_create(<span class="number">10</span>);               <span class="comment">//efd也是文件描述符，创建一个容纳10个节点的红黑树</span></span><br><span class="line">                <span class="comment">//event.events = EPOLLIN | EPOLLET;   //ET边沿触发：未读完的数据不会再次提醒，除非有新数据写入</span></span><br><span class="line">                event.events = EPOLLIN;               <span class="comment">//水平触发(默认)。这种模式下，没有读完的数据，马上又会进行读</span></span><br><span class="line">                event.data.fd = pfd[<span class="number">0</span>];              <span class="comment">//将fd定义为管道的读端</span></span><br><span class="line">                epoll_ctl(efd,EPOLL_CTL_ADD,pfd[<span class="number">0</span>],&amp;event);    <span class="comment">//将管道的读端挂到红黑树上</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        res = epoll_wait(efd,resevent,<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>,res);              <span class="comment">//打印满足就绪的文件描述符结构</span></span><br><span class="line">                        <span class="keyword">if</span>(resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>])&#123;        <span class="comment">//如果是读端满足就绪</span></span><br><span class="line">                                len = read(pfd[<span class="number">0</span>],buf,MAXLINE/<span class="number">2</span>);     <span class="comment">//从管道的读端读一半数据到buf,还有一半数据留在了管道</span></span><br><span class="line">                                write(STDOUT_FILENO,buf,len);       <span class="comment">//将读到的内容写到屏幕上</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                close(pfd[<span class="number">0</span>]);   <span class="comment">//关闭管道的读端</span></span><br><span class="line">                close(efd);      <span class="comment">//关闭红黑树的根节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-其它通信方式"><a href="#4-其它通信方式" class="headerlink" title="4. 其它通信方式"></a>4. 其它通信方式</h1><h2 id="4-1-TCP通信和UDP通信各自的优缺点"><a href="#4-1-TCP通信和UDP通信各自的优缺点" class="headerlink" title="4.1 TCP通信和UDP通信各自的优缺点"></a>4.1 TCP通信和UDP通信各自的优缺点</h2><p>TCP：面向连接的，可靠数据报传输。对于不稳定的网络层，采取完全弥补的通信方式。丢包重传。</p>
<ul>
<li><p>优点：数据流量稳定、传输速度稳定、顺序稳定</p>
</li>
<li><p>缺点：传输速度慢、效率低、资源开销大</p>
</li>
</ul>
<p>使用场景：数据的完整型要求较高，不追求效率。(大数据传输、文件传输)</p>
<p>2.UDP：无连接的，不可靠的数据报传递。对于不稳定的网络层，采取完全不弥补的通信方式。默认还原网络状况。</p>
<ul>
<li><p>优点：传输速度快、效率高、资源开销小</p>
</li>
<li><p>缺点：数据流量不稳定、传输速度不稳定、顺序不稳定</p>
</li>
</ul>
<p>使用场景：对时效性要求较高的场合，稳定性其次。(游戏、视频会议、视频电话)—–&gt;腾讯、华为、阿里：应用层数据校验协议，弥补UDP的不足。</p>
<h2 id="4-2-UDP通信"><a href="#4-2-UDP通信" class="headerlink" title="4.2 UDP通信"></a>4.2 UDP通信</h2><p>1.UDP中负责读数据函数</p>
<p><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code></p>
<ul>
<li><p>参1：套接字</p>
</li>
<li><p>参2：缓冲区地址</p>
</li>
<li><p>参3：缓冲区大小</p>
</li>
<li><p>参4：0</p>
</li>
<li><p>参5：传出参数，对端的地址结构</p>
</li>
<li><p>参6：传入传出</p>
</li>
<li><p>返回值：成功(接收数据字节数)；失败：-1(errno),0(对端关闭)</p>
</li>
</ul>
<p>2.UDP中负责写数据函数</p>
<p><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code></p>
<ul>
<li><p>参1：套接字</p>
</li>
<li><p>参2：存储数据的缓冲区</p>
</li>
<li><p>参3：数据长度</p>
</li>
<li><p>参4：0</p>
</li>
<li><p>参5：传入参数，目标地址结构</p>
</li>
<li><p>参6：地址结构长度</p>
</li>
<li><p>返回值：成功(写出数据字节数)；失败：-1(errno)</p>
</li>
</ul>
<p>UDP服务端实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);      <span class="comment">//第2个参数表示是报式协议</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//存放服务端数据的结点</span></span><br><span class="line">        bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));        <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化服务端结构体</span></span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">        bind(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//绑定</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span>               <span class="comment">//存放客户端数据结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="type">char</span> str_ip[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections.....\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,&amp;clie_addr_len);   <span class="comment">//接收客户端传来的信息，得到客户端的地址结构信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at port %d\n&quot;</span>,</span><br><span class="line">                        inet_ntop(AF_INET,&amp;clie_addr.sin_addr.s_addr,str_ip,<span class="keyword">sizeof</span>(str_ip)),</span><br><span class="line">                        ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);      <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;</span><br><span class="line">                n = sendto(sockfd,buf,n,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,<span class="keyword">sizeof</span>(clie_addr));      <span class="comment">//向客户端发送数据</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);         <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP客户端实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);         <span class="comment">//第2个参数表示是报式协议</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>             <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));       <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化服务端信息</span></span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;servaddr.sin_addr);</span><br><span class="line">        servaddr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf,BUFSIZ,<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;      <span class="comment">//从键盘输入存到buf中</span></span><br><span class="line">                n = sendto(sockfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));   <span class="comment">//将buf里的信息发送给服务端，地址结构信息是服务端的</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">//接收服务端发来的信息，NULL：表示不关心对端信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,buf,n);          <span class="comment">//将服务端写来的信息(buf里面)打印到屏幕</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-本地套接字-domain"><a href="#4-3-本地套接字-domain" class="headerlink" title="4.3 本地套接字(domain)"></a>4.3 本地套接字(domain)</h2><p>本地套接字与网络套接字使用的区别：</p>
<ul>
<li><p>网络套接字中用的AF_INET；本地套接字是用AF_UNIX&#x2F;AF_LOCAL</p>
</li>
<li><p>网络套接字中的地址结构是sockaddr_in；本地套接字是用sockaddr_un</p>
</li>
<li><p>网络套接字中是绑定ip和端口，本地套接字是绑定socket文件即可(伪文件)，类似于管道(但不是)</p>
</li>
</ul>
<p>补：本地套接字只能用于本机的两个进程通信。稳定性强，双向全双工。</p>
<p>注意：bind()函数调用成功，会创建一个socket,因此为保证bind成功，通常我们在bind之前，可以使用unlink(“serv.socket”)；本地套接字中的客户端不能依赖隐式绑定，需要自己创建一个socke文件后绑定。</p>
<p>本地套接字的服务端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR <span class="string">&quot;serv.socket&quot;</span>       <span class="comment">//服务端用到的socetk文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> lfd = Socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建本地套接字的第一个参数是AF_UNIX；第二个参数是报式还是流式都可以，返回一个本地套接字</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span>            <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));      <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化本地套接字的服务端信息</span></span><br><span class="line">        servaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);     <span class="comment">//定义的文件名，相当于本地套接字的地址结构</span></span><br><span class="line">        <span class="type">int</span> len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">//结构体大小等于2(AF_UNIX的大小)+文件名大小</span></span><br><span class="line">        unlink(SERV_ADDR);      <span class="comment">//确保bind之前serv.sock文件(伪文件)不存在当前目录(执行过程序后，会在当前目录下创建该文件，用于传数据)，bind会创建该文件</span></span><br><span class="line">        Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,len);       <span class="comment">//参3不能是sizeof(servaddr)</span></span><br><span class="line">        Listen(lfd,<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept .....\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = Accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,(<span class="type">socklen_t</span> *)&amp;len);  <span class="comment">//套接字；客户端地址结构(传出)；传入传出</span></span><br><span class="line">                len -= offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path);     <span class="comment">//得到文件名大小(传出来的len-偏移位置(AF_UNIX)大小)</span></span><br><span class="line">                cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//确保打印时没有乱码出现</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>,cliaddr.sun_path);</span><br><span class="line">                <span class="keyword">while</span>((size = read(cfd,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        write(cfd,buf,size);</span><br><span class="line">                &#125;</span><br><span class="line">                close(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">        close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地套接字的客户端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR <span class="string">&quot;serv.socket&quot;</span>       <span class="comment">//服务端用到的socetk文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIE_ADDR <span class="string">&quot;clie.socket&quot;</span>       <span class="comment">//客户端用到的socket文件</span></span></span><br><span class="line"><span class="comment">//本地套接字通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> cfd = Socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建本地套接字的第一个参数是AF_UNIX；第二个参数是报式还是流式都可以，返回一个本地套接字</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span>       <span class="comment">//存放客户端信息的结构体</span></span><br><span class="line">        bzero(&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));   <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化客户端结构体信息</span></span><br><span class="line">        cliaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);     <span class="comment">//定义的文件名，相当于本地套接字的地址结构</span></span><br><span class="line">        <span class="type">int</span> len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);   <span class="comment">//结构体大小等于2(AF_UNIX的大小)+文件名大小</span></span><br><span class="line">        unlink(CLIE_ADDR);          <span class="comment">//确保bind之前clie.sock文件(伪文件)不存在，bind会创建该文件</span></span><br><span class="line">        Bind(cfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,len);       <span class="comment">//参3不能是sizeof(cliaddr)</span></span><br><span class="line">   		</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span>           <span class="comment">//存到服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);   <span class="comment">//这些是要连的服务端的信息</span></span><br><span class="line">        len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">//计算服务端地址结构的有效长度</span></span><br><span class="line">        Connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,len);     <span class="comment">//连接服务端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;            <span class="comment">//从输入端输入信息到buf</span></span><br><span class="line">                write(cfd,buf,<span class="built_in">strlen</span>(buf));              <span class="comment">//从buf将信息传给服务端</span></span><br><span class="line">                len = read(cfd,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从服务端得到的信息存在buf</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);            <span class="comment">//将buf里的信息写到屏幕</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>协议</tag>
        <tag>套接字</tag>
        <tag>多路io转接</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>select</tag>
        <tag>epoll</tag>
        <tag>poll</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
        <tag>多进程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>静态库与动态库</title>
    <url>/2024/07/06/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h1><blockquote>
<p>在linux中静态库由程序ar生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名如下：</p>
</blockquote>
<ul>
<li><p>在Linux中静态库以lib作为前缀，以.a作为后缀，中间是库的名字(自己指定即可)，即libxxx.a</p>
</li>
<li><p>在Windows中静态库一般以lib作为前缀，以lib作为后缀，中间是库的名字(自己指定即可)，即libxxx.lib</p>
</li>
</ul>
<h2 id="1-1生成静态库链接"><a href="#1-1生成静态库链接" class="headerlink" title="1.1生成静态库链接"></a>1.1生成静态库链接</h2><blockquote>
<p>生成静态库，需要先对源文件进行汇编操作(使用参数-c)得到二进制格式的目标文件(.o格式)。然后再通过ar工具将目标文件打包就可以得到静态库文件了(libxxx.a)。</p>
</blockquote>
<p>使用ar工具创建静态库的时候需要三个参数：</p>
<ul>
<li><p>参数c：创建一个库，不管库是否存在，都将创建。</p>
</li>
<li><p>参数s：创建目标文件索引，这在创建较大的库时能加快时间。</p>
</li>
<li><p>参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>对源文件进行汇编成二进制格式的目标文件(.o格式)：gcc -c add.c sub.c div.c mult.c</p>
</li>
<li><p>生成静态库(发送给对方时，需要发送静态库和头文件(有就发))：ar rcs libcalc.a *.o</p>
</li>
</ol>
<h2 id="1-2静态库的使用"><a href="#1-2静态库的使用" class="headerlink" title="1.2静态库的使用"></a>1.2静态库的使用</h2><p>参数-l：在程序编译的时候，指定使用的库(掐头去尾)</p>
<p>参数-L：指定编译的时候，搜索的库的路径———–&gt;空格空不空都可以</p>
<p>例子：假设文件夹里面有head.h、libcalc.a、main.c</p>
<p><code>gcc main.c -o calc -L ./ -lcalc</code></p>
<h1 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h1><blockquote>
<p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为共享库。</p>
</blockquote>
<ul>
<li><p>在Linux中动态库以lib作为前缀，以.so作为后缀，中间是库的名字(自己指定即可)，即libxxx.so</p>
</li>
<li><p>在Windows中动态库一般以lib作为前缀，以dll作为后缀，中间是库的名字(自己指定)，即libxxx.dll</p>
</li>
</ul>
<h2 id="2-1生成动态链接库"><a href="#2-1生成动态链接库" class="headerlink" title="2.1生成动态链接库"></a>2.1生成动态链接库</h2><p>生成动态链接库是直接使用gcc命令并且需要添加-fPIC(-fpic)以及-shread参数</p>
<ul>
<li><p>-fPIC或-fpic参数：是使得gcc生成的代码是与位置无关的，也就是使用相对位置。</p>
</li>
<li><p>-shared参数：是告诉编译器生成一个动态链接库</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>gcc -c -fpic add.c sub.c mult.c div.c   &#x2F;&#x2F;生成.o文件</p>
</li>
<li><p>gcc -shared *.o -o libcalc.so       &#x2F;&#x2F;生成动态库文件libcalc.so</p>
</li>
<li><p>将动态库文件libcalc.so(一般是一些函数实现，不包括主函数文件)和头文件head.h放在文件夹two发送给客户即可</p>
</li>
</ol>
<h2 id="2-2使用步骤"><a href="#2-2使用步骤" class="headerlink" title="2.2使用步骤"></a>2.2使用步骤</h2><p>生成可执行文件app</p>
<p><code>gcc main.c -L . -lcalc -o app</code></p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级数据库sqlite3</title>
    <url>/2024/07/01/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93sqlite3/</url>
    <content><![CDATA[<h1 id="1、安装sqlite环境"><a href="#1、安装sqlite环境" class="headerlink" title="1、安装sqlite环境"></a>1、安装sqlite环境</h1><p>进入sqlite官网：<a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/sqlite3/1.png"></p>
<h1 id="2、创建数据库"><a href="#2、创建数据库" class="headerlink" title="2、创建数据库"></a>2、创建数据库</h1><p>在linux系统又两种方式创建数据库，如下所示：</p>
<ul>
<li><p>shell终端：sqlite3 my.db</p>
</li>
<li><p>c文件里：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 *db;                             //是指向数据库文件的句柄指针(地址)</span><br><span class="line">sqlite3_open(“my.db”,&amp;db)                //成功返回SQLITE_OK</span><br></pre></td></tr></table></figure>

<h1 id="3、系统命令"><a href="#3、系统命令" class="headerlink" title="3、系统命令"></a>3、系统命令</h1><p>系统命令是非常主要的，通过这些系统目录可以很好的操作数据库sqlite。</p>
<ol>
<li><p>help：查看帮助信息</p>
</li>
<li><p>databases：查看数据库</p>
</li>
<li><p>tables：显示数据库中所有的表的表名</p>
</li>
<li><p>schema：查看表的结构</p>
</li>
<li><p>quit：退出数据库</p>
</li>
<li><p>exit：退出数据库</p>
</li>
</ol>
<h1 id="4、增删改查"><a href="#4、增删改查" class="headerlink" title="4、增删改查"></a>4、增删改查</h1><ol>
<li><p>创建一张表：create table 表名(字段名称1 字段类型, …);</p>
</li>
<li><p>删除一张表：drop table 表名;</p>
</li>
<li><p>向表中插入一条记录:insert into 表名 values(字段值1,字段值2,…);</p>
</li>
<li><p>查询记录：select * from 表名;</p>
</li>
<li><p>删除记录：delete from 表名 where 字段名称&#x3D;关键字;</p>
</li>
<li><p>更新记录：update 表名 set 字段名称1&#x3D;关键字 where 字段名称2&#x3D;关键字;</p>
</li>
</ol>
<h1 id="5、数据库表的维护"><a href="#5、数据库表的维护" class="headerlink" title="5、数据库表的维护"></a>5、数据库表的维护</h1><ol>
<li><p>数据库主键(设置的数据库将会是唯一存在的):PRIMARY KEY</p>
</li>
<li><p>自增字段(设置的字段值自动递增):AUTOINCREMENT</p>
</li>
</ol>
<ul>
<li>使用：关键字 AUTOINCREMENT —&gt; 只能用于整型(INTEGER)字段</li>
</ul>
<h1 id="6、API函数接口"><a href="#6、API函数接口" class="headerlink" title="6、API函数接口"></a>6、API函数接口</h1><ol>
<li><p>int sqlite2_open(const char *filename,sqlite3 **ppDb);</p>
<ul>
<li>功能：创建并打开一个数据库(存在就直接打开)</li>
<li>参数1：要打开的数据库名</li>
<li>参数2：操作数据库的二级指针</li>
<li>返回值：成功(SQLITE_OK)；失败(error_code)</li>
</ul>
</li>
<li><p>const char <em>sqlite3_errmsg(sqlite3</em> db);</p>
<ul>
<li>功能：获取错误信息描述</li>
</ul>
</li>
<li><p>int sqlite3_close(sqlite3* db);</p>
<ul>
<li>功能：关闭一个数据库</li>
</ul>
</li>
<li><p>int sqlite3_exec(sqlite3* db, const char* sql, int <em>callback(参数), void</em> arg, char **errmsg);</p>
<ul>
<li><p>功能：执行一条sql语句</p>
</li>
<li><p>1：数据库的句柄指针</p>
</li>
<li><p>参数2；将要被执行的sql语句(拼接)</p>
</li>
<li><p>参数3：回调函数，只有在查询的时候，才执行此函数</p>
</li>
<li><p>参数4：是回调函数参3的参数</p>
</li>
<li><p>参数5：存放错误信息的地址(传出参数)</p>
</li>
<li><p>返回值：成功(SQLITE_OK)；失败(errcode错误码)</p>
</li>
</ul>
</li>
<li><p>int (<em>callback)(void</em> arg,int ncolumn,char** f_value,char** f_name);</p>
<ul>
<li><p>功能：每找到一次记录自动执行一次回调函数，得到查询结果</p>
</li>
<li><p>参数1：是sqlite3_exec传递的参数为回调函数使用</p>
</li>
<li><p>参数2：记录中包含的字段的数目</p>
</li>
<li><p>参数3：包含每个字段值的指针数值</p>
</li>
<li><p>参数4：包含每个字段名称的指针数值</p>
</li>
<li><p>返回值：成功(0)；失败(非0)</p>
</li>
</ul>
</li>
</ol>
<p>注意：如果只是向看一下表，可以调用sqlite3_get_table()函数</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发网络编程libevent</title>
    <url>/2024/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Blibevent/</url>
    <content><![CDATA[<h1 id="1-libevent库介绍"><a href="#1-libevent库介绍" class="headerlink" title="1. libevent库介绍"></a>1. libevent库介绍</h1><h2 id="1-1-什么是libevent"><a href="#1-1-什么是libevent" class="headerlink" title="1.1 什么是libevent"></a>1.1 什么是libevent</h2><p>libevent也称为事件通知库，即所见皆事件，是一个用C语言实现的、基于事件驱动(event-driven)的轻量级高性能开源网络库，适用于Windows、Linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。libevent不一定是用到网络当中，本地的文件描述符都可以用。</p>
<h2 id="1-2-libevent特点"><a href="#1-2-libevent特点" class="headerlink" title="1.2 libevent特点"></a>1.2 libevent特点</h2><ul>
<li><p>事件驱动(event-driven)，高性能</p>
</li>
<li><p>轻量级，专注于网络，不如 NGINX 那么臃肿庞大</p>
</li>
<li><p>源代码相当精炼、易读</p>
</li>
<li><p>跨平台，支持 Windows、Linux、*BSD和Mac OS，但Windows支持不怎么好</p>
</li>
<li><p>支持多种I&#x2F;O多路复用技术，select、epoll、poll、dev&#x2F;poll、select、kqueue、evports等</p>
</li>
<li><p>支持I&#x2F;O，定时器和信号等事件</p>
</li>
<li><p>采用Reactor设计模式</p>
</li>
<li><p>支持HTTP(S)，DNS解析</p>
</li>
</ul>
<p>libevent是用于编写高速可移植非阻塞IO应用的库，其设计目标是：可移植性、高性能、便携和可扩展性</p>
<h1 id="2-libevent框架"><a href="#2-libevent框架" class="headerlink" title="2. libevent框架"></a>2. libevent框架</h1><h2 id="2-1-步骤流程"><a href="#2-1-步骤流程" class="headerlink" title="2.1 步骤流程"></a>2.1 步骤流程</h2><p>1.创建event_base</p>
<ul>
<li><p><code>struct event_base *event_base_new(void);</code></p>
</li>
<li><p><code>struct event_base *base = event_base_new();</code></p>
</li>
</ul>
<p>2.创建事件event</p>
<ul>
<li><p>常规事件event：<code>event_new();</code></p>
</li>
<li><p>bufferevent事件：<code>bufferevent_socket_new();</code></p>
</li>
</ul>
<p>3.将事件添加到base上</p>
<ul>
<li><code>int event_add(struct event *ev, const struct timeval *tv);</code></li>
</ul>
<p>4.循环监听事件满足</p>
<ul>
<li><code>int event_base_dispatch(struct event_base *base);</code></li>
</ul>
<p>5.释放event_base</p>
<ul>
<li><code>event_base_free(base);</code></li>
</ul>
<h2 id="2-2-event事件"><a href="#2-2-event事件" class="headerlink" title="2.2 event事件"></a>2.2 event事件</h2><p>1.<code>struct event *event_new(struct event_base *base, evutil_socket_t fd, short what, event_callback_fn cb, void *arg);</code></p>
<ul>
<li><p>参1：event_base_new()返回值</p>
</li>
<li><p>参2：绑定到event上的文件描述符，也是回调函数参数</p>
</li>
<li><p>参3：对应的事件(r,w,e)，也是回调函数参数</p>
<ul>
<li>EV_READ：一次读事件</li>
<li>EV_WRITE：一次写事件</li>
<li>EV_PERSIST： 持续触发，结合event_base_dispatch函数使用</li>
</ul>
</li>
<li><p>参4：一旦事件满足监听条件，就回调的函数</p>
<ul>
<li><code>typedef void(*event_callback_fn)(evutil_socket_t fd, short, void*);</code></li>
</ul>
</li>
<li><p>参5：回调函数的参数；</p>
<ul>
<li>返回值：成功创建的event；</li>
</ul>
</li>
</ul>
<p>2.添加事件到event_base</p>
<p><code>int event_add(struct event *ev, const struct timeval *tv);</code></p>
<ul>
<li><p>参1：event_new()的返回值</p>
</li>
<li><p>参2：NULL</p>
</li>
</ul>
<p>3.从event_base上摘下事件[了解即可]</p>
<p><code>int event_del(struct event *ev);</code></p>
<ul>
<li>参数：event_new()的返回值</li>
</ul>
<p>4.销毁事件</p>
<p><code>int event_free(struct event *ev);</code></p>
<ul>
<li>参数：event_new()的返回值</li>
</ul>
<p>注意：使用到libevent库的事件，编译时后面要加-levent</p>
<p>补：常规事件event的过程状态</p>
<ul>
<li><p>未决：有资格被处理，但还没有被处理(事件没有到来)</p>
</li>
<li><p>非未决：没有资格被处理</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/libevent/2_1.png"></p>
<p>案例：通过event事件对管道写内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="comment">//写管道</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面没有设置持续写的话，在这里加一个while(1)也可以</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello,world_%d\n&quot;</span>,num++);   <span class="comment">//将要写的内容存到buf</span></span><br><span class="line">        write(fd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);             <span class="comment">//向管道发送buf数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//由于读操作那边已经创建管道了，所以这边不用创建了，它们是用同一个管道</span></span><br><span class="line">        <span class="comment">//打开管道</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;myfifo&quot;</span>,O_WRONLY | O_NONBLOCK);    <span class="comment">//以只写方式和非阻塞方式打开管道</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个event_base ---&gt; 相当于底座</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = event_base_new();</span><br><span class="line">        <span class="comment">//创建event事件ev</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//ev = event_new(base,fd,EV_WRITE,write_cb,NULL);       //只写一次,如果没有持续触发，那么下面的event_base_dispatch没有用</span></span><br><span class="line">        ev = event_new(base,fd,EV_WRITE | EV_PERSIST,write_cb,<span class="literal">NULL</span>);  <span class="comment">// 持续写。参数：底座；需要监听的fd；对fd做什么样的监听(写和持续触发)；回调函数；回调函数的参数</span></span><br><span class="line">        <span class="comment">//添加事件</span></span><br><span class="line">        event_add(ev,<span class="literal">NULL</span>);        <span class="comment">//将事件添加到base(底座)上</span></span><br><span class="line">        <span class="comment">//事件循环</span></span><br><span class="line">        event_base_dispatch(base);  <span class="comment">//接下来由内核处理 --&gt;相当于while(1)&#123; epoll(); &#125;; ---&gt;事件满足，自动回调</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        event_free(ev);</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过event事件对管道读内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="comment">//读管道</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));    <span class="comment">//从管道将读到的内容存放到buf</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read event:%s\n&quot;</span>,(what &amp; EV_READ?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data len = %d, buf = %s\n&quot;</span>,len,buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        unlink(<span class="string">&quot;myfifo&quot;</span>);</span><br><span class="line">        <span class="comment">//创建命名管道----&gt;无血缘关系的进程间也可以通信</span></span><br><span class="line">        mkfifo(<span class="string">&quot;myfifo&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">        <span class="comment">//打开管道</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;myfifo&quot;</span>,O_RDONLY | O_NONBLOCK);    <span class="comment">//以只读方式和非阻塞方式打开管道</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个event_base ---&gt; 相当于底座</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = event_base_new();</span><br><span class="line">        <span class="comment">//创建事件</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        ev = event_new(base,fd,EV_READ | EV_PERSIST,read_cb,<span class="literal">NULL</span>);  <span class="comment">//底座；需要监听的fd；对fd做什么样的监听(读和持续触发)；回调函数；回调函数的参数</span></span><br><span class="line">        <span class="comment">//添加事件</span></span><br><span class="line">        event_add(ev,<span class="literal">NULL</span>);        <span class="comment">//将事件添加到base(底座)上</span></span><br><span class="line">        <span class="comment">//事件循环</span></span><br><span class="line">        event_base_dispatch(base); <span class="comment">//接下来由内核处理 --&gt;相当于while(1)&#123; epoll(); &#125;; ---&gt;事件满足，自动回调</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        event_free(ev);</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-bufferevent缓冲事件"><a href="#2-3-bufferevent缓冲事件" class="headerlink" title="2.3 bufferevent缓冲事件"></a>2.3 bufferevent缓冲事件</h2><p>原理：bufferevent有两个缓冲区，也是队列实现，读走就没了，先进先出</p>
<p>读过程：有数据—–&gt;读回调函数被调用—–&gt;使用bufferevent_read()—–&gt;有数据。</p>
<p>写过程：使用bufferevent_write()—–&gt;向写缓冲中写数据—–&gt;该缓冲区有数据就自动写出—–&gt;写完，回调函数被调用(鸡肋)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/libevent/2_2.png"></p>
<p>1.创建bufferevent事件</p>
<p><code>struct bufferevenet *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);</code></p>
<ul>
<li><p>参1：event_base</p>
</li>
<li><p>参2：封装到bufferevent内的fd</p>
</li>
<li><p>参3：BEV_OPT_CLOSE_ON_FREE—&gt;释放bufferevent时关闭底层传输端口，这将关闭底层套接字(网络套接字)，释放底层bufferevent等</p>
</li>
<li><p>返回值：成功创建的bufferevent事件对象</p>
</li>
</ul>
<p>2.销毁bufferevent</p>
<p><code>void bufferevent_socket_free(struct bufferevent *ev);</code></p>
<p>3.给bufferevent设置回调</p>
<ul>
<li>区别：event事件设置回调 event_new(fd,callback)，一个函数就可以，而bufferevent事件设置回调则麻烦一点</li>
</ul>
<p>bufferevent_socket_new(fd); bufferevent_setcb(callback);</p>
<p>4.<code>void bufferevent_setcb(struct bufferevent* bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg);</code></p>
<ul>
<li><p>参1：bufferevent_socket_new()返回值</p>
</li>
<li><p>参2：设置bufferevent读缓冲，对应回调read_cb{bufferevent_read()读数据}</p>
</li>
<li><p>参3：设置bufferevent写缓冲，对应回调write_cb{ }–&gt;给调用者，发送写成功通知，可以写NULL</p>
</li>
<li><p>参4：设置事件回调，也可以传NULL</p>
</li>
<li><p>参5：上述回调函数使用的参数</p>
</li>
</ul>
<p>5.启动、关闭bufferevent的缓冲区</p>
<p><code>void bufferevent_enbale(struct bufferevent *bufev, short events);</code></p>
<ul>
<li>events：EV_READ、EV_WRITE、EV_READ|EV_WRITE</li>
</ul>
<p>注意：默认write缓冲是enable、read缓冲是disable，所以需要开启都缓冲</p>
<p>6.客户端实现</p>
<p><code>socket(); connect();</code></p>
<p><code>int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);</code></p>
<ul>
<li><p>参1：bufferevent事件对象(封装了fd)</p>
</li>
<li><p>参2和参3：等同于connect()的参2和参3</p>
</li>
</ul>
<p>7.服务端实现</p>
<p><code>socket(); bind(); listen(); accept();</code></p>
<p><code>struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen);</code></p>
<ul>
<li><p>参1：event_base</p>
</li>
<li><p>参2：回调函数，一旦被回调，说明在其内部应该与客户端完成，数据读写操作，进行通信。</p>
</li>
<li><p>参3：回调函数的参数</p>
</li>
<li><p>参4：LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE</p>
</li>
<li><p>参5：listen的参2，-1表示最大值</p>
</li>
<li><p>参6：服务器自身的地址结构体</p>
</li>
<li><p>参7服务器自己的地址结构体大小</p>
</li>
<li><p>返回值：成功创建的监听器</p>
</li>
</ul>
<p>8.bufferevent的读事件回调触发时机：</p>
<blockquote>
<p>当数据由内核的读缓冲区到bufferevent的读缓冲区的时候，会触发bufferevent()的读事件回调。需要注意的是，数据由内核到bufferevent的过程不是由用户程序执行的，是由bufferevent内部操作的</p>
<p>被触发的回调函数是自己写的，可以在里面读bufferevent的数据了，也可以向bufferevent写缓冲区写数据</p>
</blockquote>
<p>9.bufferevent的写事件回调触发时机：</p>
<blockquote>
<p>当用户程序将数据写到bufferevent的写缓冲区之后，bufferevent会自动将数据写到内核的写缓冲区，最终由内核程序将数据发送出去。此时回调函数起到的是通知作用，向我们传达数据已经发送出去的信息。</p>
</blockquote>
<p>案例：用bufferevent来实现网络通信(服务端)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读缓冲区回调---&gt;当数据从内核缓冲区到bufferevent的读缓冲区时，触发该事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//只能用下面这个函数(bufferevent包里面的)代替read,因为没有文件描述符</span></span><br><span class="line">    bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从bufferevent读缓冲区中读数据到buf中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>,buf);                <span class="comment">//打印buf中的内容，也就是客户端发的内容</span></span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;我是服务器，已经成功收到你发送的数据！\n&quot;</span>;</span><br><span class="line">    <span class="comment">//因为写入bufferevent写缓冲区的数据会自动发送到内核缓冲区，则读回调函数里面直接向bufferevent写数据相当于回应客户端</span></span><br><span class="line">    bufferevent_write(bev,p,<span class="built_in">strlen</span>(p)+<span class="number">1</span>);  <span class="comment">//向bufferevent写缓冲区写入数据，系统就会将信息发送给客户端</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写缓冲区回调---&gt;当bufferevent的写缓冲区的数据发送到内核缓冲区时，触发该函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//因为读回调向bufferevent写缓冲区写入了数据，并且由内核处理，数据发送给了内核缓冲区，最后客户端收到信息，这些事情写回调都不用做</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功写数据给客户端，写缓冲区回调函数被回调.....\n&quot;</span>);  <span class="comment">//写回调起到的作用就是通知，表示信息已经发送出去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">short</span> events,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events &amp; BEV_EVENT_EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some other error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);                    <span class="comment">//出现上面两种情况都释放bev(bufferevent)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffevent 资源已经被释放...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听回调 ---&gt;当客户端连上，会执行这个函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cb_listener</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,<span class="type">evutil_socket_t</span> fd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">int</span> len,<span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect new client\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> (<span class="keyword">struct</span> event_base*)ptr;     <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">    <span class="comment">//创建bufferevent事件---&gt;然后就有了bufferevent的读写缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">    bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    <span class="comment">//给bufferevent缓冲区设置回调</span></span><br><span class="line">    bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>); <span class="comment">//设置了读回调函数、写回调函数和事件回调；最后NULL是传给三个的回调函数的参数，表示无</span></span><br><span class="line">    <span class="comment">//启用bufferevent的读缓冲，默认是disable的</span></span><br><span class="line">    bufferevent_enable(bev,EV_READ);       <span class="comment">//bufferevent的读缓存区默认是关闭的，所以需要打开</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>           <span class="comment">//定义一个存放服务端信息的结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));      <span class="comment">//将改结构体清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体的信息</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//创建event_base---&gt;插座</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> event_base_new();</span><br><span class="line">    <span class="comment">//创建套接字、绑定、接收连接请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span>* <span class="title">listener</span>;</span>       <span class="comment">//监听器，下面函数第二个参数是创建监听回调函数</span></span><br><span class="line">    listener = evconnlistener_new_bind(base,cb_listener,base,LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,<span class="number">36</span>,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv)); <span class="comment">//当客户端连接上的时候，cb_listener会被调用，其中需要传入参数base，里面会用到</span></span><br><span class="line">    <span class="comment">//启动循环监听</span></span><br><span class="line">    event_base_dispatch(base);    <span class="comment">//该函数循环监听那些事件对象(有回调函数的)，满足条件就激活对应的事件，进行回调</span></span><br><span class="line">    evconnlistener_free(listener);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：用bufferevent来实现网络通信(客户端)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读缓冲区回调---&gt;当数据从内核缓冲区到bufferevent的读缓冲区时，触发该事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从bufferevent读缓冲区中读数据到buf中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>,buf);                <span class="comment">//打印buf中的内容，也就是服务端发的内容</span></span><br><span class="line">    <span class="comment">//bufferevent_write(bev,buf,strlen(buf)+1);    //向bufferevent写缓冲区写入数据，系统就会将信息发送给对端</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写缓冲区回调---&gt;当bufferevent的写缓冲区的数据发送到内核缓冲区时，触发该函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//因为读回调向bufferevent写缓冲区写入了数据，并且由内核处理，数据发送给了内核缓冲区，最后客户端收到信息，这些事情写回调都不用做</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功写入数据给服务端，客户端回调起通知作用.....\n&quot;</span>);    <span class="comment">//写回调起到的作用就是通知，表示信息已经发送出去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">short</span> events,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events &amp; BEV_EVENT_EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some other error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_CONNECTED)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已经连接到服务器.......\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);            <span class="comment">//最上面两种情况就释放bev(bufferevent)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffevent 资源已经被释放...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端与用户交互，从终端读取数据写给服务器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_terminal</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));      <span class="comment">//此时的fd是标准输入，即从标准输入数据到buf中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> (<span class="keyword">struct</span> bufferevent*)arg;   <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    bufferevent_write(bev,buf,len+<span class="number">1</span>);    <span class="comment">//向服务端发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个event_base，底座</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    base = event_base_new();</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);    <span class="comment">//通信描述符</span></span><br><span class="line">    <span class="comment">//通信的fd放到bufferevent中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE); <span class="comment">//创建了bufferevent事件，将其的bufferevent读写缓冲区与内核文件描述符建立关系</span></span><br><span class="line">    <span class="comment">//定义服务端信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    bufferevent_socket_connect(bev,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);      <span class="comment">//设置了读回调、写回调和事件回调</span></span><br><span class="line">    <span class="comment">//设置读回调生效</span></span><br><span class="line">    bufferevent_enable(bev,EV_READ);          <span class="comment">//打开读缓冲区，不打开的话，服务器发信息来，这边不会执行读回调</span></span><br><span class="line">    <span class="comment">//创建事件 ---&gt; 有了bufferevent事件只是有了它的读写缓冲区与内核缓冲区建立关系，但作为客户端，需要主动给服务器发信息，就可以创建event事件来从终端向对端发信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> event_new(base,STDIN_FILENO,EV_READ | EV_PERSIST,read_terminal,bev);  <span class="comment">//监听标准输入终端，读事件，持续触发，read_terminal是回调函数</span></span><br><span class="line">    <span class="comment">//添加事件</span></span><br><span class="line">    event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//启动循环监听</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    event_free(ev);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，需要注意的是，客户端在创建了bufferevent事件后，只是将其的读写缓冲区与内核的作了联系，若后面不创建event事件来主动向服务端发信息，将运行不起来程序，因为服务器和客户端的读缓冲区被激活的前提是有信息到自己的bufferevent读缓冲区，但没有event事件让客户端从终端的输入信息发送到对端，这个程序就不会执行下去。</p>
]]></content>
      <categories>
        <category>libevent网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>高并发</tag>
        <tag>libevent</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程</title>
    <url>/2024/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-基础入门"><a href="#1-基础入门" class="headerlink" title="1.基础入门"></a>1.基础入门</h1><h2 id="1-1基本函数"><a href="#1-1基本函数" class="headerlink" title="1.1基本函数"></a>1.1基本函数</h2><p>open()函数：打开一个文件</p>
<p>int open(char *pathname , int flags , mode_t mode)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pathname：想要打开的文件路径名</p>
</li>
<li><p>flags(头文件#include <fcntl>)：文件打开方式：O_CREAT|OAPPEND|… </fcntl></p>
</li>
<li><p>mode：权限，当第二个参数设置了O_CREAT，就需要写该参数</p>
</li>
</ul>
</li>
</ul>
<p>mode:设置文件的权限(参数3使用前提：参数2指定了O_CREAT)</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：打开文件所得到对应的文件描述符(整数)</p>
</li>
<li><p>失败：-1,设置errno</p>
</li>
</ul>
</li>
</ul>
<p>read()函数：往一个文件读内容</p>
<p>ssize_t read(int fd , void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：存数据的缓冲区</p>
</li>
<li><p>count设置读字节数大小</p>
</li>
</ul>
</li>
</ul>
<p>count：缓冲区大小</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：读到的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>write()函数</p>
<p>ssize_t write(int fd , const void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：待写出数据的缓冲区</p>
</li>
<li><p>count：写入数据字节数大小</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：写入的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将文件cp一份</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">3</span>];                           <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);      <span class="comment">//只读方式打开文件argv[1]</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);  <span class="comment">//读写|文件不存在就创建出来|文件存储就覆盖；权限</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">3</span>)) != <span class="number">0</span>)&#123;     <span class="comment">//一次循环最多读3字节，n是每次读到的字节数</span></span><br><span class="line">                write(fd2,buf,n);              <span class="comment">//一次循环写入n个字节，也就是上面读到的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>,fd2);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        close(fd1);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        close(fd2);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2基本知识"><a href="#1-2基本知识" class="headerlink" title="1.2基本知识"></a>1.2基本知识</h2><p>1.PCB进程控制块：本质是结构体</p>
<ul>
<li>成员：文件描述符表——&gt;文件描述符：0&#x2F;1&#x2F;2&#x2F;3&#x2F;…&#x2F;1023</li>
</ul>
<p>key   value(指针：指向一个结构体)</p>
<p>0 – STDIN_FILENO ——–&gt;标准输入</p>
<p>1 – STDOUT_FILENO —–&gt;标准输出</p>
<p>2 – STDERR_FILENO ——&gt;标准错误</p>
<p>注意：每次得到的文件描述符默认是表中可用最小的</p>
<p>2.阻塞、非阻塞</p>
<p>是设备文件、网络文件的属性。产生阻塞的场景：读设备文件、读网络文件(读常规文件无阻塞概念)</p>
<p>dev&#x2F;tty：终端文件。标准输入、标准输出、标准错误都在终端显示</p>
<p>非阻塞设置：open(“&#x2F;dev&#x2F;tty”,..|O_NONBLOCK)</p>
<ul>
<li>此时若返回-1，并且errno &#x3D; EAGIN或EWOULDBLOCK，说明不是read失败，而是read在以非阻塞方式读一个设备文件或网络文件，并且文件无数据(默认是阻塞状态)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];                         <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);    <span class="comment">//以只读方式|非阻塞方式 打开文件/dev/tty</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open /dev/tty&quot;</span>);              <span class="comment">//如果fd&lt;0，说明打开文件失败，打印错误信息，并退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(fd,buf,<span class="number">10</span>);                <span class="comment">//从/dev/tty读数据存到buf(最多读10字节),/dev/tty是键盘输入</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，某些异常造成</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//=EAGAIN是阻塞情况下无数据读，输出try again到终端继续等待键盘输入</span></span><br><span class="line">                        write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                        sleep(<span class="number">2</span>);        <span class="comment">//2秒钟执行一次</span></span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);      <span class="comment">//在2秒钟内读到数据就直接输出到终端</span></span><br><span class="line">        close(fd);                       <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.参数</p>
<ul>
<li><p>传入参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>有const关键字修饰</p>
</li>
<li><p>指针指向有效区域，在函数内部做读操作</p>
</li>
</ul>
</li>
<li><p>传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间可以无意义，但必须有效</p>
</li>
<li><p>在函数内部，做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
<li><p>传入传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间有实际意义</p>
</li>
<li><p>在函数内部，先做读操作，后做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
</ul>
<p>4.文件存储</p>
<ul>
<li><p>dentry：目录项，其本质是结构体，重要成员变量有两个{文件名，inode,…}，而文件内容(data)保存在磁盘块中。</p>
</li>
<li><p>inode：其本质是结构体，存储文件的属性信息。如权限、类型、大小、盘块位置…。大多数的inode都存储在磁盘上，少数常用、近期使用的inode会被存储在内存上。</p>
</li>
</ul>
<h2 id="1-3进阶函数"><a href="#1-3进阶函数" class="headerlink" title="1.3进阶函数"></a>1.3进阶函数</h2><p>1.fcntl函数</p>
<ul>
<li><p>获取文件状态：F_GETFL</p>
</li>
<li><p>设置文件状态：F_SETFL</p>
</li>
</ul>
<p>获取fd描述符的stdin属性信息：int flgs &#x3D; fcntl(fd,F_GETFL);</p>
<p>添加非阻塞状态：flgs |&#x3D; O_NONBLOCK;</p>
<p>把设置的状态信息设置到终端设备的状态信息中：fcntl(fd,F_SETFL,flgs)；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>               <span class="comment">//定义宏变量</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> flags,n;</span><br><span class="line">        flags = fcntl(STDIN_FILENO,F_GETFL); <span class="comment">//获取stdin属性信息(获取标准输入对应的终端设备的状态信息) STDIN_FILENO对应终端设备</span></span><br><span class="line">        <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= O_NONBLOCK;     <span class="comment">//添加非阻塞状态</span></span><br><span class="line">        <span class="type">int</span> ret = fcntl(STDIN_FILENO,F_SETFL,flags);    <span class="comment">//把设置的状态信息设置到终端设备的状态信息中</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，不是因为没有数据</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        sleep(<span class="number">3</span>);</span><br><span class="line">                        write(STDOUT_FILENO,MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.lseek函数</p>
<p>off_t lseek(int fd , off_t offset , int whence);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd: 文件描述符</p>
</li>
<li><p>offset：偏移量</p>
</li>
<li><p>whence：偏移位置：SEEK_SET(起点)&#x2F;SEEK_CUR(当前位置)&#x2F;SEEK_END(终点)</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：较起始位置偏移量</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>文件的读和写使用同一偏移位置(读和写都改变偏移位置)</p>
</li>
<li><p>使用lseek获取文件大小</p>
</li>
<li><p>使用lseek拓展文件大小(要想使文件大小真正拓展，必须引起IO操作)</p>
</li>
</ul>
<p>补：可以使用truncate函数，直接拓展文件大小 </p>
<ul>
<li>如int ret &#x3D; truncate(“dict.txt”,250);</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试文件的读和写使用同一偏移位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;It&#x27;s a test4 for lseek\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);     <span class="comment">//以读写方式打开|不存在就创建</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open lseek.txt error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd,msg,<span class="built_in">strlen</span>(msg));     <span class="comment">//使用fd对打开文件进行写操作，此时读写位置位于文件结尾处</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时读写指针位于结尾处了，没有下面这行，将只能写数据到文件中，但不能执行下面的读(读出数据)</span></span><br><span class="line">        lseek(fd,<span class="number">0</span>,SEEK_SET);         <span class="comment">//将读写指针设置到文件开头-----&gt;读写指针；偏移量为0；开始偏移的位置为起始位置</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd,&amp;ch,<span class="number">1</span>)))&#123;    <span class="comment">//读，以一个变量为缓冲区，缓冲区大小为1</span></span><br><span class="line">                <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,&amp;ch,n);     <span class="comment">//将文件内容按字节读出，写到屏幕上</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用lseek获取文件大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR);    <span class="comment">//以读写打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时读写指针位于文件开头</span></span><br><span class="line">        <span class="type">int</span> lenth = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//偏移量为0，偏移位置为文件末，所以读写指针从文件头到文件尾，返回偏移了多少 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%d\n&quot;</span>,lenth);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.stat&#x2F;lstat函数</p>
<p>stat底层是一个结构体，里面有文件的信息</p>
<p>int stat(const char *path , struct stat *buf);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path:文件或目录路径 </p>
</li>
<li><p>buf：(传出参数)存放文件属性</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：0</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>系统提供函数</p>
<ul>
<li><p>获取文件大小：buf.st_size</p>
</li>
<li><p>获取文件类型：buf.st_mode</p>
</li>
<li><p>获取文件权限：buf.st_mode</p>
</li>
</ul>
<p>符号穿透：stat会；lstat不会</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = stat(<span class="string">&quot;document&quot;</span>,&amp;sbuf);     <span class="comment">//查看的目录文件路径；传出参数(接受该文件的stat结构体)</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%ld\n&quot;</span>,sbuf.st_size);    <span class="comment">//打印该文件的st_size信息</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a regular\n&quot;</span>);    <span class="comment">//这是一个普通文件</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a dir\n&quot;</span>);         <span class="comment">//这是一个目录</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a pipe\n&quot;</span>);      <span class="comment">//这是一个管道</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a sym link\n&quot;</span>);    <span class="comment">//这是一个软连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.link&#x2F;unlink函数</p>
<p>link函数：可以为已经存在的文件创建目录项(硬链接)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">link(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;b.txt&quot;</span>);    <span class="comment">//旧文件；新文件</span></span><br><span class="line">unlink(<span class="string">&quot;a.txt&quot;</span>);          <span class="comment">//删除旧的,新的可以继续用</span></span><br></pre></td></tr></table></figure>

<p>unlink函数：删除一个文件的目录项。从某种意义上说，只是让文件具备了释放的条件。</p>
<p>unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放(只是目录中我们看不到该文件了而已)，要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> *p = <span class="string">&quot;test of unlink\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *p2 = <span class="string">&quot;after write something\n&quot;</span>;</span><br><span class="line">        fd = open(<span class="string">&quot;temp.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);    <span class="comment">//打开文件temp.txt，没有就创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open temp error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">5</span>);                            <span class="comment">//这些时间可以看到该文件</span></span><br><span class="line">        <span class="type">int</span> ret = unlink(<span class="string">&quot;temp.txt&quot;</span>);        <span class="comment">//具备了被释放的条件，在目录中我们看不到了</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;                                        <span class="comment">//虽然unlink了，但后面还能进行写内容</span></span><br><span class="line">        ret = write(fd,p,<span class="built_in">strlen</span>(p));             <span class="comment">//往fd里面写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;--------write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hi! I&#x27;m lxx\n&quot;</span>);</span><br><span class="line">        ret = write(fd,p2,<span class="built_in">strlen</span>(p2));          <span class="comment">//往fd里面继续写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;------Write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter anykey continue\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.readlink()函数</p>
<p>作用：读取符号链接(软链接)文件本身内容，得到链接所指向的文件名。</p>
<p>如有软链接：t.soft -&gt; &#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>终端执行：readlink t.soft    得到：&#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>6.目录操作函数</p>
<p>DIR * opendir(char *name);</p>
<p>int closedir(DIR *dp)</p>
<p>struct dirent *readdir(DIR *dp);</p>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">	inode</span><br><span class="line">	<span class="type">char</span> dname[<span class="number">256</span>]</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span>       <span class="comment">//dirent是目录项类型，相当于dentry</span></span><br><span class="line">        dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            	<span class="comment">//去掉目录项文件名是.和..的目录项</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span>)||(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);      <span class="comment">//打印每个目录项的文件名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：递归遍历目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>;    <span class="comment">//申明isFile函数</span></span><br><span class="line"><span class="comment">//打开目录读取，处理目录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_dir</span><span class="params">(<span class="type">char</span> *dir)</span>&#123;   <span class="comment">//是目录，就打开其目录项</span></span><br><span class="line">        <span class="type">char</span> path[<span class="number">256</span>];    <span class="comment">//用于后面拼接路径</span></span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">        dp = opendir(dir);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取目录项</span></span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;   </span><br><span class="line">                        <span class="keyword">continue</span>;       <span class="comment">////不排除这个，会进入死循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//目录项本身不可访问，拼接目录</span></span><br><span class="line">                <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">                <span class="comment">//判断文件类型，目录递归进入，文件显示名字/大小</span></span><br><span class="line">                isFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span>            <span class="comment">//stat是应该结构体，里面包含对应文件的信息</span></span><br><span class="line">        ret = stat(name,&amp;sb);      <span class="comment">//获取文件属性，判断文件类型</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;   <span class="comment">//是否目录</span></span><br><span class="line">                read_dir(name);    <span class="comment">//是目录，进入read_dir函数，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是普通文件，打印名字和大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;               <span class="comment">//如果没有传入参数，就遍历当前目录下的内容</span></span><br><span class="line">                isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                isFile(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.dup&#x2F;dup2函数</p>
<p>int dup(int oldfd);</p>
<ul>
<li><p>参数：oldfd：已有文件描述符</p>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<p>int dup2(int oldfd,int newfd);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>oldfd：原文件描述符 </p>
</li>
<li><p>newfd：新文件描述符—–&gt;指向源文件描述符所指向的文件</p>
</li>
</ul>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd1--&gt;3</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd2--&gt;4</span></span><br><span class="line">        <span class="type">int</span> fdret = dup2(fd1,fd2);        <span class="comment">//fd2与fd1指向的是同一个内存空间了,返回新文件描述符fd2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdret = %d\n&quot;</span>,fdret);</span><br><span class="line">        <span class="type">int</span> ret = write(fd2,<span class="string">&quot;1234567&quot;</span>,<span class="number">7</span>);  <span class="comment">//通过fd2来写内容，内容写在的是第一个文件中</span></span><br><span class="line">        dup2(fd1,STDOUT_FILENO);   <span class="comment">//令屏幕输入(fd=1)重定向给fd1所指向的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------886\n&quot;</span>);  <span class="comment">//向屏幕输出的内容都写到文件描述符3所在的内存空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fcntl函数是实现dup</p>
<p>int fcntl(int fd,int cmd,…);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：原文件描述符</p>
</li>
<li><p>cmd：F_DUPFD(特定参数)</p>
</li>
<li><p>参数3：指定文件描述符号。被占用的，返回最小可用的；未被占用的，返回&#x3D;该值的文件描述符</p>
</li>
</ul>
</li>
<li><p>返回值：返回新的文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fcntl也可以像dup那些使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);      <span class="comment">//读写方式打开文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);            <span class="comment">//打印文件描述符fd1的值，是3</span></span><br><span class="line">        <span class="comment">//原文件描述符；特定参数；新的文件描述符号(已经存在的话，系统就按正常给)</span></span><br><span class="line">        <span class="type">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>); <span class="comment">//0被占用，fcntl使用文件描述符表中可用的最小文件描述符来返回，即newfd=4</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd);       <span class="comment">//newfd的值是4</span></span><br><span class="line">        <span class="type">int</span> newfd2 = fcntl(fd1,F_DUPFD,<span class="number">7</span>);  <span class="comment">//7未被占用，返回文件描述符7(如果存在7，就返回更大的号)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd2);</span><br><span class="line">        <span class="type">int</span> ret = write(newfd2,<span class="string">&quot;yyyyyy&quot;</span>,<span class="number">6</span>);    <span class="comment">//写在的是fd1文件描述符所在的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h2 id="2-1进程与程序"><a href="#2-1进程与程序" class="headerlink" title="2.1进程与程序"></a>2.1进程与程序</h2><p>程序：死的，只占用磁盘空间    —剧本</p>
<p>进程：活的，运行起来的程序，占用内存、cpu等系统资源   —戏剧</p>
<p>1.进程控制块PCB</p>
<p>我们知道，每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>内部成员：</p>
<ul>
<li><p>进程id：系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数；</p>
</li>
<li><p>进程的状态：有初试、就绪、运行、挂起和停止五种状态</p>
</li>
<li><p>进程切换时想要保存和恢复的一些CPU寄存器；(了解)</p>
</li>
<li><p>描述虚拟地址空间的信息；(了解)</p>
</li>
<li><p>描述控制终端的信息；(了解)</p>
</li>
<li><p>当前所处工作目录；</p>
</li>
<li><p>umask掩码：rwx对应124，当umask为022时，在你创建文件和目录时，默认权限是777-022&#x3D;755，即rwxr_xr_x；(了解)</p>
</li>
<li><p>文件描述符表：是map结构，key为正整数，value为指针，指针指向结构体；它包含很多指向file结构体的指针(每个进程都有文件描述符表)</p>
</li>
<li><p>和信号相关的信息；</p>
</li>
<li><p>用户id和组id；</p>
</li>
<li><p>会话和进程组；(了解)</p>
</li>
<li><p>进程可用使用的资源上限；(了解)</p>
</li>
</ul>
<p>2.进程共享</p>
<p>父进程在fork()之后：</p>
<p>相同：全局变量、data段、text段、栈、堆、环境变量、用户id、宿主目录、进程工作目录、信号处理方式…</p>
<p>不相同：进程id、fork返回值、父进程id、进程运行时间、闹钟(定时器)、未决信号集</p>
<p>注：对于全局变量，父子进程间遵循<strong>读时共享写时复制</strong>的原则</p>
<p>3.孤儿进程&#x2F;僵尸进程</p>
<ul>
<li><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程(回收)</p>
</li>
<li><p>僵尸进程：子进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程。(kill对其无效)</p>
</li>
</ul>
<h1 id="3-相关函数"><a href="#3-相关函数" class="headerlink" title="3.相关函数"></a>3.相关函数</h1><h2 id="3-1fork-函数"><a href="#3-1fork-函数" class="headerlink" title="3.1fork()函数"></a>3.1fork()函数</h2><p>功能：是创建一个新的进程</p>
<p>pid_t fork(void);</p>
<ul>
<li>返回值：对应文件的子进程id号</li>
</ul>
<p>注意：创建出来的子进程可用执行父进程中fork()函数下面的代码。在父进程中，fork返回的是子进程id号；在子进程中，fork返回的是0；</p>
<p>补：getpid()返回的是当前进程；getppid()返回的是父进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过fork()函数来生成子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程会执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child is created,pid = %d,parent-pid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//fork成功的话，父进程里返回的是子线程的id，所以父线程执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent process: my child is %d,my pid = %d,my parent pid = %d\n&quot;</span>,pid,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======================end of file\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);  <span class="comment">//防止父进程结束了，子进程还没有打印内容，当父进程结束后，退出程序，而子进程就没有父进程了，打印的父进程就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，子进程和父进程都会执行sleep(3)这行代码，不是说只有让父进程执行，而子进程不执行，sleep(3)只是防止父进程结束退出程序了，子进程还没有打印父进程。如果父进程结束了，子进程才打印父进程，则父进程是1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环创建5个子线程，且有序打印出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;   <span class="comment">//子线程创建好了与0做对比，直接跳出循环，但父进程还需要继续执行</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//当第1个子进程创建好后，此时i=0;当第2个子进程创建好后，此时的i=1;.....</span></span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2execlp-函数"><a href="#3-2execlp-函数" class="headerlink" title="3.2execlp()函数"></a>3.2execlp()函数</h2><p>功能：指定进程执行相应的程序</p>
<p>int execlp(const *file , const *arg , …);</p>
<ul>
<li><p>参数:</p>
<ul>
<li><p>file：要加载(执行)的程序名字</p>
</li>
<li><p>arg以及后面：调用该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数常用来调用系统程序。如ls、date、cp、cat等命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execlp()：是让子线程不执行父线程的代码，而是执行/execlp所指定的代码或函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">//ls：要执行的系统函数名；ls -l -d -h：是执行的代码(命令)；NULL：是哨兵，代表着-l、-d等参数的结束</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);   <span class="comment">//当子线程调用execlp失败时，执行下面代码</span></span><br><span class="line">                <span class="comment">//execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3execl函数"><a href="#3-3execl函数" class="headerlink" title="3.3execl函数"></a>3.3execl函数</h2><p>功能：既可以执行自己写的程序，也可用执行系统程序</p>
<p>int execl(const char* path , const char *arg , ….);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path：程序的路径</p>
</li>
<li><p>arg以及后面：执行该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数是通过 路径+程序名 来加载进程</p>
<p>案例：将ps aux打印的内容写到一个文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execl()：是让子线程不执行父线程的代码，而是执行execl所指定的文件</span></span><br><span class="line"><span class="comment">//注：execl()也能像execlp()函数那些去执行系统的一些程序，如date、ls等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">// ./execlp：是路径；./execlp是命令</span></span><br><span class="line">                <span class="comment">//execlp(&quot;./execlp&quot;,&quot;./execlp&quot;,NULL);    //子线程去执行execlp程序里面的代码</span></span><br><span class="line">                execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4wait-函数"><a href="#3-4wait-函数" class="headerlink" title="3.4wait()函数"></a>3.4wait()函数</h2><blockquote>
<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态；如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个过程。</p>
</blockquote>
<p>该函数的三个功能：</p>
<ul>
<li><p>阻塞等待子进程退出；</p>
</li>
<li><p>回收子进程残留资源</p>
</li>
<li><p>获取子进程结束状态(退出原因)</p>
</li>
</ul>
<p>pid_t wait(int *status);</p>
<ul>
<li><p>参数：status是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>返回值：成功：回收子进程的id号；失败：-1(没有子进程)</p>
</li>
</ul>
<p>可使用wait函数传出的参数status来保存进程的退出状态：</p>
<ul>
<li><p>WIFEXITED(status)为非0，表示进程正常结束</p>
<ul>
<li>如上正常退出，使用WEXITSTATUS(status)来获取进程的退出状态(正常的参数)</li>
</ul>
</li>
<li><p>WIFSIGNALED(status)为非0，表示进程异常终止</p>
<ul>
<li>如上异常退出，使用WTERMSIG(status)来获取使进程终止的那个信号的编号</li>
</ul>
</li>
<li><p>WIFSTOPPED(status)为非0，表示进程处于暂停状态</p>
<ul>
<li>如上为暂停状态，使用WSTOPSIG(status)来取得使进程暂停的那个信号的编号</li>
</ul>
</li>
<li><p>WIFCONTINUED(status)为真，表示进程暂停后已经继续运行</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：wait函数只有在子线程执行完后才会回收，然后继续向下执行；否则就阻塞在该处，等子线程执行完</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child,my id = %d,going to sleep 3s\n&quot;</span>,getpid());</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent wait finish:%d\n&quot;</span>,wpid);    <span class="comment">//等子线程执行完后，才会执行该函数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：通过系统提供的宏函数来查看子线程的退出状态信息等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子线程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">93</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//wpid = wait(NULL);      //不关心子进程结束的原因</span></span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))&#123;    <span class="comment">//该子线程是否正常终止</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;我是正常终止,返回%d\n&quot;</span>,WEXITSTATUS(status));<span class="comment">//打印的值是93，即子线程执行完的返回值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))&#123;   <span class="comment">//该子线程是否被信号终止(一切异常终止都是因为信号)</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>,WTERMSIG(status));  <span class="comment">//打印导致异常退出的信号编号</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;父线程等待完毕，回收的子线程是%d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5waitpid-函数"><a href="#3-5waitpid-函数" class="headerlink" title="3.5waitpid()函数"></a>3.5waitpid()函数</h2><p>pid_t waitpid(pid_t pid , int *status , int optains)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pid：指定某个子进程进行回收(大于0：回收指定ID的子进程；-1：回收任意子进程，相当于wait；0：回收和当前调用waitpid一个组的所有子进程；小于-1：回收指定进程组内的任意子进程)</p>
</li>
<li><p>status：是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>options：通过特定参数，可以完成特定功能，如WNOHANG指以非阻塞方式回收</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>大于0：表示成功回收的子进程pid</p>
</li>
<li><p>等于0：参3指定了WNOHANG，并且没有子进程结束会返回0(非阻塞方式)</p>
</li>
<li><p>-1：失败，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>waitpid()与wait()的区别是：waitpid能指定某个进程进行回收</p>
<p>注意：一次wait&#x2F;waitpid函数调用，只能回收一个子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：指定回收某个子线程，且子线程有序打印</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid,tmpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                        tmpid = pid;    <span class="comment">//此时pid是第三个子线程的pid</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;指定回收的子线程 = %d\n&quot;</span>,tmpid);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);   <span class="comment">//如果是不阻塞状态，给主线程添加睡眠，会成功回收指定子线程</span></span><br><span class="line">                <span class="comment">//wpid = waitpid(tmpid,NULL,WNOHANG);   //指定回收子进程tmpid,并且不阻塞</span></span><br><span class="line">                wpid = waitpid(tmpid,<span class="literal">NULL</span>,<span class="number">0</span>);   <span class="comment">//指定回收子进程tmpid,并且是阻塞状态</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收子线程：%d\n&quot;</span>,wpid);  <span class="comment">//如果不阻塞状态，指定回收的子线程没有结束，则回收没有成功，waitpid会返回0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);    <span class="comment">//有序打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：回收多个子线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">/*while(wpid = waitpid(-1,NULL,0))&#123;   //循环回收每个子线程,并且是阻塞状态 后面回收完，会返回-1，一直循环</span></span><br><span class="line"><span class="comment">                        printf(&quot;成功回收子线程：%d\n&quot;,wpid);</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">                <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG)) != <span class="number">-1</span>)&#123;    <span class="comment">//以非阻塞状态进行回收</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)&#123;    <span class="comment">//当成功回收时</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;成功回收：%d\n&quot;</span>,wpid);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;    <span class="comment">//当没有成功回收时，先睡眠1秒</span></span><br><span class="line">                                sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-IPC方法"><a href="#4-IPC方法" class="headerlink" title="4.IPC方法"></a>4.IPC方法</h1><blockquote>
<p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC)。</p>
</blockquote>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。现在常用的进程间通信方式有：</p>
<ul>
<li><p>管道(使用最简单)</p>
</li>
<li><p>信号(开销最小)</p>
</li>
<li><p>共享映射区(无血缘关系)</p>
</li>
<li><p>本地套接字(最稳定)</p>
</li>
</ul>
<h2 id="4-1管道"><a href="#4-1管道" class="headerlink" title="4.1管道"></a>4.1管道</h2><blockquote>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
</blockquote>
<ul>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端(可以有多个)，一个表示写端</p>
</li>
<li><p>规定数据从管道的写端流入管道，借助内核缓冲区(4k)实现</p>
</li>
</ul>
<p>1.管道的局限性：</p>
<ul>
<li><p>数据不能进程自己写，自己读</p>
</li>
<li><p>管道中数据不可以反复读取，一旦读走，管道中不再存在</p>
</li>
<li><p>采用半双工通信方式，数据只能在单方向上流动</p>
</li>
<li><p>只能在有公共祖先的进程间使用管道。</p>
</li>
</ul>
<p>2.常见的通信方式有：单工通信、半双工通信、全双工通信</p>
<p>3.pipe函数</p>
<p>int pipe(int fd[2]);   —&gt; 创建，并打开管道</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd[0]：读端</p>
</li>
<li><p>fd[1]：写端</p>
</li>
</ul>
</li>
<li><p>返回值：成功：0；失败：-1，设置errno</p>
</li>
</ul>
<p>4.管道的读写行为：</p>
<ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据：(A)管道写端被全部关闭，read返回0(表示读到文件结尾)；(B)写端没有全部被关闭，read阻塞等待(不久的将来可能有数据写入)，此时会让出CPU</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道读端全部被关闭：进程异常终止(也可以使用SIGPIPE信号，使进程不终止)</p>
</li>
<li><p>管道读端没有全部关闭：若管道已满，write阻塞；若管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试pipe管道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;           <span class="comment">//主线程负责写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);    <span class="comment">//关闭读端</span></span><br><span class="line">                write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">                sleep(<span class="number">1</span>);        <span class="comment">//主线程睡眠1秒，防止主线程先结束</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//写完后，关闭写端</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子线程负责读</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//子线程关闭写端</span></span><br><span class="line">                ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));     <span class="comment">//将主线程写在缓冲区的内容读到buf里面    </span></span><br><span class="line">                write(STDOUT_FILENO,buf,ret);         <span class="comment">//将buf的内容打印到屏幕，其中ret为buf读到的字节数</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);     <span class="comment">//结束后，关闭读端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用管道实现父子进程间通信，完成ls | wc -l，假定父进程实现ls，子进程实现wc</p>
<p>ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;    <span class="comment">//负责出错时，打印错误</span></span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="comment">//当父进程执行ls时，子进程会永远执行在后面，所以父进程会先结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;       <span class="comment">//子线程</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);       <span class="comment">//关闭读端</span></span><br><span class="line">                <span class="comment">//重定向，相当于屏幕上的内容输入到管道的写端</span></span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);    <span class="comment">//重定向，让标准输出指向管道的读端，这样输出在屏幕上的就可以写到管道中</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);       <span class="comment">//父进程执行ls命令</span></span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//父线程</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);      <span class="comment">//关闭写端</span></span><br><span class="line">                <span class="comment">//重定向，相当于从管道读端读到的内容写到了标准输入(相当于键盘输入)</span></span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);     <span class="comment">//重定向，让标准输入指向管道的读端，从管道读取数据</span></span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：ls命令正常会将结果集写出到stdout，但现在会写入管道的写端；wc -l正常应该会从stdin读取数据，但此时会从管道的读端读。</p>
<p>案例：使用管道实现兄弟进程间通信，兄：ls，弟：wc -l，父：等待回收子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用兄弟进程实现</span></span><br><span class="line"><span class="comment">//ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);   <span class="comment">//一个出错处理函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;    <span class="comment">//父进程回收两个子线程</span></span><br><span class="line">                <span class="comment">//父进程必须关闭管道的读和写端，因为管道是单向的，而两个子线程已经占用了读和写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;    <span class="comment">//兄线程执行</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;    <span class="comment">//弟进程执行</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2FIFO"><a href="#4-2FIFO" class="headerlink" title="4.2FIFO"></a>4.2FIFO</h2><blockquote>
<p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程；但通过FIFO，不相关的进程也能交换数据。FIFO是Linux基础文件类型中的一种。但FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道，这样就实现了进程间通信，并且可以有多个写端和多个读端。</p>
</blockquote>
<p>创建管道方式：</p>
<ul>
<li><p>终端：mkfifo 命名管道文件名</p>
</li>
<li><p>代码：int ret &#x3D; mkfifo(“my_mkfifo”,0664);返回-1未成功创建</p>
</li>
</ul>
<p>注意：可以通过终端mkfifo 命名管道文件名 来创建，也可以通过c程序</p>
<p>写端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,i;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_WRONLY);     <span class="comment">// 以只写的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello lxx %d\n&quot;</span>,i++);     <span class="comment">//将要写的内容存入buf</span></span><br><span class="line">                write(fd,buf,<span class="built_in">strlen</span>(buf));             <span class="comment">//将buf中的内容写到命名管道(文件)中</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,len;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_RDONLY);     <span class="comment">// 以只写的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                len = read(fd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//将从命名管道中读到的数据放到buf中</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);      <span class="comment">//将buf中的内容读到标准输出(屏幕)</span></span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3存储映射I-O"><a href="#4-3存储映射I-O" class="headerlink" title="4.3存储映射I&#x2F;O"></a>4.3存储映射I&#x2F;O</h2><blockquote>
<p>存储映射I&#x2F;O使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样就可以在不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作。</p>
<p>使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现</p>
</blockquote>
<p>1.创建映射区</p>
<p>void *mmap(void * addr , size_t length , int prot , int flags , int fd , off_t offset);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>addr：指定映射区的首地址。通常传NULL，表示让系统自动分配</p>
</li>
<li><p>length：共享内存映射区的大小。(&lt;&#x3D;文件的实际大小)</p>
</li>
<li><p>prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE</p>
</li>
<li><p>flags：标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE(私有：对内存的操作不会反映到物理磁盘上)</p>
</li>
<li><p>fd：用于创建共享内存映射区的那个文件的文件描述符。</p>
</li>
<li><p>offset：默认0，表示映射文件全部。偏移位置需是4K的整数倍。</p>
</li>
</ul>
</li>
<li><p>返回值：成功：映射区的首地址；失败：MAP_FAILED，设置errno</p>
</li>
</ul>
<p>2.释放映射区</p>
<p>int munmap(void *addr  , size_t length);</p>
<p>参数：</p>
<ul>
<li><p>addr：mmap的返回值</p>
</li>
<li><p>length：大小</p>
</li>
</ul>
<p>3.使用注意事项：</p>
<ul>
<li><p>用于创建映射区的文件大小为0，实际指定非0大小创建映射区，出“总线错误”；</p>
</li>
<li><p>用于创建映射区的文件大小为0，实际指定0大小创建映射区，出“无效参数”；</p>
</li>
<li><p>用于创建映射区的文件读写属性为只读，映射区属性为读、写，出“无效参数”；</p>
</li>
<li><p>创建映射区，需要read权限(因为创建时，需要查看映射指定的文件)；当访问权限指定为MAP_SHARED(共享)时，mmap的读写属性应该&lt;&#x3D;文件的open权限(只给mmap写属性不可以)–&gt;因为共享时，对内存操作都会同样的对磁盘(文件)操作；</p>
</li>
<li><p>文件描述符fd，在mmap创建映射区完成即可关闭，后续访问文件用地址访问；</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，在需要open文件时，有读权限来创建映射区即可；</p>
</li>
</ul>
<p>4.mmap函数的保险调用：</p>
<ul>
<li><p>fd &#x3D; open(“文件名”,O_RDWR);</p>
</li>
<li><p>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试创建一个映射区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(<span class="string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*lseek(fd,19,SEEK_END);</span></span><br><span class="line"><span class="comment">        write(fd,&quot;\0&quot;,1);    */</span>        <span class="comment">//这两行函数与下面的ftruncate()一样</span></span><br><span class="line">        ftruncate(fd,<span class="number">20</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//系统自动分配映射区首地址；映射区的大小；创建的映射区可读可写；映射区是共享的(内存内改，磁盘也改)；文件描述符；默认0</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用p对文件进行读写操作</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);         <span class="comment">//写操作,将hello maap写到映射区(磁盘)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------%s\n&quot;</span>,p);     <span class="comment">//将映射区内的东西写到屏幕</span></span><br><span class="line">        <span class="type">int</span> ret = munmap(p,len);          <span class="comment">//对映射区进行释放</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;imunmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.mmap进程通信</p>
<ul>
<li><p>父子进程通信</p>
<ul>
<li>父子等有血缘关系的进程之间也可以提供mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：<ul>
<li>MAP_PRIVATE(私有映射)：父子进程各自独占映射区(修改，互相都看不到)；</li>
<li>MAP_SHARED(共享映射)：父子进程共享映射区；</li>
</ul>
</li>
</ul>
</li>
<li><p>无血缘关系间的进程通信</p>
<ul>
<li>两个进程打开同一个文件(创建的映射区)；一个进程写入，另外一个进程读出。</li>
</ul>
</li>
</ul>
<p>mmap：数据可以重复读取(当创建的映射区为4字节时，只要读的速度快于写的速度，那么可以重复读同一个正整数多次，直到新数据写入)；而fifo只能读取数据一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子进程实现mmap映射区之间的通信</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;temp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">                <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ftruncate(fd,<span class="number">4</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//MAP_SHARED如果是私有的话，表示映射区归父进程私有,也归子进程私有，对其修改，互相都收不到</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);      <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line">        pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                *p = <span class="number">2000</span>;      <span class="comment">//子进程写共享内存</span></span><br><span class="line">                var = <span class="number">1000</span>;     <span class="comment">//对全部变量，读时共享，写时复制</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);   <span class="comment">//等子进程写完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">                wait(<span class="literal">NULL</span>);     <span class="comment">//回收子进程</span></span><br><span class="line">                <span class="type">int</span> ret = munmap(p,<span class="number">4</span>);     <span class="comment">//释放映射区</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">                       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果是：</span></span><br><span class="line">child,*p = <span class="number">2000</span>,var = <span class="number">1000</span></span><br><span class="line">parent,*p = <span class="number">2000</span>,var = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5.信号"></a>5.信号</h1><blockquote>
<p>信号是一种软件中断，通知程序某种事件的发生。常见的信号有SIGABRT(当进程调用abort函数的时候自动发送), SIGALRM(当timer被触发的时候自动发送)，等等。</p>
</blockquote>
<h2 id="5-1常识"><a href="#5-1常识" class="headerlink" title="5.1常识"></a>5.1常识</h2><p>1.信号的共性：简单、不能携带大量信息、满足条件才发送</p>
<p>2。信号的特质：信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。所有信号的产生及处理全部都是由内核完成的</p>
<p>3.产生信号</p>
<ul>
<li><p>按键产生，如Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如kill、raise、abort</p>
</li>
<li><p>软件条件产生，如定时器alarm</p>
</li>
<li><p>硬件异常产生，如非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生：如kill命令</p>
</li>
</ul>
<p>4.信号的状态</p>
<ul>
<li><p>递达：产生并且到达进程，可以直接被内核处理掉</p>
</li>
<li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态</p>
</li>
</ul>
<p>5.信号处理的方式：执行默认动作、忽略(丢弃)、捕抓(自定义)</p>
<p>6.阻塞信号集(信号屏蔽字)：本质就是位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，再解除屏蔽前，就一直处于未决态</p>
<p>7.未决信号集：本质就是位图。用来记录信号的处理状态，该信号集中的信号表示已经产生，但尚未被处理</p>
<h2 id="5-2信号四要素及常规信号"><a href="#5-2信号四要素及常规信号" class="headerlink" title="5.2信号四要素及常规信号"></a>5.2信号四要素及常规信号</h2><p>信号使用之前，应先确定其四要素，而后再用。即信号编号、信号名称、信号对应事件、信号默认处理动作。</p>
<p>1.常规信号：</p>
<ul>
<li><p>1)SIGHUP：当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程。</p>
</li>
<li><p>2)SIGINT：当用户按下了&lt;Ctrl+c&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>3)SIGQUIT：当用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>5)SIGTRAP：该信号由断点指令或其他trap指令产生，默认动作为终止进程，并产生core文件。</p>
</li>
<li><p>6)SIGABRT：调用abort函数时产生该信号，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>7)SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>8)SIGFPE：在发生致命的运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>9)SIGKILL：无条件终止进程，本信号不能被忽略处理和阻塞，默认动作为终止进程，它向系统管理员提供了可以杀死任何进程的方法。</p>
</li>
<li><p>10)SIGUSR1：用户定义的信号，即程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>11)SIGSEGV：指示进程进行了无效内存访问，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>12)SIGUSR2：用户自定义信号，程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>13)SIGPIPE：Broken pipe向一个没有读端的管道写数据，默认动作为终止进程。</p>
</li>
<li><p>14)SIGALRM：定时器超时，超时的时间由系统调用alarm设置，默认动作为终止进程。</p>
</li>
<li><p>15)SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止，通常用来要示程序正常退出，执行shell命令kill时，缺省产生这个信号，默认动作为终止进程。</p>
</li>
<li><p>17)SIGCHLD：子进程状态发生变化时，父进程会收到这个信号，默认动作为忽略这个信号。</p>
</li>
<li><p>18)SIGCONT：如果进程已停止，则使其继续运行，默认动作为继续&#x2F;忽略。</p>
</li>
<li><p>19)SIGSTOP：停止进程的执行，信号不能被忽略处理和阻塞，默认动作为暂停进程。</p>
</li>
</ul>
<p>注意：只有每个信号所对应的事情发生了，该信号才会被递送(但不一定递达)，不应该乱发信号。</p>
<p>2.kill函数与kill命令</p>
<ul>
<li>kill函数：给指定进程发送指定信号(不一定是杀死)</li>
</ul>
<p>int kill(pid_t pid , int signum);</p>
<ul>
<li>参数pid：   &gt;0：发送信号给指定进程。&#x3D;0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。&lt;-1：取绝对值，发送信号给该绝对值所对应的进程组的所有组员。&#x3D;-1：发送信号给，有权限发送的所有进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试用kill杀死子进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,pid = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);    <span class="comment">//父进程一直循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                kill(getppid(),SIGKILL);      <span class="comment">//发送 SIGKILL 信号给其父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kill命令：如杀死一个进程(kill -9 进程号)</p>
<h2 id="5-3alarm函数"><a href="#5-3alarm函数" class="headerlink" title="5.3alarm函数"></a>5.3alarm函数</h2><blockquote>
<p>设置定时器(闹钟)，在指定seconds后，内核会给当前进程发送SIGALRM(14)信号，进程收到该信号，默认终止动作。</p>
<p>每个进程都有且只有唯一个定时器。</p>
</blockquote>
<p>unsigned int alarm(unsigned int seconds);</p>
<ul>
<li><p>参数：定时秒数</p>
</li>
<li><p>返回值：上次定时剩余秒数，无错误现象。</p>
</li>
</ul>
<p>常用：取消定时器alarm(0)，返回旧闹钟剩余的秒数</p>
<p>注意：定时与进程状态无关，无论进程处于何种状态，alarm都计时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用alarm测试1秒可以数多少次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[补]使用time命令查看程序执行的时间(如time .&#x2F;alarm_count)，alarm_count是上面代码的函数</p>
<p>得出：实际执行时间 &#x3D; 系统时间+用户时间+等待时间(最多)—-&gt;程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
<h2 id="5-4setitimer函数"><a href="#5-4setitimer函数" class="headerlink" title="5.4setitimer函数"></a>5.4setitimer函数</h2><blockquote>
<p>setitimer函数可以替代alarm函数，精度到微妙，还可以实现周期定时</p>
</blockquote>
<p>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>new_value：定时秒数(结构体类型见代码)</p>
</li>
<li><p>old_value：传出参数，上次定时剩余时间</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：0；失败：-1，设置errno</li>
</ul>
</li>
</ul>
<p>提示：</p>
<ul>
<li><p>it_interval：用来设定两次定时任务之间间隔时间</p>
</li>
<li><p>it_value：定时的时长</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>,<span class="title">oldit</span>;</span></span><br><span class="line">        signal(SIGALRM,myfunc);      <span class="comment">//注册SIGALRM 信号的捕抓处理函数</span></span><br><span class="line"></span><br><span class="line">        it.it_value.tv_sec = <span class="number">2</span>;      <span class="comment">//设置定时器闹钟为2秒</span></span><br><span class="line">        it.it_value.tv_usec = <span class="number">0</span>;     <span class="comment">//这是设置微妙的</span></span><br><span class="line"></span><br><span class="line">        it.it_interval.tv_sec = <span class="number">5</span>;   <span class="comment">//周期为5秒，每5秒提醒一次</span></span><br><span class="line">        it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it,&amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//循环一直停留在终端,方便观看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5信号集和未决信号集"><a href="#5-5信号集和未决信号集" class="headerlink" title="5.5信号集和未决信号集"></a>5.5信号集和未决信号集</h2><p>1.信号集操作函数</p>
<ul>
<li><p>自定义信号集(用于和mask发生或与关系)：sigset_t set; </p>
</li>
<li><p>清空信号集(全置为0)：sigemptyset(sigset_t *set);   </p>
</li>
<li><p>信号集全置1：sigfillset(sigset_t *set);</p>
</li>
<li><p>将一个信号添加到集合中：sigaddset(sigset_t *set,int signum);</p>
</li>
<li><p>将一个信号从集合中移除：sigdelset(sigset_t *set,int signum);</p>
</li>
<li><p>判断一个信号是否在集合中(在是1，不在是0)：sigismember(const sigset_t *set,int signum);</p>
</li>
</ul>
<p>2.设置信号屏蔽字和解除屏蔽</p>
<p>int sigprocmask(int how , const sigset_t *set , sigset_t *oldset);</p>
<ul>
<li><p>how：SIG_BLOCK是设置阻塞；SIG_UNBLOCK是取消阻塞；SIG_SETMASK是用自定义set替换mask</p>
</li>
<li><p>set：自定义set</p>
</li>
<li><p>oldset： 旧有的mask</p>
</li>
</ul>
<p>用来屏蔽信号、解除屏蔽也使用该函数。其本质是读取或修改进程的信号屏蔽字(PCB中)</p>
<p>注意：屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略是表示将信号丢弃处理</p>
<p>3.查看未决信号集</p>
<p>int sigpending(sigset_t *set);</p>
<ul>
<li>set：传出的未决参数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/System_programming/1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对信号2设置了阻塞，并查看了未决信号集,Ctrl+c可以进行查看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>&#123;     <span class="comment">//自定义函数打印位图</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sigismember(<span class="built_in">set</span>,i))&#123;     <span class="comment">//信号i是否在信号集set上</span></span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>,oldset,pedset;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);    <span class="comment">//清空信号集(置为0)</span></span><br><span class="line">        <span class="comment">//将信号添加到自定义集合中(在自定义集合中，将对应信号置为1)</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGINT);      <span class="comment">// Ctrl+c对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);     <span class="comment">// Ctrl+\对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGKILL);     <span class="comment">// 由于信号9不能被修改，所以不能被处理,可以通过kill -9 该程序对应进程号 来终止该进程</span></span><br><span class="line">        ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);     <span class="comment">//设置阻塞；自定义集合的地址，传出参数</span></span><br><span class="line">        <span class="comment">//通过上一行代码，对信号2进行了阻塞，只有解除阻塞，否则信号2一直未决，即在未决信号集中，信号2一直为1</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                ret = sigpending(&amp;pedset);   <span class="comment">//查看未决信号集,参数是传出参数，是该进程的一个未决信号集</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                print_set(&amp;pedset);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;  <span class="comment">//当i执行到10的时候，解除屏蔽字的阻塞，此时ctrl+c信号递达，退出程序</span></span><br><span class="line">                        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6sigaction函数"><a href="#5-6sigaction函数" class="headerlink" title="5.6sigaction函数"></a>5.6sigaction函数</h2><blockquote>
<p>signal函数和sigaction函数都是只注册一个信号的捕抓函数，捕抓是有内核来完成的</p>
</blockquote>
<p>int sigaction (int signum , const struct sigaction *act , struct sigaction *oldact);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>singum：捕抓的信号</p>
</li>
<li><p>act：传入参数，新的处理方式</p>
</li>
<li><p>oldact：传出参数，旧的处理方式</p>
</li>
</ul>
</li>
</ul>
<p>信号捕抓的特性：</p>
<ul>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为#，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由#来指定，而是用sa_mask来指定，调用完信号处理函数，再恢复为#。</p>
</li>
<li><p>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs&#x3D;0)。</p>
</li>
<li><p>捕捉函数执行期间，被屏蔽信号多次发生，解除屏蔽后只处理一次</p>
</li>
</ul>
<p>案例：用signal()函数对信号2进行捕抓</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        signal(SIGINT,sig_cath);      <span class="comment">//当信号SIGINT产生时，对其捕抓，去执行对应捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：用sigaction()函数对信号2进行捕抓(可以设置多个函数的捕抓)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="keyword">if</span>(signo == SIGINT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGQUIT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---catch you---%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span>     <span class="comment">//定义两个结构体</span></span><br><span class="line">        act.sa_handler = sig_cath;     <span class="comment">//设置回调函数(捕抓函数)</span></span><br><span class="line">        sigemptyset(&amp;(act.sa_mask));    <span class="comment">//将sa_mask屏蔽字置为0，这个只在sig_catch函数工作时有效</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;               <span class="comment">//默认值(在一个信号的捕抓函数执行时，默认蒙蔽该信号，防止再来)</span></span><br><span class="line">        <span class="type">int</span> ret = sigaction(SIGINT,&amp;act,&amp;oldact);     <span class="comment">//注册信号捕抓函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = sigaction(SIGQUIT,&amp;act,&amp;oldact);   <span class="comment">//注册第二个信号捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过信号捕捉回收子进程(当一个时间点有多个进程死亡时，此时只能处理一个，其他死亡的子进程没有回收就会是僵尸进程)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signo)</span>&#123;      <span class="comment">//有子进程终止，发送SIGCHLD信号时，该函数会被内核回调</span></span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>))!=<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;---catch child id %d,ret = %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="comment">//阻塞(防止父线程还没有注册完成，部分子线程就已经结束了，这样就来不及回收那些结束的子进程)</span></span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>;    <span class="comment">//自定义阻塞信号集</span></span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);   <span class="comment">//将自定义阻塞信号集的SIGCHLD信号置1，使其与pcd里面的阻塞信号集作用，让该信号阻塞</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);     <span class="comment">//使其与pcd的阻塞信号集作用</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                <span class="comment">//初始化act结构体</span></span><br><span class="line">                act.sa_handler = catch_child;     <span class="comment">//捕捉函数</span></span><br><span class="line">                sigemptyset(&amp;act.sa_mask);        <span class="comment">//设置捕捉函数执行期间的屏蔽信号集，全置为0</span></span><br><span class="line">                act.sa_flags = <span class="number">0</span>;                 <span class="comment">//设置默认属性，本信号自动屏蔽</span></span><br><span class="line">                sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);     <span class="comment">//子进程状态发生改变就触发捕捉函数</span></span><br><span class="line">                <span class="comment">//解除阻塞(父进程注册完毕，可以开始接收子线程结束后，内核传给父进程的信号了)</span></span><br><span class="line">                sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);   <span class="comment">//如果没有解除阻塞步骤，回调函数没有执行的机会(因为pcd的mask对该信号是屏蔽状态)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">                <span class="comment">//sleep(i);    //可以用sleep进行一个一个回收</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-会话与守护进程"><a href="#6-会话与守护进程" class="headerlink" title="6.会话与守护进程"></a>6.会话与守护进程</h1><h2 id="6-1进程组和会话"><a href="#6-1进程组和会话" class="headerlink" title="6.1进程组和会话"></a>6.1进程组和会话</h2><blockquote>
<p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化对多个进程的管理。当父进程，创建子进程的时候，默认子进程与父进程属于同一个进程组。进程组ID &#x3D; 第一个进程ID(组长进程)。所以，组长进程标识，其进程组ID &#x3D; 其进程ID。</p>
<p>而会话就是进程组的集合。</p>
</blockquote>
<p>1.创建一个会话需要注意以下6点：</p>
<ul>
<li>调用进程不能是进程组组长，该进程变成新会话的首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要root权限 (Ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>如果该进程调用的是组长进程，则出错返回</li>
<li>建立新会话时，先调用fork，父进程终止，子进程调用setsid（）</li>
</ul>
<p>2.getsid()函数：获取进程所属的会话ID</p>
<p>pid_t getsid(pid_t pid);</p>
<ul>
<li><p>参数：pid为所需要获取的进程</p>
</li>
<li><p>返回值：成功(返回调用进程的会话ID)；失败(返回-1，设置errno)</p>
</li>
</ul>
<p>注意：组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程</p>
<p>3.setsid()函数：创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</p>
<p>pid_t setsid(void); </p>
<p>返回值：成功(返回调用进程的会话ID)；失败(返回-1)</p>
<p>注意：调用setsid函数的进程，既是新的会长，也是新的组长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子进程成立新会话(父进程不能创建会话)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子进程执行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id(父进程的)---&gt;0为默认调用该程序的进程组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id(有可能是父进程的，也可能是父进程的父进程的)</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                setsid();   <span class="comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程(子进程id=组进程id=会话进程id)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;changed:\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id</span></span><br><span class="line">               sleep(<span class="number">20</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2守护进程"><a href="#6-2守护进程" class="headerlink" title="6.2守护进程"></a>6.2守护进程</h2><blockquote>
<p>daemon进程。通常运行于操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发送或周期性执行某一动作。不受用户登录注销影响，通常采用以d结尾的命名方式。</p>
</blockquote>
<p>1.创建守护进程，最关键的一步是调用setsid函数，创建一个新的Session，并成为Session leader。</p>
<p>2.守护进程的创建步骤：</p>
<ul>
<li><p>fork子进程，让父进程终止</p>
</li>
<li><p>子进程调用setsid()创建新会话</p>
</li>
<li><p>通常根据需要，改变工作目录位置chdir()</p>
</li>
<li><p>通常根据需要，重设umask文件权限掩码</p>
</li>
<li><p>通常根据需要，关闭&#x2F;重定向文件描述符012</p>
</li>
<li><p>守护进程 业务逻辑。—-&gt;while()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//守护进程的创建(运行在后台)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> ret,fd;</span><br><span class="line">        <span class="comment">//1、创建子进程，父进程终止</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//父进程终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、子进程创建新会话</span></span><br><span class="line">        <span class="comment">//printf(&quot;---------------------\n&quot;);</span></span><br><span class="line">        pid = setsid();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、改变工作目录位置</span></span><br><span class="line">        ret = chdir(<span class="string">&quot;/home/c_c++后端/系统编程/session_dir&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、改变文件访问权限掩码</span></span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line">        <span class="comment">//5、关闭文件描述符 (此时就可用的最小文件描述符是3)</span></span><br><span class="line">        close(STDIN_FILENO);     <span class="comment">//关闭文件描述符0</span></span><br><span class="line">        fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);   <span class="comment">//读写打开dev/null文件 -----&gt;fd=0</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);    <span class="comment">//将文件描述符1指向fd</span></span><br><span class="line">        dup2(fd,STDERR_FILENO);    <span class="comment">//将文件描述符2指向fd</span></span><br><span class="line">        <span class="comment">//6 一直运行，等待接收命令</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//模拟守护进程业务</span></span><br><span class="line">        <span class="comment">//printf(&quot;------------------\n&quot;);       </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-线程"><a href="#7-线程" class="headerlink" title="7.线程"></a>7.线程</h1><blockquote>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位，同一进程中的多条线程将共享该进程中的全部系统资源，但同一进程中的多个线程有各自的调用栈、寄存器环境和线程本地存储。</p>
</blockquote>
<p>1.线程与进程区别：</p>
<ul>
<li><p>进程：有独立的进程地址空间，有独立的pcb</p>
</li>
<li><p>线程：有独立的pcb，没有独立的进程地址空间—&gt;是轻量级进程LWP</p>
</li>
</ul>
<p>注意：线程是最小的执行单位；进程是最小分配资源单位，可看成是只有一个线程的进程。进程里创建线程后，进程也叫线程了</p>
<p>2.查看某个进程里的线程：</p>
<ul>
<li>ps -Lf 进程pid：线程号是LWP那一栏(相当于进程号，线程号是接在进程号后面的)</li>
</ul>
<p>3.线程共享资源：文件描述符、每种信号的处理的方式、当前工作目录、用户ID和组ID、内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)、全局变量；</p>
<p>4.线程非共享资源：线程id、处理器现场和栈指针(内核栈)、独立的栈空间(用户空间栈)、errno变量、信号屏蔽字、调度优先级</p>
<p>5.线程优缺点</p>
<ul>
<li><p>优点：提高程序并发性、开销小、数据通信、共享数据方便；</p>
</li>
<li><p>缺点：是库函数，不稳定、调试、编写困难、对信号支持不好</p>
</li>
</ul>
<h2 id="7-1线程控制原语"><a href="#7-1线程控制原语" class="headerlink" title="7.1线程控制原语"></a>7.1线程控制原语</h2><p>1.线程函数</p>
<p><code>pthread_t pthread_self(void);</code></p>
<ul>
<li><p>返回值：本线程id号</p>
</li>
<li><p>作用：获取线程id，线程id是在进程地址空间内部用来标识线程身份的</p>
</li>
</ul>
<p>注意：线程ID是在进程中来标识线程身份的，进程通过线程ID来对其加以区分；而LWP是线程号，标识线程身份给CPU用的(CPU用线程号来划分时间片)</p>
<p>2.创建线程</p>
<p><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void*),void *arg);</code></p>
<ul>
<li><p>参1：传出参数，表示新创建的子线程id</p>
</li>
<li><p>参2：线程属性，传NULL表示使用默认属性</p>
</li>
<li><p>参3：子线程回调函数，若创建成功，pthread_create函数返回时，该函数会被自动调用</p>
</li>
<li><p>参4：参数3函数的参数，没有的话就传NULL</p>
</li>
<li><p>返回值：成功(返回0)；失败(errno)</p>
</li>
</ul>
<p>注意：主函数利用pthread_create()创建新线程时，主函数会立即返回值并执行下面代码，不会因为新线程没有执行完回调函数而阻塞。</p>
<p>当新线程启动后，它会在后台执行回调函数，同时主线程继续执行自己的任务。如果回调函数执行时间较长，主线程仍然不会被阻塞，它会继续往下执行，直到遇到需要等待新线程完成任务的代码段。</p>
<p>3.退出当前线程</p>
<p><code>void pthread_exit(void *retval);</code></p>
<ul>
<li>参数：退出值，无退出值时，NULL</li>
</ul>
<p>注意：exit()是退出当前进程；return;是返回到调用者那里去</p>
<p>pthread_exit(NULL)的作用是在线程中显式地退出线程的函数调用。它用于终止当前线程的执行，并将线程的退出状态设置为NULL。当调用pthread_exit(NULL)时，当前线程会立即退出，并将控制返回给创建该线程的线程。这意味着线程的执行会终止，但其他线程仍然可以继续执行。</p>
<p>4.阻塞等待线程退出，获取线程退出状态</p>
<p><code>int pthread_join(pthread_t thread,void** retval);</code></p>
<ul>
<li><p>参1：要回收的线程id</p>
</li>
<li><p>参2：传出参数，存储线程退出的状态，线程正常退出，得到来自该线程在回调函数中返回的信息；线程异常退出，返回-1.</p>
</li>
<li><p>返回值：成功回收(返回0)，失败(errno)</p>
</li>
</ul>
<blockquote>
<p>注意：在进程中，进程结束是exit(1)，退出状态是int型，所以回收进程wait的参数是<code>int*</code>型；在线程中，线程结束是<code>pthread_exit(void*)</code>，退出状态是<code>void*</code>型，所以回收线程pthread_join参数是<code>void**</code>型。</p>
</blockquote>
<p>5.杀死(取消)线程，类似于进程中的kill()</p>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
<ul>
<li><p>参数：待杀死的线程id</p>
</li>
<li><p>返回值：成功(0)；失败(errno)</p>
</li>
</ul>
<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>如果子线程没有到达取消点，那么使用pthread_cancel无效。我们可以在程序中。手动添加应该取消点，使用pthread_testcancel()。</p>
<p>取消点：通常是一些系统调用creat,open,pause,close,read,write。(可以理解为是线程有进入内核，如果线程执行的内容是if,while,for这些则不能用pthread_cancel()杀死)</p>
<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<p>6.线程出错要用这个函数打印</p>
<p><code>char *strerror(int errnum);</code></p>
<ul>
<li>使用：fprintf(stderr,”pthread_join error:%s”,strerror(ret));</li>
</ul>
<p>7.实现线程分离</p>
<p><code>int pthread_detach(pthread_t thread); </code></p>
<ul>
<li><p>参数：待分离的线程id</p>
</li>
<li><p>返回值：成功(0),失败(errno)</p>
</li>
</ul>
<p>注意：pthread_detach不能与pthread_join一起用，当使用线程分离时，被分离的子线程就不归主线程管了，子线程执行完由系统回收，不需要主线程再调用pthread_join来回收，如果调用，会回收失败。</p>
<p>8.线程属性，用来设置分离属性</p>
<ul>
<li><p><code>pthread_attr_t attr;            //创建一个线程属性结构体变量</code></p>
</li>
<li><p><code>pthread_attr_init(&amp;attr);       //初始化线程属性</code></p>
</li>
<li><p><code>pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);    //设置</code></p>
</li>
<li><p><code>pthread_create(&amp;tid,&amp;attr,tfn,NULL);                //设置线程属性，创建为分离态</code></p>
</li>
<li><p><code>pthread_attr_destroy(&amp;attr);                       //销毁线程属性</code></p>
</li>
</ul>
<p>案例：创建一个线程执行回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程，先慢慢执行\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，先结束了\n&quot;</span>);</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：循环创建多个子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用pthread_exit()函数来退出子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//exit(0);      //表示退出进程，所以i=2后的线程都执行不了</span></span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);    <span class="comment">//将当前线程退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_join()回收子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> var;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;     <span class="comment">//方法2：通过在主函数中定义一个结构体变量来实现</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">tval</span> =</span> (<span class="keyword">struct</span> thrd *)arg;</span><br><span class="line">        tval-&gt;var = <span class="number">93</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(tval-&gt;str,<span class="string">&quot;hello lxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)tval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">/*struct thrd *retval;  </span></span><br><span class="line"><span class="comment">        int ret = pthread_create(&amp;tid,NULL,tfn,NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> <span class="title">arg</span>;</span>     <span class="comment">//定义一个结构体变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">retval</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)&amp;arg);</span><br><span class="line">    	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(tid,(<span class="type">void</span> **)&amp;retval);    <span class="comment">//回收子线程(阻塞)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child thread exit with var = %d,str = %s\n&quot;</span>,retval-&gt;var,retval-&gt;str);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);   <span class="comment">//线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_cancel()终止子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        ret = pthread_cancel(tid);       <span class="comment">//终止子线程</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_cancel error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while(1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_detach()设置线程分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_detach(tid);            <span class="comment">//设置线程分离</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_detach error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        ret = pthread_join(tid,<span class="literal">NULL</span>);     <span class="comment">//接收失败会返回非0值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;join ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_join error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过线程属性设置分离属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过线程属性设置来使子线程分离，这样就可以创建一个是一个了，而不需要后面手动一个一个设置</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">pthread_attr_t</span> attr;     <span class="comment">//定义属性结构体</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = pthread_attr_init(&amp;attr);    <span class="comment">//初始化属性结构体(传出参数)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_init error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);      <span class="comment">//设置线程属性为 分离属性</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_setdetachastate error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s&quot;</span>,strerror(ret));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        ret = pthread_attr_destroy(&amp;attr);    <span class="comment">//销毁属性结构体</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_destroy error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 returning\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn3</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 3 returning\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pthread_testcancel();   //自动添加取消点</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *tret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn3,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code = %d\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2线程使用注意事项"><a href="#7-2线程使用注意事项" class="headerlink" title="7.2线程使用注意事项"></a>7.2线程使用注意事项</h2><p>线程使用注意事项：</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应该调用pthread_exit()</p>
</li>
<li><p>避免僵尸线程，使用pthread_join、pthread_detach、pthread_create(指定分离属性)</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放(线程共享堆)</p>
</li>
<li><p>应该避免在多线程模型中调用fork。除非马上exec。因为如果调用fork，则子进程中只有调用fork的线程存在，其他线程在子进程中均默认被pthread_exit</p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
</li>
</ul>
<h1 id="8-线程同步"><a href="#8-线程同步" class="headerlink" title="8.线程同步"></a>8.线程同步</h1><p>协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误。</p>
<p>锁的使用：建议锁，对公共数据进行保护。所有线程应该在访问公共数据前先拿锁再访问。但锁本身不具备强制性。</p>
<h2 id="8-1互斥锁mutex"><a href="#8-1互斥锁mutex" class="headerlink" title="8.1互斥锁mutex"></a>8.1互斥锁mutex</h2><p>1.使用互斥锁的一般步骤：</p>
<ul>
<li><p><code>pthread_mutex_t lock;         //创建锁</code></p>
</li>
<li><p><code>pthread_mutex_init;           //初始化</code></p>
</li>
<li><p><code>pthread_mutex_lock;           //加锁</code></p>
</li>
<li><p>访问共享数据(stdout)</p>
</li>
<li><p><code>pthread_mutex_unlock();      //解锁</code></p>
</li>
<li><p><code>pthread_mutex_destroy;       //销毁锁</code></p>
</li>
</ul>
<p>补：restrict关键字：用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成。</p>
<p>2.初始化互斥锁的两种方法： </p>
<ul>
<li><p><code>pthread_mutex_t mutex;                             //定义一把锁</code></p>
</li>
<li><p><code>pthread_mutex_t_init(&amp;mutex,NULL);                 //动态初始化</code></p>
</li>
<li><p><code>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;   //静态初始化</code></p>
</li>
</ul>
<p>注意：尽量保证锁的粒度(范围)，越小越好。访问共享数据前加锁，访问结束立即解锁。</p>
<p>方便记忆：互斥锁，本质是结构体。我们可以看成整数，初值为1，即pthread_mutex_init()调用成功；加锁理解为–操作，阻塞线程；解锁理解为++操作，唤醒阻塞在锁上的线程。</p>
<p>try锁：尝试加锁，成功–操作；失败就返回，同时设置错误号EBUSY。</p>
<p>案例：通过互斥锁进行对公共区域的访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;          <span class="comment">//定义一把互斥锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);        <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);            <span class="comment">//模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lxx\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);      <span class="comment">//解锁              </span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> ret = pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);     <span class="comment">//对锁进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;mutex init error:%s\n&quot;</span>,strerror(ret));  <span class="comment">//打印错误信息</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);     <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                <span class="comment">//这里睡眠了1到3秒，但因为有加锁，输出依然是完整的HELLO WORLD</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);   <span class="comment">//解锁</span></span><br><span class="line">            	sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);         <span class="comment">//销毁锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2读写锁"><a href="#8-2读写锁" class="headerlink" title="8.2读写锁"></a>8.2读写锁</h2><blockquote>
<p>锁只有一把，以读方式给数据加锁为读锁；以写方式给数据加锁为写锁。相较于互斥量(互斥锁)而言，当读线程多的时候，读写锁可以提高访问效率。</p>
</blockquote>
<p>1.读写锁的特性</p>
<ul>
<li><p>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求，优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</p>
</li>
</ul>
<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。即写独占，读共享</p>
<p>2.主要应用函数</p>
<ul>
<li><p><code>pthread_rwlock_init                  //自定义读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_destroy               //销毁读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_rdlock                //读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_wrlock                //写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_tryrdlock            //尝试读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_trywrlock            //尝试写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_unlock               //读写锁解锁(通用)</code></p>
</li>
</ul>
<p>以上函数的返回值都是：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_rwlock_t rwlock             //定义一个读写锁变量rwlock</code></li>
</ul>
<p>3.死锁</p>
<p>是使用锁不恰当导致的现象，如：</p>
<ul>
<li><p>对一个锁反复lock</p>
</li>
<li><p>两个线程，各自持有一把锁，请求另一把</p>
</li>
</ul>
<p>案例：模拟3个线程不定时写同一个全局资源，5个线程不定时读同一个全局资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> counter;                  <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;      <span class="comment">//全局的读写锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;    <span class="comment">//写的回调函数</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传进来的参数进行转换</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_wrlock(&amp;rwlock);   <span class="comment">//写锁加锁</span></span><br><span class="line">                t = counter;    <span class="comment">//方便后面打印先前一个数</span></span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;======Write %d:%lu:counter = %d ++counter = %d\n&quot;</span>,i,pthread_self(),t,++counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);   <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;           <span class="comment">//读的回调函数</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_rdlock(&amp;rwlock);    <span class="comment">//读锁加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------Read %d: %lu: %d\n&quot;</span>,i,pthread_self(),counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);    <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pthread_t</span> tid[<span class="number">8</span>];                     <span class="comment">//定义一个线程组</span></span><br><span class="line">        pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);    <span class="comment">//初始化读写锁</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i],<span class="literal">NULL</span>,th_write,(<span class="type">void</span> *)i);         <span class="comment">//前面三个线程负责写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i+<span class="number">3</span>],<span class="literal">NULL</span>,th_read,(<span class="type">void</span> *)(i+<span class="number">3</span>));    <span class="comment">//后面五个线程负责读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                pthread_join(tid[i],<span class="literal">NULL</span>);                 <span class="comment">//主线程回收子线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_destroy(&amp;rwlock);                   <span class="comment">//销毁读写锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3条件变量"><a href="#8-3条件变量" class="headerlink" title="8.3条件变量"></a>8.3条件变量</h2><blockquote>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用。</p>
</blockquote>
<p>1.主要应用函数：</p>
<ul>
<li><p><code>pthread_cond_init函数      //初始化条件变量</code></p>
</li>
<li><p><code>pthread_cond_destroy函数   //销毁条件变量</code></p>
</li>
<li><p><code>pthread_cond_wait函数      //等待条件满足</code></p>
</li>
<li><p><code>pthread_cond_timewait函数  //等待条件满足(超时不等)</code></p>
</li>
<li><p><code>pthread_cond_signal函数    //唤醒阻塞在条件变量的线程(一个)</code></p>
</li>
<li><p><code>pthread_cond_broadcast函数   //唤醒阻塞在条件变量的线程(多个)</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_cond_t cond;       //定义一个条件变量cond</code></li>
</ul>
<p>2.初始化条件变量的两种方法：</p>
<p><code>pthread_cond_t cond;                     //定义一个条件变量</code></p>
<ul>
<li><p><code>pthread_cond_t_init(&amp;cond,NULL);                //动态初始化</code></p>
</li>
<li><p><code>pthread_cond_t cond=PTHREAD_MUTEX_INITIALIZER; //静态初始化</code></p>
</li>
</ul>
<p>3.pthread_cond_wait函数作用：</p>
<ul>
<li><p>阻塞等待条件变量cond(参1)满足</p>
</li>
<li><p>释放已掌握的互斥锁，相当于pthread_mutex_unlock(&amp;mutex)。</p>
</li>
</ul>
<p>注意：上面两步为一个原子操作(中间不会分开执行)</p>
<ul>
<li>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex)</li>
</ul>
<p>案例：模拟一个消费者-生产者模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">err_thread</span><span class="params">(<span class="type">int</span> ret,<span class="type">char</span>*str)</span>&#123;        <span class="comment">//线程创建失败调用的打印错误信息的函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s:%s\n&quot;</span>,str,strerror(ret));</span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span>                      <span class="comment">//定义一个结构体来存放信息</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;     <span class="comment">//定义并初始化一个互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_data = PTHREAD_COND_INITIALIZER;     <span class="comment">//定义并初始化一个条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">produser</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//生产者的回调函数：生产数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));    <span class="comment">//创建一个节点</span></span><br><span class="line">                mp-&gt;num = rand()%<span class="number">1000</span>+<span class="number">1</span>;                        <span class="comment">//模拟随机产生一个数值</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------produce %d\n&quot;</span>,mp-&gt;num);         <span class="comment">//打印生产者产生的数据</span></span><br><span class="line">                <span class="comment">//后插法生产数据(将数据结点连起来)</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);                    <span class="comment">//加锁，互斥锁</span></span><br><span class="line">                mp-&gt;next = head;</span><br><span class="line">                head = mp;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);                  <span class="comment">//解锁互斥锁</span></span><br><span class="line"></span><br><span class="line">                pthread_cond_signal(&amp;has_data);                <span class="comment">//唤醒阻塞在条件变量 has_data上的线程</span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                               <span class="comment">//随机睡眠</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//消费者的回调函数：消费数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);           <span class="comment">//加锁，互斥量</span></span><br><span class="line">                <span class="keyword">while</span>(head == <span class="literal">NULL</span>)&#123;    <span class="comment">//当是空的时候，才对消费者进行阻塞等待，阻塞期间，会解锁，让生产者拿锁生产数据(如果是只有一个消费者可以是if，多个消费者则需要while)</span></span><br><span class="line">                        pthread_cond_wait(&amp;has_data,&amp;mutex);   <span class="comment">//阻塞等待条件变量，当有数据时，消费者就会被激活，且自动加锁</span></span><br><span class="line">                &#125;  <span class="comment">//如果有多个消费者，而用的是if，则会出现没有数据时，消费者还在消费，即吐核问题</span></span><br><span class="line">                mp = head;</span><br><span class="line">                head = mp-&gt;next;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-------------cconsumer id:%lu : %d\n&quot;</span>,pthread_self(),mp-&gt;num);</span><br><span class="line">                <span class="built_in">free</span>(mp);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid1,cid2;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;pid,<span class="literal">NULL</span>,produser,<span class="literal">NULL</span>);     <span class="comment">//创建一个生产者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create produser error&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid1,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第一个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer1 error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid2,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第二个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer2 error&quot;</span>);</span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);          <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid1,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid2,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9.信号量"></a>9.信号量</h1><blockquote>
<p>应用于线程、进程间同步，因为互斥锁对于多个线程访问同一个公共内存空间时，只能一个一个访问，虽然保证了数据正确性的目的，但导致了线程的并发性下降。</p>
<p>信号量是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
</blockquote>
<p>1.主要应用函数</p>
<ul>
<li><p><code>sem_init           //信号量初始化</code></p>
</li>
<li><p><code>sem_destroy        //信号量销毁</code></p>
</li>
<li><p><code>sem_wait           //信号量加锁</code></p>
</li>
<li><p><code>sem_trywait  </code></p>
</li>
<li><p><code>sem_timedwait</code></p>
</li>
<li><p><code>sem_post          //信号量解锁</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(-1)</p>
<p>2.int sem_init(sem_t *sem,int pshared,unsigned int value);</p>
<ul>
<li><p>参1：信号量</p>
</li>
<li><p>参2：0—&gt;用于线程间同步；1—&gt;用于进程间同步</p>
</li>
<li><p>参3：N值(指定同时访问的线程数)</p>
</li>
</ul>
<p>3.sem_wait()：一次调用，做一次–操作，当信号量的值为0时，再次–就会阻塞(对比pthread_mutex_lock)</p>
<p>4.sem_post()：一次调用，做一次++操作，当信号量的值为N时，再次++就会阻塞(对比pthread_mutex_unlock)</p>
<p>案例：用信号量实现生产者-消费者模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                      <span class="comment">//全局数值实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number,product_number;   <span class="comment">//空格子信号量，产品信号量</span></span><br><span class="line"><span class="comment">//开始时，空格子为N，产品格子为0</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;blank_number);   <span class="comment">//生产者将格子数--，为0则阻塞等待(说明产品满了)</span></span><br><span class="line">                <span class="built_in">queue</span>[i]=rand()%<span class="number">100</span>+<span class="number">1</span>;     <span class="comment">//生产一个产品</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;------produce------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                sem_post(&amp;product_number);     <span class="comment">//将产品数++</span></span><br><span class="line"></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;        <span class="comment">//借助下标实现环形</span></span><br><span class="line">                sleep(rand()%<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;product_number);   <span class="comment">//消费者将产品数--，为0则阻塞等待(说明还没有产品可以消费)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-----consumer------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                <span class="built_in">queue</span>[i]=<span class="number">0</span>;                 <span class="comment">//消费一个产品</span></span><br><span class="line">                sem_post(&amp;blank_number);    <span class="comment">//消费掉以后，将空格子数++</span></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid;</span><br><span class="line">        sem_init(&amp;blank_number,<span class="number">0</span>,NUM);    <span class="comment">//初始化空格子信号量为5，0表示线程间同步</span></span><br><span class="line">        sem_init(&amp;product_number,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//初始化产品数信号量为0</span></span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;pid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);   <span class="comment">//创建生产者</span></span><br><span class="line">        pthread_create(&amp;cid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);   <span class="comment">//创建消费者</span></span><br><span class="line"></span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(cid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;blank_number);</span><br><span class="line">        sem_destroy(&amp;product_number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>管道</tag>
        <tag>信号</tag>
        <tag>pthread</tag>
        <tag>signal</tag>
      </tags>
  </entry>
</search>
