<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Http高并发服务器项目</title>
    <url>/2024/08/20/Http%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>该项目的架构是B&#x2F;S架构，也就是说客户端是浏览器，在本地随便一个浏览器即可；服务器是在linux上搭建的一个应用程序，该程序可以是多线程版的，也可以是单反应堆模型或者是多反应堆模型，反正最终都可以给客户端提供服务。</p>
<p>过程：</p>
<p>客户端(浏览器)向服务器发送一个Http请求，服务器就能把指定目录下的资源给到客户端(浏览器)，浏览器就能将得到的数据展示到界面上。如果解析不了该文件，就会自动下载到本地，如果能够展示，它在本地指定的下载目录是不会又对应文件的，因为它下载到本地之后，就直接将内容显示到窗口上了，可以理解为它下载下来的只是一个缓存，该缓存能够支撑它在浏览器上把内容显示出来，当数据显示完成之后，浏览器会定期地清除缓存，那么该资源也就不存在了。</p>
<h1 id="2-单反应堆的服务器模型"><a href="#2-单反应堆的服务器模型" class="headerlink" title="2. 单反应堆的服务器模型"></a>2. 单反应堆的服务器模型</h1><p>在网络编程中，为了提高访问通信的效率，就可以使用单反应堆的服务器模型，它是IO多路复用与多线程相结合的一种技术。</p>
<p>设计思路：</p>
<p>在主线程里面，服务器绑定本地的ip和端口来得到一个通信的套接字，因为通信的套接字需要监听它的读事件，所以就将它的读事件注册给Reactor，也就是反应堆模型。该反应堆模型底层用到的是poll、epoll或select，这三种IO多路转接技术不是同时用，而是选择其中的某一种。在选择了底层的IO模型之后，把用于监听的文件描述符的读事件注册给该模型，然后内核就可以帮助我们检测这用于监听的文件描述符的读事件是否被激活了。如果被激活了，说明有新连接到达，那么我们就需要调用用于监听的文件描述符对应的处理函数，该处理函数其实就是负责与对端建立新连接，主要的处理核心动作核就是调用accept()函数，因此就能得到一个用于通信的文件描述符，然后对该通信描述符进行一个封装。在封装的时候，给该用于通信的文件描述符指定了读回调和写回调，至于为什么要指定读写回调，是因为反应堆模型就是基于回调的。TcpConnection模型当检测到了对应的文件描述符它的读事件或写事件被触发了之后，该框架就会自动的调用这个事件的处理函数，这种机制就称为反应堆机制。其实本质就是回调函数。</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_10.png" style="zoom:67%;">

<h1 id="3-多反应堆的服务器模型"><a href="#3-多反应堆的服务器模型" class="headerlink" title="3. 多反应堆的服务器模型"></a>3. 多反应堆的服务器模型</h1><p>对于多反应堆模型，反应堆的数量取决于线程的数量。</p>
<p>在主线程里面，它是有一个用于监听的套接字Listener，我们需要将它注册给主线程的MainReactor反应堆模型。在主线程的反应堆模型里面可以选择poll、epoll或select，它们就能帮助我们检测对应的监听文件描述符的读事件是否被触发。如果被触发了，就需要建立一个新连接，调用accept()函数得到一个新的用于通信的文件描述符connfd。然后对它进行封装，封装时为它指定一个读回调和写回调。又因为这是一个多反应堆模型，在得到了用于通信的套接字之后，就不要在主线程里面做通信了，把通信交给主线程的线程池，在主线程的线程池里面有多个子线程，每个子线程里面也有一个反应堆模型，该反应堆模型里面主要就是指定的IO多路转接poll、epoll或select。</p>
<p>然后我们只需要把用于通信的文件描述符的事件注册给到对应的子线程的反应堆模型(随机给的)，因为这个过程是做了注册的，所以当用于通信的套接字，它的读事件或写事件触发了，对应的回调函数就会知道。当真正的事件被触发之后，子线程里的反应堆模型就会调用响应的处理函数。</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_11.png" style="zoom:67%;">

<h1 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h1><h2 id="4-1-http请求"><a href="#4-1-http请求" class="headerlink" title="4.1 http请求"></a>4.1 http请求</h2><p>属于应用层协议，位于最上层，通过这个协议就可以对通信的数据进行封装。如果网络模型是B&#x2F;S结构，就必须使用<code>http</code>协议，<code>https</code>协议是在<code>http</code>协议的基础上做了加密。</p>
<p>在数据发送之前，使用协议对数据进行封装，接收到数据之后，按照协议格式解析接收到的数据。</p>
<p>Http协议分为两部分：</p>
<p>1.http请求</p>
<ul>
<li><p>客户端给服务器发送数据，叫<code>http</code>请求，有两种请求方式</p>
<ul>
<li><p>get请求</p>
</li>
<li><p>post请求</p>
</li>
</ul>
</li>
</ul>
<p>2.http响应</p>
<ul>
<li>服务器给客户端回复数据叫做<code>http</code>响应</li>
</ul>
<p><code>http</code>协议封装好数据之后是一个数据块，得到若干行数据，使用的换行符是<code>\r\n</code>。通过这个<code>\r\r</code>进行判断，就知道这行是否结束了。</p>
<blockquote>
<p>http请求消息分为四部分：</p>
<p>1.请求行</p>
<ul>
<li>不管get请求还是post请求，请求行是分为三部分</li>
</ul>
<p>2.请求头</p>
<p>3.空行</p>
<p>4.客户端向服务器提交的数据</p>
</blockquote>
<p>如果使用get方式提交数据，第四部分是空的。</p>
<p>get与post分析比较:</p>
<ol>
<li><p>从给服务器发送的数据的量上来分析</p>
<ul>
<li>get：主要是向服务器索取数据，提交的数据量比较少</li>
<li>post：上传文件一般都会使用post，可以提交的数据量是非常大的</li>
</ul>
</li>
<li><p>从上传的数据安全性来分析</p>
<ul>
<li>get：提交的数据不安全，提交的数据会显示到地址栏中，数据容易被泄露</li>
<li>post：提交的数据并不会显示到地址栏中，完全不可见的，因此更安全</li>
</ul>
</li>
</ol>
<h2 id="4-2-get请求"><a href="#4-2-get请求" class="headerlink" title="4.2 get请求"></a>4.2 get请求</h2><p>下面是浏览器对用户的请求数据进行了封装之后，得到的原始的http请求数据：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93:9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>

<p>第1行是请求行：分为3部分，</p>
<ul>
<li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p>
</li>
<li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p>
</li>
<li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p>
</li>
</ul>
<p>第2-8行是请求头：由若干个键值对组成：</p>
<ul>
<li><p>Host表示要连接的服务器是192.168.88.93，绑定的端口是9393；</p>
</li>
<li><p>Connection的keep-alive表示客户端想要与服务器一直保持连接</p>
</li>
<li><p>User-Agent表示浏览器的版本，指的是内核版本</p>
</li>
<li><p>Accept-Encoding设置压缩的方式使用的是gzip</p>
</li>
<li><p>Accept-Language设置默认的语言</p>
</li>
</ul>
<p>注意：如果我们使用的是get请求，并且get请求里面携带了一些动态数据，这些数据会出现在浏览器的地址栏里面，而该地址栏它的缓存是有上限的，因此如果携带的数据量很多，后面的数据就会丢失。</p>
<p>第9行是空行，空行完之后，就是通过这个请求协议给服务器提交的数据。如果是get请求，这部分内容是空的。因为如果通过get请求向服务器提交动态数据，这个动态数据也不会出现在请求协议的第4部分，而是出现在请求行的第2部分，即：</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_12.png" style="zoom:67%;">

<h2 id="4-3-post请求"><a href="#4-3-post请求" class="headerlink" title="4.3 post请求"></a>4.3 post请求</h2><p>下面是post请求数据的格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.88.93：9393</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>98</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.106 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">username</span>=subwen%<span class="number">40</span>qq.com&amp;phon=<span class="number">111111</span>&amp;email=sub%<span class="number">40</span>qq.com&amp;date=<span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>&amp;sex=male&amp;class=<span class="number">1</span>&amp;rule=<span class="literal">on</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们通过post向服务器提交数据，那么这个数据肯定是动态的，即请求的数据在服务器上是不存在的。如注册账号，向服务器提供用户名和密码等信息。</p>
<p>第1行是请求行：分为3部分，</p>
<ul>
<li><p>第1部分是请求的方式，主要有两种，一种是get，另一种是post。如果客户端给服务器发送的是get请求，说明请求的是服务器上的静态文件，即就是在服务器上，这些文件已经被提供好了的(就是在服务器上已经存在的文件)，我们通过浏览器向服务器发起一个访问某个文件的请求，这就是get请求。</p>
</li>
<li><p>第2部分是请求的资源，&#x2F;代表服务器提供的资源目录(不代表是服务器的根目录)，该资源目录可以是服务上的任意一个目录，只要存在即可。</p>
</li>
<li><p>第3部分是http的版本，现在一般用的都是http的1.1版本</p>
</li>
</ul>
<p>第2-12行是请求头：由若干个键值对组成：</p>
<ul>
<li>Content-Length表示提交的内容长度</li>
<li>Content-Type表示客户端向服务器提交的数据块的格式(还有其它很多种格式)</li>
</ul>
<p>第13行是空行\r\n</p>
<p>第14行是客户端向服务器提交的数据块</p>
<h2 id="4-4-http响应"><a href="#4-4-http响应" class="headerlink" title="4.4 http响应"></a>4.4 http响应</h2><blockquote>
<p>服务器给客户端回复数据，称之为http响应，协议的格式分为四部分：：<br>1.状态行</p>
<p>2.消息报头&#x2F;响应头</p>
<p>3.空行</p>
<p>4.回复给客户端的数据块</p>
<ul>
<li>http响应消息也是一个数据块，若干行组成，换行是\r\n</li>
</ul>
</blockquote>
<p>响应消息(Response)</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">Http/1.1 200 Ok</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>micro_httpd</span><br><span class="line"><span class="attribute">Data</span><span class="punctuation">: </span>Fri, 18 Jul 2014 14:34:26 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain; charset=iso-8859-1 (必选项)</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>32</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://www.lxx93.online</span><br><span class="line"><span class="attribute">Content-Language</span><span class="punctuation">: </span>zh-CN</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 18 Jul 2014 08:36:36 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;hello world!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第1行是状态行，分为3部分：</p>
<ol>
<li><p>Http的版本</p>
</li>
<li><p>服务器对客户端请求的处理状态(状态码)，200就代表处理成功了</p>
</li>
<li><p>是对状态码的描述</p>
</li>
</ol>
<p>第2到9行是响应头，由一系列的键值对组成：</p>
<ul>
<li>Content-Type：表示的是http响应消息，响应的数据块的格式，text&#x2F;plain代表的是一个纯文本，charset表示使用的字符编码</li>
<li>Content-Length：表示服务器给客户端回复的数据块的大小(要准确，不确定的话就不写)</li>
</ul>
<p>第10行是空行</p>
<p>第11到16行是http响应给客户端的信息</p>
<p>http状态码类别：</p>
<p>状态码有三位数字组成，第一个数字定义了响应的类别，共分5种类别：</p>
<ul>
<li>1xx：指示信息–表示请求已经被接收，没有处理完，还正在处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作(网络地址的重新访问)</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<p>常见的状态码：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">状态描述</th>
<th align="center">文字描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">客户端请求成功</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="center">客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="center">请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">请求资源不存在，如：输入了错误的URL</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器发送不可预期的错误</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Server Unavailable</td>
<td align="center">服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody></table>
<p>整个处理流程：</p>
<p>首先调用threadPoolInit()函数，得到线程池的实例，得到该实例后，调用threadPoolRun()把线程池启动起来，即把线程池里面的子线程启动起来。然后就可以通过takeWorkerEventLoop()从线程池里面取出某一个子线程，得到子线程就能够得到对应的反应堆evLoop实例，将其返回给函数的调用者。调用者就可以通过这个evLoop实例往它的任务队列里面添加任务，当任务添加到evLoop对应的任务队列过后，就可以开始处理这个任务队列了，再根据这个任务队列节点的类型来处理这个dispatcher的检测集合。有3种情况，第1种是往检测集合里面添加新的节点；第2种是往检测集合里面删除节点；第3种情况就是修改检测集合里面某个文件描述符对应的事件。dispatcher这个检测集合处理完毕之后，对应的反应堆模型就开始进行循环了，它需要循环的调用底层的poll、epoll_wait或select来检测这个集合里面有没有激活的文件描述符。如果有激活的文件描述符，那么就通过这个文件描述符找到对应的channel，找到chennel后，然后再基于激活的事件，调用事件对应的回调函数，该回调函数调用完之后，对应的事件也就处理完毕了。</p>
<h1 id="5-多反应堆-线程池高并发服务器"><a href="#5-多反应堆-线程池高并发服务器" class="headerlink" title="5. 多反应堆+线程池高并发服务器"></a>5. 多反应堆+线程池高并发服务器</h1><h2 id="5-1-反应堆模型"><a href="#5-1-反应堆模型" class="headerlink" title="5.1 反应堆模型"></a>5.1 反应堆模型</h2><h2 id="5-2-多线程"><a href="#5-2-多线程" class="headerlink" title="5.2 多线程"></a>5.2 多线程</h2><h2 id="5-3-I-O模型的Buffer"><a href="#5-3-I-O模型的Buffer" class="headerlink" title="5.3 I&#x2F;O模型的Buffer"></a>5.3 I&#x2F;O模型的Buffer</h2><h2 id="5-4-服务器TcpServer"><a href="#5-4-服务器TcpServer" class="headerlink" title="5.4 服务器TcpServer"></a>5.4 服务器TcpServer</h2><h2 id="5-5-服务器Listener"><a href="#5-5-服务器Listener" class="headerlink" title="5.5 服务器Listener"></a>5.5 服务器Listener</h2><h2 id="5-6-I-O模型的TcpConnection"><a href="#5-6-I-O模型的TcpConnection" class="headerlink" title="5.6 I&#x2F;O模型的TcpConnection"></a>5.6 I&#x2F;O模型的TcpConnection</h2><p>流程：</p>
<p>从main()函数开始，先通过函数tcpServerInit()创建一个服务器的实例，并设置了主线程启动后，它线程池里面的子线程个数为4，这样就得到了一个服务器的实例对象server，随后就可以调用它的一个Run方法了。</p>
<p>在启动服务器的时候，就是把线程池启动起来，并且把用于监听的套接字用于封装，然后把它放到了当前主线程对应的反应堆模型里面，之后主线程的反应堆模型就运行起来了，那么它底层的pool、epool或select也就运行起来了。它就可以检测监听描述符lfd里面的事件，这里是指读事件。如果有新的客户端连接，读事件就触发了，然后读回调函数acceptConnection就被调用了。</p>
<p>在读回调函数acceptConnection里，它第一件事就是和客户端建立连接得到了一个通信的文件描述符，然后从主线程里面取出了一个子线程，并且把子线程的反应堆模型evLoop取出来，然后把用于通信的文件描述符放到了evLoop里面。在tcpConnectionInit()函数里面，其实就是把cfd进行了封装，最终得到了一个新的channel，然后把这个channel放到了evLoop子线程的反应堆模型里面。</p>
<p>总的来说，就是当主线程建立连接之后，它并不会去处理与客户端的通信，和客户端的通信全都是在子线程里面处理的。</p>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础知识</title>
    <url>/2024/07/03/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-Linux操作系统基础知识"><a href="#1-Linux操作系统基础知识" class="headerlink" title="1. Linux操作系统基础知识"></a>1. Linux操作系统基础知识</h1><h2 id="1-1-文本编译器vim"><a href="#1-1-文本编译器vim" class="headerlink" title="1.1 文本编译器vim"></a>1.1 文本编译器vim</h2><p>Vim文本编辑器，是由 vi 发展演变过来的文本编辑器，使用简单、功能强大、是 Linux众多发行版的默认文本编辑器。</p>
<p>1.vim的三种模式</p>
<ul>
<li><p>正常模式：以vim打开一个档案就直接进入了一般模式</p>
</li>
<li><p>插入模式：按下i、I、o、O、A、a、r、R等任何字母进入编辑模式</p>
</li>
<li><p>命令行模式：可以提供相关指令，完成读取、存盘、离开vim、显示行号等</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/1.png"></p>
<p>2.快捷键使用</p>
<ul>
<li><p>一般模式下，拷贝当前行 yy，拷贝当前行向下5行 5yy，粘贴 p</p>
</li>
<li><p>一般模式下，删除当前行 dd，删除当前行向下5行 5dd</p>
</li>
<li><p>在文件中找到某个单词，在命令行下输入 &#x2F;查找的关键字，然后回车即可，输入n继续查找下一个需要查找的关键字</p>
</li>
<li><p>设置文件的行号，取消文件的行号，分别为[命令行下:set nu 和:set nonu]</p>
</li>
<li><p>在一般模式下，使用快捷键到文档的最末尾 G，和最首行 gg</p>
</li>
<li><p>在一个文件中输入”hello”(编辑模式),在一般模式下，撤销这个动作 u</p>
</li>
<li><p>在一般模式下，将光标移动到 20 shift+g</p>
</li>
</ul>
<h2 id="1-2操作常识"><a href="#1-2操作常识" class="headerlink" title="1.2操作常识"></a>1.2操作常识</h2><p>1.关机&#x2F;重启命令</p>
<ul>
<li><p>立刻进行关机：shutdown  -h  now</p>
</li>
<li><p>1分钟后会关机：shutdown  -h  1</p>
</li>
<li><p>立刻重新启动计算机：shutdown  -r  now </p>
</li>
<li><p>关机，作用和上面一样：halt</p>
</li>
<li><p>立刻重新启动计算机：reboot</p>
</li>
<li><p>把内存数据同步到磁盘：sync</p>
</li>
</ul>
<p>2.用户登录或促销</p>
<ul>
<li><p>登录普通用户abc，登录后再用su - root 命令切换到系统管理员</p>
</li>
<li><p>再提示符下输入logout 即可注销用户(root下可退回到abc，abc下可退出系统)</p>
</li>
<li><p>logout只能在图形运行级别有效，在运行级别3下无效</p>
</li>
</ul>
<p>3.新建用户</p>
<ul>
<li>添加一个用户milan，默认该用户的家目录在&#x2F;home&#x2F;milan(创建成功后，会自动创建和用户同名的家目录)：useradd milan</li>
</ul>
<ul>
<li><p>也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录</p>
<ul>
<li>useradd -d &#x2F;home&#x2F;test&#x2F; king ：创建一个用户king，它的家目录在home的test下</li>
</ul>
</li>
<li><p>给用户设置&#x2F;修改密码(要用自己账号或root账号)：passwd 用户名</p>
</li>
<li><p>pwd：显示当前用户所在哪个目录下</p>
</li>
</ul>
<p>4.删除用户</p>
<ul>
<li><p>删除用户，但是保留家目录：userdel 用户名</p>
</li>
<li><p>删除用户以及家目录：userdel -r 用户名</p>
</li>
</ul>
<p>5.查询用户信息：id 用户名</p>
<p>6.切换用户名(高权限到低权限不用密码，低权限到高权限要密码)：su - 用户名</p>
<p>7.查看当前用户：who am i</p>
<p>8.组的介绍</p>
<ul>
<li><p>所有者：一般为文件的创建者，谁创建了该文件，就自然的成为了该文件的所有者</p>
<ul>
<li>查看文件下的所有者：ls -ahl</li>
</ul>
</li>
<li><p>组的创建</p>
<ul>
<li><p>创建一个组family：groupadd family</p>
</li>
<li><p>创建一个用户fox，并放入到family组里：useradd -g family fox</p>
</li>
</ul>
</li>
<li><p>修改文件所在组：chgrp 组名 文件名</p>
</li>
<li><p>改变用户所在组：usermod -g 新组名 用户名</p>
</li>
</ul>
<p>9.用户组(类似于角色，系统可以对共性&#x2F;权限的多个用户进行统一管理)</p>
<ul>
<li><p>新增组：groupadd 组名</p>
</li>
<li><p>删除组：groupdel 组名</p>
</li>
<li><p>增加用户时直接加上组：uesradd -g 用户组 用户名</p>
</li>
<li><p>修改用户的组：usermod -g 用户组 用户名</p>
</li>
</ul>
<p>10.用户和组相关文件</p>
<ul>
<li><p>&#x2F;etc&#x2F;passwd文件：用户的配置文件，记录用户的各种信息</p>
<ul>
<li>每一行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;shadow文件：口令的配置文件</p>
<ul>
<li>每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;group文件：组的配置文件，记录Linux包含的组的信息</p>
<ul>
<li>每行含义：组名:口令：组标识符:组内用户列表</li>
</ul>
</li>
</ul>
<p>11.指令的运行级别</p>
<ul>
<li><p>运行级别说明：</p>
<ul>
<li><p>0：关机</p>
</li>
<li><p>1：单用户(找回丢失密码)</p>
</li>
<li><p>2：多用户状态没有网络服务</p>
</li>
<li><p>3：多用户状态有网络服务</p>
</li>
<li><p>4：系统未使用保留给用户</p>
</li>
<li><p>5：图形界面</p>
</li>
<li><p>6：系统重启</p>
</li>
</ul>
</li>
<li><p>切换不同的运行级别：init 数字</p>
</li>
<li><p>查看当前的运行级别：systemctl get-default</p>
</li>
<li><p>设置默认级别：systemctl set-default multi-user.target(3)或graphical.target(5)</p>
<ul>
<li>注：当在Xshell中将默认级别设置为3过后，进行reboot，那么在虚拟机中重启后将是级别3，而不是级别5</li>
</ul>
</li>
</ul>
<h1 id="2-命令指令"><a href="#2-命令指令" class="headerlink" title="2.命令指令"></a>2.命令指令</h1><h2 id="2-1帮助指令"><a href="#2-1帮助指令" class="headerlink" title="2.1帮助指令"></a>2.1帮助指令</h2><p>1.man：获得帮助信息——-&gt;用法：man ls(要退出的话直接输入q)</p>
<p>2.help：获得shell内置目录的帮助信息</p>
<p>注：在Linux下，隐藏文件是以.开头的，选项可以组合使用，如ls -al,或ls -al &#x2F;root</p>
<h2 id="2-2文件目录类指令"><a href="#2-2文件目录类指令" class="headerlink" title="2.2文件目录类指令"></a>2.2文件目录类指令</h2><p>1.pwd指令：显示当前工作目录的绝对路径</p>
<p>2.ls指令：显示目录和文件</p>
<ul>
<li><p>-a：显示当前目录所有的文件和目录，包括隐藏的；</p>
</li>
<li><p>-l：以列表的方式显示信息</p>
</li>
</ul>
<p>3.cd指令：切换到指定目录</p>
<ul>
<li><p>cd ~或者cd回到直接的家目录(root回到&#x2F;root)；</p>
</li>
<li><p>cd ..回到当前目录的上一级目录；</p>
</li>
</ul>
<p>4.mkdir指令：用于创建目录</p>
<ul>
<li><p>home下创建一个dog目录：mkdir &#x2F;home&#x2F;dog</p>
</li>
<li><p>home下创建多级目录：mkdir -p &#x2F;home&#x2F;animal&#x2F;tiger</p>
</li>
</ul>
<p>5.rmdir指令：删除目录</p>
<ul>
<li><p>删除home下的dog空目录：rmdir &#x2F;home&#x2F;dog</p>
</li>
<li><p>删除home下的animal非空目录：rm -rf &#x2F;home&#x2F;animal</p>
</li>
</ul>
<p>6.touch指令：创建空文件</p>
<ul>
<li>在home目录下，创建一个空文件hello.txt：touch &#x2F;home&#x2F;hello.txt</li>
</ul>
<p>7.cp指令：拷贝文件到指定目录</p>
<ul>
<li><p>将&#x2F;home&#x2F;hello.txt拷贝到&#x2F;home&#x2F;bbb目录下：cp &#x2F;home&#x2F;hello.txt &#x2F;home&#x2F;bbb</p>
</li>
<li><p>递归复制整个文件夹，如将&#x2F;home&#x2F;bbb整个目录，拷贝到&#x2F;opt：cp -r &#x2F;home&#x2F;bbb &#x2F;opt</p>
</li>
</ul>
<p>注：cp -r &#x2F;home&#x2F;bbb &#x2F;opt强制覆盖不提醒</p>
<p>8.rm指令：移除文件或目录</p>
<ul>
<li><p>-r：递归删除整个文件夹；</p>
</li>
<li><p>-f：强制删除不提示；</p>
<ul>
<li><p>将&#x2F;home&#x2F;hello.txt删除：rm &#x2F;home&#x2F;hello.txt</p>
</li>
<li><p>递归删除(不提示)整个文件夹&#x2F;home&#x2F;bbb：rm -rf &#x2F;home&#x2F;bbb</p>
</li>
</ul>
</li>
</ul>
<p>9.mv指令：移动文件与目录或重命名</p>
<ul>
<li><p>将&#x2F;home&#x2F;dog.txt文件重命名为pig.txt(同一个目录下)：mv &#x2F;home&#x2F;dog.txt &#x2F;home&#x2F;pig.txt</p>
</li>
<li><p>将&#x2F;home&#x2F;dog.txt文件移动到&#x2F;root目录下(不同目录下)：mv &#x2F;home&#x2F;dog.txt &#x2F;root</p>
</li>
<li><p>将&#x2F;home&#x2F;dog.txt文件移动到&#x2F;root目录下并重命名为pig.txt：mv &#x2F;home&#x2F;dog.txt &#x2F;root&#x2F;pig.txt</p>
</li>
<li><p>移动整个目录，如将 &#x2F;opt&#x2F;bbb移动到&#x2F;home下：mv &#x2F;opt&#x2F;bbb &#x2F;home</p>
</li>
</ul>
<p>10.cat指令：查看文件内容，但不能修改(-n可以显示行号)</p>
<ul>
<li>查看&#x2F;etc&#x2F;profile文件内容，并显示行号：cat -n &#x2F;etc&#x2F;profile</li>
</ul>
<p>注：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道指令|more进行交互</p>
<p>11.more指令</p>
<p>是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more有若干快捷键(交互的指令)，如空白健(向下翻一页)、Enter(向下翻一行)等</p>
<ul>
<li>浏览文件内容：more &#x2F;etc&#x2F;profile</li>
</ul>
<p>12.less指令：分屏查看文件内容，功能与more类似，但比more指令更强大，</p>
<ul>
<li>浏览文件内容：less &#x2F;opt&#x2F;杂文.txt</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/2.png"></p>
<p>12.echo指令：输出内容到控制台</p>
<ul>
<li>echo $PATH 或者echo $HOSTNAME<ul>
<li>输出hello：echo “hello”</li>
</ul>
</li>
</ul>
<p>13.head指令：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
<ul>
<li><p>查看&#x2F;etc&#x2F;profile文件的前10行：head &#x2F;etc&#x2F;profile</p>
</li>
<li><p>查看&#x2F;etc&#x2F;profile文件的前5行：head -n 5 &#x2F;etc&#x2F;profile</p>
</li>
</ul>
<p>14.tail：指令用于显示文件的尾部的内容，默认情况下head指令显示文件的尾10行内容</p>
<ul>
<li><p>查看&#x2F;etc&#x2F;profile文件的尾10行：tail &#x2F;etc&#x2F;profile</p>
</li>
<li><p>查看&#x2F;etc&#x2F;profile文件的尾5行：tail -n 5 &#x2F;etc&#x2F;profile</p>
</li>
<li><p>补：tail指令可以实时地追踪文档的所有变化：tail -f &#x2F;home&#x2F;hello.txt(Ctrl+c退出监控)</p>
</li>
</ul>
<p>15.&gt;指令和&gt;&gt;指令</p>
<ul>
<li><p>ls -l &gt;文件：列表的内容写入文件(a.txt)中—&gt;会覆盖</p>
</li>
<li><p>ls -al &gt;&gt;文件：列表的内容追加到文件(aa.txt)的末尾</p>
</li>
<li><p>cat 文件1 &gt;文件2：将文件1的内容覆盖到文件</p>
<ul>
<li><p>echo “内容”&gt;&gt;文件：追加</p>
</li>
<li><p>将&#x2F;home目录下的文件列表写入到&#x2F;home&#x2F;info.txt中(覆盖)：ls -l &#x2F;home &gt; &#x2F;home&#x2F;info.txt(如果没有该文件，会自动创建)</p>
</li>
<li><p>将当前日历信息追加到&#x2F;home&#x2F;mycal文件中：cal &gt;&gt; &#x2F;home&#x2F;mycal</p>
</li>
</ul>
</li>
</ul>
<p>16.ln指令：ln 命令用于创建链接。具体而言，ln 命令可以用来创建硬链接或符号链接(软链接)。软链接类似于windows里的快捷方式</p>
<ul>
<li><p>在&#x2F;home目录下创建一个软链接myroot，连接到&#x2F;root目录：ln -s &#x2F;root &#x2F;home&#x2F;myroot</p>
</li>
<li><p>删除软链接myroot：rm &#x2F;home&#x2F;myroot</p>
</li>
<li><p>创建硬链接：使用 ln 命令时，如果不指定任何选项，默认情况下会创建硬链接。硬链接是指多个文件名指向同一个索引节(inode)，它们在文件系统中实际上指向相同的数据块。</p>
</li>
<li><p>如：创建一个名为 b.c 的硬链接，指向与 a.c 相同的文件数据:ln a.c b.c</p>
</li>
</ul>
<p>17.history指令：查看已经执行过历史命令，也可以执行历史指令</p>
<ul>
<li><p>显示所有的历史指令：history</p>
</li>
<li><p>显示最近使用过的10个指令：history 10</p>
</li>
<li><p>执行历史编号为5的指令：!5</p>
</li>
</ul>
<h2 id="2-3时间日期类指令"><a href="#2-3时间日期类指令" class="headerlink" title="2.3时间日期类指令"></a>2.3时间日期类指令</h2><p>1.date指令：显示当前日期</p>
<ul>
<li><p>显示当前年份、月份、具体哪一天：date +%Y、date +%m、date +%d</p>
</li>
<li><p>显示年月日时分秒：date “+%Y-%m-%d %H:%M%S”</p>
</li>
</ul>
<p>2.cal指令：查看日历</p>
<ul>
<li><p>显示当前日历：cal</p>
</li>
<li><p>显示1999年日历：cal 1999</p>
</li>
</ul>
<h2 id="2-4搜索查找类指令"><a href="#2-4搜索查找类指令" class="headerlink" title="2.4搜索查找类指令"></a>2.4搜索查找类指令</h2><p>1.find指令：将从指定目录向下递归遍历其各个子目录，将满足条件的文件或目录显示在终端</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/3.png"></p>
<ul>
<li><p>按文件名查找：根据名称查找&#x2F;home目录下的hello.txt：find &#x2F;home -name hello.txt</p>
</li>
<li><p>按拥有者查找：查找&#x2F;opt目录下，用户名称为nobody的文件：find &#x2F;opt -user nobody</p>
</li>
<li><p>按文件大小查找：查找整个linux系统下大于200M的文件(+n大于 -n小于 n等于，单位K,	M,G)：find &#x2F; -size +200M</p>
</li>
</ul>
<p>2.locate指令：可以快速定位文件路径，locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件(无需遍历整个文件系统)</p>
<p>注：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p>
<ul>
<li>利用locate指令快速定位hello.txt文件所在目录：locate hello.txt</li>
</ul>
<p>3.which指令：可以查看某个指令在哪个目录下，比如ls指令在哪个目录下(which ls)</p>
<p>4.grep指令和管道符号|：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理</p>
<ul>
<li>-n：显示匹配及其行号；-i：忽略字母大小写；<ul>
<li>在hello.txt文件中，查找”yes”所在行，并显示行号： cat &#x2F;home&#x2F;hello.txt | grep -n “yes” 或者 grep -n “yes” &#x2F;home&#x2F;hello.txt</li>
</ul>
</li>
</ul>
<h2 id="2-5压缩和解压类指令"><a href="#2-5压缩和解压类指令" class="headerlink" title="2.5压缩和解压类指令"></a>2.5压缩和解压类指令</h2><p>市面上有非常多的压缩格式</p>
<ul>
<li><p>zip格式：Linux、Windows、MacOS常用</p>
</li>
<li><p>7zip和rar：Windows常用</p>
</li>
<li><p>tar和gzip：Linux、MacOS常用</p>
</li>
</ul>
<p>1.gzip&#x2F;gunzip指令：gzip用于压缩文件，gunzip用于解压文件</p>
<ul>
<li><p>gzip压缩，将&#x2F;home下的hello.txt文件进行压缩：gzip &#x2F;home&#x2F;hello.txt</p>
</li>
<li><p>gunzip解压，将&#x2F;home下的hello.txt.gz文件进行解压：gunzip &#x2F;home&#x2F;hello.txt.gz</p>
</li>
</ul>
<p>2.zip&#x2F;unzip指令：zip用于压缩文件，unzip用于解压的。这个在项目打包发布中很有用</p>
<ul>
<li>-r：递归压缩，即压缩目录<ul>
<li>将&#x2F;home下的所有文件&#x2F;文件夹进行压缩成myhome.zip：zip -r myhome.zip &#x2F;home</li>
</ul>
</li>
<li>-d&lt;目录&gt;：指定解压后文件的存放目录<ul>
<li>将myhome.zip解压到&#x2F;opt&#x2F;tmp目录下：unzip -d &#x2F;opt&#x2F;tmp &#x2F;home&#x2F;myhome.zip</li>
</ul>
</li>
</ul>
<p>3.tar指令：是打包指令，最后打包后的文件是.tar.gz文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/4.png"></p>
<ul>
<li><p>压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz：tar -zcvf pc.tar.gz &#x2F;home&#x2F;pig.txt &#x2F;home&#x2F;cat.txt</p>
</li>
<li><p>将&#x2F;home的文件夹压缩成myhome.tar.gz：tar -zcvf myhome.tar.gz &#x2F;home</p>
</li>
<li><p>将pc.tar.gz解压到当前目录：tar -zxvf pc.tar.gz</p>
</li>
<li><p>将myhome.tar.gz解压到&#x2F;opt.tmp2目录下：tar -zxvf &#x2F;home&#x2F;myhome&#x2F;.tar.gz -C &#x2F;opt&#x2F;tmp2</p>
</li>
</ul>
<h1 id="3-Linux系统操作"><a href="#3-Linux系统操作" class="headerlink" title="3.Linux系统操作"></a>3.Linux系统操作</h1><h2 id="3-1权限"><a href="#3-1权限" class="headerlink" title="3.1权限"></a>3.1权限</h2><p>1.权限的基本介绍</p>
<ul>
<li><p>第0位确定文件的类型(d、-、l、c、b)</p>
<ul>
<li><p>d是目录，相当于windows的文件夹</p>
</li>
<li><p>-是普通文件</p>
</li>
<li><p>l是链接，相当于windows的快捷方式</p>
</li>
<li><p>c是字符设备文件、比如鼠标、键盘</p>
</li>
<li><p>b是块设备，比如硬盘</p>
</li>
</ul>
</li>
<li><p>第1-3位确定所有者拥有该文件的权限</p>
</li>
<li><p>第4-6位确定所属组拥有该文件的权限</p>
</li>
<li><p>第7-9位确定其他用户拥有该文件的权限</p>
</li>
</ul>
<p>2.rwx权限详解(难)</p>
<ul>
<li><p>rxw作用到文件</p>
<ul>
<li><p>r代表可读：可以读取，查看</p>
</li>
<li><p>w代表可写：可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件</p>
</li>
<li><p>x代表可执行：可以被执行</p>
</li>
</ul>
</li>
<li><p>rwx作用到目录</p>
<ul>
<li><p>r代表可读：可以读取，ls查看目录内容</p>
</li>
<li><p>w代表可写：可以修改，对目录内创建创建+删除+重命名目录</p>
</li>
<li><p>x代表可执行：可以进入该目录</p>
</li>
</ul>
</li>
</ul>
<p>3.修改权限</p>
<p>chmod：可以修改文件或者目录的权限</p>
<ul>
<li><p>第1种方式：用+、-、&#x3D;变更权限，其中u是所有者、g是所有组、o是其他人、a是所有人(u、g、o的总和)</p>
<ul>
<li><p>给abc文件的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限：chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx abc</p>
</li>
<li><p>给abc文件的所有者除去执行的权限，增加组写的权限：chmod u-x,g+w abc</p>
</li>
<li><p>给abc文件的所有用户添加读的权限：chmod a+r abc</p>
</li>
</ul>
</li>
<li><p>第2种方式：通过数字变更权限(r&#x3D;4,w&#x3D;2,x&#x3D;1)</p>
<ul>
<li><p>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名  相当于  chmod 751 文件目录名</p>
</li>
<li><p>将&#x2F;home&#x2F;abc.txt文件的权限修改成rwxr-xr-x，使用给数字的方式实现：chmod 755 &#x2F;home&#x2F;abc.txt</p>
</li>
</ul>
</li>
</ul>
<p>4.修改所有者和所在组</p>
<ul>
<li><p>修改文件&#x2F;目录所有者：chown 用户名 文件名</p>
<ul>
<li>将hello.txt文件的所有者从root改为lxx：chown lxx &#x2F;home&#x2F;hello.txt</li>
</ul>
</li>
<li><p>修改文件&#x2F;目录 改变所有者和所在主：chown 用户名:所在主 文件名</p>
<ul>
<li><p>-R：如果是目录，则使其下所有子文件或目录递归生效</p>
</li>
<li><p>将&#x2F;home&#x2F;test目录下所有的文件和目录的所有者都修改成tom：chown -R tom &#x2F;home&#x2F;test</p>
</li>
</ul>
</li>
<li><p>修改文件所在组：chgrp 组名 文件&#x2F;目录</p>
<ul>
<li><p>将&#x2F;home&#x2F;abc.txt文件的所在组修改成shaolin：chgrp shaolin &#x2F;home&#x2F;abc.txt</p>
</li>
<li><p>将&#x2F;home&#x2F;test.txt目录下所有的文件和目录的所在组都修改成shaolin：chgrp -R shaolin &#x2F;home&#x2F;test</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2crond任务调度"><a href="#3-2crond任务调度" class="headerlink" title="3.2crond任务调度"></a>3.2crond任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序</p>
<ul>
<li><p>-e：编辑crontab定时任务</p>
</li>
<li><p>-l：查询crontab任务</p>
</li>
<li><p>-r：删除当前用户所有的crontab任务</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/5.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/6.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/7.png"></p>
<p>1.将&#x2F;etc下的文件每各一分钟打印一次，到&#x2F;home&#x2F;to.txt文件中：</p>
<ul>
<li><p>crontab -e：进入编辑任务的页面，然后按i进入编辑模式</p>
</li>
<li><p>*&#x2F;1 * * * * ls -l &#x2F;etc &gt; &#x2F;home&#x2F;to.txt：在编辑模式下输入指令，按esc退出编辑模式，输入:wq保存退出</p>
</li>
</ul>
<p>2.每隔1分钟，将当前日期和日历都追加到&#x2F;home&#x2F;mycal文件中：</p>
<ul>
<li><p>a:输入vim &#x2F;home&#x2F;my.sh ，写入内容date &gt;&gt; &#x2F;home&#x2F;mycal和cal &gt;&gt; &#x2F;home&#x2F;mycal；</p>
</li>
<li><p>b:给my.sh增加执行权限，chmod u+x &#x2F;home&#x2F;my.sh；</p>
</li>
<li><p>c:crontab -e 写入*&#x2F;1 * * * * &#x2F;home&#x2F;my.sh；</p>
</li>
</ul>
<p>3.每天凌晨2点将mysql数据库testdb，备份到文件中：</p>
<ul>
<li>0 2 * * * mysqldump -u root -p密码 数据库 &gt; &#x2F;home&#x2F;db.bak</li>
</ul>
<p>4.crond相关指令</p>
<ul>
<li><p>crontab -r：终止任务调度</p>
</li>
<li><p>crontab -l：列出当前有哪些任务调度</p>
</li>
<li><p>service crond restart：重启任务调度</p>
</li>
</ul>
<h2 id="3-3at定时任务"><a href="#3-3at定时任务" class="headerlink" title="3.3at定时任务"></a>3.3at定时任务</h2><p>1.注意事项：</p>
<ul>
<li><p>at命令是一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行；</p>
</li>
<li><p>默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</p>
</li>
<li><p>at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了；</p>
</li>
<li><p>在使用at命令的时候，一定要保证atd进程的启动，可以使用相关指令来查看</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/8.png"></p>
<p>2.表示方式</p>
<ul>
<li><p>ps -ef | grep atd：可以检测atd是否在</p>
</li>
<li><p>at命令格式：at 选项 时间</p>
</li>
<li><p>Ctrl + D：结束at命令的输入</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/9.png"></p>
<ul>
<li><p>2天后的下午5点执行&#x2F;bin&#x2F;ls &#x2F;home：at 5pm + 2days 回车，输入&#x2F;bin&#x2F;ls &#x2F;home ctrl+d(2次)</p>
</li>
<li><p>查看系统中还没有执行的工作任务：atq</p>
</li>
<li><p>明天17点钟，输出时间到指定文件内&#x2F;root&#x2F;date100.log：at 5pm tomorrow 回车，date &gt; &#x2F;root&#x2F;date100.log ctrl+d(2次)</p>
</li>
<li><p>2分钟后，输出时间到指定文件内&#x2F;root&#x2F;date200.log：at now + 2minutes 回车，date &gt; &#x2F;root&#x2F;date200.log  ctrl+d(2次)</p>
</li>
<li><p>删除已经设置好的案例：atrm 编号</p>
</li>
</ul>
<h2 id="3-4Linux分区"><a href="#3-4Linux分区" class="headerlink" title="3.4Linux分区"></a>3.4Linux分区</h2><p>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘。对于IDE硬盘，驱动器标识符为hdx~，hd表明分区所在设备的类型，波浪线代表分区。如hda3表示为第一个IDE硬盘上的第三个主分区；hdb2表示为第二个IDE硬盘上的第二个主分区。(1到4表示主分区或扩展分区，从5开始就是逻辑分区)</p>
<p>对于SCSI硬盘，标识符为sdx~，sd来表示分区所在设备的类型，其余和IDE硬盘一样。</p>
<ul>
<li>查看所有设备的挂载情况：lsblk或者lsblk -f</li>
</ul>
<p>1.虚拟机增加硬盘后挂载</p>
<ul>
<li><p>分区命令：fdisk &#x2F;dev&#x2F;sdb</p>
</li>
<li><p>涉及m 的相关命令列表</p>
<ul>
<li><p>p显示磁盘分区 同 fdisk -l</p>
</li>
<li><p>n 新增分区</p>
</li>
<li><p>d 删除分区</p>
</li>
<li><p>w 写入并退出</p>
</li>
</ul>
</li>
</ul>
<p>2.步骤(对sdb进行分区)：</p>
<ul>
<li><p>在虚拟机菜单中，选择[设置]，然后设备列表下面点[添加]，选择[硬盘]，然后一路下一步，完成后需要重启系统</p>
</li>
<li><p>对sdb分区，输入fdisk &#x2F;dev&#x2F;sdb —-&gt; 获取指令，输入m —–&gt; 添加一个新的分区，输入n —–&gt;按主分区来分，输入p —-&gt; 选择分区数，输入1 —–&gt; 然后2次回车 —-&gt; 相当于保存并退出，输入w(q表示上述操作不保存)</p>
</li>
<li><p>格式化磁盘：mkfs -t ext4 &#x2F;dev&#x2F;sdb1    (其中ext4是分区类型)</p>
</li>
<li><p>挂载：将一个分区与一个目录联系起来</p>
</li>
</ul>
<p>3.mount 设备名称 挂载目录</p>
<ul>
<li>如sdb1挂载到根目录下的newdisk：mount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk</li>
</ul>
<p>4.取消挂载点：umount 设备名称&#x2F;挂载目录</p>
<ul>
<li>如取消sdb1在目录newdisk上的挂载点：umount &#x2F;dev&#x2F;sdb1  或者  umount &#x2F;newdisk</li>
</ul>
<p>注：用命令行进行挂载，重启后会失效</p>
<p>5.永久挂载：通过修改&#x2F;etc&#x2F;fstab实现挂载，添加完成后 执行mount -a 即刻生效(不需要重启)</p>
<p>6.磁盘情况查询</p>
<ul>
<li><p>-s：指定目录占用大小汇总</p>
</li>
<li><p>-h：带计量单位</p>
</li>
<li><p>-a：含文件(目录)</p>
</li>
<li><p>–max-depth&#x3D;1：子目录深度</p>
</li>
<li><p>-c：列出明细的同时，增加汇总值</p>
<ul>
<li><p>如查询&#x2F;opt目录下的磁盘占用情况，深度为1：du -h –max-depth&#x3D;1 &#x2F;opt</p>
</li>
<li><p>查询系统整体磁盘使用情况：df -h</p>
</li>
<li><p>查询指定目录的磁盘占用情况(默认为当前目录)：du -h</p>
</li>
</ul>
</li>
</ul>
<p>7.磁盘情况-工作实用指令</p>
<ul>
<li><p>统计&#x2F;opt文件夹下文件的个数：ls -l &#x2F;opt | grep “^-” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下目录的个数：ls -l &#x2F;opt | grep “^d” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下文件的个数，包括子文件夹里的：ls -lR &#x2F;opt | grep “^-” | wc -l</p>
</li>
<li><p>统计&#x2F;opt文件夹下目录的个数，包括子文件夹里的：ls -lR &#x2F;opt | grep “^d” | wc -l</p>
</li>
<li><p>以树状显示目录结构tree目录，注意，如果没有tree，则使用yum install tree安装：tree 文件名</p>
</li>
</ul>
<h1 id="4-网路配置"><a href="#4-网路配置" class="headerlink" title="4.网路配置"></a>4.网路配置</h1><h2 id="4-1环境配置"><a href="#4-1环境配置" class="headerlink" title="4.1环境配置"></a>4.1环境配置</h2><p>1.ping测试当前服务器是否可以连接目的主机：ping ip(目的主机IP)</p>
<p>2、wget是非交互式的文件下载器，可以在命令行内下载网络文件</p>
<ul>
<li><p>-b是可选，表示后台下载，并将日志写入到当前工作目录的wget-log文件</p>
</li>
<li><p>url是下载链接</p>
<ul>
<li>语法：wget -b url</li>
</ul>
</li>
</ul>
<p>3、linux网络环境配置</p>
<p>第1种方法(自动获取)</p>
<ul>
<li>说明：登录后，通过界面的来设置自动获取ip；特点：linux启动后会自动获取ip；缺点：每次自动获取的ip地址可能不一样；</li>
</ul>
<p>第2种方法(指定ip)</p>
<ul>
<li>说明：直接修改配置文件来指定IP，并可以连接到外网(程序员推荐)</li>
<li>编辑：vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</li>
<li>要求：将ip地址配置为静态的，比如：ip地址为192.168.93.39</li>
</ul>
<p>修改后需要停止和启动网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop network</span><br><span class="line">systemctl start network</span><br></pre></td></tr></table></figure>

<p>4.设置主机名和hosts映射</p>
<p>为了方便记忆，可以给linux系统设置主机名，也可以根据需要修改主机名</p>
<ul>
<li><p>方法1：修改文件在&#x2F;etc&#x2F;hostname，终端输入：vim &#x2F;etc&#x2F;hostname 回车打开文件后在里面修改主机名即可。修改后，重启生效</p>
</li>
<li><p>方法·2：直接终端输入：hostnamectl set-hostname 修改主机名 回车完成后重启</p>
</li>
<li><p>查看主机名指令：hostname</p>
</li>
</ul>
<p>2.设置hosts映射</p>
<p>windows系统：</p>
<ul>
<li><p>在C:\Windows\System32\drivers\etc\hosts文件(该文件是记录主机与ip映射的文件)指定即可：</p>
<ul>
<li><p>如：192.168.88.93  lxx</p>
</li>
<li><p>完成后就可以在windows下通过ping lxx来ping通</p>
</li>
</ul>
</li>
<li><p>如果因为权限问题遇到hosts文件不能打开解决办法：</p>
<ul>
<li><p>1.可以先拖到桌面，修改后再拖回etc下</p>
</li>
<li><p>2.可以通过管理员身份打开记事本，然后再记事本里面找到该文件，可以直接修改。</p>
</li>
</ul>
</li>
</ul>
<p>linux系统：</p>
<ul>
<li>在&#x2F;etc&#x2F;hosts文件指定：<ul>
<li>如：vim &#x2F;etc&#x2F;hosts 回车打开该文件</li>
<li>192.168.200.1(vmnet8的ip) windows的主机名</li>
</ul>
</li>
</ul>
<p>完成后就可以在linux下通过 ping windows主机名 来ping通</p>
<p>3.主机名解析过程分析(hosts、DNS)</p>
<p>hosts是一个文本文件，用来记录IP和主机名的映射关系；DNS就是domain name system的缩写，翻译过来就是域名系统；是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>
<p>应用实例1：用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></p>
<ul>
<li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存(本地的)，如果有就直接返回IP完成解析。这两个缓存可以理解为本地解析器缓存；</p>
</li>
<li><p>如果本地解析器缓存没有找到对应的映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回；</p>
</li>
<li><p>如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS(互联网的)进行解析域；</p>
</li>
</ul>
<p>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存它的IP地址(DNS解析记录)。在cmd窗口可以输入</p>
<p>应用实例2：访问<a href="http://www.baidu.com的流程如下：">www.baidu.com的流程如下：</a></p>
<ul>
<li><p>先查看本机的记录(私人地址本)，Windows看：C:\Windows\System32\drivers\etc\hosts；Linux看：&#x2F;etc&#x2F;hosts</p>
</li>
<li><p>没有找到的话，再联网去DNS服务器(如114.114.114.114，8.8.8.8)寻找&#x2F;访问</p>
</li>
</ul>
<p>在windows系统</p>
<ul>
<li><p>查看DNS解析器缓存(本地的)：ipconfig &#x2F;displaydns</p>
</li>
<li><p>手动清理DNS缓存：ipconfig &#x2F;flushdns</p>
</li>
</ul>
<p>在hosts文件夹下如果被人修改，当访问百度网站时，会跳入到别人的ip地址</p>
<h1 id="5-网络知识"><a href="#5-网络知识" class="headerlink" title="5.网络知识"></a>5.网络知识</h1><h2 id="5-1进程基本介绍"><a href="#5-1进程基本介绍" class="headerlink" title="5.1进程基本介绍"></a>5.1进程基本介绍</h2><p>在Linux中，每个执行的程序都称为一个进程，每一个进程都分配一个ID号(pid,进程号)。每个进程都可能以两种方式存在的，前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的(占用屏幕，直到退出才能进行其他操作)；后台进程则是实际在操作，但由于屏幕上无法看到的进程。一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</p>
<p>1.程序与进程的关系：程序在没有运行的时候就是一段代码，一旦运行了，就会被加载到内存，然后它就是进程了</p>
<p>2.ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况(可以不加任何参数，也可以混合使用)</p>
<ul>
<li><p>ps -a：显示当前终端的所有进程信息；</p>
</li>
<li><p>ps -u：以用户的格式显示进程信息；</p>
</li>
<li><p>ps -x：显示后台进程运行的参数；</p>
</li>
<li><p>查看系统正在执行进程的状况：ps -aux</p>
</li>
</ul>
<p>3.对ps指令的一些指标介绍</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/10.png"></p>
<p>USER：进程执行用户；PID：进程号；%CPU：占用cpu的百分比；%MEM：占用物理内存的百分比；VSZ：占用虚拟内存的大小；RSS：占用物理内存的大小；TTY：终端机号；STAT：运行状态；START：执行的开始时间；TIME：占用的cpu时间；COMMAND：进程名，启动该进程所用的命令和参数，如果过长会被截断显示</p>
<p>例如：查看有没有sshd服务：ps -aux | grep sshd ———–&gt; 回车后只看第一条</p>
<p>在STAT进程状态中，其中S-表示睡眠，s-表示该进程是会活的先导进程，N-表示进程拥有比普通进程优先级更低的优先级，R-表示正在运行，D-表示短期等待，Z-表示僵死进程(进程已经死掉，但内存未被释放，需要定时进行清除)，T-表示被跟踪或者被停止等等</p>
<p>4.终止进程kill和killall</p>
<p>若是某个进程执行一半需要停止时，或是已消耗了很大的系统资源时，此时可以考虑停止该进程。使用kill或killall命令来完成此项任务</p>
<ul>
<li><p>通过进程号杀死\终止进程：kill 进程号</p>
</li>
<li><p>通过进程名杀死\终止进程：killall 进程名</p>
<ul>
<li>注意：这种方式会杀掉下面所有的子进程</li>
</ul>
</li>
<li><p>-9：表示强迫进程立即停止(有些情况下，因为系统保护机制下，会忽略kill和killall)</p>
</li>
</ul>
<p>例如：当远程通过fox用户连接linux系统后</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/11.png"></p>
<ul>
<li>踢掉fox非法登录用户：kill 5024</li>
</ul>
<p>小例子：</p>
<ul>
<li><p>终止远程登录服务sshd(其它设备就连不上linux系统了)：kill 1433</p>
</li>
<li><p>重启sshd服务：&#x2F;bin&#x2F;systemctl start sshd.servic</p>
</li>
<li><p>终止多个gedit(打开两个文件夹)：killall gedit 回车后会关闭打开的文件夹</p>
</li>
<li><p>强制杀掉一个终端： 先通过ps -aux | grep bash 查看要杀掉的终端进程号；然后终端输入：kill -9 bash对应的进程号</p>
</li>
</ul>
<p>5.查看进程树pstree(只输入pstree，查看得不清楚)</p>
<p>-p：显示进程的PID(进程号)；-u：显示进程的所属用户；</p>
<p>案例1：以树状的形式显示进程的pid：pstree -p</p>
<p>案例2：以树状的形式显示进程的用户：pstree -u</p>
<h1 id="6-服务-service-管理"><a href="#6-服务-service-管理" class="headerlink" title="6.服务(service)管理"></a>6.服务(service)管理</h1><p>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，比如(mysqld,sshd,防火墙等)，因此又称为守护进程，是linux中非常重要的知识点</p>
<p>1.service管理指令</p>
<p>service 服务名 [start|stop|restart|reload|status]</p>
<ul>
<li>案例：使用service指令关闭和启动network：service network stop；service network start</li>
</ul>
<p>2.chkconfig指令</p>
<p>通过chkconfig命令可以给服务的各个运行级别设置自 启动&#x2F;关闭</p>
<p>查看服务：chkconfig –list    需要过滤的话可以在后面加|grep xxx</p>
<p>修改运行级别是自 启动&#x2F;关闭：chkconfig –level 3 network on&#x2F;off</p>
<p>案例：把network在3运行级别，关闭自启动以及开启：</p>
<ul>
<li><p>chkconfig –level 3 network off</p>
</li>
<li><p>chkconfig –level 3 network on</p>
</li>
</ul>
<p>使用细节：chkconfig重新设置服务后自启动或关闭，需要重启机器reboot生效。</p>
<p>3.systemctl管理指令</p>
<ul>
<li><p>查看及修改某个服务状态：systemctl [start|stop|restart|reload|status] 服务名(这种方式修改的状态是临时生效，当重启系统后，还是回归以前对系统的设置)</p>
</li>
<li><p>systemctl指令管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看</p>
</li>
<li><p>查看服务开机启动状态，grep可以进行过滤：systemctl list-unit-files [| grep 服务名]</p>
</li>
</ul>
<p>设置服务开机启动：systemctl enable 服务名(永久生效)</p>
<p>关闭服务开机启动：systemctl disable 服务名(永久生效)</p>
<p>查询某个服务是否是自启动的：systemctl is-enabled 服务名</p>
<p>查看当前防火墙状况，关闭防火墙和重启防火墙：</p>
<ul>
<li>systemctl status firewalld；systemctl stop firewalld</li>
</ul>
<p>4、打开或者关闭指定端口</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/12.png"></p>
<p>在真正的生成环境，往往需要将防火墙打开，但问题来了，如果把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定端口，比如80、22、8080等。</p>
<p>查看端口号对应的协议：netstat -anp</p>
<p>5.firewall指令</p>
<p>打开端口：firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</p>
<p>关闭端口：firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</p>
<p>完成后，重新载入才能生效：firewall-cmd –reload</p>
<p>查询端口是否开放：firewall-cmd –query-port&#x3D;端口号&#x2F;协议</p>
<p>namp可以查看端口占用情况(yum -y install nmap)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/13.png"></p>
<p>可以看到：本机(127.0.0.1)上有4个端口现在被程序占用</p>
<p>6.动态监控进程</p>
<p>top与ps命令很相似，它们都用来显示正在执行的进程。top与ps最大的不同之处，在于top在执行一段时间可以更新正在运行的进程</p>
<p>基本语法：top [选项]</p>
<ul>
<li><p>-d 秒数：指定top命令每隔几秒更新，默认是3秒</p>
</li>
<li><p>-i：使top不显示任何闲置或者僵死进程</p>
</li>
<li><p>-p：通过指定监控进程ID来仅仅监控某个进程的状态</p>
</li>
</ul>
<p>案例：指定top命令每隔5秒更新：top -d 5</p>
<p>7.交互操作说明(在top界面使用)</p>
<ul>
<li><p>P：以cpu使用率排序，，默认就是此项</p>
</li>
<li><p>M：以内存的使用率排序</p>
</li>
<li><p>N：以PID排序</p>
</li>
<li><p>q：退出top</p>
</li>
</ul>
<p>案例：监视特定用户，比如我们监控fox用户：</p>
<ul>
<li>在top(查看执行进程的)界面，按u，然后输入用户名，回车；</li>
</ul>
<p>案例：终止指定的进程，比如结束fox登录：</p>
<ul>
<li>在top(查看执行进程的)界面，按k，输入要结束进程的PID号(fox登录后，bash进程的PID号)，最后输入9，表示强制结束；</li>
</ul>
<p>8.netstat查看系统网络情况</p>
<p>基本语法：netstat [选项]</p>
<ul>
<li>-an：按一定顺序排列输出</li>
<li>-p：显示对应的进程</li>
</ul>
<p>案例：查看服务名为sshd的服务信息：netstat -anp | grep sshd</p>
<p>检测主机连接命令ping：是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障；</p>
<p>环境变量PATH：在前面提出的问题中，我们说无论当前的工作目录是什么，都能执行&#x2F;user&#x2F;bin&#x2F;cd这个程序，这个就是借助环境变量中，PATH这个项目的值来做的</p>
<h1 id="7-下载包"><a href="#7-下载包" class="headerlink" title="7.下载包"></a>7.下载包</h1><p>1.rpm包的管理</p>
<p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有.RPM扩展名的文件。RPM是RedHat Package Manager(RedHat软件包管理工具)的缩写，类似windows的setup.exe。</p>
<p>查询已安装的rpm列表： rpm -qa | grep xxx</p>
<ul>
<li>举例：查看当前系统，是否已经安装了firefox：rpm -qa | grep firefox 或 rpm -q firefox</li>
</ul>
<p>查询软件包信息：rpm -qi 软件包名</p>
<ul>
<li>举例：查询火狐信息：rpm -qi firefox</li>
</ul>
<p>查询软件包的位置及其包含的文件：rpm -ql 软件包名</p>
<ul>
<li>举例：查询火狐的位置及其包含的文件：rpm -ql firefox</li>
</ul>
<p>查询文件所属的软件包：rpm -qf 文件全路径名</p>
<ul>
<li>举例：查询&#x2F;etc&#x2F;passwd所属的软件包：rpm -qf &#x2F;etc&#x2F;passwd</li>
</ul>
<p>卸载rpm包：rpm -e RPM包的名称</p>
<ul>
<li><p>案例：删除firefox包：rpm -e firefox</p>
</li>
<li><p>注意：有些包卸载后会对其它依赖的包产生错误信息，删除时系统会提醒，强制删除可以加–nodeps；如rpm -e –nodeps 软件包名</p>
</li>
</ul>
<p>安装rpm包：rpm -ivh RPM包全路径名称</p>
<ul>
<li>i&#x3D;install：安装</li>
<li>v&#x3D;verbose：提示</li>
<li>h&#x3D;hash：进度条</li>
</ul>
<p>2.yum</p>
<p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所以依赖的软件包</p>
<ul>
<li><p>查询yum服务器是否有需要安装的软件：yum list | grep 软件名</p>
</li>
<li><p>安装指定的yum包：yum install 软件名</p>
</li>
</ul>
<p>案例：使用yum的方式来安装firefox：yum list | grep firefox ; yum install firefox</p>
<h1 id="8-日志"><a href="#8-日志" class="headerlink" title="8.日志"></a>8.日志</h1><h2 id="8-1日志介绍"><a href="#8-1日志介绍" class="headerlink" title="8.1日志介绍"></a>8.1日志介绍</h2><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等</p>
<p>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。可以这样理解，日志是用来记录重大事件的工具</p>
<p>1.&#x2F;var&#x2F;log 目录就是系统日志文件的保存位置，系统常用的日志(一般用cat来查看)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/14.png"></p>
<p>案例：使用root用户通过xshell登录，第一次使用错误的密码，第二次使用正确的密码登录，看看在日志文件&#x2F;var&#x2F;log&#x2F;secure里有没有记录相关信息。</p>
<ul>
<li><p>先清空secure文件里的内容，后面查看更方便(在log目录下)：echo ‘’ &gt; secure</p>
</li>
<li><p>退出输入错误密码，再输入正确密码后：cat secure</p>
</li>
</ul>
<p>2.日志管理服务</p>
<p>在配置文件&#x2F;etc&#x2F;rsyslog.conf里面记录了我们的日志服务程序rsyslogd管理或者维护的相关日志以及放在哪个文件里。日志管理很重要，需要保证Linux的rsyslogd服务是启动状态以及是自启动</p>
<p>案例：查询Linux中的rsyslogd服务是否启动：pa aux | grep “rsyslog” | grep -v “grep”</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/15.png"></p>
<p>注意：-v表示不包含后面括号里面的那一行(反向匹配)</p>
<p>案例：查询rsyslogd服务的自启动状态：systemctl list-unit-files | grep rsyslog</p>
<p>3.配置文件(重要)：&#x2F;etc&#x2F;rsyslog.conf</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/16.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/17.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/18.png"></p>
<p>案例：查看一下&#x2F;var&#x2F;log&#x2F;secure日志，这个日志中记录的是用户验证和授权方面的信息，来分析如何查看</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/19.png"></p>
<p>案例(自定义一个日志)：在&#x2F;etc&#x2F;rsyslog.conf中添加一个日志文件&#x2F;var&#x2F;log&#x2F;hsp.log，当有事件发送时(比如sshd服务相关事件)，该文件会接收到信息并保存</p>
<ul>
<li>vim &#x2F;etc&#x2F;rsyslog.conf  ——————–&gt;打开配置文件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/20.png"></p>
<p>&gt; &#x2F;var&#x2F;log&#x2F;hsp.log  ———————–&gt;创建文件hsp.log</p>
<p>重启后：cat &#x2F;var&#x2F;log&#x2F;hsp.log | grep sshd  —————–&gt;打开这个文件只查看sshd服务的</p>
<p>注意：上面的*.*表示所有类型的日志以及所有类型的级别</p>
<p>4.日志轮替</p>
<p>日志轮替就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。&#x2F;etc&#x2F;logrotate.conf：是全局的日志轮替策略&#x2F;规则，当然可以单独给某个日志文件指定策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/21.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/22.png"></p>
<p>说明：也可以把某个日志文件的轮替规则，写到&#x2F;etc&#x2F;logrotate.d目录下，比如bootlog</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/23.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/24.png"></p>
<p>案例：在&#x2F;etc&#x2F;logrotate.conf进行配置，或者直接在&#x2F;etc&#x2F;logrotate.d下创建&#x2F;var&#x2F;log&#x2F;hsp.log日志的轮替文件hsplog编写boot.log日志的轮替文件中内容</p>
<ul>
<li>vim &#x2F;etc&#x2F;logrotate.d&#x2F;hsplog ———&gt;建立日志的轮替文件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/25.png"></p>
<p>5.日志轮替的机制</p>
<p>日志轮替之所以可以在指定的时间备份日志，是依赖系统定时任务。在&#x2F;etc&#x2F;cron.daily目录，就会发现这个目录中是有logrotate文件(可执行)，logrotate通过这个文件依赖定时任务执行的</p>
<p>crond后台程序每天都执行logrotate程序，logrotate程序会去读取我们写好的策略(&#x2F;etc&#x2F;logrotate.conf里面的轮替策或&#x2F;etc&#x2F;logrotate.d目录下的轮替规则)。rsyslogd只管写日志，不管轮替，轮替工作是由logrotate完成，当满足轮替规则时，进行移动、改名或删除。</p>
<p>6、内存日志</p>
<p>在Linux里面，有一部分日志是先写在内存里面的，还没有写到文件里面。如内核相关的日志是写在内存的。</p>
<p>特定：当重新启动的时候，内存日志就会被清空。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/26.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/linux_base/27.png"></p>
]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>QT基础</title>
    <url>/2024/08/03/QT%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展以及一些宏，Qt很容易扩展，并且允许真正的组件编程。</p>
<p>Qt Creator是一个用于Qt开发的轻量级跨平台集成开发环境。Qt Creator可带来两大关键益处：提供首个专为支持跨平台开发而设计的集成开发环境(IDE)，并确保首次接触Qt框架的开发人员能迅速上手和操作。即使不开发Qt应用程序，Qt Creator也是一个简单易用且功能强大的IDE。</p>
<h2 id="1-2-Qt特征"><a href="#1-2-Qt特征" class="headerlink" title="1.2 Qt特征"></a>1.2 Qt特征</h2><p>1.面向对象</p>
<p>Qt具有模块设计和控件或元素的可重用性的特点。一个控件不需要找到它的内容和用途，通过Signal和slot与外界通信、交流。而且Qt的控件都可通过继承。</p>
<p>2.控件间的相互通信</p>
<p>Qt提供signal和slot概念，这是一种安全可靠的方法，它允许回调，并支持对象之间在彼此不知道对方信息的情况下，进行合作，这使Qt非常合适于真正的控件编程。</p>
<p>3.友好的联机帮助</p>
<p>Qt包括大量的联机参考文档，有超文本HTML方式、UNIX帮助页、man手册和补充的指南。对于初学者，指南将一步步地解释Qt编程。</p>
<p>4.用户自定义</p>
<p>其它的工具包在应用时都存在一个普遍的问题，就是经常没有真正适合需求的控件，生成的自定义控件对用户来说，也是一个黑匣子。比如，在Motif手册中就讨论了用户自定义的控件问题。而在Qt中，能够创建控件，具有绝对的优越性，生成自定义控件非常简单，并且容易修改控件。</p>
<p>5.方便性</p>
<p>由于Qt是一种跨平台的GUI工具包，所以它对编程者隐藏了在处理不同窗口系统时的潜在问题。为了将基于Qt程序更加方便，Qt包含了一系列类。该类能够使程序员避免了在文件处理、时间处理等方面存在依赖操作系统方面的细节问题。</p>
<h1 id="2-Qt编译过程"><a href="#2-Qt编译过程" class="headerlink" title="2. Qt编译过程"></a>2. Qt编译过程</h1><p>1.编写代码</p>
<p>通过文本文档写入如下代码，后缀改为cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLineEdit&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHBoxLayout&gt;</span>                         <span class="comment">//水平布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QVBoxLayout&gt;</span>                         <span class="comment">//垂直布局</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span>                                <span class="comment">//窗口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;                            <span class="comment">//程序</span></span><br><span class="line">	QLabel *infoLabel = <span class="keyword">new</span> QLabel;                        <span class="comment">//信息标签对象</span></span><br><span class="line">	QLabel *openLabel = <span class="keyword">new</span> QLabel;                     <span class="comment">//打开标签对象</span></span><br><span class="line">	QLineEdit *cmdLineEdit = <span class="keyword">new</span> QLineEdit;        <span class="comment">//文本行编辑框对象</span></span><br><span class="line">	QPushButton *commitButton = <span class="keyword">new</span> QPushButton;          <span class="comment">//确定按钮</span></span><br><span class="line">	QPushButton *cancelButton = <span class="keyword">new</span> QPushButton;             <span class="comment">//取消按钮</span></span><br><span class="line">	QPushButton *browseButton = <span class="keyword">new</span> QPushButton;           <span class="comment">//浏览按钮</span></span><br><span class="line"></span><br><span class="line">	infoLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;input cmd：&quot;</span>);</span><br><span class="line">	openLabel-&gt;<span class="built_in">setText</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">	commitButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line">	cancelButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;cancel&quot;</span>);</span><br><span class="line">	browseButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;browse&quot;</span>);</span><br><span class="line"></span><br><span class="line">	QHBoxLayout *cmdLayout = <span class="keyword">new</span> QHBoxLayout;                 <span class="comment">//水平布局对象</span></span><br><span class="line">	cmdLayout-&gt;<span class="built_in">addWidget</span>(openLabel);</span><br><span class="line">	cmdLayout-&gt;<span class="built_in">addWidget</span>(cmdLineEdit);</span><br><span class="line"></span><br><span class="line">	QHBoxLayout *buttonLayout = <span class="keyword">new</span> QHBoxLayout;             <span class="comment">//水平布局对象</span></span><br><span class="line">	buttonLayout-&gt;<span class="built_in">addWidget</span>(commitButton);</span><br><span class="line">	buttonLayout-&gt;<span class="built_in">addWidget</span>(cancelButton);</span><br><span class="line">	buttonLayout-&gt;<span class="built_in">addWidget</span>(browseButton);</span><br><span class="line"></span><br><span class="line">	QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout;              <span class="comment">//垂直布局对象</span></span><br><span class="line">	mainLayout-&gt;<span class="built_in">addWidget</span>(infoLabel);</span><br><span class="line">	mainLayout-&gt;<span class="built_in">addLayout</span>(cmdLayout);                              <span class="comment">//将布局添加到布局是用addLayout函数</span></span><br><span class="line">	mainLayout-&gt;<span class="built_in">addLayout</span>(buttonLayout);</span><br><span class="line">	</span><br><span class="line">	QWidget w;                                    <span class="comment">//窗口对象</span></span><br><span class="line">	w.<span class="built_in">setLayout</span>(mainLayout);             <span class="comment">//将主布局(所有内容都在这个布局里)嵌入到窗口</span></span><br><span class="line">	w.<span class="built_in">show</span>()；</span><br><span class="line">	<span class="keyword">return</span> app.<span class="built_in">exec</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.生成工程文件</p>
<ul>
<li><p>cmd进入工程目录(最好是QT自带的)</p>
</li>
<li><p>在过程目录下的cmd输入：<code>qmake -project</code></p>
</li>
<li><p>修改工程文件，在工程目录下会生成一个后缀为pro的文件，在该文件的最后一行添加：<code>QT += widgets gui</code></p>
</li>
</ul>
<p>3.生成makefile，终端输入qmake</p>
<p>4.输入mingw32-make，执行成功就可以在工程目录下的debug或release目录下生成可执行文件。</p>
<p>注：以上步骤可能存在环境变量文件，如果出现，想要配置</p>
<h1 id="3-Qt-Creator"><a href="#3-Qt-Creator" class="headerlink" title="3. Qt Creator"></a>3. Qt Creator</h1><p>在创建一个Qt的项目时，也就是创建一个主窗口，基类的选择有以下三种：</p>
<ul>
<li><code>QmainWindow</code>：带有菜单栏的界面</li>
<li><code>QWidget</code>：不带菜单栏的界面，类似于QQ、微信的登录框</li>
<li><code>Qdialog</code>：对话框界面，完成一些业务时，弹出的对话框</li>
</ul>
<p>下面创建了一个MainWindow窗口类，继承的基类是<code>QWidget</code>，下面是窗口类的构造函数以及一些程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//this-&gt;move(100,100);   //主窗口MainWindow窗口也可以移动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnA = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);  <span class="comment">//指定父对象，这个按钮就可以内嵌到MainWindow这个窗口里面</span></span><br><span class="line">    btnA-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                   <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnA-&gt;<span class="built_in">setFixedSize</span>(<span class="number">200</span>,<span class="number">200</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnB = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnA);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnA这个按钮窗口里面</span></span><br><span class="line">    btnB-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                  <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnB-&gt;<span class="built_in">setFixedSize</span>(<span class="number">100</span>,<span class="number">100</span>);        <span class="comment">//给按钮设置固定大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第三个按钮，让这个按钮作为当前创建的子控件</span></span><br><span class="line">    QPushButton* btnC = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(btnB);   <span class="comment">//指定父对象，这个按钮就可以内嵌到btnB这个窗口里面</span></span><br><span class="line">    btnC-&gt;<span class="built_in">move</span>(<span class="number">10</span>,<span class="number">10</span>);                 <span class="comment">//移动按钮的位置</span></span><br><span class="line">    btnC-&gt;<span class="built_in">setFixedSize</span>(<span class="number">50</span>,<span class="number">50</span>);         <span class="comment">//给按钮设置固定大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>ui</code> 是一个指向UI类对象的指针，该对象通常通过UI设计器生成，并包含了所有UI组件的实例和布局信息。而<code>setupUi</code> 是UI类中的一个成员函数，它的作用是将UI组件添加到主窗口上，并设置它们的位置、大小等属性。<code>this</code> 是一个指向当前对象的指针，通常是主窗口的实例。<code>setupUi</code> 函数会使用这个指针来确定UI组件应该添加到哪个窗口上。</p>
<p>执行后的效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Qt/8_1.png" style="zoom: 67%;">

<h1 id="4-基本知识1"><a href="#4-基本知识1" class="headerlink" title="4. 基本知识1"></a>4. 基本知识1</h1><p><code>QWidget</code>类是所有用户界面对象的基类，它提供了创建和管理窗口部件的功能。另一方面，<code>QObject</code>类是Qt对象模型的基类，它提供了对象树、信号与槽机制、事件处理等基本功能。</p>
<p>Qt中有内存回收机制，但不是所有被new出的对象被自动回收，满足下面两个条件才可以自动回收：</p>
<ol>
<li>创建的对象必须是<code>QObject</code>类的子类(间接子类也可以)，<code>QObject</code>类是没有父类的，Qt中有很大一部分类都是从这个类派生出去的</li>
<li>创建出的类对象，必须要指定其父对象是谁，一般情况下有两种操作方式：<ul>
<li>在构造对象时指定父对象</li>
<li>通过调用<code>QWidget</code>的API指定父窗口对象，就是setParent()方法</li>
</ul>
</li>
</ol>
<h2 id="4-1-程序"><a href="#4-1-程序" class="headerlink" title="4.1 程序"></a>4.1 程序</h2><p>下面创建了一个主窗口MainWindow窗口类，继承的基类是QWidget，又创建了一个SubWindow窗口类，继承的基类是QWidget，并且通过ui界面将SubWindow窗口添加了一些组件(方便与主窗口做区分)。</p>
<p>以下是主窗口MainWindow类的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//SubWindow是QWidget的子类，而QWidget是Qobject类的子类，所以SubWindow执行完，其可以自动释放</span></span><br><span class="line">    SubWindow* sub = <span class="keyword">new</span> <span class="built_in">SubWindow</span>(<span class="keyword">this</span>);      <span class="comment">//this(指向了父对象MainWindow类)</span></span><br><span class="line">    sub-&gt;<span class="built_in">show</span>();      <span class="comment">//非模态显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Qt/8_2.png" style="zoom:67%;">

<h1 id="5-信号槽机制"><a href="#5-信号槽机制" class="headerlink" title="5. 信号槽机制"></a>5. 信号槽机制</h1><p>下面编写了多个类，类与类之间想要在Qt中使用信号槽机制，那么必须要满足如下条件：</p>
<ol>
<li>这个类必须从<code>QObject</code>类或者是其子类进行派生</li>
<li>在定义类的头文件种加入Q_OBJECT宏</li>
</ol>
<h2 id="5-1-自定义信号与槽"><a href="#5-1-自定义信号与槽" class="headerlink" title="5.1 自定义信号与槽"></a>5.1 自定义信号与槽</h2><p>自定义信号要求：</p>
<ul>
<li>信号是类的成员函数</li>
<li>返回值是void类型</li>
<li>信号的名字可以根据实际情况进行指定</li>
<li>参数可以随意指定，信号也可以重载</li>
<li>信号需要使用signals关键字进行声明，类似于public</li>
<li>信号函数只需要声明，不需要定义(没有函数体实现)</li>
<li>在程序中发送自定义信号，发送的本质就是调用信号函数</li>
</ul>
<p>建议：习惯性在信号函数前加关键字emit；其只是显示的声明信号被发送,没有特殊含义。底层emit &#x3D;&#x3D; #define emit</p>
<p>槽函数就是信号的处理动作，自定义槽函数和自定义的普通函数写法是一样的，要求：</p>
<ul>
<li>返回值是void类型</li>
<li>槽也是函数，因此也支持重载</li>
<li>Qt中的槽函数的类型有类的成员函数、全局函数、静态函数和lambda表达式(匿名函数)</li>
<li>槽函数可以使用关键字进行声明：public slots、private slots、protected slots</li>
</ul>
<p>信号槽使用扩展：</p>
<ol>
<li>一个信号可以连接多个槽函数，发送一个信号有多个处理函数<ul>
<li>需要写多个connect连接</li>
<li>槽函数的执行顺序是随机的，和connect函数的调用顺序没有关系</li>
<li>信号的接收者可以是一个对象，也可以是多个对象</li>
</ul>
</li>
<li>一个槽函数可以连接多个信号，多个不同的信号，处理动作是相同的<ul>
<li>写多个connect就可以</li>
</ul>
</li>
<li>信号可以连接信号：信号接收者可以接收信号，继续发出新的信号，即传递了数据，并没有进行处理</li>
<li>信号槽是可以断开的，通过disconnect()函数，其与connect函数的参数一样</li>
</ol>
<h2 id="5-2-定时器程序"><a href="#5-2-定时器程序" class="headerlink" title="5.2 定时器程序"></a>5.2 定时器程序</h2><p>下面是一个非自定义的信号与槽，所以就需要先手动在ui界面添加两个按钮和两个标签。然后通过系统提供的按钮信号来触发槽函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器对象</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);  <span class="comment">//new一个定时器对象，给其指定一个父对象(构成对象树，当析构MainWindow时，先析构timer)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改定时器对象的精度(可有可无)---&gt;添加后，显示时间时，1秒会只相差几毫秒，不然会相差有点大</span></span><br><span class="line">    timer-&gt;<span class="built_in">setTimerType</span>(Qt::PreciseTimer);   <span class="comment">//PreciseTimer表示设置了最高精度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击loopBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;loopBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer-&gt;<span class="built_in">isActive</span>())&#123;     <span class="comment">//如果定时器正在工作</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();         <span class="comment">//关闭定时器</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;开始&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//定时器还没有工作</span></span><br><span class="line">            ui-&gt;loopBtn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;关闭&quot;</span>);    <span class="comment">//设置按钮标题</span></span><br><span class="line">            timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);    <span class="comment">//启动定时器，1000ms==1s,即1秒发一个timeout信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>,[=]()&#123;        <span class="comment">//发出一个timeout信号处理该动作</span></span><br><span class="line">        QTime tm = QTime::<span class="built_in">currentTime</span>();                <span class="comment">//得到当前的一个时间</span></span><br><span class="line">        QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);    <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">        ui-&gt;curTime-&gt;<span class="built_in">setText</span>(tmstr);                    <span class="comment">//在标签上显示时间(动态显示，因为每1秒会发timeout)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按钮的点击事件：点击onceBtn会发送信号clicked，由主窗口接收，匿名函数执行对应的操作</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;onceBtn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//获取2s以后的系统时间</span></span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">            QTime tm = QTime::<span class="built_in">currentTime</span>();              <span class="comment">//得到当前的一个时间</span></span><br><span class="line">            QString tmstr = tm.<span class="built_in">toString</span>(<span class="string">&quot;hh:mm:ss.zzz&quot;</span>);  <span class="comment">//格式化当前得到的系统时间</span></span><br><span class="line">            ui-&gt;onceTime-&gt;<span class="built_in">setText</span>(tmstr);                 <span class="comment">//在标签上显示时间(静态显示，只有按下按钮才发信息)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt斗地主项目(上)</title>
    <url>/2024/08/04/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>这是一个基于Qt开发的单机版的斗地主小游戏。该项目一共涉及到的类有如下：</p>
<p>1.卡牌类</p>
<ul>
<li>单张卡牌：Card</li>
<li>多张卡牌：Cards</li>
</ul>
<p>2.玩家类</p>
<ul>
<li><p>玩家类(父类)：Player</p>
</li>
<li><p>机器人玩家(子类)：Robot</p>
</li>
<li><p>非机器人玩家(子类)：UserPlayer</p>
</li>
</ul>
<p>3.窗口类</p>
<ul>
<li><p>游戏开始加载动画窗口：Loading</p>
</li>
<li><p>游戏主窗口：GamePanel</p>
</li>
<li><p>单张卡牌窗口：CardPanel</p>
</li>
<li><p>特效动画窗口：AnimationWindow</p>
</li>
<li><p>游戏窗口中的按钮窗口：ButtonGroup</p>
</li>
<li><p>游戏结束玩家的成绩窗口：EndingPanel</p>
</li>
<li><p>自定义按钮：MyButton</p>
</li>
<li><p>游戏分数面板窗口：ScorePanel</p>
</li>
</ul>
<p>4.游戏策略类</p>
<ul>
<li><p>出牌类：PlayHand</p>
</li>
<li><p>游戏策略类：Strategy</p>
</li>
</ul>
<p>5.游戏控制类</p>
<ul>
<li>游戏控制类：GameControl</li>
</ul>
<p>6.线程类</p>
<ul>
<li><p>机器人玩家抢地主：RobotGrapLord</p>
</li>
<li><p>机器人玩家出牌：RobotPlayHand</p>
</li>
</ul>
<p>7.音频类</p>
<ul>
<li>控制播放游戏中的所有音频：BGMControl</li>
</ul>
<p>首先，创建一个项目，项目名为Landlords，再创建一个游戏主窗口类<code>GamePanel</code>，继承的基类是<code>QMainWindow</code>。该类也将作为斗地主小游戏的一个主窗口。</p>
<h1 id="2-单张卡牌类Card"><a href="#2-单张卡牌类Card" class="headerlink" title="2. 单张卡牌类Card"></a>2. 单张卡牌类Card</h1><p>单张卡牌类Card主要完成的是扑克牌中花色和点数的定义，以及一些操作符重载，以方便后序的开发中更加简便和高效。</p>
<p>单张卡牌类Card的创建：通过选择新建、c++、c++class、类名为<code>Card</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p>
<h2 id="2-1-Card类的头文件"><a href="#2-1-Card类的头文件" class="headerlink" title="2.1 Card类的头文件"></a>2.1 Card类的头文件</h2><p>该头文件主要就是定义了卡牌花色和点数的枚举类，并通过有参构造来定义一张扑克牌。在这里为了后期的开发简便，事先定义了两个card类的排序函数，后期可以通过这两个函数实现对玩家手牌的排序。由于卡牌是存储在QSet容器里面的(定义在Cards类里面的)，Qt中规定该容器里面存储的元素数据必须是可以分配和可以指定的类型，如果要存储一个自定义对象类型，需要提供其比较操作符函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Card</span>              <span class="comment">//卡牌类：每张牌的一个类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//花色枚举类(为了操作方便，给枚举类加上开始和结尾)</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardSuit</span>&#123;</span><br><span class="line">        Suit_Begin,</span><br><span class="line">        Diamond,             <span class="comment">//方块</span></span><br><span class="line">        Club,                <span class="comment">//梅花</span></span><br><span class="line">        Heart,               <span class="comment">//红桃</span></span><br><span class="line">        Spade,               <span class="comment">//黑桃</span></span><br><span class="line">        Suit_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//点数枚举类</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardPoint</span>&#123;</span><br><span class="line">        Card_Begin,         <span class="comment">//对应整数0</span></span><br><span class="line">        Card_3,</span><br><span class="line">        Card_4,</span><br><span class="line">        Card_5,</span><br><span class="line">        Card_6,</span><br><span class="line">        Card_7,</span><br><span class="line">        Card_8,</span><br><span class="line">        Card_9,</span><br><span class="line">        Card_10,</span><br><span class="line">        Card_J,</span><br><span class="line">        Card_Q,</span><br><span class="line">        Card_K,</span><br><span class="line">        Card_A,</span><br><span class="line">        Card_2,</span><br><span class="line">        Card_SJ,               <span class="comment">//小王</span></span><br><span class="line">        Card_BJ,               <span class="comment">//大王</span></span><br><span class="line">        Card_End</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Card</span>();</span><br><span class="line">    <span class="built_in">Card</span>(CardPoint point, CardSuit suit);      <span class="comment">//通过点数和花色创建一张扑克牌</span></span><br><span class="line">    <span class="comment">//设置成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPoint</span><span class="params">(CardPoint point)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSuit</span><span class="params">(CardSuit suit)</span></span>;</span><br><span class="line">    <span class="comment">//返回成员变量</span></span><br><span class="line">    <span class="function">CardPoint <span class="title">point</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">CardSuit <span class="title">suit</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CardPoint m_point;           <span class="comment">//成员变量点数</span></span><br><span class="line">    CardSuit m_suit;             <span class="comment">//成员变量花色</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象比较</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;         <span class="comment">//升序调用</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span></span>;      <span class="comment">//降序调用</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2);      <span class="comment">//操作符重载(&lt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用QSet容器,里面的使用的数据必须是可以分配和可以指定的类型(常用的基础数据类型)，如果是要存储一个对象的，不能处理的情况，就需要提供一个比较操作符的重载，并且重写</span></span><br><span class="line"><span class="comment">//一个qHash的全局函数，该函数作用是得到某个对象对应的哈希值，计算方式可以自己指定。</span></span><br><span class="line"><span class="comment">//操作符重载(==)</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right);     <span class="comment">//因为QSet容器存储自定义类型Card是有问题的，不能进行比较</span></span><br><span class="line"><span class="comment">//重写全局函数qHash</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line"><span class="comment">//定义类型的别名</span></span><br><span class="line"><span class="keyword">using</span> CardList = QVector&lt;Card&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Card类函数实现"><a href="#2-2-Card类函数实现" class="headerlink" title="2.2 Card类函数实现"></a>2.2 Card类函数实现</h2><p>这部分就是对单张卡牌Card类声明的函数进行实现，即卡牌进行构造，设置卡牌点数、花色，获取卡牌点数、花色等。也完成了一些Card类运算符的重载实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Card::<span class="built_in">Card</span>()&#123;&#125;</span><br><span class="line"><span class="comment">//提供卡牌点数和花色初始化一张牌</span></span><br><span class="line">Card::<span class="built_in">Card</span>(Card::CardPoint point, Card::CardSuit suit)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setPoint</span>(point);</span><br><span class="line">    <span class="built_in">setSuit</span>(suit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setPoint</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_point = point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置卡牌花色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Card::setSuit</span><span class="params">(Card::CardSuit suit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_suit = suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Card::point</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_point;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌的花色</span></span><br><span class="line"><span class="function">Card::CardSuit <span class="title">Card::suit</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_suit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const对象只能调用带const限定的函数，所以point和suit需要加const限定</span></span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &lt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &lt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterSort</span><span class="params">(<span class="type">const</span> Card &amp;c1, <span class="type">const</span> Card &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">point</span>() == c2.<span class="built_in">point</span>())&#123;               <span class="comment">//点数相同，就比较花色(黑桃&gt;红桃&gt;梅花&gt;方块)</span></span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">suit</span>() &gt; c2.<span class="built_in">suit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">point</span>() &gt; c2.<span class="built_in">point</span>();         <span class="comment">//不同就比较点数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Card&amp; left, <span class="type">const</span> Card&amp; right)&#123;</span><br><span class="line">    <span class="built_in">return</span> (left.<span class="built_in">point</span>()==right.<span class="built_in">point</span>()&amp;&amp;left.<span class="built_in">suit</span>()==right.<span class="built_in">suit</span>());      <span class="comment">//花色和点数完成相等放回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function">uint <span class="title">qHash</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> card.<span class="built_in">point</span>()*<span class="number">100</span>+card.<span class="built_in">suit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Card&amp; c1, <span class="type">const</span> Card&amp; c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lessSort</span>(c1, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-多张卡牌类Cards"><a href="#3-多张卡牌类Cards" class="headerlink" title="3. 多张卡牌类Cards"></a>3. 多张卡牌类Cards</h1><p>多张卡牌类Cards主要是在Card类的基础上，将对卡牌的一些功能操作进行完善和增添。</p>
<p>多张卡牌类Cards创建：通过选择新建、c++、c++class、类名为<code>Cards</code>，基类为Custom，意思是自定义，不给Card类提供基类。</p>
<h2 id="3-1-Cards类的头文件"><a href="#3-1-Cards类的头文件" class="headerlink" title="3.1 Cards类的头文件"></a>3.1 Cards类的头文件</h2><p>该头文件主要定义了一个成员变量<code>m_cards</code>，它是存储多张卡牌的的一个容器对象，以及定义了一系列的成员函数，如对卡牌的添加、删除，和获得<code>m_cards</code>对象的属性，如几张卡牌，是否为空等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cards</span>                  <span class="comment">//多张卡牌类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">SortType</span>&#123;Asc,Desc,NoSort&#125;;          <span class="comment">//枚举类，卡牌排序类型</span></span><br><span class="line">    <span class="built_in">Cards</span>();</span><br><span class="line">    <span class="built_in">Cards</span>(<span class="type">const</span> Card&amp; card);       <span class="comment">//带参的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;                   <span class="comment">//添加单张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;                 <span class="comment">//添加多张</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp; cards)</span></span>;        <span class="comment">//添加一个容器的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次性插入多个数据(操作符重载&lt;&lt;)</span></span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card);</span><br><span class="line">    Cards&amp; <span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt;&amp;cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cardCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//是否为空</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">maxPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//最小点数</span></span><br><span class="line">    <span class="function">Card::CardPoint <span class="title">minPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//指定点数的牌的数量</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pointCount</span><span class="params">(Card::CardPoint point)</span></span>;</span><br><span class="line">    <span class="comment">//某张(些)牌是否在集合中(底层是通过是否存在子集来返回)</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机取出一张扑克牌(发牌时会用)</span></span><br><span class="line">    <span class="function">Card <span class="title">takeRandomCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将QSet容器转为Qvector容器，实现排序功能</span></span><br><span class="line">    <span class="function">CardList <span class="title">toCardList</span><span class="params">(SortType type = Desc)</span></span>; <span class="comment">//CardList是在card.h里面定义的一种QVector&lt;Card&gt;的一个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QSet&lt;Card&gt; m_cards;     <span class="comment">//容器里存的是单张卡牌类对象(不重复、无序的)，不能进行排序，要排序就只能转QVector</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Cards类函数实现"><a href="#3-2-Cards类函数实现" class="headerlink" title="3.2 Cards类函数实现"></a>3.2 Cards类函数实现</h2><p>这部分就是对多张卡牌Cards类声明的函数进行实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cards::<span class="built_in">Cards</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Cards::<span class="built_in">Cards</span>(<span class="type">const</span> Card &amp;card)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">insert</span>(card);             <span class="comment">//添加单张卡牌就直接往容器m_cards插入即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">unite</span>(cards.m_cards);    <span class="comment">//添加多张卡牌就通过并联添加到容器m_cards里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::add</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">count</span>(); ++i)&#123;</span><br><span class="line">        <span class="built_in">add</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写操作符</span></span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Card&amp; card)&#123;</span><br><span class="line">    <span class="built_in">add</span>(card);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;             <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line">Cards &amp;Cards::<span class="keyword">operator</span> &lt;&lt;(<span class="type">const</span> Cards&amp; cards)&#123;</span><br><span class="line">    <span class="built_in">add</span>(cards);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;            <span class="comment">//返回当前类对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> QVector&lt;Cards&gt; &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cards.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">remove</span>(cards.<span class="built_in">at</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(card);                 <span class="comment">//从容器中移出卡牌card</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除多张卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::remove</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">subtract</span>(cards.m_cards);      <span class="comment">//通过差集将容器m_cards移出多张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::cardCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断手牌是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">isEmpty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除m_cards容器里的卡牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cards::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最大点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::maxPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint max = Card::Card_Begin;             <span class="comment">//Card_Begin对应的枚举类值为0</span></span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &gt; max)&#123;</span><br><span class="line">                max = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;       <span class="comment">//返回容器中最大点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取手牌中最小点数的卡牌</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">Cards::minPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Card::CardPoint min = Card::Card_End;</span><br><span class="line">    <span class="keyword">if</span>(!m_cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() &lt; min)&#123;</span><br><span class="line">                min = it-&gt;<span class="built_in">point</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;       <span class="comment">//返回容器中最小点数的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到点数为point的卡牌</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Cards::pointCount</span><span class="params">(Card::CardPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;            <span class="comment">//记录数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;<span class="built_in">point</span>() == point)&#123;</span><br><span class="line">            count++;          <span class="comment">//如果等于指定点数，数量就+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(card);            <span class="comment">//是否存在该张卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cards::contains</span><span class="params">(<span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards.<span class="built_in">contains</span>(cards.m_cards);    <span class="comment">//是否存在该些卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌，后面发牌操作会用到</span></span><br><span class="line"><span class="function">Card <span class="title">Cards::takeRandomCard</span><span class="params">()</span>          <span class="comment">//随机取出一张卡牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成一个随机数</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(m_cards.<span class="built_in">size</span>());     <span class="comment">//返回一个0到(卡牌数-1)范围的数字，即0到51</span></span><br><span class="line">    QSet&lt;Card&gt;::const_iterator it = m_cards.<span class="built_in">constBegin</span>();              <span class="comment">//const_iterator是只读迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++,it++);</span><br><span class="line">    Card card = *it;         <span class="comment">//记录随机数对应的卡牌</span></span><br><span class="line">    m_cards.<span class="built_in">erase</span>(it);       <span class="comment">//从容器中移出该卡牌</span></span><br><span class="line">    <span class="keyword">return</span> card;             <span class="comment">//返回随机数对应的卡牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对手牌进行升序还是降序</span></span><br><span class="line"><span class="function">CardList <span class="title">Cards::toCardList</span><span class="params">(Cards::SortType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cards.<span class="built_in">begin</span>(); it!=m_cards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        list &lt;&lt; *it;           <span class="comment">//每遍历一个元素，就将元素存入list</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == Asc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),lessSort);            <span class="comment">//升序</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == Desc)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(list.<span class="built_in">begin</span>(),list.<span class="built_in">end</span>(),greaterSort);         <span class="comment">//降序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-卡牌窗口类CardPanel"><a href="#4-卡牌窗口类CardPanel" class="headerlink" title="4. 卡牌窗口类CardPanel"></a>4. 卡牌窗口类CardPanel</h1><p>因为每张卡牌在主界面中都是以窗口的形式出现，所以该卡牌窗口类<code>CardPanel</code>相当于是对卡牌对象更充分的完善。</p>
<p>卡牌窗口类创建：通过选择新建、c++、c++class、类名为<code>CardPanel</code>，基类为QWidget。</p>
<h2 id="4-1-CardPanel类头文件"><a href="#4-1-CardPanel类头文件" class="headerlink" title="4.1 CardPanel类头文件"></a>4.1 CardPanel类头文件</h2><p>该头文件加载了每张卡牌的的图片，其定义了一系列的成员变量和成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CardPanel</span> : <span class="keyword">public</span> QWidget          <span class="comment">//卡牌窗口类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CardPanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置获取图片函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span>;      <span class="comment">//保存图片信息的，参数1是正面图片；参数2是背面图片</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">getImage</span><span class="params">()</span></span>;               <span class="comment">//获取正面图片信息(背面都是一样的)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌显示哪一面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFrontSide</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录窗口是否被选中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSelected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function">Card <span class="title">getCard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扑克牌的所有者</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setOwner</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getOwner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clicked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *event)</span></span>;             <span class="comment">//事件处理函数，更新窗口信息的</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;        <span class="comment">//重写鼠标按下事件</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;       <span class="comment">//用户玩家的鼠标选择信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_front;</span><br><span class="line">    QPixmap m_back;</span><br><span class="line">    <span class="type">bool</span> m_isfront=<span class="literal">true</span>;                <span class="comment">//是否是正面</span></span><br><span class="line">    <span class="type">bool</span> m_isSelect=<span class="literal">false</span>;              <span class="comment">//是否被选中</span></span><br><span class="line">    Card m_card;                        <span class="comment">//卡牌类对象</span></span><br><span class="line">    Player* m_owner=<span class="literal">nullptr</span>;            <span class="comment">//玩家类对象</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-CardPanel类函数实现"><a href="#4-2-CardPanel类函数实现" class="headerlink" title="4.2 CardPanel类函数实现"></a>4.2 CardPanel类函数实现</h2><p>这部分就是卡牌窗口类<code>CardPanel</code>里面声明的函数进行实现。可以通过该类成员获得卡牌窗口的一些属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CardPanel::<span class="built_in">CardPanel</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)&#123;&#125;</span><br><span class="line"><span class="comment">//加载卡牌窗口图片</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setImage</span><span class="params">(<span class="type">const</span> QPixmap &amp;front, <span class="type">const</span> QPixmap &amp;back)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_front = front;</span><br><span class="line">    m_back = back;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_front.<span class="built_in">size</span>());        <span class="comment">//设置当前的窗口大小为图片大小</span></span><br><span class="line">    <span class="built_in">update</span>();                           <span class="comment">//刷新窗口，调用的是paintEvent()函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取卡牌窗口的正面</span></span><br><span class="line"><span class="function">QPixmap <span class="title">CardPanel::getImage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置是正面还是反面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setFrontSide</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isfront = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isFrontSide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isfront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口是否被选中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setSeclected</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isSelect = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CardPanel::isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isSelect;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的花色以及点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_card = card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Card <span class="title">CardPanel::getCard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::setOwner</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_owner = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扑克牌的所有者</span></span><br><span class="line"><span class="function">Player *<span class="title">CardPanel::getOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_owner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟扑克牌的点击事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(Qt::LeftButton)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口刷新函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::paintEvent</span><span class="params">(QPaintEvent *event)</span>     <span class="comment">//当setImage()函数把图片设置好后，就可以重新绘制窗口了，即调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(event);               <span class="comment">//处理event参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;             <span class="comment">//定义一个画家类</span></span><br><span class="line">    <span class="keyword">if</span>(m_isfront)&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_front);      <span class="comment">//如果是正面，就画正面，大小和当前窗口一样大rect()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_back);       <span class="comment">//如果是背面，就画背面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新写鼠标划过函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CardPanel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">cardSelected</span><span class="params">(event-&gt;button())</span></span>;             <span class="comment">//游戏的主窗口接收该信号(鼠标按键的选择)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-玩家类Player"><a href="#5-玩家类Player" class="headerlink" title="5. 玩家类Player"></a>5. 玩家类Player</h1><p>该类是作为游戏里的三个玩家的基类，即两个机器人玩家类和用户玩家类。作为基类，它定义了一些共同的属性，提示为后序的开发提供了一些辅助函数，方便得到需要的属性内容。</p>
<p>玩家类创建：通过选择新建、c++、c++class、类名为<code>Player</code>，基类为QObject。</p>
<h2 id="5-1-Player类头文件"><a href="#5-1-Player类头文件" class="headerlink" title="5.1 Player类头文件"></a>5.1 Player类头文件</h2><p>该头文件不仅定义了许多关于玩家的成员变量和成员函数，还定义了四个虚函数，通过多态的方式来实现不同机器人玩家的这个处理逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> : <span class="keyword">public</span> QObject               <span class="comment">//玩家类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Role</span>&#123;Lord, Farmer&#125;;             <span class="comment">//角色</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Sex</span>&#123;Man, Woman&#125;;                <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Direction</span>&#123;Left, Right&#125;;         <span class="comment">//头像的显示方位</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Robot, User, UnKnow&#125;;      <span class="comment">//玩家的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Player</span><span class="params">(QString name, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//名字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(QString name)</span></span>;</span><br><span class="line">    <span class="function">QString <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setRole</span><span class="params">(Role role)</span></span>;</span><br><span class="line">    <span class="function">Role <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSex</span><span class="params">(Sex sex)</span></span>;</span><br><span class="line">    <span class="function">Sex <span class="title">getSex</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头像方位</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDirection</span><span class="params">(Direction direction)</span></span>;</span><br><span class="line">    <span class="function">Direction <span class="title">getDirection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setType</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getScore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//游戏结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供当前对象的上家/下家对象</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPrevPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNextPlayer</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getPrevPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Player* <span class="title">getNextPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//叫地主、抢地主(传出一个信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">grabLordBet</span><span class="params">(<span class="type">int</span> point)</span></span>;           <span class="comment">//传入的是分数(1，2，3，0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储扑克牌(发牌的时候得到的)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Card&amp; card)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storeDispatchCard</span><span class="params">(Cards&amp; cards)</span></span>;        <span class="comment">//抢地主得到的牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到所有的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//清空玩家手中所有的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">(Cards&amp; cards)</span></span>;            <span class="comment">//出牌可以出一张也可以出多张</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取待出牌玩家对象以及这个玩家打出的牌(比如说当前玩家出牌后，要记录出牌的玩家和出的牌，下一个出牌玩家会用到)</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">storePendingInfo</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚函数 通过多态来实现机器人玩家A和机器人玩家B(有相同的同名函数，但处理逻辑不一样，所以用多态实现)</span></span><br><span class="line">    <span class="comment">//下面4个虚函数在play只需要定义即可，功能实现交给子类，即机器人玩家和用户玩家</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span></span>;           <span class="comment">//准备叫地主(启动 考虑叫地主 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span></span>;           <span class="comment">//准备出牌(启动 考虑出牌 子线程来完成)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span></span>;             <span class="comment">//考虑叫地主(计算权重)---&gt;机器人玩家类Robot会重写该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span></span>;             <span class="comment">//考虑出牌---&gt;计算机玩家类Robot会重写该函数</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//通知已经叫地主下注</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;         <span class="comment">//参数：叫地主的玩家，下的分数</span></span><br><span class="line">    <span class="comment">//通知已经出牌(playHand()出牌函数会使用，当玩家出完牌后，需要发送的信号)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;        <span class="comment">//参数：出牌玩家，出的牌</span></span><br><span class="line">    <span class="comment">//向主窗口通知已经得到了卡牌(两种情况，普通得牌和得3张底牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPickCards</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                       <span class="comment">//子类也需要访问这些成员属性遍历，所以得是protected类型</span></span><br><span class="line">    QString m_name;              <span class="comment">//玩家姓名</span></span><br><span class="line">    Role m_role;                 <span class="comment">//玩家角色(枚举类)，地主还是农民</span></span><br><span class="line">    Sex m_sex;                   <span class="comment">//玩家性别(枚举类)，角色性别</span></span><br><span class="line">    Direction m_direction;       <span class="comment">//玩家的头像的显示方位(枚举类)，左或右</span></span><br><span class="line">    Type m_type;                 <span class="comment">//玩家的类型(枚举类)，机器人、用户或未知</span></span><br><span class="line">    <span class="type">int</span> m_score;                 <span class="comment">//玩家的分数</span></span><br><span class="line">    <span class="type">bool</span> m_isWin;                <span class="comment">//玩家是否获胜</span></span><br><span class="line"></span><br><span class="line">    Player* m_prev;            <span class="comment">//上家</span></span><br><span class="line">    Player* m_next;            <span class="comment">//下家</span></span><br><span class="line"></span><br><span class="line">    Cards m_cards;             <span class="comment">//存储多张扑克牌(玩家手中的牌)</span></span><br><span class="line"></span><br><span class="line">    Cards m_pendCards;                    <span class="comment">//打出的扑克牌</span></span><br><span class="line">    Player* m_pendPlayer = <span class="literal">nullptr</span>;         <span class="comment">//打出扑克牌的玩家(初始化先置为空)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Player类函数实现"><a href="#5-2-Player类函数实现" class="headerlink" title="5.2 Player类函数实现"></a>5.2 Player类函数实现</h2><p>该玩家类Player实现了两种类的构造函数方法，同时实现了设置和获取玩家的相关属性。而虚函数在这里只需要定义出来即可，不需要实现，留给子类实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Player::<span class="built_in">Player</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)        <span class="comment">//玩家类的构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    m_score = <span class="number">0</span>;                  <span class="comment">//分数初始化为0</span></span><br><span class="line">    m_isWin = <span class="literal">false</span>;              <span class="comment">//初始化是否赢</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;       <span class="comment">//上次出牌玩家开始指向空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当用的是这个构造函数时，也会初始化父类的构造函数</span></span><br><span class="line">Player::<span class="built_in">Player</span>(QString name, QObject *parent) : <span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的名字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setName</span><span class="params">(QString name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QString <span class="title">Player::getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的角色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setRole</span><span class="params">(Role role)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_role = role;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Role <span class="title">Player::getRole</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_role;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家性别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setSex</span><span class="params">(Player::Sex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Sex <span class="title">Player::getSex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的头像方位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setDirection</span><span class="params">(Player::Direction direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_direction = direction;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Direction <span class="title">Player::getDirection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_direction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的类型(机器人玩家还是用户玩家)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setType</span><span class="params">(Player::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player::Type <span class="title">Player::getType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和获取玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setScore</span><span class="params">(<span class="type">int</span> score)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Player::getScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家身份获胜</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setWin</span><span class="params">(<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_isWin = flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Player::isWin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_isWin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置玩家的上一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setPrevPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_prev = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置玩家的下一个位置玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::setNextPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_next = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的上一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPrevPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回玩家的下一个位置玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getNextPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::grabLordBet</span><span class="params">(<span class="type">int</span> point)</span>      <span class="comment">//抢地主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(<span class="keyword">this</span>, point)</span></span>;  <span class="comment">//发出玩家叫地主的信号，游戏控制类接收该信号，参数：抢地主玩家，下的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入单张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Card &amp;card)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(card);</span><br><span class="line">    Cards cs;</span><br><span class="line">    cs.<span class="built_in">add</span>(card);</span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>, cs)</span></span>;            <span class="comment">//向主窗口通知得到牌了(发牌阶段)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存入多张扑克牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storeDispatchCard</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">add</span>(cards);           <span class="comment">//添加底牌</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPickCards</span><span class="params">(<span class="keyword">this</span>,cards)</span></span>;      <span class="comment">//向主窗口通知得到3张底牌了(在游戏控制类中becomelords()中,添加底牌会调用该函数)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_cards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::clearCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::playHand</span><span class="params">(Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_cards.<span class="built_in">remove</span>(cards);                 <span class="comment">//从玩家手中的牌移出要出的牌</span></span><br><span class="line">    <span class="comment">//发出信号，因为该信号可能是机器人玩家发出，也可能是用户玩家发出，所以就通过基类指针this指向子类对象</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(<span class="keyword">this</span>, cards)</span></span>;         <span class="comment">//该信号由游戏控制类接收处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得上一次的出牌玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">Player::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得上一次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Player::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录上一次的出牌玩家和出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::storePendingInfo</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_pendPlayer = player;</span><br><span class="line">    m_pendCards = cards;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只定义出四个虚函数即可，留给子类实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::prepareCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::preparePlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkCallLord</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Player::thinkPlayHand</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-机器人玩家类Robot"><a href="#6-机器人玩家类Robot" class="headerlink" title="6. 机器人玩家类Robot"></a>6. 机器人玩家类Robot</h1><p>机器人玩家类Robot的基类是玩家类Player，它主要任务就是实现从父类继承下来的虚函数。</p>
<p>机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>Robot</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将基类改为Player类。</p>
<h2 id="6-1-Robot类头文件"><a href="#6-1-Robot类头文件" class="headerlink" title="6.1 Robot类头文件"></a>6.1 Robot类头文件</h2><p>机器人玩家类Robot只需要实现从父类继承来的虚函数即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span> : <span class="keyword">public</span> Player          <span class="comment">//机器人玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Robot</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">//重写父类函数，创建子线程类对象，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">thinkPlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;       <span class="comment">//考虑出牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-Robot类函数实现"><a href="#6-2-Robot类函数实现" class="headerlink" title="6.2 Robot类函数实现"></a>6.2 Robot类函数实现</h2><p>这部分主要就是实现了准备叫地主、考虑叫地主、准备出牌和考虑出牌。</p>
<p>当是机器人玩家时，它会将从父类Player继承下来的虚函数进行重写。首先是在准备叫地主函数<code>prepareCallLord()</code>中，它会创建一个叫地主的子线程类<code>RobotGrapLord</code>(在后面)，然后执行<code>strat()</code>，它会启动子线程类里面的<code>run()</code>函数，而<code>run()</code>函数是睡眠了2s后，调用考虑叫地主函数<code>thinkCallLord()</code>。机器人玩家通过计算手牌的权重来得出是否叫地主的决定。对于准备和考虑出牌过程和这个一模一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Robot::<span class="built_in">Robot</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::Robot;         <span class="comment">//确定玩家类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::prepareCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotGrapLord* subThread = <span class="keyword">new</span> <span class="built_in">RobotGrapLord</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑叫地主的子线程类</span></span><br><span class="line">    <span class="comment">//当子线程里面内容都执行完了，会发出finished信号过后，就调用deleteLater()方法，释放掉该线程占用的内存</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotGrapLord 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();        <span class="comment">//启动考虑叫地主子线程类的run，run函数里面会调用thinkCallLord()来计算权重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::preparePlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RobotPlayHand* subThread = <span class="keyword">new</span> <span class="built_in">RobotPlayHand</span>(<span class="keyword">this</span>);       <span class="comment">//创建一个考虑出牌的子线程类</span></span><br><span class="line">    <span class="built_in">connect</span>(subThread, &amp;RobotGrapLord::finished, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt;<span class="string">&quot;RobotPlayHand 子线程对象析构.....&quot;</span> &lt;&lt; <span class="string">&quot;,Robot name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        subThread-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    subThread-&gt;<span class="built_in">start</span>();             <span class="comment">//启动run函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑叫地主</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkCallLord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*  机器人玩家基于手中的牌计算权重，根据权重来考虑是否叫地主</span></span><br><span class="line"><span class="comment">        大小王：6</span></span><br><span class="line"><span class="comment">        顺子/炸弹：5</span></span><br><span class="line"><span class="comment">        三张点数相同的牌：4</span></span><br><span class="line"><span class="comment">        2的权重：3</span></span><br><span class="line"><span class="comment">        对牌：1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;</span><br><span class="line">    weight += st.<span class="built_in">getRangeCards</span>(Card::Card_SJ,Card::Card_BJ).<span class="built_in">cardCount</span>()*<span class="number">6</span>;     <span class="comment">//得到手牌中大小王的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;optSeq = st.<span class="built_in">pickOptimalSeqSingles</span>();   <span class="comment">//pickOptimalSeqSingles函数内部还是再找顺子之前，已经剔除了炸弹、3带1和飞机类型牌</span></span><br><span class="line">    weight += optSeq.<span class="built_in">size</span>()*<span class="number">5</span>;                   <span class="comment">//得到手牌中的顺子的权重</span></span><br><span class="line"></span><br><span class="line">    QVector&lt;Cards&gt;bombs = st.<span class="built_in">findCardsByCount</span>(<span class="number">4</span>);</span><br><span class="line">    weight += bombs.<span class="built_in">size</span>()*<span class="number">5</span>;                                 <span class="comment">//得到手牌中炸弹的权重</span></span><br><span class="line"></span><br><span class="line">    weight += m_cards.<span class="built_in">pointCount</span>(Card::Card_2) * <span class="number">3</span>;           <span class="comment">//得到2的权重</span></span><br><span class="line"></span><br><span class="line">    Cards tmp = m_cards;                            <span class="comment">//防止计算权重的牌重复，先复制手牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(optSeq);                             <span class="comment">//剔除顺子</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(bombs);                              <span class="comment">//剔除炸弹</span></span><br><span class="line">    Cards card2 = st.<span class="built_in">getRangeCards</span>(Card::Card_2,Card::Card_2);       <span class="comment">//先取出点数为2的牌</span></span><br><span class="line">    tmp.<span class="built_in">remove</span>(card2);                              <span class="comment">//剔除2</span></span><br><span class="line">    QVector&lt;Cards&gt;triples = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">3</span>);  <span class="comment">//在剔除相应牌型后，再继续找三张相同的牌</span></span><br><span class="line">    weight += triples.<span class="built_in">size</span>()*<span class="number">4</span>;                                      <span class="comment">//得到三张点数相同的牌的权重</span></span><br><span class="line"></span><br><span class="line">    tmp.<span class="built_in">remove</span>(triples);                           <span class="comment">//剔除三张相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;pairs = <span class="built_in">Strategy</span>(<span class="keyword">this</span>,tmp).<span class="built_in">findCardsByCount</span>(<span class="number">2</span>);   <span class="comment">//在tmp里找对牌</span></span><br><span class="line">    weight += pairs.<span class="built_in">size</span>()*<span class="number">1</span>;                                       <span class="comment">//得到对牌的权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(weight &gt;= <span class="number">22</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">22</span> &amp;&amp; weight&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(weight&lt;<span class="number">18</span> &amp;&amp; weight&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">grabLordBet</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Robot::thinkPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Strategy <span class="title">st</span><span class="params">(<span class="keyword">this</span>, m_cards)</span></span>;              <span class="comment">//先构造一个Strategy对象，这样就可以使用Strategy类里面的函数了</span></span><br><span class="line">    Cards cs = st.<span class="built_in">makeStrategy</span>();                  <span class="comment">//调用出牌策略函数，可以直接得到机器人玩家要出的牌</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;打出的牌数量：&quot;</span> &lt;&lt;cs.<span class="built_in">cardCount</span>();</span><br><span class="line">    <span class="built_in">playHand</span>(cs);                                  <span class="comment">//出牌，即从手牌中移除要出的牌cs</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-用户玩家类UserPlayer"><a href="#7-用户玩家类UserPlayer" class="headerlink" title="7. 用户玩家类UserPlayer"></a>7. 用户玩家类UserPlayer</h1><p>用户玩家类UserPlayer只需要实现从基类Player继承下来的虚函数准备叫地主和准备出牌，且都不需要写太多程序操作，因为这些过程都是用户通过鼠标点击来完成的。</p>
<p>非机器人玩家类创建：通过选择新建、c++、c++class、类名为<code>UserPlayer</code>，基类设为Custom，选择Player，勾选Include QObject和Add QOBJECT。创建好后，将其基类改为Player。</p>
<h2 id="7-1-UserPlayer类头文件"><a href="#7-1-UserPlayer类头文件" class="headerlink" title="7.1 UserPlayer类头文件"></a>7.1 UserPlayer类头文件</h2><p>该类只定义从基类继承下来的虚函数准备叫地主和准备出牌。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserPlayer</span> : <span class="keyword">public</span> Player              <span class="comment">//非机器人(用户)玩家子类</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用继承构造函数(就不需要自己重新写了)</span></span><br><span class="line">    <span class="keyword">using</span> Player::Player;                   <span class="comment">//using是告诉当前的类，可以使用基类Player里面的所有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UserPlayer</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareCallLord</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preparePlayHand</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">//用户玩家准备出牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startCountDown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-UserPlayer类函数实现"><a href="#7-2-UserPlayer类函数实现" class="headerlink" title="7.2 UserPlayer类函数实现"></a>7.2 UserPlayer类函数实现</h2><p>该部分实现的两个虚函数都不需要做太多操作，因为是用户玩家，这些过程都是通过鼠标完成。但在准备出牌函数中，发出了一个信号<code>startCountDown</code>，表示从轮到用户玩家出牌开始就通知主窗口计时，当秒数从15变为0时，就默认用户玩家放弃出牌。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UserPlayer::<span class="built_in">UserPlayer</span>(QObject *parent):<span class="built_in">Player</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = Player::User;         <span class="comment">//确定玩家类型(用户)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备叫地主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::prepareCallLord</span><span class="params">()</span>               <span class="comment">//用户玩家的这个类是空的，机器人玩家才会使用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备出牌函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UserPlayer::preparePlayHand</span><span class="params">()</span>               <span class="comment">//用户玩家准备出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">emit <span class="title">startCountDown</span><span class="params">()</span></span>;                       <span class="comment">//发射一个信号，告知主窗口是用户玩家准备出牌，要开始倒计时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="8-叫地主线程类RobotGrapLord"><a href="#8-叫地主线程类RobotGrapLord" class="headerlink" title="8. 叫地主线程类RobotGrapLord"></a>8. 叫地主线程类RobotGrapLord</h1><p>叫地主线程类<code>RobotGrapLord</code>是专为机器人玩家设计的类，就是负责模拟叫地主这一过程。</p>
<p>机器人玩家叫地主线程类创建：新建、c、c++、类名为<code>RobotGrapLord</code>，基类为QObject，创建好后修改基类为QThread。</p>
<h2 id="8-1-RobotGrapLord类头文件"><a href="#8-1-RobotGrapLord类头文件" class="headerlink" title="8.1 RobotGrapLord类头文件"></a>8.1 RobotGrapLord类头文件</h2><p>叫地主线程类RobotGrapLord就定义了一个从基类继承下来的run()方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RobotGrapLord</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotGrapLord</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//重写QThread类里面的run方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;                <span class="comment">//执行机器人玩家叫地主</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-RobotGrapLor类函数实现"><a href="#8-2-RobotGrapLor类函数实现" class="headerlink" title="8.2 RobotGrapLor类函数实现"></a>8.2 RobotGrapLor类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑叫地主函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RobotGrapLord::<span class="built_in">RobotGrapLord</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player= player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过start()来调用run()函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotGrapLord::run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);                      <span class="comment">//睡2秒，模拟机器人玩家一个思考的过程</span></span><br><span class="line">    m_player-&gt;<span class="built_in">thinkCallLord</span>();         <span class="comment">//直接调用Robot类写的考虑叫地主函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-出牌线程类RobotPlayHand"><a href="#9-出牌线程类RobotPlayHand" class="headerlink" title="9. 出牌线程类RobotPlayHand"></a>9. 出牌线程类RobotPlayHand</h1><p>出牌线程类<code>RobotPlayHand</code>是专为机器人玩家设计的类，就是负责模拟出牌这一过程。</p>
<p>机器人玩家出牌线程类创建：新建、c、c++、类名为<code>RobotPlayHand</code>，基类为QObject，创建好后修改基类为QThread。</p>
<h2 id="9-1-RobotPlayHand类头文件"><a href="#9-1-RobotPlayHand类头文件" class="headerlink" title="9.1 RobotPlayHand类头文件"></a>9.1 RobotPlayHand类头文件</h2><p>出牌线程类RobotPlayHand就定义了一个从基类继承下来的run()方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机器人玩家出牌子线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotPlayHand</span> : <span class="keyword">public</span> QThread</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">RobotPlayHand</span><span class="params">(Player* player, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>;                   <span class="comment">//重写</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-RobotPlayHand类函数实现"><a href="#9-2-RobotPlayHand类函数实现" class="headerlink" title="9.2 RobotPlayHand类函数实现"></a>9.2 RobotPlayHand类函数实现</h2><p>该子线程就睡眠了2s，模拟机器人玩家考虑的这个过程，然后调用机器人玩家类的考虑出牌函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RobotPlayHand::<span class="built_in">RobotPlayHand</span>(Player* player, QObject *parent) : <span class="built_in">QThread</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_player = player;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RobotPlayHand::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">msleep</span>(<span class="number">2000</span>);</span><br><span class="line">    m_player-&gt;<span class="built_in">thinkPlayHand</span>();        <span class="comment">//调用考虑出牌函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-玩家分数窗口类ScorePanel"><a href="#10-玩家分数窗口类ScorePanel" class="headerlink" title="10. 玩家分数窗口类ScorePanel"></a>10. 玩家分数窗口类ScorePanel</h1><p>分数窗口类ScorePanel就是负责显示各个玩家的分数，在该小项目中，有两处会使用该分数窗口。一个是主窗口的左上角会显示各个玩家的分数；还有一个是一局游戏结束后，在结束面板上显示各个玩家的分数。</p>
<h2 id="10-1-制作分数面板窗口"><a href="#10-1-制作分数面板窗口" class="headerlink" title="10.1 制作分数面板窗口"></a>10.1 制作分数面板窗口</h2><p>创建子窗口：</p>
<p>1.游戏分数面板子窗口：通过选择新建、Qt、Qt设计师界面类、选择Widget类型的窗口(可以内嵌的，以没有边框的形式完美的附着在父窗口上面)，类名为<code>ScorePanel</code>。</p>
<p>2.将分数窗口添加到主窗口(右上方)</p>
<p>在主窗口拖入一个Widget子窗口，因为它是一个Widget类型，而不是分数面板的类型，所以就需要进行提升，即就是把父类变为子类。基于这个理论，可以发现分数面板类ScorePanel的基类是Widget类型，所以就可以将该Widget类提升为ScorePanel类型。这样就将Qt中的标准控件变为了自定义控件(把一个基类变成了子类类型)。</p>
<h2 id="10-2-ScorePanel类头文件"><a href="#10-2-ScorePanel类头文件" class="headerlink" title="10.2 ScorePanel类头文件"></a>10.2 ScorePanel类头文件</h2><p>分数窗口类ScorePanel就定义了一些设置属性的函数，如字体的大小和颜色，这样后期要使用分数窗口的时候，也可以根据环境来设置适合的字体和颜色。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScorePanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FontColor</span>&#123;Black, White,Red,Blue,Green&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ScorePanel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ScorePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置玩家的得分(将得分显示在窗口上)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span>;     <span class="comment">//参数是三个玩家的得分</span></span><br><span class="line">    <span class="comment">//设置字体大小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span>;</span><br><span class="line">    <span class="comment">//设置字体的颜色</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMyFontColor</span><span class="params">(FontColor color)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ScorePanel *ui;</span><br><span class="line">    QVector&lt;QLabel*&gt; m_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="10-3-ScorePanel类函数实现"><a href="#10-3-ScorePanel类函数实现" class="headerlink" title="10.3 ScorePanel类函数实现"></a>10.3 ScorePanel类函数实现</h2><p>该部分就是实现了头文件定义的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> QString MYCOLOR[] = &#123;<span class="string">&quot;black&quot;</span>, <span class="string">&quot;white&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line">ScorePanel::<span class="built_in">ScorePanel</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ScorePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//将拖到ui上的标签都存入到m_list容器中</span></span><br><span class="line">    m_list &lt;&lt; ui-&gt;meScore &lt;&lt; ui-&gt;leftScore &lt;&lt; ui-&gt;rightScore</span><br><span class="line">           &lt;&lt; ui-&gt;meTitle &lt;&lt; ui-&gt;leftTitle &lt;&lt; ui-&gt;rightTitle</span><br><span class="line">           &lt;&lt; ui-&gt;score1 &lt;&lt; ui-&gt;score2 &lt;&lt; ui-&gt;score3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScorePanel::~<span class="built_in">ScorePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置3个玩家的分数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setScores</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要将整形数据转换为字符串类型数据</span></span><br><span class="line">    ui-&gt;leftScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(left));</span><br><span class="line">    ui-&gt;rightScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(right));</span><br><span class="line">    ui-&gt;meScore-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(user));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置字体</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontSize</span><span class="params">(<span class="type">int</span> point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QFont <span class="title">font</span><span class="params">(<span class="string">&quot;微软雅黑&quot;</span>, point, QFont::Bold)</span></span>;               <span class="comment">//定义一个字体对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;                     <span class="comment">//遍历分数面板的所有按钮，都设置为该字体</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setFont</span>(font);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScorePanel::setMyFontColor</span><span class="params">(ScorePanel::FontColor color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString style = <span class="built_in">QString</span>(<span class="string">&quot;QLabel&#123;color:%1&#125;&quot;</span>).<span class="built_in">arg</span>(MYCOLOR[color]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_list.<span class="built_in">size</span>(); i++)&#123;              <span class="comment">//遍历分数面板的所有按钮，都设置为该颜色</span></span><br><span class="line">        m_list[i]-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-自定义按钮类MyButton"><a href="#11-自定义按钮类MyButton" class="headerlink" title="11. 自定义按钮类MyButton"></a>11. 自定义按钮类MyButton</h1><p>自定义按钮类MyButton主要就是对按钮进行美化，当鼠标经过按钮、按下按钮都加载显示不同的图片，起到一个有点击的效果。</p>
<h2 id="11-1-自定义按钮类"><a href="#11-1-自定义按钮类" class="headerlink" title="11.1 自定义按钮类"></a>11.1 自定义按钮类</h2><p>创建自定义按钮类：</p>
<p>通过选择新建、c++、c++class、类名为<code>MyButton</code>，基类设为QWidget。但创建好后，就将MyButton的基类QWidget修改为QPushButton。</p>
<p>不用带ui，该类只对按钮做美化，按钮上要放什么东西，不在考虑内。从QpushButton派生，然后基于QpushButton在按钮上做美化。</p>
<h2 id="11-2-MyButton类头文件"><a href="#11-2-MyButton类头文件" class="headerlink" title="11.2 MyButton类头文件"></a>11.2 MyButton类头文件</h2><p>自定义按钮类<code>MyButton</code>主要就是将从基类继承下来的函数进行定义，如鼠标按下、鼠标释放、鼠标进入和鼠标离开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyButton</span> : <span class="keyword">public</span> QPushButton</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyButton</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//鼠标按下</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标进入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//鼠标离开</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent* ev)</span></span>;</span><br><span class="line">    <span class="comment">//绘图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    </span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//成员变量，对应三张图片的路径</span></span><br><span class="line">    QString m_normal;            <span class="comment">//定义的是正常情况下的图片路径</span></span><br><span class="line">    QString m_hover;             <span class="comment">//定义的是鼠标滑过按钮的图片路径</span></span><br><span class="line">    QString m_pressed;           <span class="comment">//定义的是鼠标按下按钮的图片路径</span></span><br><span class="line"></span><br><span class="line">    QPixmap m_pixmap;           <span class="comment">//得到的路径需要转为QPixmap对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="11-3-MyButton类函数实现"><a href="#11-3-MyButton类函数实现" class="headerlink" title="11.3 MyButton类函数实现"></a>11.3 MyButton类函数实现</h2><p>这部分就是对自定义按钮类MyButton的头文件定义的函数进行实现，不同情况，加载不同图片，也显示不同图片。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyButton::<span class="built_in">MyButton</span>(QWidget *parent) : <span class="built_in">QPushButton</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::setImage</span><span class="params">(QString normal, QString hover, QString pressed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_normal = normal;</span><br><span class="line">    m_hover = hover;</span><br><span class="line">    m_pressed = pressed;</span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);           <span class="comment">//默认情况下，就加载m_normal图片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mousePressEvent</span><span class="params">(QMouseEvent *ev)</span>               <span class="comment">//鼠标按下</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标按下的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_pressed);                             <span class="comment">//加载m_pressed图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mousePressEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::mouseReleaseEvent</span><span class="params">(QMouseEvent *ev)</span>             <span class="comment">//鼠标释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">button</span>() == Qt::LeftButton)&#123;                       <span class="comment">//如果鼠标释放的是左键</span></span><br><span class="line">        m_pixmap.<span class="built_in">load</span>(m_normal);                              <span class="comment">//加载m_normal图片</span></span><br><span class="line">        <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为重写了父类的虚函数，而又需要使用到父类该虚函数定义的一些功能，所以就等执行完重写的后，再执行父类的该虚函数</span></span><br><span class="line">    QPushButton::<span class="built_in">mouseReleaseEvent</span>(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::enterEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标进入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_hover);                                     <span class="comment">//鼠标经过按钮，加载hover图片</span></span><br><span class="line">    <span class="built_in">update</span>();                   <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::leaveEvent</span><span class="params">(QEvent *ev)</span>                         <span class="comment">//鼠标离开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    m_pixmap.<span class="built_in">load</span>(m_normal);                                     <span class="comment">//鼠标经过按钮，加载normal图片</span></span><br><span class="line">    <span class="built_in">update</span>();                       <span class="comment">//鼠标事件产生之后，强制重绘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyButton::paintEvent</span><span class="params">(QPaintEvent *ev)</span>   <span class="comment">//绘图,当窗口刷新的时候被调用重绘，而产生鼠标事件是不会调用该对象的，所以需要手动强制重绘update()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="comment">//对应的事件产生之后，就需要将相关的图片挂到当前的按钮对象上</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;                        <span class="comment">//创建一个画家类，参数是指定绘图设备(当前按钮对象)</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_pixmap);          <span class="comment">//将对应图片完整画到当前对象上。参数：当前按钮所对应的矩形区域、指定m_pixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-按钮组窗口类ButtonGroup"><a href="#12-按钮组窗口类ButtonGroup" class="headerlink" title="12. 按钮组窗口类ButtonGroup"></a>12. 按钮组窗口类ButtonGroup</h1><p>按钮组窗口类主要是为用户玩家服务的，因为开始游戏界面、抢地主界面、必须出牌界面和可放弃出牌界面都需要显示出不同的按钮，所以得在ui中使用Stacked Widget栈窗口，它可以容纳多张不同的窗口，然后通过函数调用切换即可。</p>
<h2 id="12-1-创建按钮组窗口"><a href="#12-1-创建按钮组窗口" class="headerlink" title="12.1 创建按钮组窗口"></a>12.1 创建按钮组窗口</h2><p>1.窗口创建：</p>
<p>选择新建、Qt、Qt设计师界面类(是带ui界面的)、选择Widget类型的窗口，类名为<code>ButtonGroup</code>。</p>
<p>该类是在ui界面上拖入了一个Stacked Widget栈窗口，在该栈窗口中建了5个页面。第1个页面是开始页面；第2个页面是必须出牌页面；第3个为可放弃出牌页面；第4个为叫地主页面；第5个是空白页面。并利用信号槽机制实现了connect操作，即按下按钮，就会触发响应的按钮信号，然后发送自定义信号。该类只负责发送信号即可，不用处理相关的操作。</p>
<p>2.对每个页面的按钮做美化</p>
<p>将Stacked Widget栈窗口中的5个窗口的按钮都提升为<code>MyButton</code>类。然后基于<code>MyButton</code>类对窗口所有按钮进行美化。</p>
<p>3.添加资源文件：选择新建、Qt、Qt Resource File、名称为res。</p>
<p>4.将按钮组窗口添加到主窗口(中下方)</p>
<p>在主窗口的下方拖入一个Widget窗口，将其提升为ButtonGroup类。因为主窗口最下方放的是扑克牌，所以得在最下面放一根弹簧将ButtonGroup窗口撑起来一点。然后在主窗口析构函数中，初始化按钮组，并设定刚开的页面为游戏开始页面的按钮组即可。</p>
<h2 id="12-2-ButtonGroup类头文件"><a href="#12-2-ButtonGroup类头文件" class="headerlink" title="12.2 ButtonGroup类头文件"></a>12.2 ButtonGroup类头文件</h2><p>按钮组窗口类ButtonGroup就是定义了一个Page页的切换函数，通过传入的参数配置页枚举类的不同，会发出信号通知主窗口该显示哪个按钮组窗口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonGroup</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Panel</span>&#123;Start, PlayCard, PassOrPlay,CallLord,Empty&#125;;         <span class="comment">//配置页枚举类</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ButtonGroup</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">ButtonGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化按钮</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtons</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Page页的切换(因为第2个参数是只有抢地主页面按钮组时才会用到，其它按钮组页面窗口用不到，所以设置默认参数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">selectPanel</span><span class="params">(Panel type, <span class="type">int</span> bet = <span class="number">0</span>)</span></span>; <span class="comment">//传入的参数是配置页的枚举类，即窗口,当是叫地主窗口时，要目前下注最高分数(用户玩家需要知道)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startGame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//不出牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抢地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">betPoint</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::ButtonGroup *ui;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="12-3-ButtonGroup类函数实现"><a href="#12-3-ButtonGroup类函数实现" class="headerlink" title="12.3 ButtonGroup类函数实现"></a>12.3 ButtonGroup类函数实现</h2><p>这部分代码实现了头文件定义的函数，对每个按钮都加载了三种图片，即常规状态下、鼠标滑过状态下和点击按钮状态下。同时也通过信号槽机制，对每个按钮按下后，都会发出信号，触发对应的槽函数处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ButtonGroup::<span class="built_in">ButtonGroup</span>(QWidget *parent) :</span><br><span class="line">    <span class="built_in">QWidget</span>(parent),</span><br><span class="line">    <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::ButtonGroup)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ButtonGroup::~<span class="built_in">ButtonGroup</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有按钮的图片初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::initButtons</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    ui-&gt;start-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/start-1.png&quot;</span>, <span class="string">&quot;:/images/start-3.png&quot;</span>, <span class="string">&quot;:/images/start-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//出牌</span></span><br><span class="line">    ui-&gt;playCard-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;playCard1-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/chupai_btn-1.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-3.png&quot;</span>, <span class="string">&quot;:/images/chupai_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不要</span></span><br><span class="line">    ui-&gt;pass-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/pass_btn-1.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-3.png&quot;</span>, <span class="string">&quot;:/images/pass_btn-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//不抢</span></span><br><span class="line">    ui-&gt;giveup-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/buqiang-1.png&quot;</span>, <span class="string">&quot;:/images/buqiang-3.png&quot;</span>, <span class="string">&quot;:/images/buqiang-2.png&quot;</span>);</span><br><span class="line">    <span class="comment">//1，2，3分</span></span><br><span class="line">    ui-&gt;oneScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/1fen-1.png&quot;</span>, <span class="string">&quot;:/images/1fen-3.png&quot;</span>, <span class="string">&quot;:/images/1fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;twoScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/2fen-1.png&quot;</span>, <span class="string">&quot;:/images/2fen-3.png&quot;</span>, <span class="string">&quot;:/images/2fen-2.png&quot;</span>);</span><br><span class="line">    ui-&gt;threeScore-&gt;<span class="built_in">setImage</span>(<span class="string">&quot;:/images/3fen-1.png&quot;</span>, <span class="string">&quot;:/images/3fen-3.png&quot;</span>, <span class="string">&quot;:/images/3fen-2.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置按钮的大小</span></span><br><span class="line">    QVector&lt;MyButton*&gt;btns;</span><br><span class="line">    btns &lt;&lt; ui-&gt;start &lt;&lt; ui-&gt;playCard &lt;&lt; ui-&gt;playCard1 &lt;&lt; ui-&gt;pass &lt;&lt; ui-&gt;giveup &lt;&lt; ui-&gt;oneScore &lt;&lt; ui-&gt;twoScore &lt;&lt; ui-&gt;threeScore;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;btns.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        btns[i]-&gt;<span class="built_in">setFixedSize</span>(<span class="number">90</span>,<span class="number">45</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击不同按钮，发出信号后，处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;start, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::startGame);     <span class="comment">//按下开始按钮(初始界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);   <span class="comment">//按下出牌按钮(必须出牌界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;playCard1, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::playHand);  <span class="comment">//按下出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;pass, &amp;MyButton::clicked, <span class="keyword">this</span>, &amp;ButtonGroup::pass);      <span class="comment">//按下放弃出牌按钮(可出可不出界面)</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;giveup, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                  <span class="comment">//按下不抢地主按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">0</span>);       <span class="comment">//当点击的是放弃抢地主，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;oneScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注1分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">1</span>);       <span class="comment">//当点击1分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;twoScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;                <span class="comment">//按下下注2分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">2</span>);       <span class="comment">//当点击2分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;threeScore, &amp;MyButton::clicked, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//按下下注3分按钮(抢地主界面)</span></span><br><span class="line">        emit <span class="built_in">betPoint</span>(<span class="number">3</span>);       <span class="comment">//当点击3分按钮，发出的信号</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示对应的按钮组窗口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ButtonGroup::selectPanel</span><span class="params">(ButtonGroup::Panel type, <span class="type">int</span> bet)</span>   <span class="comment">//传入的是页数,分数(用户玩家才会调用该函数，要知道目前下注的最高分)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;stackedWidget-&gt;<span class="built_in">setCurrentIndex</span>(type);           <span class="comment">//设置当前要找展示的按钮页面窗口</span></span><br><span class="line">    <span class="keyword">if</span>(type != CallLord)&#123;             <span class="comment">//如果不是叫地主状态，就直接返回(说明用户玩家不叫地主)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面是用户玩家是叫地主状态</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;            <span class="comment">//如果目前最高分是0，说明还可以显示1，2，3分三个按钮</span></span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        ui-&gt;oneScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//1分按钮隐藏</span></span><br><span class="line">        ui-&gt;twoScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">false</span>);          <span class="comment">//2分按钮隐藏</span></span><br><span class="line">        ui-&gt;threeScore-&gt;<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-游戏控制类GameControl"><a href="#13-游戏控制类GameControl" class="headerlink" title="13. 游戏控制类GameControl"></a>13. 游戏控制类GameControl</h1><p>游戏控制类负责对游戏整个过程进行一个管理和控制，像游戏状态、玩家状态等都想要通过该类来进行一个维护。同时该类也会和主窗口类直接连接，在游戏控制过程中，每个玩家的变化、游戏的变化都需要通过信号的方式通知主窗口。</p>
<p>游戏控制类添加：通过选择新建、c++、c++class、类名为<code>GameControl</code>，基类为QObject。</p>
<h2 id="13-1-GameControl类头文件"><a href="#13-1-GameControl类头文件" class="headerlink" title="13.1 GameControl类头文件"></a>13.1 GameControl类头文件</h2><p>游戏控制类<code>GameControl</code>定义了枚举类游戏状态和玩家状态，当它们发送变化时，都会通过信号发送出去。同时，该头文件还定义了许多游戏过程函数，如发牌、叫地主、出牌等。而且有些后面开发会用到的信息都会记录保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BetRecord</span>&#123;     <span class="comment">//存放三个玩家叫地主情况的结构体(因为c++的结构体类似于类，所以可以有构造函数)</span></span><br><span class="line">    <span class="built_in">BetRecord</span>()&#123;      <span class="comment">//当创建BetRecord时，就自动清空，初始化了</span></span><br><span class="line">        <span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player = <span class="literal">nullptr</span>;</span><br><span class="line">        bet = <span class="number">0</span>;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Player* player;</span><br><span class="line">    <span class="type">int</span> bet;</span><br><span class="line">    <span class="type">int</span> times;       <span class="comment">//第几次叫地主</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//游戏状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">GameStatus</span>&#123;</span><br><span class="line">        DispatchCard,                 <span class="comment">//发牌状态</span></span><br><span class="line">        CallingLord,                  <span class="comment">//叫地主状态</span></span><br><span class="line">        PlayingHand                   <span class="comment">//出牌状态</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//玩家状态</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">PlayerStatus</span>&#123;</span><br><span class="line">        ThinkingForCallLord,          <span class="comment">//考虑叫地主</span></span><br><span class="line">        ThinkingForPlayHand,          <span class="comment">//考虑出牌</span></span><br><span class="line">        Winning                       <span class="comment">//玩家赢了</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化玩家,将三个对象创建出来</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到玩家的实例化对象</span></span><br><span class="line">    <span class="function">Robot* <span class="title">getLeftRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Robot* <span class="title">getRightRobot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">UserPlayer* <span class="title">getUserPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和获取当前玩家</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCurrentPlayer</span><span class="params">(Player* player)</span></span>;         <span class="comment">//参数是玩家类型，由于不知道具体玩家类型，传它们的父类</span></span><br><span class="line">    <span class="function">Player *<span class="title">getCurrentPlayer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到出牌玩家和打出的牌</span></span><br><span class="line">    <span class="function">Player* <span class="title">getPendPlayer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cards <span class="title">getPendCards</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化扑克牌(所有)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initAllCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//每次发一张牌</span></span><br><span class="line">    <span class="function">Card <span class="title">takeOneCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到最后的三张底牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getSurplusCards</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//重置卡牌数据(当完成一局游戏就会清空玩家手中的扑克牌)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resetCardData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备叫地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startLordCard</span><span class="params">()</span></span>;       <span class="comment">//该函数会发出信号，主窗口接收</span></span><br><span class="line">    <span class="comment">//成为地主</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">becomeLord</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//清空所有玩家的得分</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearPlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//得到玩家下注的最高得分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPlayerMaxBet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理叫地主(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabBet</span><span class="params">(Player* player, <span class="type">int</span> bet)</span></span>;        <span class="comment">//参数：具体是哪个玩家，玩家叫地主时下的分数</span></span><br><span class="line">    <span class="comment">//处理出牌(槽函数) ---&gt;当玩家调用了playhand()出牌函数后，会发出出牌信号，由该槽函数接收处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;    <span class="comment">//参数：出牌的玩家，出的牌</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="comment">//向主窗口通知 玩家的状态变化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerStatusChanged</span><span class="params">(Player* player, PlayerStatus status)</span></span>;     <span class="comment">//告诉主窗口是哪个玩家，当前玩家是什么状态(考虑叫地主，考虑出牌，玩家赢了)</span></span><br><span class="line">    <span class="comment">//向主窗口通知是哪个玩家抢了地主以及下注分数(然后轮到其它玩家抢地主下分)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;</span><br><span class="line">    <span class="comment">//游戏状态变化的信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusChanged</span><span class="params">(GameStatus status)</span></span>;         <span class="comment">//参数是游戏的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向主窗口通知玩家出牌了</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notifyPlayHand</span><span class="params">(Player* player, Cards&amp; card)</span></span>;       <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line">    <span class="comment">//给玩家传递出牌数据</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pendingInfo</span><span class="params">(Player* player, Cards&amp; card)</span></span>;          <span class="comment">//参1：出牌玩家；参2：出的牌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Robot* m_robotLeft=<span class="literal">nullptr</span>;</span><br><span class="line">    Robot* m_robotRight=<span class="literal">nullptr</span>;</span><br><span class="line">    UserPlayer* m_user=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Player* m_currPlayer=<span class="literal">nullptr</span>;           <span class="comment">//保存当前玩家对象的指针(实时变化的)</span></span><br><span class="line"></span><br><span class="line">    Player* m_pendPlayer=<span class="literal">nullptr</span>;           <span class="comment">//出牌的玩家</span></span><br><span class="line">    Cards m_pendCards;              <span class="comment">//出牌玩家打出的牌</span></span><br><span class="line"></span><br><span class="line">    Cards m_allCards;               <span class="comment">//一副扑克牌</span></span><br><span class="line"></span><br><span class="line">    BetRecord m_betRecord;          <span class="comment">//存放三个玩家叫地主的情况结构体对象</span></span><br><span class="line">    <span class="type">int</span> m_curBet = <span class="number">0</span>;               <span class="comment">//记录下注底分，方便后期计算</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-GameControl类函数实现"><a href="#13-2-GameControl类函数实现" class="headerlink" title="13.2 GameControl类函数实现"></a>13.2 GameControl类函数实现</h2><p>这部分实现了头文件定义的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GameControl::<span class="built_in">GameControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::playerInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.对象实例化,通过构造函数指定名字，并给该对象指定一个父对象(当释放GameControl时，会自动释放该对象)</span></span><br><span class="line">    m_robotLeft = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人A&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    m_robotRight = <span class="keyword">new</span> <span class="built_in">Robot</span>(<span class="string">&quot;机器人B&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">    m_user = <span class="keyword">new</span> <span class="built_in">UserPlayer</span>(<span class="string">&quot;我自己&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.给各对象设置属性信息</span></span><br><span class="line">    <span class="comment">//头像的显示</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setDirection</span>(Player::Left);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    m_user-&gt;<span class="built_in">setDirection</span>(Player::Right);</span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    Player::Sex sex;</span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setSex</span>(sex);                                     <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setSex</span>(sex);                                    <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    sex = (Player::Sex)QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);    <span class="comment">//生成随机数0或1，0表示男，1表示女，然后需要做强制类型转换，转换为枚举类型</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setSex</span>(sex);                                          <span class="comment">//把生成的随机性别设置给对应玩家</span></span><br><span class="line">    <span class="comment">//玩家出牌顺序</span></span><br><span class="line">    <span class="comment">// user</span></span><br><span class="line">    m_user-&gt;<span class="built_in">setPrevPlayer</span>(m_robotLeft);</span><br><span class="line">    m_user-&gt;<span class="built_in">setNextPlayer</span>(m_robotRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left robot</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setPrevPlayer</span>(m_robotRight);</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setNextPlayer</span>(m_user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// right robot</span></span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setPrevPlayer</span>(m_user);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setNextPlayer</span>(m_robotLeft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定当前玩家为用户(优先叫地主的权力)</span></span><br><span class="line">    m_currPlayer = m_user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家发射出的抢地主信号(几分)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;UserPlayer::notifyGrabLordBet,<span class="keyword">this</span>,&amp;GameControl::onGrabBet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递出牌玩家对象和玩家打出的牌给其它玩家</span></span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotLeft, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_robotRight, &amp;Robot::storePendingInfo);</span><br><span class="line">    <span class="built_in">connect</span>(<span class="keyword">this</span>, &amp;GameControl::pendingInfo, m_user, &amp;Robot::storePendingInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理玩家出牌</span></span><br><span class="line">    <span class="built_in">connect</span>(m_robotLeft, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_robotRight, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">    <span class="built_in">connect</span>(m_user, &amp;Robot::notifyPlayHand, <span class="keyword">this</span>, &amp;GameControl::onPlayHand);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到左手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getLeftRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotLeft;        <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到右手玩家对象</span></span><br><span class="line"><span class="function">Robot *<span class="title">GameControl::getRightRobot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_robotRight;      <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到用户玩家对象</span></span><br><span class="line"><span class="function">UserPlayer *<span class="title">GameControl::getUserPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_user;            <span class="comment">//返回对应玩家对象指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置和获取当前出牌玩家</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::setCurrentPlayer</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getCurrentPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_currPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出牌的玩家</span></span><br><span class="line"><span class="function">Player *<span class="title">GameControl::getPendPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendPlayer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到上次出的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getPendCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pendCards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化所有的牌(发牌会用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::initAllCards</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_allCards.<span class="built_in">clear</span>();             <span class="comment">//先对一副扑克牌做清空操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p=Card::Card_Begin+<span class="number">1</span>; p&lt;Card::Card_SJ; p++)&#123;           <span class="comment">//遍历点数，枚举类型不能做算术运算，所以定义p只能是int,不能是Card::CardPoint</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s=Card::Suit_Begin+<span class="number">1</span>; s&lt;Card::Suit_End; s++)&#123;      <span class="comment">//遍历花色</span></span><br><span class="line">            <span class="function">Card <span class="title">c</span><span class="params">((Card::CardPoint)p, (Card::CardSuit)s)</span></span>;         <span class="comment">//再将int类型强制转换为枚举类型</span></span><br><span class="line">            m_allCards.<span class="built_in">add</span>(c);         <span class="comment">//创建完一张扑克牌，就插入到m_allCards中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_SJ, Card::Suit_Begin));              <span class="comment">//插入小王</span></span><br><span class="line">    m_allCards.<span class="built_in">add</span>(<span class="built_in">Card</span>(Card::Card_BJ, Card::Suit_Begin));              <span class="comment">//插入大王</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机获得一张卡牌(发牌)</span></span><br><span class="line"><span class="function">Card <span class="title">GameControl::takeOneCard</span><span class="params">()</span>                <span class="comment">//一次发一张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards.<span class="built_in">takeRandomCard</span>();          <span class="comment">//调用Cards类里面定义的函数，随机返回一张扑克牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地主得到3张底牌</span></span><br><span class="line"><span class="function">Cards <span class="title">GameControl::getSurplusCards</span><span class="params">()</span>           <span class="comment">//获取底牌函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_allCards;                         <span class="comment">//当发完后，做后留下的三张牌就作为底牌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发牌前的初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::resetCardData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//洗牌</span></span><br><span class="line">    <span class="built_in">initAllCards</span>();</span><br><span class="line">    <span class="comment">//清空所有玩家的牌(就是将玩家对象里的Cards容器清空)</span></span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    m_user-&gt;<span class="built_in">clearCards</span>();</span><br><span class="line">    <span class="comment">//初始化出牌玩家和牌(新一局开始之前，是没有出牌玩家的)</span></span><br><span class="line">    m_pendPlayer = <span class="literal">nullptr</span>;           <span class="comment">//出牌对象也先默认为空</span></span><br><span class="line">    m_pendCards.<span class="built_in">clear</span>();              <span class="comment">//打出的牌也是空的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::startLordCard</span><span class="params">()</span>        <span class="comment">//准备叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用叫地主函数</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();         <span class="comment">//m_currPlayer可能是用户玩家，也可能是机器人玩家(多态实现)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, ThinkingForCallLord)</span></span>;      <span class="comment">//发出信号，参数：当前玩家，当前玩家状态(准备叫地主)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::becomeLord</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>  <span class="comment">//成为地主，参数传进来的是地主角色，其它两个角色就是农民了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_curBet = bet;             <span class="comment">//保存下注的底分，出牌(炸弹)和打完牌后计算需要用到</span></span><br><span class="line">    player-&gt;<span class="built_in">setRole</span>(Player::Lord);</span><br><span class="line">    player-&gt;<span class="built_in">getPrevPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的上一家是农民</span></span><br><span class="line">    player-&gt;<span class="built_in">getNextPlayer</span>()-&gt;<span class="built_in">setRole</span>(Player::Farmer);         <span class="comment">//设置地主角色的下一家是农民</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成为地主的是要先出牌，所以他是当前玩家</span></span><br><span class="line">    m_currPlayer = player;</span><br><span class="line">    player-&gt;<span class="built_in">storeDispatchCard</span>(m_allCards);     <span class="comment">//给该玩家的手牌添加三张底牌(m_allCards是发完牌后，剩下三张)</span></span><br><span class="line"></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">1000</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        emit <span class="built_in">gameStatusChanged</span>(PlayingHand);                       <span class="comment">//发送游戏的状态信号(出牌状态)</span></span><br><span class="line">        emit <span class="built_in">playerStatusChanged</span>(player, ThinkingForPlayHand);     <span class="comment">//玩家状态(考虑出牌)</span></span><br><span class="line">        <span class="comment">//调用准备出牌函数</span></span><br><span class="line">        m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::clearPlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_robotLeft-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_robotRight-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">    m_user-&gt;<span class="built_in">setScore</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GameControl::getPlayerMaxBet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_betRecord.bet;        <span class="comment">//结构体里面存的就是最高分(因为高分信息会覆盖低分信息)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onGrabBet</span><span class="params">(Player *player, <span class="type">int</span> bet)</span>     <span class="comment">//处理叫地主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 通知主界面，该玩家叫地主了(主界面就要更新信息提示)</span></span><br><span class="line">    <span class="keyword">if</span>(bet==<span class="number">0</span> || m_betRecord.bet&gt;=bet)&#123;           <span class="comment">//这种情况说明该玩家放弃抢地主</span></span><br><span class="line">        <span class="function">emit <span class="title">notifyGrabLordBet</span><span class="params">(player, <span class="number">0</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet&gt;<span class="number">0</span> &amp;&amp; m_betRecord.bet==<span class="number">0</span>)&#123; <span class="comment">//如果当前玩家下注的分数大于0，且之前结构体存的是0分(说明之前玩家没有抢地主或现在是第一次下注)</span></span><br><span class="line">        <span class="comment">//第1个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">true</span>);      <span class="comment">//如果是第一个抢地主的玩家，参数3置为true(主窗口需要知道第一个抢地主的玩家)</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//第2或3个抢地主的玩家</span></span><br><span class="line">        emit <span class="built_in">notifyGrabLordBet</span>(player, bet, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断玩家下注是不是3分，如果是就抢地主成功(抢地主就结束了)</span></span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//该玩家成为地主</span></span><br><span class="line">        <span class="built_in">becomeLord</span>(player,bet);            <span class="comment">//调用成为地主的函数</span></span><br><span class="line">        <span class="comment">//清空抢地主结构体数据</span></span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span>;            <span class="comment">//直接退出了。当某个玩家给出3分时，那么该玩家就是地主了，不用再执行下面内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.下注不够3分，对玩家的分数进行比较，分数高的是地主(低的被覆盖)</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.bet &lt; bet)&#123;  <span class="comment">//m_betRecord结构体是玩家抢地主，就存其信息，当下一个玩家也抢地主，如果分数比之前的高，m_betRecord就进行更新</span></span><br><span class="line">        m_betRecord.bet = bet;             <span class="comment">//重新存储分数</span></span><br><span class="line">        m_betRecord.player = player;       <span class="comment">//重新存储地主玩家</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_betRecord.times++;                   <span class="comment">//下注抢地主的次数++</span></span><br><span class="line">    <span class="comment">//如果每个玩家都抢过一次地主，抢地主结束</span></span><br><span class="line">    <span class="keyword">if</span>(m_betRecord.times == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_betRecord.bet == <span class="number">0</span>)&#123;        <span class="comment">//如果分数还是为0，说明没有玩家叫地主</span></span><br><span class="line">            <span class="function">emit <span class="title">gameStatusChanged</span><span class="params">(DispatchCard)</span></span>;        <span class="comment">//通知此时需要改变为发牌状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;     <span class="comment">//如果不为0，说明有玩家会成为地主</span></span><br><span class="line">            <span class="built_in">becomeLord</span>(m_betRecord.player, m_betRecord.bet);              <span class="comment">//成为地主的玩家是结构体中保存的玩家对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_betRecord.<span class="built_in">reset</span>();          <span class="comment">//结构体重置，为下一节游戏清空结构体(因为到了下一句游戏，不会重新创建，还是用这个创建好的结构体)</span></span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">//直接返回，就不用执行下面玩家切换了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.切换玩家，通知下一个玩家继续抢地主</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();      <span class="comment">//改变当前玩家</span></span><br><span class="line">    <span class="comment">//发送信号给主界面，告知当前状态还是为抢地主状态</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer,ThinkingForCallLord)</span></span>;</span><br><span class="line">    <span class="comment">//每个玩家都有一个prepareCallLord()函数，即考虑叫地主，如果是机器人玩家，有专门的线程来处理该操作，如果是用户玩家，该函数就是空的(只需要点击按钮完成操作)</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">prepareCallLord</span>();      <span class="comment">//告诉新的当前玩家继续抢地主</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GameControl::onPlayHand</span><span class="params">(Player *player, Cards &amp;card)</span>    <span class="comment">//处理出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 将玩家出牌信号转给主界面(主界面更新出出牌窗口内容)</span></span><br><span class="line">    <span class="function">emit <span class="title">notifyPlayHand</span><span class="params">(player, card)</span></span>;</span><br><span class="line">    <span class="comment">//2. 如果不是空牌，给其它玩家发送信号，保存出牌玩家对象和打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!card.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        m_pendCards = card;</span><br><span class="line">        m_pendPlayer = player;</span><br><span class="line">        <span class="function">emit <span class="title">pendingInfo</span><span class="params">(player, card)</span></span>;       <span class="comment">//发出信号给玩家，参数是打出牌的当前玩家和打出的牌(其它玩家需要根据出的牌和玩家，做相应的处理)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有炸弹，底分翻倍</span></span><br><span class="line">    PlayHand::HandType type = <span class="built_in">PlayHand</span>(card).<span class="built_in">getHandType</span>();      <span class="comment">//传入当前玩家出的牌，得到出牌类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Bomb || type == PlayHand::Hand_Bomb_Jokers)&#123;      <span class="comment">//如果出的牌是炸弹和王炸</span></span><br><span class="line">        m_curBet = m_curBet*<span class="number">2</span>;                     <span class="comment">//将底分*2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 如果玩家的牌都出完了，计算本局游戏的总分</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        Player* prev = player-&gt;<span class="built_in">getPrevPlayer</span>();                  <span class="comment">//获取当前玩家的上一个玩家</span></span><br><span class="line">        Player* next = player-&gt;<span class="built_in">getNextPlayer</span>();                  <span class="comment">//获取当前玩家的下一个玩家</span></span><br><span class="line">        <span class="keyword">if</span>(player-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;                   <span class="comment">//如果当前玩家为地主</span></span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + <span class="number">2</span>*m_curBet);       <span class="comment">//当前玩家加分(原来得分+当前得分)</span></span><br><span class="line">            prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - m_curBet);</span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;             <span class="comment">//当前玩家为农民</span></span><br><span class="line">            player-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            player-&gt;<span class="built_in">setScore</span>(player-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">            <span class="keyword">if</span>(prev-&gt;<span class="built_in">getRole</span>() == Player::Lord)&#123;             <span class="comment">//如果当前玩家的上一个玩家是地主</span></span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                           <span class="comment">//如果当前玩家的上一个玩家是农民</span></span><br><span class="line">                next-&gt;<span class="built_in">setScore</span>(next-&gt;<span class="built_in">getScore</span>() - <span class="number">2</span>*m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setScore</span>(prev-&gt;<span class="built_in">getScore</span>() + m_curBet);</span><br><span class="line">                prev-&gt;<span class="built_in">setWin</span>(<span class="literal">true</span>);</span><br><span class="line">                next-&gt;<span class="built_in">setWin</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(player, GameControl::Winning)</span></span>;          <span class="comment">//向主窗口通知 当前玩家的状态变化(赢了)</span></span><br><span class="line">        <span class="keyword">return</span>;         <span class="comment">//赢了就退出了，不然还会执行下面程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 如果牌没有出完，下一个玩家继续出牌</span></span><br><span class="line">    m_currPlayer = player-&gt;<span class="built_in">getNextPlayer</span>();                <span class="comment">//将下一个玩家更新为当前玩家</span></span><br><span class="line">    m_currPlayer-&gt;<span class="built_in">preparePlayHand</span>();         <span class="comment">//更新的当前玩家准备出牌(该函数是一个多态实现，不同类型玩家调用会执行不同的处理)</span></span><br><span class="line">    <span class="function">emit <span class="title">playerStatusChanged</span><span class="params">(m_currPlayer, GameControl::ThinkingForPlayHand)</span></span>;    <span class="comment">//向主窗口通知 更新的当前玩家的状态变化(考虑出牌)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-出牌类PlayHand"><a href="#14-出牌类PlayHand" class="headerlink" title="14. 出牌类PlayHand"></a>14. 出牌类PlayHand</h1><p>该类主要是对一些牌进行分类和识别，得出调用者传入牌的一个牌型。</p>
<p>出牌类(策略)：新建、c、c++、类名为PlayHand，基类为Custom。</p>
<h2 id="14-1-PlayHand类头文件"><a href="#14-1-PlayHand类头文件" class="headerlink" title="14.1 PlayHand类头文件"></a>14.1 PlayHand类头文件</h2><p>出牌类PlayeHand定义了一个牌的类型枚举类，它里面都是斗地主小游戏里面所有的牌型。然后定义了对牌的分类函数和识别函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayHand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 出牌组合或者方式</span></span><br><span class="line">        <span class="keyword">enum</span> <span class="title class_">HandType</span></span><br><span class="line">        &#123;</span><br><span class="line">            Hand_Unknown,               <span class="comment">// 未知</span></span><br><span class="line">            Hand_Pass,                  <span class="comment">// 过</span></span><br><span class="line">            Hand_Single,                <span class="comment">// 单</span></span><br><span class="line">            Hand_Pair,                  <span class="comment">// 对</span></span><br><span class="line">            Hand_Triple,                <span class="comment">// 三个</span></span><br><span class="line">            Hand_Triple_Single,         <span class="comment">// 三带一</span></span><br><span class="line">            Hand_Triple_Pair,           <span class="comment">// 三带二</span></span><br><span class="line">            Hand_Plane,                 <span class="comment">// 飞机，555_666</span></span><br><span class="line">            Hand_Plane_Two_Single,      <span class="comment">// 飞机带单，555_666_3_4</span></span><br><span class="line">            Hand_Plane_Two_Pair,        <span class="comment">// 飞机带双，555_666_33_44</span></span><br><span class="line">            Hand_Seq_Pair,              <span class="comment">// 连对，33_44_55(_66...)</span></span><br><span class="line">            Hand_Seq_Single,            <span class="comment">// 顺子，34567(8...)</span></span><br><span class="line">            Hand_Bomb,                  <span class="comment">// 炸弹</span></span><br><span class="line">            Hand_Bomb_Single,           <span class="comment">// 炸弹带一个</span></span><br><span class="line">            Hand_Bomb_Pair,             <span class="comment">// 炸弹带一对</span></span><br><span class="line">            Hand_Bomb_Two_Single,       <span class="comment">// 炸弹带两单</span></span><br><span class="line">            Hand_Bomb_Jokers,           <span class="comment">// 王炸</span></span><br><span class="line">            Hand_Bomb_Jokers_Single,    <span class="comment">// 王炸带一个</span></span><br><span class="line">            Hand_Bomb_Jokers_Pair,      <span class="comment">// 王炸带一对</span></span><br><span class="line">            Hand_Bomb_Jokers_Two_Single	<span class="comment">// 王炸带两单</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PlayHand</span>();</span><br><span class="line">        <span class="comment">// 传递给类一组牌, 通过类分析出牌型, 点数, 以及相关的附属信息(比如顺子: 记录牌的数量)</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PlayHand</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="built_in">PlayHand</span>(HandType type, Card::CardPoint pt, <span class="type">int</span> extra);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到牌的属性信息</span></span><br><span class="line">        <span class="function">HandType <span class="title">getHandType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Card::CardPoint <span class="title">getCardPoint</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getExtra</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较自己的牌和其他人的牌的大小</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">canBeat</span><span class="params">(<span class="type">const</span> PlayHand&amp; other)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 1. 对扑克牌进行分类: 1张相同的, 2张相同的, 3张相同的, 4张相同的</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">classify</span><span class="params">(Cards&amp; cards)</span></span>;</span><br><span class="line">        <span class="comment">// 2. 对牌型进行分类</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">judgeCardType</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 判断牌的类型</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPass</span><span class="params">()</span></span>;              <span class="comment">// 放弃出牌</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSingle</span><span class="params">()</span></span>;            <span class="comment">// 单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPair</span><span class="params">()</span></span>;              <span class="comment">// 对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriple</span><span class="params">()</span></span>;            <span class="comment">// 三个(相同)</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTripleSingle</span><span class="params">()</span></span>;      <span class="comment">// 三带一</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isTriplePair</span><span class="params">()</span></span>;        <span class="comment">// 三带二</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlane</span><span class="params">()</span></span>;             <span class="comment">// 飞机</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoSingle</span><span class="params">()</span></span>;    <span class="comment">// 飞机带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isPlaneTwoPair</span><span class="params">()</span></span>;      <span class="comment">// 飞机带2对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqPair</span><span class="params">()</span></span>;           <span class="comment">// 连对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isSeqSingle</span><span class="params">()</span></span>;         <span class="comment">// 顺子</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBomb</span><span class="params">()</span></span>;              <span class="comment">// 炸弹</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombSingle</span><span class="params">()</span></span>;        <span class="comment">// 炸弹带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombPair</span><span class="params">()</span></span>;          <span class="comment">// 炸弹带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombTwoSingle</span><span class="params">()</span></span>;     <span class="comment">// 炸弹带两单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokers</span><span class="params">()</span></span>;        <span class="comment">// 王炸</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersSingle</span><span class="params">()</span></span>;  <span class="comment">// 王炸带一单</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersPair</span><span class="params">()</span></span>;    <span class="comment">// 王炸带一对</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isBombJokersTwoSingle</span><span class="params">()</span></span>;   <span class="comment">// 王炸带两单</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        HandType m_type;                          <span class="comment">//牌型</span></span><br><span class="line">        Card::CardPoint m_pt;                     <span class="comment">//点数</span></span><br><span class="line">        <span class="type">int</span> m_extra;                              <span class="comment">//附加类型(如顺子是5张还是6张还是7张，连对是3对还是4对还是5对)</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_oneCard;       <span class="comment">//存储单张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_twoCard;       <span class="comment">//存储两种相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_threeCard;     <span class="comment">//存储三张相同点数的牌</span></span><br><span class="line">        QVector&lt;Card::CardPoint&gt; m_fourCard;      <span class="comment">//存储四张相同点数的牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-PlayHand类函数实现"><a href="#14-2-PlayHand类函数实现" class="headerlink" title="14.2 PlayHand类函数实现"></a>14.2 PlayHand类函数实现</h2><p>该部分实现了头文件定义的函数，首先是通过函数classify()对传进来的牌进行分类，用4个容器进行存放，分别为1张相同点数的牌容器、2张相同点数的牌容器、3张相同点数的牌容器和4张相同点数的牌容器。然后通过judgeCardType()函数基于分类的4个容器来对牌进行分析。记录扑克牌的牌型、点数和附加类型(连对的对数和顺子的张数)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;playhand.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(Cards &amp;cards)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.对扑克牌进行分类：1张的，2张，3张，4张有多少种</span></span><br><span class="line">    <span class="built_in">classify</span>(cards);</span><br><span class="line">    <span class="comment">//2.对牌型进行分类</span></span><br><span class="line">    <span class="built_in">judgeCardType</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlayHand::<span class="built_in">PlayHand</span>(PlayHand::HandType type, Card::CardPoint pt, <span class="type">int</span> extra)</span><br><span class="line">&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">    m_pt = pt;</span><br><span class="line">    m_extra = extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的牌型</span></span><br><span class="line"><span class="function">PlayHand::HandType <span class="title">PlayHand::getHandType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取扑克牌的点数</span></span><br><span class="line"><span class="function">Card::CardPoint <span class="title">PlayHand::getCardPoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取附加类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PlayHand::getExtra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_extra;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较牌是否大于对方</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::canBeat</span><span class="params">(<span class="type">const</span> PlayHand &amp;other)</span>           <span class="comment">//和对方比较牌型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//我的牌型是未知的</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Unknown)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对方放弃出牌</span></span><br><span class="line">    <span class="keyword">if</span>(other.m_type == Hand_Pass)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我是王炸</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己是炸弹，而对方是比炸弹小的牌型(牌类型的枚举类是按照牌型从小到大排列的)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type==Hand_Bomb &amp;&amp; other.m_type&gt;=Hand_Single &amp;&amp; other.m_type&lt;=Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双方的牌型是一致的(比点数)</span></span><br><span class="line">    <span class="keyword">if</span>(m_type == other.m_type)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_type == Hand_Seq_Pair || m_type == Hand_Seq_Single)&#123;      <span class="comment">//如果是连对或是顺子</span></span><br><span class="line">            <span class="keyword">return</span> m_pt&gt;other.m_pt &amp;&amp; m_extra == other.m_extra;        <span class="comment">//就要求最小点数要比它大，同时个数要一样，才返回true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_pt &gt; other.m_pt;       <span class="comment">//如果是其它类型，就直接比点数了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//如果都不满足上面，就返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将传进来的牌按张数进行分类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::classify</span><span class="params">(Cards &amp;cards)</span>           <span class="comment">//分析传进来的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将转进来牌存到QVector容器</span></span><br><span class="line">    <span class="type">int</span> cardRecord[Card::Card_End];               <span class="comment">//创建一个数组，大小为不同点数类型大小</span></span><br><span class="line">    <span class="built_in">memset</span>(cardRecord, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*Card::Card_End);     <span class="comment">//数组清0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;             <span class="comment">//遍历每一张牌</span></span><br><span class="line">        Card c = list.<span class="built_in">at</span>(i);                      <span class="comment">//取出扑克牌</span></span><br><span class="line">        cardRecord[c.<span class="built_in">point</span>()]++;                  <span class="comment">//卡牌点数与数组里元素的位置是有对应关系的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先清空四个容器(分别存储相同点数只有1张、2张、3张和4张的牌型)</span></span><br><span class="line">    m_oneCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_twoCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_threeCard.<span class="built_in">clear</span>();</span><br><span class="line">    m_fourCard.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;Card::Card_End; i++)&#123;         <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(cardRecord[i] == <span class="number">1</span>)&#123;               <span class="comment">//数组某下标位置元素为1，则说明该点数的牌就为1</span></span><br><span class="line">            m_oneCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到1张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">2</span>)&#123;</span><br><span class="line">            m_twoCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到2张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">3</span>)&#123;</span><br><span class="line">            m_threeCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到3张相同牌的容器里</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cardRecord[i] == <span class="number">4</span>)&#123;</span><br><span class="line">            m_fourCard.<span class="built_in">push_back</span>((Card::CardPoint)i);     <span class="comment">//将其转换后存到4张相同牌的容器里</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分析牌的一个类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PlayHand::judgeCardType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = Hand_Unknown;               <span class="comment">//牌的类型先初始化为未知</span></span><br><span class="line">    m_pt = Card::Card_Begin;             <span class="comment">//初始化点数</span></span><br><span class="line">    m_extra = <span class="number">0</span>;                         <span class="comment">//这个一般是记录像连队多少对，顺子多少张</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPass</span>())&#123;                      <span class="comment">//放弃出牌</span></span><br><span class="line">        m_type = Hand_Pass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isSingle</span>())&#123;                 <span class="comment">//单牌</span></span><br><span class="line">        m_type = Hand_Single;          <span class="comment">//记录类型</span></span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];           <span class="comment">//获取其点数</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPair</span>())&#123;                <span class="comment">//一对</span></span><br><span class="line">        m_type= Hand_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriple</span>())&#123;                        <span class="comment">//3张点数相同</span></span><br><span class="line">        m_type= Hand_Triple;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTripleSingle</span>())&#123;                  <span class="comment">//3带1</span></span><br><span class="line">        m_type= Hand_Triple_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isTriplePair</span>())&#123;                   <span class="comment">//3带一对</span></span><br><span class="line">        m_type= Hand_Triple_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlane</span>())&#123;                         <span class="comment">//飞机</span></span><br><span class="line">        m_type= Hand_Plane;</span><br><span class="line">        <span class="comment">//记录点数最小的牌</span></span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoSingle</span>())&#123;                <span class="comment">//飞机带两单</span></span><br><span class="line">        m_type= Hand_Plane_Two_Single;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isPlaneTwoPair</span>())&#123;                  <span class="comment">//飞机带两对</span></span><br><span class="line">        m_type= Hand_Plane_Two_Pair;</span><br><span class="line">        m_pt = m_threeCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqPair</span>())&#123;                       <span class="comment">//连对</span></span><br><span class="line">        m_type= Hand_Seq_Pair;</span><br><span class="line">        m_pt = m_twoCard[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//记录连对的个数</span></span><br><span class="line">        m_extra = m_twoCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isSeqSingle</span>())&#123;                     <span class="comment">//顺子</span></span><br><span class="line">        m_type= Hand_Seq_Single;</span><br><span class="line">        m_pt = m_oneCard[<span class="number">0</span>];</span><br><span class="line">        m_extra = m_oneCard.<span class="built_in">size</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBomb</span>())&#123;                           <span class="comment">//炸弹</span></span><br><span class="line">        m_type= Hand_Bomb;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombSingle</span>())&#123;                    <span class="comment">//炸弹带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombPair</span>())&#123;                       <span class="comment">//炸弹带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Pair;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombTwoSingle</span>())&#123;                  <span class="comment">//炸弹带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Two_Single;</span><br><span class="line">        m_pt = m_fourCard[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokers</span>())&#123;                     <span class="comment">//王炸</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersSingle</span>())&#123;               <span class="comment">//王炸带1单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Single;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersPair</span>())&#123;                 <span class="comment">//王炸带一对</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Pair;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isBombJokersTwoSingle</span>())&#123;            <span class="comment">//王炸带2单</span></span><br><span class="line">        m_type= Hand_Bomb_Jokers_Two_Single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPass</span><span class="params">()</span>           <span class="comment">//放弃出牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//每个容器中都为空，说明是放弃出牌了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSingle</span><span class="params">()</span>            <span class="comment">//判断牌(打出的)是否是单牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果存在1张相同点数容器大小为1，其它2、3、4张相同点数的牌容器为空，说明打出的是单牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//打出的是单牌，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPair</span><span class="params">()</span>                <span class="comment">//判断牌(打出的)是否是一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriple</span><span class="params">()</span>              <span class="comment">//判断牌(打出的)是否是三张一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTripleSingle</span><span class="params">()</span>        <span class="comment">//判断牌(打出的)是否是三带一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isTriplePair</span><span class="params">()</span>           <span class="comment">//三带二(两张要一样)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlane</span><span class="params">()</span>                <span class="comment">//飞机</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoSingle</span><span class="params">()</span>         <span class="comment">//飞机带两单(不能是大小王)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                  <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2 &amp;&amp; m_oneCard[<span class="number">0</span>]!=Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]!=Card::Card_BJ)&#123;       <span class="comment">//必须是相连且不涉及卡牌2且两单不是大小王</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isPlaneTwoPair</span><span class="params">()</span>                <span class="comment">// 飞机带2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_threeCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_threeCard.<span class="built_in">begin</span>(),m_threeCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_threeCard[<span class="number">1</span>]-m_threeCard[<span class="number">0</span>]==<span class="number">1</span> &amp;&amp; m_threeCard[<span class="number">1</span>]&lt;Card::Card_2)&#123;     <span class="comment">//必须是相连且不涉及卡牌2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqPair</span><span class="params">()</span>                    <span class="comment">//连对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_twoCard.<span class="built_in">begin</span>(),m_twoCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="comment">//如果是三个连续的就满足：(最大数-最小数)=(牌类型总数-1)，如456。还必须满足卡牌是3到2之间(不包括2)</span></span><br><span class="line">        <span class="keyword">if</span>(m_twoCard.<span class="built_in">last</span>()-m_twoCard.<span class="built_in">first</span>()==(m_twoCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_twoCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_twoCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isSeqSingle</span><span class="params">()</span>                 <span class="comment">//顺子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()&gt;=<span class="number">5</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(),m_oneCard.<span class="built_in">end</span>());                <span class="comment">//进行排序(升序)</span></span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">last</span>()-m_oneCard.<span class="built_in">first</span>()==(m_oneCard.<span class="built_in">size</span>()<span class="number">-1</span>) &amp;&amp; m_oneCard.<span class="built_in">first</span>()&gt;=Card::Card_3 &amp;&amp; m_oneCard.<span class="built_in">last</span>()&lt;Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBomb</span><span class="params">()</span>                    <span class="comment">//炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombSingle</span><span class="params">()</span>              <span class="comment">//炸弹带一个单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombPair</span><span class="params">()</span>                 <span class="comment">//炸弹带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombTwoSingle</span><span class="params">()</span>            <span class="comment">//炸弹带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()!=Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()!=Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokers</span><span class="params">()</span>           <span class="comment">//王炸</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard.<span class="built_in">first</span>()==Card::Card_SJ &amp;&amp; m_oneCard.<span class="built_in">last</span>()==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersSingle</span><span class="params">()</span>            <span class="comment">//王炸带一单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">3</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">1</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">2</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersPair</span><span class="params">()</span>           <span class="comment">//王炸带一对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">2</span> &amp;&amp; m_twoCard.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">0</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">1</span>]==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PlayHand::isBombJokersTwoSingle</span><span class="params">()</span>            <span class="comment">//王炸带两单</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_oneCard.<span class="built_in">size</span>()==<span class="number">4</span> &amp;&amp; m_twoCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_threeCard.<span class="built_in">isEmpty</span>() &amp;&amp; m_fourCard.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_oneCard.<span class="built_in">begin</span>(), m_oneCard.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(m_oneCard[<span class="number">2</span>]==Card::Card_SJ &amp;&amp; m_oneCard[<span class="number">3</span>]==Card::Card_BJ)&#123;    <span class="comment">//两王比两单大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-游戏策略类Strategy"><a href="#15-游戏策略类Strategy" class="headerlink" title="15. 游戏策略类Strategy"></a>15. 游戏策略类Strategy</h1><p>游戏策略类主要是负责制定斗地主小游戏的规则，和模拟机器人玩家出牌的策略。</p>
<p>游戏策略类创建：选择新建、c、c++、类名为Strategy，基类为Custom。</p>
<h2 id="15-1-Strategy类头文件"><a href="#15-1-Strategy类头文件" class="headerlink" title="15.1 Strategy类头文件"></a>15.1 Strategy类头文件</h2><p>游戏策略类Strategy头文件定义的多数是一些游戏的规则，和对机器人玩家的出牌策略，机器人玩家会根据自己的手牌来判断该出什么牌，是否抢地主等操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Strategy</span>(Player* player, <span class="type">const</span> Cards&amp; cards);          <span class="comment">//只有机器人玩家才会调用该函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.制定出牌策略</span></span><br><span class="line">    <span class="function">Cards <span class="title">makeStrategy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.第一个出牌firstPlay(没有限制，想出啥出啥)---&gt;机器人玩家使用的函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">firstPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//3.得到比指定牌型大的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getGreaterCards</span><span class="params">(PlayHand type)</span></span>;</span><br><span class="line">    <span class="comment">//4.能大过指定的牌时，判断是出牌还是放行，返回true是出牌。返回false是放行</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">whetherToBeat</span><span class="params">(Cards&amp; cs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.找出指定数量(count)的相同点数的牌(point)，找出count张点数为point的牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span></span>;       <span class="comment">//满足指定点数、指定数量的牌</span></span><br><span class="line">    <span class="comment">//6.找出所有点数数量为count的牌 ---&gt; 得到一个多张扑克牌数组</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardsByCount</span>(<span class="type">int</span> count);                        <span class="comment">//满足指定数量的牌</span></span><br><span class="line">    <span class="comment">//7.根据点数范围找牌</span></span><br><span class="line">    <span class="function">Cards <span class="title">getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span></span>;     <span class="comment">//满足指定范围的牌</span></span><br><span class="line">    <span class="comment">//8.按牌型找牌，并且指定要找的牌是否要大过指定的牌型</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">findCardType</span>(PlayHand hand, <span class="type">bool</span> beat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//9.从指定的Cards对象中挑选出满足条件的顺子(allSeqRecord中每个元素都是一个容器，里面装着满足条件的顺子)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt;&gt;&amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt;&amp;seqSingle, <span class="type">const</span> Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//10.筛选最优的顺子的集合</span></span><br><span class="line">    <span class="function">QVector&lt;Cards&gt; <span class="title">pickOptimalSeqSingles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> function = <span class="built_in">Cards</span> (Strategy::*)(Card::CardPoint point);      <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CardInfo</span>&#123;</span><br><span class="line">        Card::CardPoint begin;</span><br><span class="line">        Card::CardPoint end;</span><br><span class="line">        <span class="type">int</span> extra;                    <span class="comment">//顺子或连对的数量</span></span><br><span class="line">        <span class="type">bool</span> beat;</span><br><span class="line">        <span class="type">int</span> number;                   <span class="comment">//指定点数的牌的数量(1表示找单排，就是寻找顺子；2表示找对子，就是寻找连对)</span></span><br><span class="line">        <span class="type">int</span> base;                     <span class="comment">//最基础的顺子或者连对的数量(连对是3或顺子是5)</span></span><br><span class="line">        function getSeq;              <span class="comment">//函数指针对象，主要是用来生成基础连对和基础顺子</span></span><br><span class="line">    &#125;;</span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getCards</span>(Card::CardPoint point, <span class="type">int</span> number);     <span class="comment">//从point点数开始查找，找number张---找单、双、三</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getTripleSingleOrPair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//起始点开始找；带1还是带对</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane</span>(Card::CardPoint begin);                <span class="comment">//飞机不带牌</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getPlane2SingleOr2Pair</span>(Card::CardPoint begin, PlayHand::HandType type);    <span class="comment">//飞机带2单还是2对</span></span><br><span class="line">    <span class="comment">//QVector&lt;Cards&gt;getSepPairOrSeqSingle(Card::CardPoint begin, int extra, bool beat);       //连对或顺子</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getSepPairOrSeqSingle</span>(CardInfo &amp;info);       <span class="comment">//连对或顺子</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span></span>;          <span class="comment">//生成基础连对函数</span></span><br><span class="line">    <span class="function">Cards <span class="title">getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span></span>;        <span class="comment">//生成基础顺子函数</span></span><br><span class="line">    QVector&lt;Cards&gt;<span class="built_in">getBomb</span>(Card::CardPoint begin);         <span class="comment">//炸弹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Player* m_player;</span><br><span class="line">    Cards m_cards;                 <span class="comment">//存放的是玩家手牌</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-Strategy类函数实现"><a href="#15-2-Strategy类函数实现" class="headerlink" title="15.2 Strategy类函数实现"></a>15.2 Strategy类函数实现</h2><p>这部分是对游戏策略类的头文件中定义的函数进行实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Strategy::<span class="built_in">Strategy</span>(Player *player, <span class="type">const</span> Cards &amp;cards):</span><br><span class="line">    <span class="built_in">m_player</span>(player),</span><br><span class="line">    <span class="built_in">m_cards</span>(cards)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌策略，机器人玩家出牌时直接调用即可，是否出牌和出什么牌都已经处理好了</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::makeStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到出牌玩家对象以及打出的牌</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    Cards pendCards = m_player-&gt;<span class="built_in">getPendCards</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断上次出牌的玩家是不是自己</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer == m_player || pendPlayer == <span class="literal">nullptr</span>)&#123;  <span class="comment">//情况1是上次出牌是我自己，其余玩家没有出牌；情况2是刚开时，上一次出牌玩家就为空</span></span><br><span class="line">        <span class="comment">//直接出牌(没有限制)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">firstPlay</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果不是自己想要，需要找出比出牌玩家点数大的牌</span></span><br><span class="line">        PlayHand <span class="built_in">type</span>(pendCards);               <span class="comment">//构造一个playhand对象，对出的牌进行分析</span></span><br><span class="line">        Cards beatCards = <span class="built_in">getGreaterCards</span>(type);      <span class="comment">//通过分析出类型，得到比上个玩家出队牌更大的牌</span></span><br><span class="line">        <span class="comment">//找到了点数大的牌需要考虑是否出牌</span></span><br><span class="line">        <span class="type">bool</span> shouldBeat = <span class="built_in">whetherToBeat</span>(beatCards);    <span class="comment">//将找到更大的牌作为参数传入</span></span><br><span class="line">        <span class="keyword">if</span>(shouldBeat)&#123;         <span class="comment">//如果出牌，打出要出的牌</span></span><br><span class="line">            <span class="keyword">return</span> beatCards;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//否则返回空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();     <span class="comment">//返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//机器人玩家自由出牌函数</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::firstPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断玩家手中是否只剩下单一的牌型</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(m_cards)</span></span>;           <span class="comment">//传入手牌进行分析</span></span><br><span class="line">    <span class="keyword">if</span>(hand.<span class="built_in">getHandType</span>() != PlayHand::Hand_Unknown)&#123;           <span class="comment">//如果只剩单一牌型</span></span><br><span class="line">        <span class="keyword">return</span> m_cards;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是单一的牌型</span></span><br><span class="line">    <span class="comment">//判断玩家手中是否有顺子</span></span><br><span class="line">    QVector&lt;Cards&gt; optimalSeq = <span class="built_in">pickOptimalSeqSingles</span>();     <span class="comment">//获取顺子(筛选后较大的顺子)---&gt;optimalSeq容器里可能有多个顺子</span></span><br><span class="line">    <span class="keyword">if</span>(!optimalSeq.<span class="built_in">isEmpty</span>())&#123;                    <span class="comment">//如果不为空</span></span><br><span class="line">        <span class="comment">//得到单牌的数量</span></span><br><span class="line">        <span class="type">int</span> baseNum = <span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();            <span class="comment">//没有剔除顺子前的单牌数量</span></span><br><span class="line">        <span class="comment">//把得到的顺子的集合从玩家手中删除</span></span><br><span class="line">        Cards save = m_cards;                  <span class="comment">//复制手牌</span></span><br><span class="line">        save.<span class="built_in">remove</span>(optimalSeq);               <span class="comment">//删除顺子</span></span><br><span class="line">        <span class="type">int</span> lastNum = <span class="built_in">Strategy</span>(m_player,save).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>).<span class="built_in">size</span>();  <span class="comment">//在去除顺子的手牌中找到单牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(baseNum &gt; lastNum)&#123;           <span class="comment">//这种情况是说明剔除顺子后，单牌数量更少了，是想要的结果</span></span><br><span class="line">            <span class="keyword">return</span> optimalSeq[<span class="number">0</span>];        <span class="comment">//返回其中一个顺子打出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> hasPlane, hasTriple, hasPair;</span><br><span class="line">    hasPair = hasTriple = hasPlane = <span class="literal">false</span>;</span><br><span class="line">    Cards backup = m_cards;               <span class="comment">//复制手牌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有炸弹</span></span><br><span class="line">    QVector&lt;Cards&gt; bombArray = <span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Bomb, Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    backup.<span class="built_in">remove</span>(bombArray);             <span class="comment">//剔除炸弹</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;planeArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Plane,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!planeArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPlane = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(planeArray);        <span class="comment">//剔除飞机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有三张点数相同的牌</span></span><br><span class="line">    QVector&lt;Cards&gt;seqTripleArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Triple,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqTripleArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasTriple = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqTripleArray);        <span class="comment">//剔除3张点数相同的牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有没有连对</span></span><br><span class="line">    QVector&lt;Cards&gt;seqPairArray = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Pair,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(!seqPairArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        hasPair = <span class="literal">true</span>;</span><br><span class="line">        backup.<span class="built_in">remove</span>(seqPairArray);        <span class="comment">//剔除连对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPair)&#123;         <span class="comment">//找到了连对不为空，就返回最大连对</span></span><br><span class="line">        Cards maxPair;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqPairArray.<span class="built_in">size</span>(); i++)&#123;   <span class="comment">//seqPairArray的元素是类似于34567、345678、3456789....</span></span><br><span class="line">            <span class="keyword">if</span>(seqPairArray[i].<span class="built_in">cardCount</span>() &gt; maxPair.<span class="built_in">cardCount</span>())&#123;        <span class="comment">//比较找出最大连对</span></span><br><span class="line">                maxPair = seqPairArray[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasPlane)&#123;        <span class="comment">//找到了飞机</span></span><br><span class="line">        <span class="comment">//1.飞机带2个对</span></span><br><span class="line">        <span class="type">bool</span> twoPairFond = <span class="literal">false</span>;</span><br><span class="line">        QVector&lt;Cards&gt; pairArray;</span><br><span class="line">        <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">            Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>); <span class="comment">//将搜索的的对子放入pair</span></span><br><span class="line">            <span class="keyword">if</span>(!pair.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                pairArray.<span class="built_in">push_back</span>(pair);             <span class="comment">//添加到pairArray</span></span><br><span class="line">                <span class="keyword">if</span>(pairArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                    twoPairFond = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(twoPairFond)&#123;                       <span class="comment">//如果成功找到2个对</span></span><br><span class="line">            Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">            tmp.<span class="built_in">add</span>(pairArray);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;               <span class="comment">//没有找到2个对，就找2个单牌</span></span><br><span class="line">            <span class="comment">//2.飞机带2个单牌</span></span><br><span class="line">            <span class="type">bool</span> twoSingleFond = <span class="literal">false</span>;</span><br><span class="line">            QVector&lt;Cards&gt; singleArray;</span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_10; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;   <span class="comment">//搜索对子(3-10)</span></span><br><span class="line">                <span class="keyword">if</span>(backup.<span class="built_in">pointCount</span>(point) == <span class="number">1</span>)&#123;            <span class="comment">//先查看该点数的牌是否是只有1张，只有1张才进行添加(防止把一些对拆开)</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//将搜索的的单牌放入single</span></span><br><span class="line">                    <span class="keyword">if</span>(!single.<span class="built_in">isEmpty</span>())&#123;                       <span class="comment">//如果不为空</span></span><br><span class="line">                        singleArray.<span class="built_in">push_back</span>(single);           <span class="comment">//添加到pairArray</span></span><br><span class="line">                        <span class="keyword">if</span>(singleArray.<span class="built_in">size</span>()==<span class="number">2</span>)&#123;               <span class="comment">//如果搜索到2对了，就直接退出循环</span></span><br><span class="line">                            twoSingleFond = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(twoPairFond)&#123;</span><br><span class="line">                Cards tmp = planeArray[<span class="number">0</span>];         <span class="comment">//先使用最小的飞机，将找到的最小飞机复制给tmp</span></span><br><span class="line">                tmp.<span class="built_in">add</span>(singleArray);</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//如果2对和2单都没有找到满足条件的，就直接打出飞机不带</span></span><br><span class="line">                <span class="comment">//3.直接是飞机</span></span><br><span class="line">                <span class="keyword">return</span> planeArray[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hasTriple)&#123;                      <span class="comment">//找到了3张相同的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(seqTripleArray[<span class="number">0</span>]).<span class="built_in">getCardPoint</span>()&lt;Card::Card_A)&#123;         <span class="comment">//如果找到的最小的3张相同牌是小于A的，才执行下面</span></span><br><span class="line">            <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;=Card::Card_A; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);              <span class="comment">//得到较小点数的牌数</span></span><br><span class="line">                <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;              <span class="comment">//如果是1张，就打出3带1</span></span><br><span class="line">                    Cards single = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);       <span class="comment">//取出点数为point的单牌</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];      <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(single);                          <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount==<span class="number">2</span>)&#123;                      <span class="comment">//如果找到的较小点数的牌数是2</span></span><br><span class="line">                    Cards pair = <span class="built_in">Strategy</span>(m_player, backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);         <span class="comment">//取出点数为point的对子</span></span><br><span class="line">                    Cards tmp = seqTripleArray[<span class="number">0</span>];     <span class="comment">//取出找的3张相同点数的牌集合中，取出最小的3张相同的牌</span></span><br><span class="line">                    tmp.<span class="built_in">add</span>(pair);                     <span class="comment">//将找到的单牌放入</span></span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到满足条件的单排和对子，就不带副牌</span></span><br><span class="line">        <span class="keyword">return</span> seqTripleArray[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的牌型都没有得到打出，就考虑打单牌或对牌</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();</span><br><span class="line">    <span class="comment">//如果下一家的手牌数只有1张了，且和下一个玩家不是相同身份</span></span><br><span class="line">    <span class="keyword">if</span>(nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()==<span class="number">1</span> &amp;&amp; m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::<span class="built_in">CardPoint</span>(Card::Card_End<span class="number">-1</span>);</span><br><span class="line">            point&gt;=Card::Card_3; point=Card::<span class="built_in">CardPoint</span>(point<span class="number">-1</span>))&#123;                 <span class="comment">//从大到小遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;       <span class="comment">//如果下一家的手牌数为1且和它是相同身份；如果下一家手牌数大于1且与它不是相同身份；如果下一家手牌数大于1且与它是相同身份</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point = Card::Card_3; point&lt;Card::Card_End; point=Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>))&#123;       <span class="comment">//从小到大遍历</span></span><br><span class="line">            <span class="type">int</span> pointCount = backup.<span class="built_in">pointCount</span>(point);             <span class="comment">//得到指定点数牌的数量</span></span><br><span class="line">            <span class="keyword">if</span>(pointCount == <span class="number">1</span>)&#123;                     <span class="comment">//如果只有1张，就取出来打出</span></span><br><span class="line">                Cards single = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> single;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pointCount == <span class="number">2</span>)&#123;               <span class="comment">//如果有2张牌就，取出来打出</span></span><br><span class="line">                Cards pair = <span class="built_in">Strategy</span>(m_player,backup).<span class="built_in">findSamePointCards</span>(point,<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//上面所有情况呕没有打出牌，就说明牌打完了，直接返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从自己手牌中找到能击败已出牌的牌</span></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getGreaterCards</span><span class="params">(PlayHand type)</span>         <span class="comment">//参数是要被击败出牌的类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1 出牌玩家和当前玩家不是一伙的</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="comment">//上一个出牌玩家出了牌，与它不是一伙，且出牌玩家的手牌已经小于3---&gt;pendPlayer != nullptr是防止第一次出牌的情况(地主自由出)</span></span><br><span class="line">    <span class="keyword">if</span>(pendPlayer != <span class="literal">nullptr</span> &amp;&amp; pendPlayer-&gt;<span class="built_in">getRole</span>()!=m_player-&gt;<span class="built_in">getRole</span>() &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        QVector&lt;Cards&gt; bombs = <span class="built_in">findCardsByCount</span>(<span class="number">4</span>);      <span class="comment">//通过传入参数4，找出手牌中的所有炸弹，且是从小到大排的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;bombs.<span class="built_in">size</span>(); i++)&#123;               <span class="comment">//从最小开始遍历炸弹比较</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(bombs[i]).<span class="built_in">canBeat</span>(type))&#123;        <span class="comment">//如果我的炸弹类型比出的牌类型大，就会发挥true</span></span><br><span class="line">                <span class="keyword">return</span> bombs[i];                         <span class="comment">//说明找到了击败已出牌的的最小炸弹，就直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有返回，说明没有找到合适的炸弹，就搜索当前玩家有没有王炸</span></span><br><span class="line">        Cards sj = <span class="built_in">findSamePointCards</span>(Card::Card_SJ,<span class="number">1</span>);</span><br><span class="line">        Cards bj = <span class="built_in">findSamePointCards</span>(Card::Card_BJ,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sj.<span class="built_in">isEmpty</span>() &amp;&amp; !bj.<span class="built_in">isEmpty</span>())&#123;        <span class="comment">//如果有王炸，就返回王炸</span></span><br><span class="line">            Cards jokers;</span><br><span class="line">            jokers &lt;&lt; sj &lt;&lt; bj;</span><br><span class="line">            <span class="keyword">return</span> jokers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 当前玩家和下一个玩家不是一伙的</span></span><br><span class="line">    Player* nextPlayer = m_player-&gt;<span class="built_in">getNextPlayer</span>();              <span class="comment">//得到下一个玩家对象</span></span><br><span class="line">    <span class="comment">//将玩家手中的顺子剔除出去，万不得已还是不拆除(这里的顺子是指较大的顺子)</span></span><br><span class="line">    Cards remain = m_cards;</span><br><span class="line">    remain.<span class="built_in">remove</span>(<span class="built_in">Strategy</span>(m_player,remain).<span class="built_in">pickOptimalSeqSingles</span>());   <span class="comment">//去除掉手牌中较大的顺子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除冗余的思路：就是将相同的代码放到匿名函数里面，然后通过可调用对象绑定器进行绑定，最后可得到一个可调用对象，要用到的时候，直接使用该可调用对象即可</span></span><br><span class="line">    <span class="keyword">auto</span> beatCard = std::<span class="built_in">bind</span>([=](Cards &amp;cards)&#123;      <span class="comment">//参入的参数是一些牌，返回的还是Cards类型</span></span><br><span class="line">        QVector&lt;Cards&gt;beatCardsArray = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(type, <span class="literal">true</span>);   <span class="comment">//找出已出牌的类型，且要求比它更大一点(true)</span></span><br><span class="line">        <span class="keyword">if</span>(!beatCardsArray.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果找出的不为空，说明找到了比已出牌更大的类型牌</span></span><br><span class="line">            <span class="comment">//如果我与下一个玩家不是相同身份，且下一个玩家的手牌小于等于2了，这时需要出更大的牌，防止下一个玩家能出牌</span></span><br><span class="line">            <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>()!=nextPlayer-&gt;<span class="built_in">getRole</span>() &amp;&amp; nextPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">back</span>();             <span class="comment">//已经找出的牌型是从小到大排的，所以取出最大的牌返回</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;   <span class="comment">//下一个不是相同玩家但牌数小于等于2；下一个是不同玩家，但牌数大于2；下一个是相同玩家，但牌数大于2</span></span><br><span class="line">                <span class="keyword">return</span> beatCardsArray.<span class="built_in">front</span>();      <span class="comment">//否则的话，就直接返回最小的能压制已出牌的相同牌型</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();              <span class="comment">//不满足上面，就返回空对象</span></span><br><span class="line">    &#125;, std::placeholders::_1);</span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(remain)).<span class="built_in">isEmpty</span>())&#123;          <span class="comment">//这是从剔除顺子的手牌中找</span></span><br><span class="line">        <span class="keyword">return</span> cs;                    <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                                         <span class="comment">//如果从剔除顺子的手牌中没有找到，就从所有手牌中找</span></span><br><span class="line">        <span class="keyword">if</span>(!(cs=<span class="built_in">beatCard</span>(m_cards)).<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> cs;        <span class="comment">//如果得到的cs不为空，就返回给调用者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();               <span class="comment">//没有找到合适出牌类型，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Strategy::whetherToBeat</span><span class="params">(Cards &amp;cs)</span>      <span class="comment">//参数是通过其它函数得到的一个更大的牌，或为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//没有找到能够击败对方的牌,即cs为空</span></span><br><span class="line">    <span class="keyword">if</span>(cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到出牌玩家的对象</span></span><br><span class="line">    Player* pendPlayer = m_player-&gt;<span class="built_in">getPendPlayer</span>();     <span class="comment">//得到上次出牌的玩家身份</span></span><br><span class="line">    <span class="keyword">if</span>(m_player-&gt;<span class="built_in">getRole</span>() == pendPlayer-&gt;<span class="built_in">getRole</span>())&#123;   <span class="comment">//如果身份相同，即农民</span></span><br><span class="line">        <span class="comment">//手里的牌所剩无几并且是一个完整的牌型,就可以打</span></span><br><span class="line">        Cards left = m_cards;              <span class="comment">//先复制手牌</span></span><br><span class="line">        left.<span class="built_in">remove</span>(cs);                   <span class="comment">//从手牌移出要打的牌</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">PlayHand</span>(left).<span class="built_in">getHandType</span>()!=PlayHand::Hand_Unknown)&#123;    <span class="comment">//如果手牌剩的类型不是不确定的(即就是可以一下子打完的那中牌类型)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs对象中的牌的最小点数是2，大小王就不出牌</span></span><br><span class="line">        Card::CardPoint basePoint = <span class="built_in">PlayHand</span>(cs).<span class="built_in">getCardPoint</span>();               <span class="comment">//得出要打牌的点数</span></span><br><span class="line">        <span class="keyword">if</span>(basePoint==Card::Card_2 || basePoint==Card::Card_SJ || basePoint==Card::Card_BJ)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果过大就不出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                  <span class="comment">//如果与出牌的玩家不是相同身份</span></span><br><span class="line">        PlayHand <span class="built_in">myHand</span>(cs);                       <span class="comment">//先判断要出牌的类型</span></span><br><span class="line">        <span class="comment">//如果是三个2带1，或者带1对，不出牌(保存实力)</span></span><br><span class="line">        <span class="keyword">if</span>((myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Single || myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Triple_Pair)</span><br><span class="line">                &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cs是对2，并且出牌玩家手中的牌数量大于等于10 &amp;&amp; 自己的牌数量大于等于5，暂时放弃出牌</span></span><br><span class="line">        <span class="keyword">if</span>(myHand.<span class="built_in">getHandType</span>()==PlayHand::Hand_Pair &amp;&amp; myHand.<span class="built_in">getCardPoint</span>()==Card::Card_2 &amp;&amp; pendPlayer-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">10</span> &amp;&amp; m_player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>()&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//上面情况都不是，就可以出牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::findSamePointCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> count)</span>     <span class="comment">//指定点数和指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;               <span class="comment">//如果要找的牌的数量小于1或大于4，都是不合法的，返回空对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//大小王</span></span><br><span class="line">    <span class="keyword">if</span>(point == Card::Card_SJ || point == Card::Card_BJ)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;              <span class="comment">//非法的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Cards</span>();       <span class="comment">//返回空对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        Card card;</span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);               <span class="comment">//存放点数(大王或小王)</span></span><br><span class="line">        card.<span class="built_in">setSuit</span>(Card::Suit_Begin);     <span class="comment">//存放花色</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;         <span class="comment">//如果该牌在m_cards是真的存在</span></span><br><span class="line">            Cards cards;</span><br><span class="line">            cards.<span class="built_in">add</span>(card);</span><br><span class="line">            <span class="keyword">return</span> cards;                   <span class="comment">//就将该牌添加到cards并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cards</span>();                    <span class="comment">//没有找到大小王就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是大小王</span></span><br><span class="line">    <span class="type">int</span> findCount = <span class="number">0</span>;                   <span class="comment">//这是用来记录指定点数的牌的数量</span></span><br><span class="line">    Cards findCards;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++)&#123;       <span class="comment">//遍历花色</span></span><br><span class="line">        Card card;                                    <span class="comment">//创建一个card,记录的是指定的点数，和该遍历的花色</span></span><br><span class="line">        card.<span class="built_in">setPoint</span>(point);</span><br><span class="line">        card.<span class="built_in">setSuit</span>((Card::CardSuit)suit);</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">contains</span>(card))&#123;                 <span class="comment">//如果该card在m_cards，说明有该张牌</span></span><br><span class="line">            findCount++;</span><br><span class="line">            findCards.<span class="built_in">add</span>(card);                    <span class="comment">//将该张牌添加到findCards</span></span><br><span class="line">            <span class="keyword">if</span>(findCount == count)&#123;</span><br><span class="line">                <span class="keyword">return</span> findCards;                   <span class="comment">//如果指定点数的牌的数量到达了指定的点数，就返回这些牌</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cards</span>();        <span class="comment">//如果遍历完所有的花色，都没有找到指定点数、指定数量的牌，就返回空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardsByCount</span><span class="params">(<span class="type">int</span> count)</span>          <span class="comment">//指定数量的牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">1</span> || count&gt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();            <span class="comment">//如果指定的数量不合法，就直接返回空</span></span><br><span class="line">    &#125;</span><br><span class="line">    QVector&lt;Cards&gt;cardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=Card::Card_3; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(point)==count)&#123;               <span class="comment">//pointCount()函数是指定点数的牌数量</span></span><br><span class="line">            <span class="comment">//如果该点数的牌数量和要求的牌数量相等，就取出该牌(通过上面刚写的函数)</span></span><br><span class="line">            Cards cs;</span><br><span class="line">            cs &lt;&lt; <span class="built_in">findSamePointCards</span>(point,count);       <span class="comment">//取出指定点数、指定数量的牌</span></span><br><span class="line">            cardsArray &lt;&lt; cs;             <span class="comment">//最后返回的容器cardsArray中，一个cards存放的是相同点数的牌</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cardsArray;         <span class="comment">//然后容器，里面存的是指定数量的牌(可能有多中不同点数的牌)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getRangeCards</span><span class="params">(Card::CardPoint begin, Card::CardPoint end)</span>      <span class="comment">//指定范围的所有牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards rangeCards;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;   <span class="comment">//遍历这个范围点数的牌</span></span><br><span class="line">        <span class="type">int</span> count = m_cards.<span class="built_in">pointCount</span>(point);                     <span class="comment">//先获得该点数的牌数量</span></span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, count);               <span class="comment">//通过点数、牌数量得到这些牌</span></span><br><span class="line">        rangeCards  &lt;&lt; cs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rangeCards;                      <span class="comment">//这里面存的都是在指定范围的牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::findCardType</span><span class="params">(PlayHand hand, <span class="type">bool</span> beat)</span>    <span class="comment">//hand是要求牌的类型，beat是否需要点数更大</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//取出要求牌的类型</span></span><br><span class="line">    Card::CardPoint point = hand.<span class="built_in">getCardPoint</span>();         <span class="comment">//取出要求牌的点数</span></span><br><span class="line">    <span class="type">int</span> extra = hand.<span class="built_in">getExtra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定起始点数(如果beat为true，就在原来基础上+1；为false，就直接从最小3开始找)</span></span><br><span class="line">    Card::CardPoint beginPoint = beat?Card::<span class="built_in">CardPoint</span>(point+<span class="number">1</span>):Card::Card_3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">1</span>);        <span class="comment">//单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">2</span>);        <span class="comment">//对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getCards</span>(beginPoint, <span class="number">3</span>);        <span class="comment">//三个一样</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Single);      <span class="comment">//3带1</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getTripleSingleOrPair</span>(beginPoint, PlayHand::Hand_Pair);        <span class="comment">//3带一对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane</span>(beginPoint);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Single);</span><br><span class="line">    <span class="keyword">case</span>::PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getPlane2SingleOr2Pair</span>(beginPoint, PlayHand::Hand_Pair);</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:                    <span class="comment">//连对</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_Q;          <span class="comment">//最大点数到Q即可</span></span><br><span class="line">        info.number = <span class="number">2</span>;</span><br><span class="line">        info.base = <span class="number">3</span>;                    <span class="comment">//基础连对至少是3对</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqPair;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:               <span class="comment">//顺子</span></span><br><span class="line">    &#123;</span><br><span class="line">        CardInfo info;</span><br><span class="line">        info.begin = beginPoint;</span><br><span class="line">        info.end = Card::Card_10;           <span class="comment">//最大点数到10即可</span></span><br><span class="line">        info.number = <span class="number">1</span>;</span><br><span class="line">        info.base = <span class="number">5</span>;                   <span class="comment">//基础顺子至少是5个</span></span><br><span class="line">        info.extra = extra;</span><br><span class="line">        info.beat = beat;</span><br><span class="line">        info.getSeq = &amp;Strategy::getBaseSeqSingle;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSepPairOrSeqSingle</span>(info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:                    <span class="comment">//炸弹</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBomb</span>(beginPoint);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();                <span class="comment">//如果都不是，就返回空对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的Cards对象中挑选出顺子(参1和参2都是传出参数，参3是传入参数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Strategy::pickSeqSingles</span><span class="params">(QVector&lt;QVector&lt;Cards&gt; &gt; &amp;allSeqRecord, <span class="type">const</span> QVector&lt;Cards&gt; &amp;seqSingle, <span class="type">const</span> Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.得到传入牌cards的所有顺子的组合</span></span><br><span class="line">    QVector&lt;Cards&gt; allSeq = <span class="built_in">Strategy</span>(m_player,cards).<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(PlayHand::Hand_Seq_Single,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(allSeq.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//如果为空了，就结束递归，将满足条件的顺子传入allSeqRecord</span></span><br><span class="line">        allSeqRecord &lt;&lt; seqSingle;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;           <span class="comment">//2.对顺子进行筛选</span></span><br><span class="line">        Cards saveCards = cards;      <span class="comment">//先复制手牌，备份使用，马上进入for循环了</span></span><br><span class="line">        <span class="comment">//遍历得到的所有的顺子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;allSeq.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            Cards aScheme = allSeq.<span class="built_in">at</span>(i);             <span class="comment">//将顺子取出</span></span><br><span class="line">            Cards temp = saveCards;</span><br><span class="line">            temp.<span class="built_in">remove</span>(aScheme);                     <span class="comment">//将顺子从用户手中剔除</span></span><br><span class="line"></span><br><span class="line">            QVector&lt;Cards&gt; seqArray = seqSingle;</span><br><span class="line">            seqArray &lt;&lt; aScheme;                      <span class="comment">//将得到的顺子放入seqArray</span></span><br><span class="line">            <span class="comment">//检测还没有其它的顺子</span></span><br><span class="line">            <span class="comment">//seqArray:存储一轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//allSeqRecord:存储多轮for循环中多轮递归得到的所有的可用的顺子</span></span><br><span class="line">            <span class="comment">//temp:是剔除顺子的手牌</span></span><br><span class="line">            <span class="built_in">pickSeqSingles</span>(allSeqRecord,seqArray,temp);</span><br><span class="line">            <span class="comment">//allSeqRecord里面的存的，比如说第1个元素存的是剔除34567后，手牌中还满足的顺子(包括34567)；第2个元素是剔除345678后还满足的顺子(包括345678)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//筛选最优的顺子</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::pickOptimalSeqSingles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;QVector&lt;Cards&gt;&gt;seqRecord;</span><br><span class="line">    QVector&lt;Cards&gt; seqSingles;</span><br><span class="line">    <span class="comment">//找顺子之前，先把一些更重要的牌型剔除，防止被拆</span></span><br><span class="line">    Cards save = m_cards;                            <span class="comment">//先复制手牌</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">4</span>));                <span class="comment">//剔除炸弹</span></span><br><span class="line">    save.<span class="built_in">remove</span>(<span class="built_in">findCardsByCount</span>(<span class="number">3</span>));                <span class="comment">//剔除一些3带1或飞机类型的牌</span></span><br><span class="line">    <span class="built_in">pickSeqSingles</span>(seqRecord, seqSingles, save);     <span class="comment">//对一些重要的牌进行剔除后，基于剩下的牌save来进行查找顺子</span></span><br><span class="line">    <span class="keyword">if</span>(seqRecord.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果找出的集合为空，说明没有找到顺子，就返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">QVector</span>&lt;Cards&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历容器</span></span><br><span class="line">    QMap&lt;<span class="type">int</span>,<span class="type">int</span>&gt;seqMarks;              <span class="comment">//存储对应关系的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;seqRecord.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        Cards backupCards = m_cards;                  <span class="comment">//先复制手牌到backupCards</span></span><br><span class="line">        QVector&lt;Cards&gt;seqArray = seqRecord[i];        <span class="comment">//复制此刻要处理的容器(里面都是顺子)</span></span><br><span class="line">        backupCards.<span class="built_in">remove</span>(seqArray);                 <span class="comment">//从复制的手牌backupCards中移除此刻容器里面的所有顺子</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断剩下的单牌数量，数量越少，顺子的组合就越合理</span></span><br><span class="line">        QVector&lt;Cards&gt; singleArray = <span class="built_in">Strategy</span>(m_player, backupCards).<span class="built_in">findCardsByCount</span>(<span class="number">1</span>);     <span class="comment">//将移除顺子容器后的手牌传入</span></span><br><span class="line">        <span class="comment">//因为传入的数量是1,所以返回的singleArray中每个元素cards里面都是存的不同点数的牌，但每个点数的牌数量都为1</span></span><br><span class="line">        CardList cardList;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;singleArray.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cardList &lt;&lt; singleArray[j].<span class="built_in">toCardList</span>();      <span class="comment">//将所有的单牌取出转换后存入到cardList</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里选择点数相对较大一点的顺子，则在两种组合中留下的单牌数量相同的情况下，单牌点数就可能小。所以下面就选择单牌点数小的组合来返回</span></span><br><span class="line">        <span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;cardList.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            mark += cardList[j].<span class="built_in">point</span>() + <span class="number">15</span>;   <span class="comment">//加15的原因，是防止两组组合留下的单牌数不一样情况下，类似3、4和k这两种，应该选择k对应的组合</span></span><br><span class="line">        &#125;</span><br><span class="line">        seqMarks.<span class="built_in">insert</span>(i,mark);          <span class="comment">//将对应的mark值和其最大容器组合下标i的对应关系存到seqMarks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> comMark = <span class="number">1000</span>;                    <span class="comment">//先初始化一个较大值</span></span><br><span class="line">    <span class="keyword">auto</span> it = seqMarks.<span class="built_in">constBegin</span>();       <span class="comment">//常量迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(; it!=seqMarks.<span class="built_in">constEnd</span>(); it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.<span class="built_in">value</span>() &lt; comMark)&#123;            <span class="comment">//寻找最小的key值对应的value</span></span><br><span class="line">            comMark = it.<span class="built_in">value</span>();</span><br><span class="line">            value = it.<span class="built_in">key</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seqRecord[value];            <span class="comment">//返回最优的顺子(较大的顺子)，是QVector&lt;Cards&gt;类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getCards</span><span class="params">(Card::CardPoint point, <span class="type">int</span> number)</span>   <span class="comment">//起点点数point,number张</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint pt=point; pt&lt;Card::Card_End; pt=(Card::CardPoint)(pt+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//目的是尽量不拆分别的牌型</span></span><br><span class="line">        <span class="keyword">if</span>(m_cards.<span class="built_in">pointCount</span>(pt)==number)&#123;  <span class="comment">//这里是确保找的点数的牌数量与想找的牌数量一样，就执行下面，防止本来有个炸弹，但因为找但牌，就拆开了</span></span><br><span class="line">            Cards cs = <span class="built_in">findSamePointCards</span>(pt, number);</span><br><span class="line">            findCardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getTripleSingleOrPair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到点数相同的三张牌</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getCards</span>(begin,<span class="number">3</span>);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type,Card::Card_Begin,<span class="number">0</span>),<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cardsArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            <span class="comment">//将找到的牌和三张点数相同的牌进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(cardsArray.<span class="built_in">at</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane</span><span class="params">(Card::CardPoint begin)</span>                 <span class="comment">//飞机不带牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findCardArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;=Card::Card_K; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="comment">//根据点数和数量进行搜索</span></span><br><span class="line">        Cards prevCards = <span class="built_in">findSamePointCards</span>(point, <span class="number">3</span>);                      <span class="comment">//找出飞机小</span></span><br><span class="line">        Cards nextCards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">3</span>);  <span class="comment">//找出飞机大</span></span><br><span class="line">        <span class="keyword">if</span>(!prevCards.<span class="built_in">isEmpty</span>() &amp;&amp; !nextCards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            Cards tmp;</span><br><span class="line">            tmp &lt;&lt; prevCards &lt;&lt; nextCards;       <span class="comment">//将飞机小和大存到一个Cards里面，再存入到findCardArray</span></span><br><span class="line">            findCardArray &lt;&lt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getPlane2SingleOr2Pair</span><span class="params">(Card::CardPoint begin, PlayHand::HandType type)</span>   <span class="comment">//飞机带2单还是2对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找飞机</span></span><br><span class="line">    QVector&lt;Cards&gt;findCardArray = <span class="built_in">getPlane</span>(begin);     <span class="comment">//找出有3张相同点数的一些牌</span></span><br><span class="line">    <span class="keyword">if</span>(!findCardArray.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        <span class="comment">//将找到的牌从用户手中删除</span></span><br><span class="line">        Cards remainCards = m_cards;                   <span class="comment">//复制用户手牌</span></span><br><span class="line">        remainCards.<span class="built_in">remove</span>(findCardArray);             <span class="comment">//删除3张相同的牌</span></span><br><span class="line">        <span class="comment">//在剩余牌中继续搜索(搜索单牌或成对的牌)</span></span><br><span class="line">        <span class="function">Strategy <span class="title">st</span><span class="params">(m_player, remainCards)</span></span>;</span><br><span class="line">        QVector&lt;Cards&gt;cardsArray = st.<span class="built_in">findCardType</span>(<span class="built_in">PlayHand</span>(type, Card::Card_Begin, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(cardsArray.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//将找到的牌就和飞机进行组合</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;findCardArray.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                Cards tmp;</span><br><span class="line">                tmp &lt;&lt; cardsArray[<span class="number">0</span>] &lt;&lt; cardsArray[<span class="number">1</span>];</span><br><span class="line">                findCardArray[i].<span class="built_in">add</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            findCardArray.<span class="built_in">clear</span>();          <span class="comment">//没有找到，说明不满足这种飞机，就直接清空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将最终结果返回给函数调用者(可能为空)</span></span><br><span class="line">    <span class="keyword">return</span> findCardArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//连对或顺子(begin是起始点；extra是要找的牌数；beat指是否比原基础上至少大1点)</span></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getSepPairOrSeqSingle</span><span class="params">(CardInfo &amp;info)</span>    <span class="comment">//连对和顺子提供的数据是不一样的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt;findCardsArray;</span><br><span class="line">    <span class="keyword">if</span>(info.beat)&#123;       <span class="comment">//为true，表示要找能压制对方的牌</span></span><br><span class="line">        <span class="comment">//最少3个，最大A(连对)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">bool</span> found = <span class="literal">true</span>;           <span class="comment">//记录是否查找成功</span></span><br><span class="line">            Cards seqCards;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;info.extra; i++)&#123;</span><br><span class="line">                <span class="comment">//基于点数和数量进行牌的搜索</span></span><br><span class="line">                Cards cards = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+i),info.number);     <span class="comment">//连续的2张2张的找连对</span></span><br><span class="line">                <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>() || (point+info.extra&gt;=Card::Card_2))&#123;     <span class="comment">//这种情况就是没有找到</span></span><br><span class="line">                    found = <span class="literal">false</span>;</span><br><span class="line">                    seqCards.<span class="built_in">clear</span>();</span><br><span class="line">                    <span class="keyword">break</span>;       <span class="comment">//说明以此刻的point为起点，遍历extra个是找不到的，直接跳出循环，继续下一个point为起点开始查找</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    seqCards &lt;&lt; cards;         <span class="comment">//如果找到了就加入seqCards</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found)&#123;    <span class="comment">//如果以此刻的point为起点找到了满足条件的，就没有必要继续找了，因为压制对方的最小的连对已经找到</span></span><br><span class="line">                findCardsArray &lt;&lt; seqCards;</span><br><span class="line">                <span class="keyword">return</span> findCardsArray;                <span class="comment">//直接返回即可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;     <span class="comment">//bet为false，意味着要找的连对对点数和数量是没有要求的(不受extra约束)</span></span><br><span class="line">        <span class="keyword">for</span>(Card::CardPoint point=info.begin; point&lt;=info.end; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="comment">//将找到的这个基础连对存储起来</span></span><br><span class="line">            Cards baseSeq = (<span class="keyword">this</span>-&gt;*info.getSeq)(point);       <span class="comment">//使用函数指针，得到一个基础连对或基础顺子</span></span><br><span class="line">            <span class="keyword">if</span>(baseSeq.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//如果是空，就不执行下面了，重新循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            findCardsArray &lt;&lt; baseSeq;            <span class="comment">//将基础连对存储到最终容器中</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> followed = info.base;           <span class="comment">//因为之前已经找到了3对，接下来是再其基础上找连续对子</span></span><br><span class="line">            Cards alreadyFollowedCards;         <span class="comment">//存储后序找到的满足条件的连对</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                Card::CardPoint followedPoint = Card::<span class="built_in">CardPoint</span>(point+followed);      <span class="comment">//新的起始点数</span></span><br><span class="line">                <span class="comment">//判断是否超出了上限</span></span><br><span class="line">                <span class="keyword">if</span>(followedPoint &gt;= Card::Card_2)&#123;              <span class="comment">//如果点数比2大，是不合理的，直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Cards follwedCards = <span class="built_in">findSamePointCards</span>(followedPoint, info.number);     <span class="comment">//如果点数合理，就寻找该点数的对子</span></span><br><span class="line">                <span class="keyword">if</span>(follwedCards.<span class="built_in">isEmpty</span>())&#123;           <span class="comment">//为空表示没有找到，退出循环(说明以此刻的point为起点的后序对子段了或没有了)</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//比如说345是基础连对，在此基础上，3456、34567都会作为一个独立的cards存储到最终容器中，当没有8连对时，以345为基础的也结束查找了</span></span><br><span class="line">                    alreadyFollowedCards &lt;&lt; follwedCards;   <span class="comment">//在后面基础每找到一对，就将其存入到alreadyFollowedCards</span></span><br><span class="line">                    Cards newSeq = baseSeq;                 <span class="comment">//通过拷贝赋值得到newSeq，它里面存的是此刻的基础对子</span></span><br><span class="line">                    newSeq &lt;&lt; alreadyFollowedCards;         <span class="comment">//将这一轮找到的对子加入到基础对子，又得到一种新的连对</span></span><br><span class="line">                    findCardsArray &lt;&lt; newSeq;               <span class="comment">//将这一轮得到的新连对存入到最终容器中</span></span><br><span class="line">                    followed++;                             <span class="comment">//++操作，在此刻的基础连对上，继续找下一个对子</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findCardsArray;       <span class="comment">//如果遍历完了还没有找到，返回的就是一个空对象，否则里面就有很多连对cards对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqPair</span><span class="params">(Card::CardPoint point)</span>      <span class="comment">//生成基础连对函数(参数是起始点)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">2</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">2</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">2</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Cards <span class="title">Strategy::getBaseSeqSingle</span><span class="params">(Card::CardPoint point)</span>    <span class="comment">//生成基础顺子函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards0 = <span class="built_in">findSamePointCards</span>(point, <span class="number">1</span>);</span><br><span class="line">    Cards cards1 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards2 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">2</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards3 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">3</span>),<span class="number">1</span>);</span><br><span class="line">    Cards cards4 = <span class="built_in">findSamePointCards</span>((Card::CardPoint)(point+<span class="number">4</span>),<span class="number">1</span>);</span><br><span class="line">    Cards baseSeq;</span><br><span class="line">    <span class="keyword">if</span>(!cards0.<span class="built_in">isEmpty</span>() &amp;&amp; !cards1.<span class="built_in">isEmpty</span>() &amp;&amp; !cards2.<span class="built_in">isEmpty</span>() &amp;&amp; !cards3.<span class="built_in">isEmpty</span>() &amp;&amp; !cards4.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        baseSeq &lt;&lt; cards0 &lt;&lt; cards1 &lt;&lt; cards2 &lt;&lt; cards3 &lt;&lt; cards4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> baseSeq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QVector&lt;Cards&gt; <span class="title">Strategy::getBomb</span><span class="params">(Card::CardPoint begin)</span>            <span class="comment">//找炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QVector&lt;Cards&gt; findcardsArray;</span><br><span class="line">    <span class="keyword">for</span>(Card::CardPoint point=begin; point&lt;Card::Card_End; point=(Card::CardPoint)(point+<span class="number">1</span>))&#123;</span><br><span class="line">        Cards cs = <span class="built_in">findSamePointCards</span>(point, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(!cs.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">            findcardsArray &lt;&lt; cs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findcardsArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt斗地主项目(下)</title>
    <url>/2024/08/08/Qt%E6%96%97%E5%9C%B0%E4%B8%BB%E9%A1%B9%E7%9B%AE(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="1-结束面板窗口类EndingPanel"><a href="#1-结束面板窗口类EndingPanel" class="headerlink" title="1. 结束面板窗口类EndingPanel"></a>1. 结束面板窗口类EndingPanel</h1><p>结束面板窗口类是用于在当一个玩家打完自己手中的牌时，也就意味着游戏结束。当结束的时候，会在主窗口的正中间跳入一个结束面板窗口，上面记录了各个玩家的得分。</p>
<p>结束分数面板窗口类：新建、c++、c++clase、类名为EndignPanel，基类为QWidget。</p>
<h2 id="1-1-EndingPanel类头文件"><a href="#1-1-EndingPanel类头文件" class="headerlink" title="1.1 EndingPanel类头文件"></a>1.1 EndingPanel类头文件</h2><p>结束面板窗口类的头文件主要就是定义一些有关结束面板的私有变量，如背景、按钮等。同时也定义一个关于是否继续游戏的信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EndingPanel</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">EndingPanel</span><span class="params">(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取玩家的得分，并显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">continueGame</span><span class="params">()</span></span>;               <span class="comment">//添加一个自定义信号(点击继续按钮时，发出该信号)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_bk;                     <span class="comment">//结束面板的背景</span></span><br><span class="line">    QLabel* m_title;                  <span class="comment">//地主赢或输、农民赢或输的标签</span></span><br><span class="line">    ScorePanel *m_score;              <span class="comment">//之前创建的分数窗口</span></span><br><span class="line">    QPushButton* m_continue;          <span class="comment">//继续游戏按钮</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-EndingPanel类函数实现"><a href="#1-2-EndingPanel类函数实现" class="headerlink" title="1.2 EndingPanel类函数实现"></a>1.2 EndingPanel类函数实现</h2><p>这部分就是对头文件定义的函数实现，通过构造函数，直接初始化完结束面板窗口上的所有内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EndingPanel::<span class="built_in">EndingPanel</span>(<span class="type">bool</span> isLord, <span class="type">bool</span> isWin, QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_bk.<span class="built_in">load</span>(<span class="string">&quot;:/images/gameover.png&quot;</span>);            <span class="comment">//先把结束面板加载出来</span></span><br><span class="line">    <span class="built_in">setFixedSize</span>(m_bk.<span class="built_in">size</span>());                     <span class="comment">//设置大小为图片大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示用户玩家的角色以及游戏状态</span></span><br><span class="line">    m_title = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                    <span class="comment">//创建一个标签</span></span><br><span class="line">    <span class="keyword">if</span>(isLord &amp;&amp; isWin)&#123;                           <span class="comment">//如果用户是地主，且赢了，就在标签上加载对应的图</span></span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLord &amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/lord_fail.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_win.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isLord &amp;&amp; !isWin)&#123;</span><br><span class="line">        m_title-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/farmer_fail.png&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    m_title-&gt;<span class="built_in">move</span>(<span class="number">125</span>,<span class="number">125</span>);                <span class="comment">//标签显示位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分数面板</span></span><br><span class="line">    m_score = <span class="keyword">new</span> <span class="built_in">ScorePanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">move</span>(<span class="number">75</span>, <span class="number">230</span>);</span><br><span class="line">    m_score-&gt;<span class="built_in">setFixedSize</span>(<span class="number">260</span>, <span class="number">160</span>);              <span class="comment">//设置结束面板中，显示分数面板的大小</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontColor</span>(ScorePanel::Red);     <span class="comment">//设置字体颜色为红色</span></span><br><span class="line">    m_score-&gt;<span class="built_in">setMyFontSize</span>(<span class="number">18</span>);                   <span class="comment">//设置字体大小为8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续游戏按钮</span></span><br><span class="line">    m_continue = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_continue-&gt;<span class="built_in">move</span>(<span class="number">84</span>, <span class="number">429</span>);</span><br><span class="line">    QString style = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">            QPushButton&#123;border-image: url(:/images/button_normal.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:hover&#123;border-image: url(:/images/button_hover.png)&#125;</span></span><br><span class="line"><span class="string">            QPushButton:pressed&#123;border-image: url(:/images/button_pressed.png)&#125;</span></span><br><span class="line"><span class="string">        )&quot;</span>;</span><br><span class="line">    m_continue-&gt;<span class="built_in">setStyleSheet</span>(style);</span><br><span class="line">    m_continue-&gt;<span class="built_in">setFixedSize</span>(<span class="number">231</span>,<span class="number">48</span>);       <span class="comment">//按钮大小</span></span><br><span class="line">    <span class="built_in">connect</span>(m_continue, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;EndingPanel::continueGame);     <span class="comment">//发出信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::setPlayerScore</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> me)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_score-&gt;<span class="built_in">setScores</span>(left, right, me);           <span class="comment">//直接调用左上角分数面板的设置分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndingPanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_bk);         <span class="comment">//参1：这个图像要显示到哪个矩形区域里面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-动画效果类AnimationWindow"><a href="#2-动画效果类AnimationWindow" class="headerlink" title="2. 动画效果类AnimationWindow"></a>2. 动画效果类AnimationWindow</h1><p>动画效果类主要就是负责在游戏构成中，在主窗口显示的一些动画。比如说当抢地主阶段，每个玩家的下注分数或不叫。和当有用户打出王炸、顺子、飞机等特殊牌型时，都会有触发一些动画，来提高游戏的体验感。</p>
<p>动画效果类创建：选择新建、c++、c++clase、类名为AnimationWindow，基类为QWidget。</p>
<h2 id="2-1-AnimationWindow类头文件"><a href="#2-1-AnimationWindow类头文件" class="headerlink" title="2.1 AnimationWindow类头文件"></a>2.1 AnimationWindow类头文件</h2><p>动画效果类的头文件定义了一些特殊牌型的动画显示函数和下注的分数显示函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnimationWindow</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;Sequence, Pair&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AnimationWindow</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示下注分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBetScore</span><span class="params">(<span class="type">int</span> bet)</span></span>;</span><br><span class="line">    <span class="comment">//显示顺子和连对</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showSequence</span><span class="params">(Type type)</span></span>;</span><br><span class="line">    <span class="comment">//显示王炸</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showJokerBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示炸弹</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showBomb</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//显示飞机</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPlane</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_image;                <span class="comment">//加载图片的对象</span></span><br><span class="line">    <span class="type">int</span> m_index;</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-AnimationWindow类函数实现"><a href="#2-2-AnimationWindow类函数实现" class="headerlink" title="2.2 AnimationWindow类函数实现"></a>2.2 AnimationWindow类函数实现</h2><p>这不是是对AnimationWindow类头文件中定义的函数实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AnimationWindow::<span class="built_in">AnimationWindow</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示分数窗口加载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBetScore</span><span class="params">(<span class="type">int</span> bet)</span>         <span class="comment">//主窗口创建AnimationWindow类对象后，会调用该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">1</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score1.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">2</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score2.png&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bet == <span class="number">3</span>)&#123;</span><br><span class="line">        m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/score3.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>();              <span class="comment">//将加载的图片显示到窗口</span></span><br><span class="line">    <span class="comment">//当抢地主完毕之后，就隐藏该显示分数这个窗口，也就是让被实例化的AnimationWindow对象调用hide方法</span></span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>, <span class="keyword">this</span>, &amp;AnimationWindow::hide);        <span class="comment">//定时器只触发一次(一次性信号)，2秒钟后隐藏分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showSequence</span><span class="params">(AnimationWindow::Type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QString name = type == Pair ? <span class="string">&quot;:/images/liandui.png&quot;</span> : <span class="string">&quot;:/images/shunzi.png&quot;</span>;      <span class="comment">//通过传进来的参数加载对应的图片</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(name);</span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">    QTimer::<span class="built_in">singleShot</span>(<span class="number">2000</span>,<span class="keyword">this</span>,&amp;AnimationWindow::hide);               <span class="comment">//2s后隐藏动画</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showJokerBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">8</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于8了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">8</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/joker_bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showBomb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_index = <span class="number">0</span>;</span><br><span class="line">    m_x = <span class="number">0</span>;</span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);                   <span class="comment">//创建定时器</span></span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_index++;                        <span class="comment">//每进来一次,index++</span></span><br><span class="line">        <span class="keyword">if</span>(m_index &gt; <span class="number">12</span>)&#123;</span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();                <span class="comment">//然后大于12了，就停止定时器</span></span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();         <span class="comment">//销毁回收定时器</span></span><br><span class="line">            m_index = <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">hide</span>();                       <span class="comment">//隐藏动画</span></span><br><span class="line">        &#125;</span><br><span class="line">        QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/bomb_%1.png&quot;</span>).<span class="built_in">arg</span>(m_index);           <span class="comment">//拼接图片路径</span></span><br><span class="line">        m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">60</span>);                                   <span class="comment">//指定间隔为60毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::showPlane</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_x = <span class="built_in">width</span>();                                  <span class="comment">//x轴就默认为动画窗口的宽度</span></span><br><span class="line">    m_image.<span class="built_in">load</span>(<span class="string">&quot;:/images/plane_1.png&quot;</span>);</span><br><span class="line">    <span class="built_in">setFixedHeight</span>(m_image.<span class="built_in">height</span>());               <span class="comment">//y轴就为图片的高度</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="built_in">width</span>() / <span class="number">5</span>;                        <span class="comment">//将宽度分为5份，得到5份取区间</span></span><br><span class="line">    QTimer* timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> dist = <span class="number">0</span>;                       <span class="comment">//飞机移动的距离</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> timers = <span class="number">0</span>;</span><br><span class="line">        dist += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist&gt;=step)&#123;                            <span class="comment">//如果满足，说明某一个区间已经走完了,就进入下一个区间</span></span><br><span class="line">            dist = <span class="number">0</span>;</span><br><span class="line">            timers++;</span><br><span class="line">            QString name = <span class="built_in">QString</span>(<span class="string">&quot;:/images/plane_%1.png&quot;</span>).<span class="built_in">arg</span>(timers%<span class="number">5</span>+<span class="number">1</span>);      <span class="comment">//图片在1到5之间切换</span></span><br><span class="line">            m_image.<span class="built_in">load</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_x &lt;= <span class="number">-110</span>)&#123;                <span class="comment">//当飞机飞出动画窗口，就结束</span></span><br><span class="line">            timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            timer-&gt;<span class="built_in">deleteLater</span>();</span><br><span class="line">            dist = timers = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">hide</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_x -= <span class="number">5</span>;              <span class="comment">//每次往左走5像素</span></span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    timer-&gt;<span class="built_in">start</span>(<span class="number">15</span>);             <span class="comment">//每个15毫秒执行一次，画一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimationWindow::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="comment">//因为对于飞机动画来说，m_x是移动的，而其它动画不移动，所以就把m_x初始化为0</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(m_x,<span class="number">0</span>,m_image.<span class="built_in">width</span>(),m_image.<span class="built_in">height</span>(),m_image);        <span class="comment">//加载的图片在窗口中的位置x和y；宽度和高度；QPixmap对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-闹钟窗口类CountDown"><a href="#3-闹钟窗口类CountDown" class="headerlink" title="3. 闹钟窗口类CountDown"></a>3. 闹钟窗口类CountDown</h1><p>闹钟窗口类主要是在主窗口为用户玩家创建了一个定时闹钟，轮到用户玩家出牌阶段，用户玩家只能在指定的时间内完成出牌或不出，当15秒过后，就默认玩家放弃出牌。当然，闹钟会起作用的前提是玩家必须出牌阶段，比如说当玩家抢完地主后或出牌后，没有前提玩家出牌，又该自己出时，这两种情况闹钟是不会出现的，其他情况，闹钟都会起作用。</p>
<p>闹钟窗口类：新建、c、c++、类名为<code>CountDown</code>，基类为QWidget</p>
<h2 id="3-1-CountDown类头文件"><a href="#3-1-CountDown类头文件" class="headerlink" title="3.1 CountDown类头文件"></a>3.1 CountDown类头文件</h2><p>闹钟窗口类CountDown的头文件就是定义了闹钟的图像对象和倒计时数字的图片对象，又定义显示闹钟函数来完成对应的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountDown</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CountDown</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showCountDown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopCountDown</span><span class="params">()</span></span>; <span class="comment">//终止倒计时的(当闹钟的秒数还没有读到0，但用户玩家已经将牌打出去了，这种情况也需要终止倒计时)</span></span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notMuchTime</span><span class="params">()</span></span>;                 <span class="comment">//当闹钟的秒数减到5时，向主界面发送提醒信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timeout</span><span class="params">()</span></span>;                     <span class="comment">//当闹钟的秒数减到0时，向主界面发送信号(切换当前玩家为下一个玩家)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPixmap m_clock;                <span class="comment">//加载闹钟图片对象</span></span><br><span class="line">    QPixmap m_number;               <span class="comment">//加载闹钟上的数字对象</span></span><br><span class="line">    QTimer* m_timer;</span><br><span class="line">    <span class="type">int</span>  m_count;                   <span class="comment">//倒计时的总时长</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-CountDown类函数实现"><a href="#3-2-CountDown类函数实现" class="headerlink" title="3.2 CountDown类函数实现"></a>3.2 CountDown类函数实现</h2><p>这部分就是对CountDown类头文件中定义的函数实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CountDown::<span class="built_in">CountDown</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">setFixedSize</span>(<span class="number">70</span>,<span class="number">70</span>);               <span class="comment">//给当前闹钟窗口显示固定大小(与图片大小一样)</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        m_count--;                         <span class="comment">//每次-1</span></span><br><span class="line">        <span class="keyword">if</span>(m_count&lt;<span class="number">10</span> &amp;&amp; m_count&gt;<span class="number">0</span>)&#123;       <span class="comment">//当count大于0小于10时，显示闹钟出来</span></span><br><span class="line">            m_clock.<span class="built_in">load</span>(<span class="string">&quot;:/images/clock.png&quot;</span>);</span><br><span class="line">            <span class="comment">//加载数字到闹钟上，数字的宽度是30像素，间隙是10个像素，从后从30*42像素缩放成20*30像素</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/number.png&quot;</span>).<span class="built_in">copy</span>(m_count*(<span class="number">30</span>+<span class="number">10</span>), <span class="number">0</span>, <span class="number">30</span>, <span class="number">42</span>).<span class="built_in">scaled</span>(<span class="number">20</span>,<span class="number">30</span>);   <span class="comment">//x轴上是从远到近</span></span><br><span class="line">            <span class="keyword">if</span>(m_count == <span class="number">5</span>)&#123;</span><br><span class="line">                emit <span class="built_in">notMuchTime</span>();         <span class="comment">//当秒数减为5时，发出信号(播放提示音乐)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">            m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">            emit <span class="built_in">timeout</span>();                     <span class="comment">//发出信号(切换当前玩家)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::showCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_count = <span class="number">15</span>;</span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">1000</span>);                <span class="comment">//启动定时器(每隔1s切换闹钟里面的数字)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::stopCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer-&gt;<span class="built_in">stop</span>();                    <span class="comment">//停掉定时器</span></span><br><span class="line">    m_clock = <span class="built_in">QPixmap</span>();                <span class="comment">//将闹钟设置成空值(不显示了)</span></span><br><span class="line">    m_number = <span class="built_in">QPixmap</span>();               <span class="comment">//将数字设置成空值(不显示了)</span></span><br><span class="line">    <span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDown::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);               <span class="comment">//处理ev参数没有使用的警告</span></span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(), m_clock);                                       <span class="comment">//绘制闹钟</span></span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="number">24</span>,<span class="number">24</span>,m_number.<span class="built_in">width</span>(),m_number.<span class="built_in">height</span>(),m_number);     <span class="comment">//绘制数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-背景音乐类BGMControl"><a href="#4-背景音乐类BGMControl" class="headerlink" title="4. 背景音乐类BGMControl"></a>4. 背景音乐类BGMControl</h1><p>背景音乐类是负责整个游戏的一个配音，有的是循环一直播放，有的是只播放一次。比如说游戏的背景音乐就是一直播放，我们出牌时，男生和女生的声音就是只一次播放，还有一写特殊牌型的声音也是只播放一次，如飞机、炸弹等。</p>
<p>背景音乐类：新建、c++、c++clase、类名为BGMControl、基类为QObject。</p>
<h2 id="4-1-BGMControl类头文件"><a href="#4-1-BGMControl类头文件" class="headerlink" title="4.1 BGMControl类头文件"></a>4.1 BGMControl类头文件</h2><p>背景音乐类的头文件定义了一个牌型的枚举类，它与文件中的json文件里面的配音目录顺序一致，这样方便在程序中调用。同时定义了在不同情况下，播放不同的音乐函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BGMControl</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">RoleSex</span>&#123;Man, Woman&#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardType</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 单张牌</span></span><br><span class="line">            Three,</span><br><span class="line">            Foue,</span><br><span class="line">            Five,</span><br><span class="line">            Six,</span><br><span class="line">            Seven,</span><br><span class="line">            Eight,</span><br><span class="line">            Nine,</span><br><span class="line">            Ten,</span><br><span class="line">            Jack,</span><br><span class="line">            Queen,</span><br><span class="line">            King,</span><br><span class="line">            Ace,</span><br><span class="line">            Tow,</span><br><span class="line">            SmallJoker,</span><br><span class="line">            BigJoker,</span><br><span class="line">            <span class="comment">// 两张牌</span></span><br><span class="line">            Three_Double,</span><br><span class="line">            Foue_Double,</span><br><span class="line">            Five_Double,</span><br><span class="line">            Six_Double,</span><br><span class="line">            Seven_Double,</span><br><span class="line">            Eight_Double,</span><br><span class="line">            Nine_Double,</span><br><span class="line">            Ten_Double,</span><br><span class="line">            Jack_Double,</span><br><span class="line">            Queen_Double,</span><br><span class="line">            King_Double,</span><br><span class="line">            Ace_Double ,</span><br><span class="line">            Tow_Double,</span><br><span class="line">            <span class="comment">// 三张牌</span></span><br><span class="line">            Three_Triple,</span><br><span class="line">            Foue_Triple,</span><br><span class="line">            Five_Triple,</span><br><span class="line">            Six_Triple,</span><br><span class="line">            Seven_Triple,</span><br><span class="line">            Eight_Triple,</span><br><span class="line">            Nine_Triple,</span><br><span class="line">            Ten_Triple,</span><br><span class="line">            Jack_Triple,</span><br><span class="line">            Queen_Triple,</span><br><span class="line">            King_Triple,</span><br><span class="line">            Ace_Triple,</span><br><span class="line">            Tow_Triple,</span><br><span class="line">            <span class="comment">// 其他组合</span></span><br><span class="line">            Plane,          <span class="comment">// 飞机</span></span><br><span class="line">            SequencePair,   <span class="comment">// 连对</span></span><br><span class="line">            ThreeBindOne,   <span class="comment">// 三带一</span></span><br><span class="line">            ThreeBindPair,  <span class="comment">// 三带一对</span></span><br><span class="line">            Sequence,       <span class="comment">// 顺子</span></span><br><span class="line">            FourBindTwo,    <span class="comment">// 四带二(单张)</span></span><br><span class="line">            FourBind2Pair,  <span class="comment">// 四带两对</span></span><br><span class="line">            Bomb,           <span class="comment">// 炸弹</span></span><br><span class="line">            JokerBomb,      <span class="comment">// 王炸</span></span><br><span class="line">            Pass1,          <span class="comment">// 过</span></span><br><span class="line">            Pass2,</span><br><span class="line">            Pass3,</span><br><span class="line">            Pass4,</span><br><span class="line">            MoreBiger1,     <span class="comment">// 大你</span></span><br><span class="line">            MoreBiger2,</span><br><span class="line">            Biggest,        <span class="comment">// 压死</span></span><br><span class="line">            <span class="comment">// 抢地主</span></span><br><span class="line">            NoOrder,        <span class="comment">// 不叫</span></span><br><span class="line">            NoRob,          <span class="comment">// 不抢</span></span><br><span class="line">            Order,          <span class="comment">// 叫地主</span></span><br><span class="line">            Rob1,           <span class="comment">// 抢地主</span></span><br><span class="line">            Rob2,</span><br><span class="line">            Last1,          <span class="comment">// 只剩1张牌</span></span><br><span class="line">            Last2           <span class="comment">// 只剩2张牌</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AssistMusic</span>       <span class="comment">//辅助音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispatch,   <span class="comment">// 发牌</span></span><br><span class="line">        SelectCard, <span class="comment">// 选牌</span></span><br><span class="line">        PlaneVoice, <span class="comment">// 飞机</span></span><br><span class="line">        BombVoice,  <span class="comment">// 炸弹</span></span><br><span class="line">        Alert,      <span class="comment">// 提醒</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BGMControl</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化播放列表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.背景音乐(播放和停止播放)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopBGM</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//2.播放玩家抢地址音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span>;</span><br><span class="line">    <span class="comment">//3.播放出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span>;           <span class="comment">//播放剩余1张或2张牌的音乐</span></span><br><span class="line">    <span class="comment">//4.播放不出牌的背景音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playPassMusic</span><span class="params">(RoleSex sex)</span></span>;</span><br><span class="line">    <span class="comment">//5.播放辅助音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playAssistMusic</span><span class="params">(AssistMusic type)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stopAssistMusic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//6.播放结尾音乐</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    QVector&lt;QMediaPlayer*&gt; m_players;</span><br><span class="line">    QVector&lt;QMediaPlaylist* &gt; m_lists;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-BGMControl函数实现"><a href="#4-2-BGMControl函数实现" class="headerlink" title="4.2 BGMControl函数实现"></a>4.2 BGMControl函数实现</h2><p>这部分就是实现了<code>BGMControl</code>类中定义的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BGMControl::<span class="built_in">BGMControl</span>(QObject *parent) : <span class="built_in">QObject</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//0.man 1.woman 2.bgm 3.辅助音乐 4.结束音乐</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QMediaPlayer* player = <span class="keyword">new</span> <span class="built_in">QMediaPlayer</span>(<span class="keyword">this</span>);             <span class="comment">//创建多媒体对象</span></span><br><span class="line">        QMediaPlaylist* list = <span class="keyword">new</span> <span class="built_in">QMediaPlaylist</span>(<span class="keyword">this</span>);           <span class="comment">//创建播放列表对象</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span> || i == <span class="number">4</span>)                 <span class="comment">//当是0、1或4时，音乐只播放一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::CurrentItemOnce);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)                   <span class="comment">//当是2时，就循环播放音乐</span></span><br><span class="line">        &#123;</span><br><span class="line">            list-&gt;<span class="built_in">setPlaybackMode</span>(QMediaPlaylist::Loop);</span><br><span class="line">        &#125;</span><br><span class="line">        player-&gt;<span class="built_in">setPlaylist</span>(list);</span><br><span class="line">        player-&gt;<span class="built_in">setVolume</span>(<span class="number">100</span>);                <span class="comment">//音量</span></span><br><span class="line">        m_players.<span class="built_in">push_back</span>(player);</span><br><span class="line">        m_lists.<span class="built_in">push_back</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">initPlayList</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化播放列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::initPlayList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringList list;</span><br><span class="line">    list &lt;&lt; <span class="string">&quot;Man&quot;</span> &lt;&lt; <span class="string">&quot;Woman&quot;</span> &lt;&lt; <span class="string">&quot;BGM&quot;</span> &lt;&lt; <span class="string">&quot;Other&quot;</span> &lt;&lt; <span class="string">&quot;Ending&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读json配置文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;:/conf/playList.json&quot;</span>)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QFile::ReadOnly);</span><br><span class="line">    QByteArray json = file.<span class="built_in">readAll</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="comment">// 解析从文件中读出的json数据</span></span><br><span class="line">    QJsonDocument doc = QJsonDocument::<span class="built_in">fromJson</span>(json);</span><br><span class="line">    QJsonObject obj = doc.<span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        QString prefix = list.<span class="built_in">at</span>(i);</span><br><span class="line">        QJsonArray array = obj.<span class="built_in">value</span>(prefix).<span class="built_in">toArray</span>();</span><br><span class="line">        <span class="comment">// 初始化多媒体播放列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;array.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[i]-&gt;<span class="built_in">addMedia</span>(<span class="built_in">QMediaContent</span>(<span class="built_in">QUrl</span>(array.<span class="built_in">at</span>(j).<span class="built_in">toString</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏背景音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::startBGM</span><span class="params">(<span class="type">int</span> volume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2是背景音乐，其音频对应的下标是2</span></span><br><span class="line">    m_lists[<span class="number">2</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">setVolume</span>(volume);</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">play</span>();                  <span class="comment">//通过对应的多媒体对象的play播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopBGM</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">2</span>]-&gt;<span class="built_in">stop</span>();                  <span class="comment">//停止播放背景音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 玩家下注了没有?</span></span><br><span class="line"><span class="comment">// 玩家的性别?</span></span><br><span class="line"><span class="comment">// 什么时候播放什么样的音频文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playerRobLordMusic</span><span class="params">(<span class="type">int</span> point, RoleSex sex, <span class="type">bool</span> isFirst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(isFirst &amp;&amp; point &gt; <span class="number">0</span>)                 <span class="comment">//如果是第一个叫地主，且下注分数大于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Order);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">0</span>)                      <span class="comment">//下注分数为0，即没有叫地主</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFirst)</span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoOrder);          <span class="comment">//如果是第一家就播放不叫音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(NoRob);            <span class="comment">//如果不是第一家就播放不抢音乐</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">2</span>)                        <span class="comment">//下注2分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(point == <span class="number">3</span>)                        <span class="comment">//下注3分</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[index]-&gt;<span class="built_in">setCurrentIndex</span>(Rob2);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();             <span class="comment">//通过多媒体对象播放音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出牌的音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playCardMusic</span><span class="params">(Cards cards, <span class="type">bool</span> isFirst, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 得到播放列表</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    QMediaPlaylist* list = m_lists[index];           <span class="comment">//通过男生或女生，得到相应的播放列表对象</span></span><br><span class="line"></span><br><span class="line">    Card::CardPoint pt = Card::CardPoint::Card_Begin;</span><br><span class="line">    <span class="comment">// 取出牌型 然后进行判断</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();</span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Single || type == PlayHand::Hand_Pair || type == PlayHand::Hand_Triple)</span><br><span class="line">    &#123;</span><br><span class="line">        pt = cards.<span class="built_in">takeRandomCard</span>().<span class="built_in">point</span>();    <span class="comment">//如果是单牌、双牌或三牌，取出其点数(取出随机一张牌即可)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 单牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Single:</span><br><span class="line">        number = pt - <span class="number">1</span>;           <span class="comment">//因为pt的枚举类是从begin开始的，需要减1才能和json文件里面的枚举类一一对应</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 对牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Pair:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span>;      <span class="comment">//对牌在单牌后面，所以需要跳过单牌个数15</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三张点数相同的牌</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple:</span><br><span class="line">        number = pt - <span class="number">1</span> + <span class="number">15</span> + <span class="number">13</span>;         <span class="comment">//跳过对牌个数13</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带一</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Single:</span><br><span class="line">        number = ThreeBindOne;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 三带二</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Triple_Pair:</span><br><span class="line">        number = ThreeBindPair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 飞机</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane:</span><br><span class="line">    <span class="comment">// 飞机带两个单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Single:</span><br><span class="line">    <span class="comment">// 飞机带两个对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Plane_Two_Pair:</span><br><span class="line">        number = Plane;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 连对</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Pair:</span><br><span class="line">        number = SequencePair;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 顺子</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Seq_Single:</span><br><span class="line">        number = Sequence;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb:</span><br><span class="line">        number = Bomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 王炸</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers:</span><br><span class="line">        number = JokerBomb;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 炸弹带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Pair:</span><br><span class="line">    <span class="comment">// 炸弹带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Two_Single:</span><br><span class="line">    <span class="comment">// 王炸带一对儿</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Pair:</span><br><span class="line">    <span class="comment">// 王炸带两单</span></span><br><span class="line">    <span class="keyword">case</span> PlayHand::Hand_Bomb_Jokers_Two_Single:</span><br><span class="line">        number = FourBindTwo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isFirst &amp;&amp; (number &gt;= Plane &amp;&amp; number &lt;= FourBindTwo))</span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(MoreBiger1 + QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    <span class="keyword">if</span>(number == Bomb || number == JokerBomb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(BombVoice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number == Plane)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">playAssistMusic</span>(PlaneVoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playLastMusic</span><span class="params">(CardType type, RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="keyword">if</span>(m_players[index]-&gt;<span class="built_in">state</span>() == QMediaPlayer::StoppedState)     <span class="comment">//如果当前对应的多媒体播放是空闲状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">        m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QTimer::<span class="built_in">singleShot</span>(<span class="number">1500</span>, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">            list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">            m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playPassMusic</span><span class="params">(RoleSex sex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 玩家的性别</span></span><br><span class="line">    <span class="type">int</span> index = sex == Man ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[index];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">4</span>);    <span class="comment">//随机生成一个数字，0到3</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(Pass1 + random);                  <span class="comment">//随机播放不要音乐</span></span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[index]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playAssistMusic</span><span class="params">(AssistMusic type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QMediaPlaylist::PlaybackMode mode;                <span class="comment">//定义一个播放模式</span></span><br><span class="line">    <span class="keyword">if</span>(type == Dispatch)                              <span class="comment">//如果是发牌状态，就循环播放音乐</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环播放</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemInLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                       <span class="comment">//其它情况，只播放一次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单曲播放一次</span></span><br><span class="line">        mode = QMediaPlaylist::CurrentItemOnce;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 找到播放列表</span></span><br><span class="line">    QMediaPlaylist* list = m_lists[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 3. 找到要播放的音乐</span></span><br><span class="line">    list-&gt;<span class="built_in">setCurrentIndex</span>(type);</span><br><span class="line">    list-&gt;<span class="built_in">setPlaybackMode</span>(mode);</span><br><span class="line">    <span class="comment">// 4. 播放音乐</span></span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::stopAssistMusic</span><span class="params">()</span>           <span class="comment">//停止辅助音乐播放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_players[<span class="number">3</span>]-&gt;<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后输或赢播放音乐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BGMControl::playEndingMusic</span><span class="params">(<span class="type">bool</span> isWin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isWin)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_lists[<span class="number">4</span>]-&gt;<span class="built_in">setCurrentIndex</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_players[<span class="number">4</span>]-&gt;<span class="built_in">play</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="5-游戏主窗口类GamePanel"><a href="#5-游戏主窗口类GamePanel" class="headerlink" title="5. 游戏主窗口类GamePanel"></a>5. 游戏主窗口类GamePanel</h1><p>游戏主窗口类是游戏的展示界面，玩家玩游戏的整个过程都是在这个窗口中显示的。</p>
<h2 id="5-1-GamePanel类头文件"><a href="#5-1-GamePanel类头文件" class="headerlink" title="5.1 GamePanel类头文件"></a>5.1 GamePanel类头文件</h2><p>游戏窗口类的头文件需要定义很多初始化的函数，同时也需要接收很多发送过来的信号，然后通过相应的函数(槽函数)来实现对应的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePanel</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GamePanel</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">GamePanel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">AnimationType</span>&#123;ShunZi, LianDui, Plane, JokerBomb, Bomb, Bet&#125;;             <span class="comment">//效果动画类要显示的一些动画</span></span><br><span class="line">    <span class="comment">//初始化游戏控制类信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameControlInit</span><span class="params">()</span></span>;       <span class="comment">//该函数也负责信号槽的一些连接</span></span><br><span class="line">    <span class="comment">//更新分数面板的分数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerScore</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//切割并存储图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCardMap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//裁剪图片</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cropImage</span><span class="params">(QPixmap&amp; pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span></span>;       <span class="comment">//参数：裁剪图片对象，x位置，y位置，卡牌对象(需要它的花色和点数)</span></span><br><span class="line">    <span class="comment">//初始化游戏按钮组</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initButtonsGroup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化玩家在窗口中的上下文环境(每个玩家的位置信息)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initPlayerContext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化游戏场景</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initGameScene</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理游戏的状态</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span></span>;     <span class="comment">//参数枚举类型游戏状态，有发牌、叫地主和出牌</span></span><br><span class="line">    <span class="comment">//发牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">startDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cardMoveStep</span><span class="params">(Player* player, <span class="type">int</span> curPos)</span></span>;</span><br><span class="line">    <span class="comment">//处理分发得到的扑克牌(发牌时卡牌区域更新)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disposeCard</span><span class="params">(Player* player, <span class="type">const</span> Cards&amp; cards)</span></span>;        <span class="comment">//参数：处理的牌属于哪个玩家，要处理的牌(一张或多张)</span></span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示(把玩家得到的牌更新到该显示的位置上,和打出的牌更新到出牌区域)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updatePlayerCards</span><span class="params">(Player* player)</span></span>;          <span class="comment">//更新的是哪个玩家的扑克牌窗口</span></span><br><span class="line">    <span class="comment">//加载玩家的头像</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定时器的处理动作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDispatchCard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家状态的变化(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onPlayerStatusChanged</span><span class="params">(Player* player, GameControl::PlayerStatus status)</span></span>;</span><br><span class="line">    <span class="comment">//处理玩家抢地主情况，再在主窗口显示(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onGrabLordBet</span><span class="params">(Player* player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span></span>;     <span class="comment">//参数：具体哪个玩家，下注分数，是否是第一个叫地主的玩家</span></span><br><span class="line">    <span class="comment">//处理玩家的出牌显示</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onDisposePlayHand</span><span class="params">(Player* player, Cards&amp; cards)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家鼠标选牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span>;</span><br><span class="line">    <span class="comment">//处理用户玩家出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPlayHand</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理用户放弃出牌(槽函数)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onUserPass</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示特效动画</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showAnimation</span><span class="params">(AnimationType type, <span class="type">int</span> bet=<span class="number">0</span>)</span></span>;  <span class="comment">//因为室友特效动画都是该函数显示，所以直接传入动画枚举类，当是抢地主分数的时候，会用到参2</span></span><br><span class="line">    <span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hidePlayerDropCards</span><span class="params">(Player* player)</span></span>;</span><br><span class="line">    <span class="comment">// 显示玩家的最终得分(结束面板设置)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showEndingScorePanel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//初始化闹钟倒计时</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initCountDown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 重写父类的虚函数---事件处理函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent* ev)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent* ev)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">CardAlign</span>&#123;Horizontal, Vertical&#125;;             <span class="comment">//对齐方式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">PlayerContext</span>&#123;                   <span class="comment">//每个玩家有一个这样的结构体,是存放玩家对应的位置信息</span></span><br><span class="line">        <span class="comment">//1.玩家扑克牌显示的区域</span></span><br><span class="line">        QRect cardRect;</span><br><span class="line">        <span class="comment">//2.出牌的区域</span></span><br><span class="line">        QRect playHandRect;</span><br><span class="line">        <span class="comment">//3.扑克牌的对齐方式(水平 or 垂直)</span></span><br><span class="line">        CardAlign align;</span><br><span class="line">        <span class="comment">//4.扑克牌显示正面还是背面</span></span><br><span class="line">        <span class="type">bool</span> isFrontSide;</span><br><span class="line">        <span class="comment">//5.游戏过程中的提示信息，比如：不出</span></span><br><span class="line">        QLabel* info;</span><br><span class="line">        <span class="comment">//6.玩家的头像</span></span><br><span class="line">        QLabel* roleImg;</span><br><span class="line">        <span class="comment">//7.玩家刚打出的牌</span></span><br><span class="line">        Cards lastCards;</span><br><span class="line">    &#125;;</span><br><span class="line">    Ui::GamePanel *ui;</span><br><span class="line">    QPixmap m_bkImage;                     <span class="comment">//背景图片的加载对象</span></span><br><span class="line">    GameControl* m_gameCtl;                <span class="comment">//游戏控制类对象</span></span><br><span class="line">    QVector&lt;Player*&gt; m_playerList;         <span class="comment">//存放三个玩家对象的实例</span></span><br><span class="line">    QMap&lt;Card, CardPanel*&gt;m_cardMap;       <span class="comment">//保存卡牌数据和卡牌窗口对象的容器</span></span><br><span class="line">    QSize m_cardSize;                      <span class="comment">//卡牌大小(宽和高)</span></span><br><span class="line">    QPixmap m_cardBackImg;                 <span class="comment">//卡牌背景图加载对象</span></span><br><span class="line">    QMap&lt;Player*, PlayerContext&gt; m_contextMap;      <span class="comment">//将玩家与其对应的位置结构体存到map</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_baseCard;              <span class="comment">//刚开始，发牌区的扑克牌</span></span><br><span class="line">    CardPanel* m_moveCard;              <span class="comment">//移动中的扑克牌</span></span><br><span class="line">    QVector&lt;CardPanel*&gt;m_last3Card;     <span class="comment">//最后三张底牌</span></span><br><span class="line"></span><br><span class="line">    QPoint m_baseCardPos;               <span class="comment">//起始时，牌的初始位置(中心偏上一点)</span></span><br><span class="line">    GameControl::GameStatus m_gameStatus;           <span class="comment">//存放游戏状态</span></span><br><span class="line">    QTimer* m_timer;                    <span class="comment">//定时器</span></span><br><span class="line"></span><br><span class="line">    AnimationWindow* m_animation;            <span class="comment">//动画效果类对象</span></span><br><span class="line"></span><br><span class="line">    CardPanel* m_curSelCard;       <span class="comment">//鼠标选择的卡牌窗口对象(只限自己手牌的，因为点击其它机器人玩家的牌，在onCardSelected()函数中已经被排除了)</span></span><br><span class="line">    QSet&lt;CardPanel*&gt; m_selectCards;       <span class="comment">//保存用户鼠标选择的卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//下面两个在updatePlayerCards()里面初始化的</span></span><br><span class="line">    QRect m_cardsRect;                          <span class="comment">//存储用户玩家剩余的牌显示区域</span></span><br><span class="line">    QHash&lt;CardPanel*,QRect&gt; m_userCards;         <span class="comment">//记录用户玩家手中的牌，以及每张牌在窗口中的位置</span></span><br><span class="line"></span><br><span class="line">    CountDown* m_countDown;                <span class="comment">//闹钟类对象指针</span></span><br><span class="line"></span><br><span class="line">    BGMControl* m_bgm;                     <span class="comment">//BGM音乐类对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-GamePanel类函数实现"><a href="#5-2-GamePanel类函数实现" class="headerlink" title="5.2 GamePanel类函数实现"></a>5.2 GamePanel类函数实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GamePanel::<span class="built_in">GamePanel</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::GamePanel)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 背景图</span></span><br><span class="line">    <span class="type">int</span> num = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">10</span>);          <span class="comment">//生成0到9随机数</span></span><br><span class="line">    QString path = <span class="built_in">QString</span>(<span class="string">&quot;:/images/background-%1.png&quot;</span>).<span class="built_in">arg</span>(num+<span class="number">1</span>);     <span class="comment">//拼接背景图路径</span></span><br><span class="line">    m_bkImage.<span class="built_in">load</span>(path);   <span class="comment">//随机加载一张背景图(刚开始时)，通过事件处理器函数painEvent就能将背景图画到窗口上了，当窗口初始化好后，painEvent会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.窗口的标题和大小(固定)</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;欢乐斗地主&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setFixedSize</span>(<span class="number">1000</span>, <span class="number">650</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实例化游戏控制类对象</span></span><br><span class="line">    <span class="built_in">gameControlInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 玩家得分(更新)</span></span><br><span class="line">    <span class="built_in">updatePlayerScore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 切割游戏图片</span></span><br><span class="line">    <span class="built_in">initCardMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 初始化游戏中的按钮组</span></span><br><span class="line">    <span class="built_in">initButtonsGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 初始化玩家在窗口中的上下文环境</span></span><br><span class="line">    <span class="built_in">initPlayerContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 扑克牌场景初始化</span></span><br><span class="line">    <span class="built_in">initGameScene</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 倒计时窗口初始化</span></span><br><span class="line">    <span class="built_in">initCountDown</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器实例化</span></span><br><span class="line">    m_timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">connect</span>(m_timer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;GamePanel::onDispatchCard);     <span class="comment">//每触发一次定时器，就会调用槽函数，发牌</span></span><br><span class="line"></span><br><span class="line">    m_animation = <span class="keyword">new</span> <span class="built_in">AnimationWindow</span>(<span class="keyword">this</span>);          <span class="comment">//创建一个动画效果类，指定了父对象，它就显示在父对象窗口上面，而且没有边框</span></span><br><span class="line">    m_bgm = <span class="keyword">new</span> <span class="built_in">BGMControl</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GamePanel::~<span class="built_in">GamePanel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameControlInit</span><span class="params">()</span>       <span class="comment">//实例化游戏控制类对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_gameCtl = <span class="keyword">new</span> <span class="built_in">GameControl</span>(<span class="keyword">this</span>);       <span class="comment">//指定父对象，窗口析构的时候，就会先自动析构m_gameCtl了</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">playerInit</span>();                 <span class="comment">//三个玩家对象被创建出来了</span></span><br><span class="line">    <span class="comment">//得到三个玩家的实例对象</span></span><br><span class="line">    Robot* leftRobot = m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>();</span><br><span class="line">    Robot* rightRobot = m_gameCtl-&gt;<span class="built_in">getRightRobot</span>();</span><br><span class="line">    UserPlayer* user = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();</span><br><span class="line">    m_playerList &lt;&lt; leftRobot &lt;&lt; rightRobot &lt;&lt; user;        <span class="comment">//存储顺序：左侧机器人，右侧机器人，用户玩家</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家状态变化)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::playerStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::onPlayerStatusChanged);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(抢地主的情况)，主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyGrabLordBet, <span class="keyword">this</span>, &amp;GamePanel::onGrabLordBet);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(游戏状态变化),主窗口接收并处理相应的槽函数</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::gameStatusChanged, <span class="keyword">this</span>, &amp;GamePanel::gameStatusPrecess);</span><br><span class="line">    <span class="comment">//GameControl类发出的一个信号(玩家出牌了),主窗口接收并处理相应的槽函数(处理一些动画效果，更新玩家的牌，并将出的牌显示在出牌区域)</span></span><br><span class="line">    <span class="built_in">connect</span>(m_gameCtl, &amp;GameControl::notifyPlayHand, <span class="keyword">this</span>, &amp;GamePanel::onDisposePlayHand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不管是哪个玩家得到牌后都会发出一个信号，主窗口接收该信号</span></span><br><span class="line">    <span class="built_in">connect</span>(leftRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(rightRobot, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">    <span class="built_in">connect</span>(user, &amp;Player::notifyPickCards, <span class="keyword">this</span>, &amp;GamePanel::disposeCard);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;scorePanel-&gt;<span class="built_in">setScores</span>(                    <span class="comment">//setScores函数负责将传入的得分显示在窗口上</span></span><br><span class="line">                m_playerList[<span class="number">0</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">1</span>]-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                m_playerList[<span class="number">2</span>]-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCardMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.加载大图</span></span><br><span class="line">    <span class="function">QPixmap <span class="title">pixmap</span><span class="params">(<span class="string">&quot;:/images/card.png&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//2.计算每张图片的大小</span></span><br><span class="line">    m_cardSize.<span class="built_in">setWidth</span>(pixmap.<span class="built_in">width</span>()/<span class="number">13</span>);</span><br><span class="line">    m_cardSize.<span class="built_in">setHeight</span>(pixmap.<span class="built_in">height</span>()/<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//3.背面图加载(裁剪)，需要提供背景图左上角的点，copy(x轴，y轴，要裁剪的宽度，要裁剪的高度)</span></span><br><span class="line">    m_cardBackImg = pixmap.<span class="built_in">copy</span>(<span class="number">2</span>*m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">    <span class="comment">//正常花色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, suit=Card::Suit_Begin+<span class="number">1</span>; suit&lt;Card::Suit_End; suit++,i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,pt=Card::Card_Begin+<span class="number">1</span>; pt&lt;Card::Card_SJ; pt++,j++)&#123;</span><br><span class="line">            <span class="function">Card <span class="title">card</span><span class="params">((Card::CardPoint)pt, (Card::CardSuit)suit)</span></span>;</span><br><span class="line">            <span class="comment">//裁剪图片(参数：大图对象，裁剪卡牌的x轴，裁剪卡牌的y轴，对应的单张卡牌对象(记录的是对应的花色和点数))</span></span><br><span class="line">            <span class="built_in">cropImage</span>(pixmap, j*m_cardSize.<span class="built_in">width</span>(), i*m_cardSize.<span class="built_in">height</span>(), card);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小王</span></span><br><span class="line">    Card c;</span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_SJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, <span class="number">0</span>, <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">    <span class="comment">//大王</span></span><br><span class="line">    c.<span class="built_in">setPoint</span>(Card::Card_BJ);</span><br><span class="line">    c.<span class="built_in">setSuit</span>(Card::Suit_Begin);</span><br><span class="line">    <span class="built_in">cropImage</span>(pixmap, m_cardSize.<span class="built_in">width</span>(), <span class="number">4</span>*m_cardSize.<span class="built_in">height</span>(), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cropImage</span><span class="params">(QPixmap &amp;pix, <span class="type">int</span> x, <span class="type">int</span> y, Card&amp; c)</span>              <span class="comment">//裁剪图片</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QPixmap sub = pix.<span class="built_in">copy</span>(x, y, m_cardSize.<span class="built_in">width</span>(), m_cardSize.<span class="built_in">height</span>());       <span class="comment">//得到一张扑克牌正面</span></span><br><span class="line">    CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);           <span class="comment">//创建一张卡牌窗口对象</span></span><br><span class="line">    panel-&gt;<span class="built_in">setImage</span>(sub, m_cardBackImg);              <span class="comment">//参数：正面图片对象，背面图片对象 -----&gt;图片显示的已经是对应的花色和点数了</span></span><br><span class="line">    panel-&gt;<span class="built_in">setCard</span>(c);                                <span class="comment">//设置花色和点数   -----&gt;这相当于是记录该图片的花色和点数</span></span><br><span class="line">    panel-&gt;<span class="built_in">hide</span>();                                    <span class="comment">//隐藏</span></span><br><span class="line">    m_cardMap.<span class="built_in">insert</span>(c,panel);                        <span class="comment">//裁剪成功的卡牌存入容器，方便后期管理和处理</span></span><br><span class="line">    <span class="comment">//接收CardPanel类发出的鼠标选择信号---&gt;每张牌的窗口对象只要满足条件，都可以发出信号</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;CardPanel::cardSelected, <span class="keyword">this</span>, &amp;GamePanel::onCardSelected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initButtonsGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">initButtons</span>();                                <span class="comment">//所有的按钮初始化完成</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Start);              <span class="comment">//开始时，显示的是开始游戏页面</span></span><br><span class="line">    <span class="comment">//处理各个按钮发出的信号</span></span><br><span class="line">    <span class="comment">//初始页面的开始按钮，当发出startGame信号，就说明开始游戏的按钮被按下了</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::startGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="comment">//界面的初始化</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">clearPlayerScore</span>();          <span class="comment">//将所有玩家的得分清0(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();                    <span class="comment">//更新所有玩家的得分(在构造函数时调用过了，可写可不写)</span></span><br><span class="line">        <span class="comment">//修改游戏状态 ---&gt; 发牌</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);        <span class="comment">//基于这个参数，里面是通过switcha函数来执行不同游戏状态下的函数</span></span><br><span class="line">        <span class="comment">//播放背景音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);                 <span class="comment">//指定音量为80</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::playHand, <span class="keyword">this</span>, &amp;GamePanel::onUserPlayHand); <span class="comment">//当点击了出牌按钮，会发出playHand信号</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::pass, <span class="keyword">this</span>, &amp;GamePanel::onUserPass);</span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;btnGroup, &amp;ButtonGroup::betPoint, <span class="keyword">this</span>, [=](<span class="type">int</span> bet)&#123;        <span class="comment">//叫地主几分按钮</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">grabLordBet</span>(bet);</span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//按完下注分数按钮后，就执行选择空页面，这样窗口的所有按钮都被隐藏了</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initPlayerContext</span><span class="params">()</span>              <span class="comment">//为每个玩家设置对应的位置信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.设置玩家扑克牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect cardsRect[]=&#123;</span><br><span class="line">        <span class="comment">//x,y,width,heught</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">90</span>,<span class="number">130</span>,<span class="number">100</span>,<span class="built_in">height</span>()<span class="number">-200</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-190</span>, <span class="number">130</span>, <span class="number">100</span>, <span class="built_in">height</span>()<span class="number">-200</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">250</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-120</span>, <span class="built_in">width</span>()<span class="number">-500</span>,<span class="number">100</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//2.玩家出牌的区域</span></span><br><span class="line">    <span class="type">const</span> QRect playHandRect[]=&#123;</span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">260</span>,<span class="number">150</span>,<span class="number">100</span>,<span class="number">100</span>),                           <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="built_in">rect</span>().<span class="built_in">right</span>()<span class="number">-360</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QRect</span>(<span class="number">150</span>, <span class="built_in">rect</span>().<span class="built_in">bottom</span>()<span class="number">-290</span>, <span class="built_in">width</span>()<span class="number">-300</span>,<span class="number">105</span>)          <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//3.玩家头像显示的位置</span></span><br><span class="line">    <span class="type">const</span> QPoint roleImgPos[]=&#123;</span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">0</span>].<span class="built_in">left</span>()<span class="number">-80</span>,cardsRect[<span class="number">0</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),         <span class="comment">//左侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">1</span>].<span class="built_in">right</span>()+<span class="number">10</span>,cardsRect[<span class="number">1</span>].<span class="built_in">height</span>()/<span class="number">2</span>+<span class="number">20</span>),        <span class="comment">//右侧机器人</span></span><br><span class="line">        <span class="built_in">QPoint</span>(cardsRect[<span class="number">2</span>].<span class="built_in">right</span>()<span class="number">-10</span>,cardsRect[<span class="number">2</span>].<span class="built_in">top</span>()<span class="number">-10</span>)              <span class="comment">//当前玩家</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());     <span class="comment">//得到m_playerList存放用户玩家的下标索引(是2,但是不想把代码写死，所以通过这行代码获取)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>();i++)&#123;                          <span class="comment">//变量三个玩家</span></span><br><span class="line">        PlayerContext context;                                <span class="comment">//为每个玩家创建各自的PlayerContext位置结构体</span></span><br><span class="line">        context.align = i==index ? Horizontal:Vertical;             <span class="comment">//对齐方式：机器人玩家和用户玩家是不一样的</span></span><br><span class="line">        context.isFrontSide = i==index ? <span class="literal">true</span>:<span class="literal">false</span>;                  <span class="comment">//扑克牌展示正面还是背面，需要判定，i=index，说明是用户玩家</span></span><br><span class="line">        context.cardRect = cardsRect[i];                              <span class="comment">//卡牌区域(因为m_playerList和cardsRect的顺序是一样的，所以直接赋值即可)</span></span><br><span class="line">        context.playHandRect = playHandRect[i];                       <span class="comment">//出牌区域</span></span><br><span class="line">        <span class="comment">//提示信息(每个玩家的提示信息位置)</span></span><br><span class="line">        context.info = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个标签</span></span><br><span class="line">        context.info-&gt;<span class="built_in">resize</span>(<span class="number">160</span>, <span class="number">98</span>);                  <span class="comment">//指定标签大小</span></span><br><span class="line">        context.info-&gt;<span class="built_in">hide</span>();                           <span class="comment">//初始是隐藏的</span></span><br><span class="line">        <span class="comment">//将提示信息显示到出牌区域的中心位置</span></span><br><span class="line">        QRect rect = playHandRect[i];                   <span class="comment">//每个玩家的出牌区域</span></span><br><span class="line">        <span class="function">QPoint <span class="title">pt</span><span class="params">(rect.left()+(rect.width()-context.info-&gt;width())/<span class="number">2</span>, rect.top()+(rect.height()-context.info-&gt;height())/<span class="number">2</span>)</span></span>;   <span class="comment">//获取出牌区域的中心位置，需要(出牌区域框架-提示信息框架)/2</span></span><br><span class="line">        context.info-&gt;<span class="built_in">move</span>(pt);          <span class="comment">//将提示信息移动到pt位置</span></span><br><span class="line">        <span class="comment">//玩家头像</span></span><br><span class="line">        context.roleImg = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);         <span class="comment">//创建一个放头像的标签</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">resize</span>(<span class="number">84</span>, <span class="number">120</span>);           <span class="comment">//固定大小</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">hide</span>();                    <span class="comment">//隐藏</span></span><br><span class="line">        context.roleImg-&gt;<span class="built_in">move</span>(roleImgPos[i]);       <span class="comment">//将头像标签移动到指定位置</span></span><br><span class="line">        m_contextMap.<span class="built_in">insert</span>(m_playerList.<span class="built_in">at</span>(i), context);   <span class="comment">//key存玩家对象，value存对应的位置结构体context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initGameScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//下面三部分，每一部分都对应一张或多张扑克牌，每张扑克牌都是一个卡牌窗口，所以需要创建卡牌窗口对象</span></span><br><span class="line">    <span class="comment">//1.发牌区的扑克牌</span></span><br><span class="line">    m_baseCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_baseCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 2. 发牌过程中移动的扑克牌</span></span><br><span class="line">    m_moveCard = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">    m_moveCard-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">    <span class="comment">// 3. 最后的三张底牌(用于窗口的显示)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        CardPanel* panel = <span class="keyword">new</span> <span class="built_in">CardPanel</span>(<span class="keyword">this</span>);</span><br><span class="line">        panel-&gt;<span class="built_in">setImage</span>(m_cardBackImg, m_cardBackImg);      <span class="comment">//两面都显示背面即可</span></span><br><span class="line">        m_last3Card.<span class="built_in">push_back</span>(panel);</span><br><span class="line">        panel-&gt;<span class="built_in">hide</span>();              <span class="comment">//初始先隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发牌区和移动过程扑克牌的位置(同一个)</span></span><br><span class="line">    m_baseCardPos = <span class="built_in">QPoint</span>((<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>()) / <span class="number">2</span>, <span class="built_in">height</span>() / <span class="number">2</span> - <span class="number">100</span>);     <span class="comment">//中心位置偏上一点</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">move</span>(m_baseCardPos);         <span class="comment">//设置发牌区的扑克牌位置</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(m_baseCardPos);          <span class="comment">//设置移动过程中扑克牌的位置</span></span><br><span class="line">    <span class="comment">//底牌位置(三种牌的x轴不一样，y轴一样)</span></span><br><span class="line">    <span class="type">int</span> base = (<span class="built_in">width</span>() - <span class="number">3</span> * m_cardSize.<span class="built_in">width</span>() - <span class="number">2</span> * <span class="number">10</span>) / <span class="number">2</span>;   <span class="comment">//width()是当前窗口的总宽度，三张牌有2个空隙(2*10)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_last3Card[i]-&gt;<span class="built_in">move</span>(base + (m_cardSize.<span class="built_in">width</span>() + <span class="number">10</span>) * i, <span class="number">20</span>);      <span class="comment">//分别设置三张底牌的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::gameStatusPrecess</span><span class="params">(GameControl::GameStatus status)</span>            <span class="comment">//处理游戏的状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录游戏状态</span></span><br><span class="line">    m_gameStatus = status;</span><br><span class="line">    <span class="comment">//处理游戏状态</span></span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::DispatchCard:        <span class="comment">//开始发牌状态</span></span><br><span class="line">        <span class="built_in">startDispatchCard</span>();               <span class="comment">//调用发牌函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::CallingLord:         <span class="comment">//叫地主状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//取出底牌数据</span></span><br><span class="line">        CardList last3Card = m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">toCardList</span>();     <span class="comment">//将存放三张底牌的set容器转为了QVector容器</span></span><br><span class="line">        <span class="comment">//给底牌窗口设置图片</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;last3Card.<span class="built_in">size</span>(); i++)&#123;        <span class="comment">//遍历三张底牌</span></span><br><span class="line">            QPixmap front = m_cardMap[last3Card.<span class="built_in">at</span>(i)]-&gt;<span class="built_in">getImage</span>();         <span class="comment">//获取每张牌它的一个图像</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">setImage</span>(front,m_cardBackImg);            <span class="comment">//设置该卡牌的正面图片和反面图片</span></span><br><span class="line">            m_last3Card[i]-&gt;<span class="built_in">hide</span>();                                   <span class="comment">//先是隐藏的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始叫地主</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">startLordCard</span>();      <span class="comment">//gamecontrol的一个函数，里面会发出一个信号，主窗口再接收处理槽函数onPlayerStatusChanged</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> GameControl::PlayingHand:           <span class="comment">//出牌状态(抢完地主)</span></span><br><span class="line">        <span class="comment">//隐藏发牌区的底牌和移动的牌</span></span><br><span class="line">        m_baseCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();</span><br><span class="line">        <span class="comment">//显示留给地主的三张底牌(顶部)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">show</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            PlayerContext &amp;context = m_contextMap[m_playerList.<span class="built_in">at</span>(i)];       <span class="comment">//获取每个玩家的位置结构体</span></span><br><span class="line">            context.info-&gt;<span class="built_in">hide</span>();                       <span class="comment">//隐藏各个玩家抢地主过程中的提示信息</span></span><br><span class="line">            <span class="comment">//显示各个玩家的头像</span></span><br><span class="line">            Player* player = m_playerList.<span class="built_in">at</span>(i);</span><br><span class="line">            QPixmap pixmap = <span class="built_in">loadRoleImage</span>(player-&gt;<span class="built_in">getSex</span>(),player-&gt;<span class="built_in">getDirection</span>(), player-&gt;<span class="built_in">getRole</span>());   <span class="comment">//得到对应玩家的头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">setPixmap</span>(pixmap);     <span class="comment">//设置头像</span></span><br><span class="line">            context.roleImg-&gt;<span class="built_in">show</span>();                <span class="comment">//显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::startDispatchCard</span><span class="params">()</span>            <span class="comment">//发牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重置每张卡牌的属性(不是所有属性)   QMap&lt;Card, CardPanel*&gt;m_cardMap;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_cardMap.<span class="built_in">begin</span>(); it!=m_cardMap.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);     <span class="comment">//设置非选中状态</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);     <span class="comment">//显示正面图片</span></span><br><span class="line">        it.<span class="built_in">value</span>()-&gt;<span class="built_in">hide</span>();                  <span class="comment">//窗口隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//隐藏三张底牌</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_last3Card.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        m_last3Card.<span class="built_in">at</span>(i)-&gt;<span class="built_in">hide</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置玩家的窗口上下文信息(位置)</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>());        <span class="comment">//传入用户玩家对象，得到它在m_playerList的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m_playerList.<span class="built_in">size</span>(); i++)&#123;                            <span class="comment">//对玩家容器进行遍历</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].lastCards.<span class="built_in">clear</span>();              <span class="comment">//玩家上一次打出的牌进行清空</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].info-&gt;<span class="built_in">hide</span>();                   <span class="comment">//隐藏游戏过程中的提示信息</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].roleImg-&gt;<span class="built_in">hide</span>();                <span class="comment">//玩家的头像隐藏</span></span><br><span class="line">        m_contextMap[m_playerList.<span class="built_in">at</span>(i)].isFrontSide = i==index ? <span class="literal">true</span> : <span class="literal">false</span>;   <span class="comment">//显示正面还是背面(用户玩家显示正面，机器人玩家显示背面)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重置所有玩家的卡牌数据</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">resetCardData</span>();        <span class="comment">//该函数里面是做了：洗牌、清空三个玩家的手牌、将出牌玩家对象指向空和出的牌清空</span></span><br><span class="line">    <span class="comment">//显示底牌</span></span><br><span class="line">    m_baseCard-&gt;<span class="built_in">show</span>();            <span class="comment">//正中间的扑克牌，刚开是背面时(显示出来)</span></span><br><span class="line">    <span class="comment">//隐藏按钮面板</span></span><br><span class="line">    ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);        <span class="comment">//传入的是空窗口</span></span><br><span class="line">    <span class="comment">//启动定时器</span></span><br><span class="line">    m_timer-&gt;<span class="built_in">start</span>(<span class="number">10</span>);               <span class="comment">//每隔10毫秒，定时器就触发一次</span></span><br><span class="line">    <span class="comment">//播放背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Dispatch);             <span class="comment">//播放发牌的音乐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::cardMoveStep</span><span class="params">(Player *player, <span class="type">int</span> curPos)</span>     <span class="comment">//参数：具体是哪个玩家，移动步长的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//得到每个玩家的扑克牌展示区域</span></span><br><span class="line">    QRect cardRect = m_contextMap[player].cardRect;</span><br><span class="line">    <span class="comment">//每个玩家的单位步长</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> unit[] = &#123;(m_baseCardPos.<span class="built_in">x</span>() - cardRect.<span class="built_in">right</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">left</span>() - m_baseCardPos.<span class="built_in">x</span>())/<span class="number">100</span>, (cardRect.<span class="built_in">top</span>() - m_baseCardPos.<span class="built_in">y</span>())/<span class="number">100</span> &#125;;   <span class="comment">//左侧玩家:(发牌区域x坐标-左侧玩家区域右变x轴)/长度；右侧玩家</span></span><br><span class="line">    <span class="comment">//每次窗口移动的时候，每个玩家对应的移动牌的实时坐标位置</span></span><br><span class="line">    <span class="type">const</span> QPoint pos[]=&#123; <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() - curPos * unit[<span class="number">0</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>() + curPos * unit[<span class="number">1</span>], m_baseCardPos.<span class="built_in">y</span>()), <span class="built_in">QPoint</span>(m_baseCardPos.<span class="built_in">x</span>(), m_baseCardPos.<span class="built_in">y</span>() + curPos * unit[<span class="number">2</span>])&#125;;  <span class="comment">//左侧机器人x轴坐标越来越小；右侧机器人x轴坐标越来越大</span></span><br><span class="line">    <span class="comment">//移动扑克牌窗口</span></span><br><span class="line">    <span class="type">int</span> index = m_playerList.<span class="built_in">indexOf</span>(player);          <span class="comment">//得到对应玩家的下标</span></span><br><span class="line">    m_moveCard-&gt;<span class="built_in">move</span>(pos[index]);                      <span class="comment">//卡牌移动到对应玩家 移动路径上 的某一点</span></span><br><span class="line">    <span class="comment">//临界状态处理</span></span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">0</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">show</span>();      <span class="comment">//说明该牌才刚开始移动，想要展示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curPos == <span class="number">100</span>)&#123;</span><br><span class="line">        m_moveCard-&gt;<span class="built_in">hide</span>();      <span class="comment">//说明该牌已经到了对应玩家的卡牌区域，就需要隐藏了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一张或多张卡牌时，会发出一个信号告诉主窗口，该函数就是接收该信号的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::disposeCard</span><span class="params">(Player *player, <span class="type">const</span> Cards &amp;cards)</span>      <span class="comment">//卡牌区域更新</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards&amp; myCard = <span class="built_in">const_cast</span>&lt;Cards&amp;&gt;(cards);</span><br><span class="line">    CardList list = myCard.<span class="built_in">toCardList</span>();</span><br><span class="line">    <span class="comment">//CardList list = cards.toCardList();           //CardList是QVector&lt;Card&gt;的一个别名</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//通过Card取出对应的窗口对象</span></span><br><span class="line">        panel-&gt;<span class="built_in">setOwner</span>(player);                        <span class="comment">//设置该张卡牌窗口的所有者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::updatePlayerCards</span><span class="params">(Player *player)</span>       <span class="comment">//把玩家得到的牌更新到该显示的位置上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cards cards = player-&gt;<span class="built_in">getCards</span>();             <span class="comment">//取出该玩家得到的牌(手牌)</span></span><br><span class="line">    CardList list = cards.<span class="built_in">toCardList</span>();           <span class="comment">//将得到的牌存放到QVector，默认是降序排列</span></span><br><span class="line"></span><br><span class="line">    m_cardsRect = <span class="built_in">QRect</span>();             <span class="comment">//先将m_cardsRect初始化</span></span><br><span class="line">    m_userCards.<span class="built_in">clear</span>();               <span class="comment">//每次进来要清空，因为手牌位置发生变化了</span></span><br><span class="line">    <span class="comment">//取出展示扑克牌的区域</span></span><br><span class="line">    <span class="type">int</span> cardSpace = <span class="number">20</span>;               <span class="comment">//卡牌间相隔的像素(也是每张牌能显示出来的宽度)</span></span><br><span class="line">    QRect cardsRect = m_contextMap[player].cardRect;       <span class="comment">//取出该玩家的手牌区域坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;                   <span class="comment">//遍历每一张手牌</span></span><br><span class="line">        CardPanel* panel = m_cardMap[list.<span class="built_in">at</span>(i)];       <span class="comment">//每一张牌对应一张卡牌窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">show</span>();                       <span class="comment">//显示窗口</span></span><br><span class="line">        panel-&gt;<span class="built_in">raise</span>();                      <span class="comment">//让当前的卡牌窗口升起来(就是让当前卡牌窗口是所有之前出现的卡牌子窗口中最上层那个)</span></span><br><span class="line">        panel-&gt;<span class="built_in">setFrontSide</span>(m_contextMap[player].isFrontSide);    <span class="comment">//玩家的卡牌(手牌)显示正面还是反面</span></span><br><span class="line">        <span class="comment">//水平 or 垂直显示 -----&gt;下面是为了让卡牌显示在卡牌区域的正中间(卡牌区域要大一点)</span></span><br><span class="line">        <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;          <span class="comment">//如果是水平(用户玩家)</span></span><br><span class="line">            <span class="comment">//(总宽度-牌占用的宽度)/2：卡牌区域左边距离+(卡牌区域总宽度 - (卡牌总数量-1)*间隔 - 最后一张牌的完整宽度)/2</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>()+(cardsRect.<span class="built_in">width</span>()-(list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - m_cardSize.<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域上面距离+(卡牌区域高度-卡牌高度)/2</span></span><br><span class="line">            <span class="keyword">if</span>(panel-&gt;<span class="built_in">isSelected</span>())&#123;       <span class="comment">//如果这张扑克牌是被选中了，有各向上的弹跳效果</span></span><br><span class="line">                topY -= <span class="number">10</span>;                <span class="comment">//y轴像素-10</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX + cardSpace*i, topY);     <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">            m_cardsRect = <span class="built_in">QRect</span>(leftX, topY, cardSpace*i+m_cardSize.<span class="built_in">width</span>(),m_cardSize.<span class="built_in">height</span>());</span><br><span class="line">            <span class="type">int</span> curWidth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.<span class="built_in">size</span>()<span class="number">-1</span> == i)&#123;                 <span class="comment">//如果是最后一张牌了，则该牌的宽度是一整张</span></span><br><span class="line">                curWidth = m_cardSize.<span class="built_in">width</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curWidth = cardSpace;               <span class="comment">//如果不是最后一张牌，则宽度就是间隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">QRect <span class="title">cardRect</span><span class="params">(leftX + cardSpace*i, topY, curWidth, m_cardSize.height())</span></span>;</span><br><span class="line">            m_userCards.<span class="built_in">insert</span>(panel, cardRect);      <span class="comment">//将每张牌对象和在窗口的位置</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                     <span class="comment">//如果是垂直(机器人玩家)</span></span><br><span class="line">            <span class="comment">//因为不是在窗口的最左测，所以还是需要加上cardsRect.left()</span></span><br><span class="line">            <span class="type">int</span> leftX = cardsRect.<span class="built_in">left</span>() + (cardsRect.<span class="built_in">width</span>() - m_cardSize.<span class="built_in">width</span>())/<span class="number">2</span>;  <span class="comment">//卡牌区域左边距离+(卡牌区域宽度-卡牌宽度)/2</span></span><br><span class="line">            <span class="type">int</span> topY = cardsRect.<span class="built_in">top</span>() + (cardsRect.<span class="built_in">height</span>() - (list.<span class="built_in">size</span>()<span class="number">-1</span>)*cardSpace - panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>;  <span class="comment">//m_cardSize和panel都可以表示牌的高度</span></span><br><span class="line">            panel-&gt;<span class="built_in">move</span>(leftX, topY+i*cardSpace);         <span class="comment">//移动卡牌窗口坐标位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示玩家打出的牌</span></span><br><span class="line">    <span class="comment">//得到当前玩家的出牌区域以及本轮打出的牌</span></span><br><span class="line">    QRect playCardRect = m_contextMap[player].playHandRect;</span><br><span class="line">    Cards lastCards = m_contextMap[player].lastCards;                <span class="comment">//玩家本轮打出的牌</span></span><br><span class="line">    <span class="keyword">if</span>(!lastCards.<span class="built_in">isEmpty</span>())&#123;                                        <span class="comment">//如果不为空(本轮出牌了)</span></span><br><span class="line">        <span class="type">int</span> playSpacing = <span class="number">24</span>;                      <span class="comment">//出牌区域中牌与牌的间隙</span></span><br><span class="line">        CardList lastCardList = lastCards.<span class="built_in">toCardList</span>();              <span class="comment">//将出的牌存到QVector容器</span></span><br><span class="line">        CardList::ConstIterator itplayed = lastCardList.<span class="built_in">constBegin</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; itplayed!=lastCardList.<span class="built_in">constEnd</span>(); itplayed++,i++)&#123;             <span class="comment">//通过常量迭代器遍历本轮出的牌</span></span><br><span class="line">            CardPanel* panel = m_cardMap[*itplayed];          <span class="comment">//得到对应的卡牌窗口对象</span></span><br><span class="line">            panel-&gt;<span class="built_in">setFrontSide</span>(<span class="literal">true</span>);                        <span class="comment">//显示正面</span></span><br><span class="line">            panel-&gt;<span class="built_in">raise</span>();           <span class="comment">//提升牌(让当前窗口能显示在同以级别窗口的上方)---&gt;当有多张考牌时，为了达到堆叠的效果，2叠1，3叠2，4叠3</span></span><br><span class="line">            <span class="comment">//将打出的牌移动到出牌区域</span></span><br><span class="line">            <span class="keyword">if</span>(m_contextMap[player].align == Horizontal)&#123;            <span class="comment">//水平</span></span><br><span class="line">                <span class="type">int</span> leftBase = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-(lastCardList.<span class="built_in">size</span>()<span class="number">-1</span>)*playSpacing-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>() + (playCardRect.<span class="built_in">height</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;</span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(leftBase+i*playSpacing, top);      <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> left = playCardRect.<span class="built_in">left</span>()+(playCardRect.<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>;   <span class="comment">//出牌区域左像素+卡牌x在出牌区域x的中点像素</span></span><br><span class="line">                <span class="type">int</span> top = playCardRect.<span class="built_in">top</span>();               <span class="comment">//y轴就是出牌区域的y轴</span></span><br><span class="line">                panel-&gt;<span class="built_in">move</span>(left, top+i*playSpacing);           <span class="comment">//牌与牌之间有空隙</span></span><br><span class="line">            &#125;</span><br><span class="line">            panel-&gt;<span class="built_in">show</span>();                 <span class="comment">//不确定是隐藏还是显示的，预防是隐藏的，所以就将其显示出来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QPixmap <span class="title">GamePanel::loadRoleImage</span><span class="params">(Player::Sex sex, Player::Direction direct, Player::Role role)</span>  <span class="comment">//参2是图像的显示方位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找图片</span></span><br><span class="line">    QVector&lt;QString&gt;lordMan;</span><br><span class="line">    QVector&lt;QString&gt;lordWoman;</span><br><span class="line">    QVector&lt;QString&gt;farmerMan;</span><br><span class="line">    QVector&lt;QString&gt;farmerWoman;</span><br><span class="line">    lordMan &lt;&lt; <span class="string">&quot;:/images/lord_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_man_2.png&quot;</span>;</span><br><span class="line">    lordWoman &lt;&lt; <span class="string">&quot;:/images/lord_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/lord_woman_2.png&quot;</span>;</span><br><span class="line">    farmerMan &lt;&lt; <span class="string">&quot;:/images/farmer_man_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_man_2.png&quot;</span>;</span><br><span class="line">    farmerWoman &lt;&lt; <span class="string">&quot;:/images/farmer_woman_1.png&quot;</span> &lt;&lt; <span class="string">&quot;:/images/farmer_woman_2.png&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过QImage加载图片,因为其提供镜像操作(将朝向左的图片变为朝向右的图片)</span></span><br><span class="line">    QImage image;</span><br><span class="line">    <span class="type">int</span> random = QRandomGenerator::<span class="built_in">global</span>()-&gt;<span class="built_in">bounded</span>(<span class="number">2</span>);          <span class="comment">//随机用一张图片</span></span><br><span class="line">    <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Lord)&#123;                   <span class="comment">//如果是男性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Man &amp;&amp; role==Player::Farmer)&#123;           <span class="comment">//如果是男性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerMan.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Lord)&#123;           <span class="comment">//如果是女性，且是地主</span></span><br><span class="line">        image.<span class="built_in">load</span>(lordWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==Player::Woman &amp;&amp; role==Player::Farmer)&#123;         <span class="comment">//如果是女性，且是农民</span></span><br><span class="line">        image.<span class="built_in">load</span>(farmerWoman.<span class="built_in">at</span>(random));</span><br><span class="line">    &#125;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">    <span class="keyword">if</span>(direct == Player::Left)&#123;        <span class="comment">//如果图片是显示在左侧的，就不需要做镜像</span></span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image);        <span class="comment">//因为返回值是QPixmap，所以还得进行转换</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pixmap = QPixmap::<span class="built_in">fromImage</span>(image.<span class="built_in">mirrored</span>(<span class="literal">true</span>,<span class="literal">false</span>));   <span class="comment">//参1：是否做水平镜像；参2：是否做垂直镜像</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pixmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDispatchCard</span><span class="params">()</span>                 <span class="comment">//每触发一次定时器就会执行该函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录扑克牌的位置(各玩家的牌移动距离都分100次步长完成)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> curMovePos = <span class="number">0</span>;     <span class="comment">//主要是记录移动了多少个步长(第一次进该函数执行一次后，以后进该函数，都不执行该句)</span></span><br><span class="line">    <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(curMovePos &gt;= <span class="number">100</span>)&#123;               <span class="comment">//满足条件的话，就说明当前玩家得到了牌，轮到下一个玩家得牌了</span></span><br><span class="line">        <span class="comment">//给当前玩家发一张牌</span></span><br><span class="line">        Card card = m_gameCtl-&gt;<span class="built_in">takeOneCard</span>();            <span class="comment">//随机获取一张牌</span></span><br><span class="line">        curPlayer-&gt;<span class="built_in">storeDispatchCard</span>(card);              <span class="comment">//将该牌存入到当前玩家的手牌中</span></span><br><span class="line">        <span class="comment">//Cards cs(card);                   //带参构造函数</span></span><br><span class="line">        <span class="comment">//disposeCard(curPlayer,cs);   //卡牌区域更新，该函数在上面执行storeDispatchCard()时，里面就发出了信号，并执行disposeCard</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换当前玩家</span></span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(curPlayer-&gt;<span class="built_in">getNextPlayer</span>());      <span class="comment">//将下一个玩家改为当前玩家，轮到发牌给他了</span></span><br><span class="line">        curMovePos = <span class="number">0</span>;           <span class="comment">//重新将步长次数置为0</span></span><br><span class="line">        <span class="comment">//发牌动画</span></span><br><span class="line">        <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);</span><br><span class="line">        <span class="comment">//判断牌是否发完了</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getSurplusCards</span>().<span class="built_in">cardCount</span>()==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="comment">//终止定时器</span></span><br><span class="line">            m_timer-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            <span class="comment">//切换游戏状态</span></span><br><span class="line">            <span class="built_in">gameStatusPrecess</span>(GameControl::CallingLord);        <span class="comment">//切换为叫地主状态</span></span><br><span class="line">            <span class="comment">//终止发牌音乐的播放(牌发完了)</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">stopAssistMusic</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动扑克牌</span></span><br><span class="line">    <span class="built_in">cardMoveStep</span>(curPlayer, curMovePos);        <span class="comment">//参数：当前玩家，移动步长的次数</span></span><br><span class="line">    curMovePos += <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理玩家状态的变化(槽函数)---&gt;gamecontrol类发出的信号(玩家状态变化)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onPlayerStatusChanged</span><span class="params">(Player *player, GameControl::PlayerStatus status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForCallLord:                        <span class="comment">//考虑叫地主</span></span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                 <span class="comment">//只有当前玩家是用户玩家时，才执行下面(机器人玩家没有该按钮组窗口)</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::CallLord, m_gameCtl-&gt;<span class="built_in">getPlayerMaxBet</span>()); <span class="comment">//切换按钮组窗口为抢地主的窗口(修改目前下注最高分)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::ThinkingForPlayHand:                        <span class="comment">//考虑出牌</span></span><br><span class="line">        <span class="comment">//玩家出牌前，隐藏上一轮打出的牌</span></span><br><span class="line">        <span class="built_in">hidePlayerDropCards</span>(player);</span><br><span class="line">        <span class="keyword">if</span>(player == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;                       <span class="comment">//先判断玩家是否是用户玩家</span></span><br><span class="line">            <span class="comment">//取出出牌玩家的对象</span></span><br><span class="line">            Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();            <span class="comment">//取出上一次的出牌玩家，如果为空，说明出牌刚开始,</span></span><br><span class="line">            <span class="keyword">if</span>(pendPlayer == m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>() || pendPlayer == <span class="literal">nullptr</span>)&#123;              <span class="comment">//如果用户玩家是上一次的出牌玩家(说明上一次出的牌，机器人玩家不要)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PlayCard);           <span class="comment">//显示相应的按钮组窗口(这是用户玩家自由出牌)</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                                                       <span class="comment">//不是上一次的出牌玩家(轮到自己了，可以出牌，也可以不出牌)</span></span><br><span class="line">                ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::PassOrPlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                        <span class="comment">//如果玩家是机器人玩家，则就不用显示空即可</span></span><br><span class="line">            ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> GameControl::Winning:</span><br><span class="line">        m_bgm-&gt;<span class="built_in">stopBGM</span>();                    <span class="comment">//结束播放背景音乐</span></span><br><span class="line">        <span class="comment">//如果玩家赢了，就要显示出其它玩家的牌(由背面变为正面)</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()].isFrontSide = <span class="literal">true</span>;        <span class="comment">//先将遍历置为true</span></span><br><span class="line">        m_contextMap[m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()].isFrontSide = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>());            <span class="comment">//updatePlayerCards会将剩余的牌会显示正面</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(m_gameCtl-&gt;<span class="built_in">getRightRobot</span>());</span><br><span class="line">        <span class="comment">//更新玩家的得分</span></span><br><span class="line">        <span class="built_in">updatePlayerScore</span>();</span><br><span class="line">        m_gameCtl-&gt;<span class="built_in">setCurrentPlayer</span>(player);            <span class="comment">//将本局赢的玩家又设为当前玩家(下一局由它先决定要不要地主)</span></span><br><span class="line">        <span class="built_in">showEndingScorePanel</span>();                         <span class="comment">//显示游戏结束面板</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onGrabLordBet</span><span class="params">(Player *player, <span class="type">int</span> bet, <span class="type">bool</span> flag)</span>   <span class="comment">//处理抢地主情况的槽函数(显示在主窗口)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//显示抢地主的信息提示</span></span><br><span class="line">    PlayerContext context = m_contextMap[player];</span><br><span class="line">    <span class="keyword">if</span>(bet == <span class="number">0</span>)&#123;                      <span class="comment">//分数为0，说明不叫地主</span></span><br><span class="line">        context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/buqinag.png&quot;</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;         <span class="comment">//如果是第一次叫地主</span></span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/jiaodizhu.png&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            context.info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/qiangdizhu.png&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示叫地主的分数(如果不叫地主，下注分数是0，就没有必要显示，所以这句代码写在else语句里)</span></span><br><span class="line">        <span class="built_in">showAnimation</span>(Bet,bet);            <span class="comment">//调用动画效果类。参1是动画效果枚举类的分数枚举，参2是具体的分数</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.info-&gt;<span class="built_in">show</span>();              <span class="comment">//显示出提示信息</span></span><br><span class="line">    <span class="comment">//播放分数的背景音乐</span></span><br><span class="line">    m_bgm-&gt;<span class="built_in">playerRobLordMusic</span>(bet, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>(),flag);        <span class="comment">//性别需要强制转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onDisposePlayHand</span><span class="params">(Player *player, Cards &amp;cards)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//存储玩家当轮打出的牌</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);         <span class="comment">//获取出牌玩家的一些位置信息</span></span><br><span class="line">    it-&gt;lastCards = cards;</span><br><span class="line">    <span class="comment">//2.根据牌型播放游戏特效</span></span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cards)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();        <span class="comment">//获得牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type == PlayHand::Hand_Plane || type==PlayHand::Hand_Plane_Two_Pair || type== PlayHand::Hand_Plane_Two_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Plane);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Pair)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(LianDui);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Seq_Single)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(ShunZi);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(Bomb);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == PlayHand::Hand_Bomb_Jokers)&#123;</span><br><span class="line">        <span class="built_in">showAnimation</span>(JokerBomb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果玩家打出的是空牌(不出牌)，显示提示信息</span></span><br><span class="line">    <span class="keyword">if</span>(cards.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">setPixmap</span>(<span class="built_in">QPixmap</span>(<span class="string">&quot;:/images/pass.png&quot;</span>));</span><br><span class="line">        it-&gt;info-&gt;<span class="built_in">show</span>();         <span class="comment">//把info对应的窗口显示出来(之前被隐藏掉了)</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playPassMusic</span>((BGMControl::RoleSex)player-&gt;<span class="built_in">getRole</span>());      <span class="comment">//播放不要音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;            <span class="comment">//如果不为空，就需要判断是不是第一个(自由)出牌的玩家</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==player || m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()==<span class="literal">nullptr</span>)&#123;    <span class="comment">//如果是自由出牌</span></span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">true</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());     <span class="comment">//播放音乐，是自由出牌，参2为true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_bgm-&gt;<span class="built_in">playCardMusic</span>(cards, <span class="literal">false</span>, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.更新玩家剩余的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(player);</span><br><span class="line">    <span class="comment">//4. 播放提示音乐</span></span><br><span class="line">    <span class="comment">//判断玩家剩余的牌的数量</span></span><br><span class="line">    <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">2</span>)&#123;              <span class="comment">//剩余2张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last2, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(player-&gt;<span class="built_in">getCards</span>().<span class="built_in">cardCount</span>() == <span class="number">1</span>)&#123;        <span class="comment">//剩余1张</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playLastMusic</span>(BGMControl::Last1, (BGMControl::RoleSex)player-&gt;<span class="built_in">getSex</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数是一个槽函数，是接收到control发出的键盘选择信号后，执行的槽函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onCardSelected</span><span class="params">(Qt::MouseButton button)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 判断是不是出牌状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus==GameControl::DispatchCard || m_gameStatus==GameControl::CallingLord)&#123;  <span class="comment">//如果当前是发牌或叫地主状态，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 判断发出信号的牌的所有者是不是当前用户玩家(有时候我们的鼠标点击了机器人玩家的牌。这样对应的牌窗口也会发出信号，所以需要进行判断)</span></span><br><span class="line">    CardPanel* panel = (CardPanel*)<span class="built_in">sender</span>();       <span class="comment">//sender()返回的是QObject类型的指针()，转换后，得到发出信号的卡牌窗口对象</span></span><br><span class="line">    <span class="keyword">if</span>(panel-&gt;<span class="built_in">getOwner</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;     <span class="comment">//判断发出信号的卡牌窗口的所有者，如果不是用户对象，就直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 保存当前被选中的牌的窗口对象</span></span><br><span class="line">    m_curSelCard = panel;               <span class="comment">//记录在当前手牌中选择的卡牌对象</span></span><br><span class="line">    <span class="comment">//4. 判断参数的鼠标键是左键还是右键</span></span><br><span class="line">    <span class="keyword">if</span>(button == Qt::LeftButton)&#123;                 <span class="comment">//点击的是左键，就设置对应的卡牌窗口加入到准备出牌的容器中</span></span><br><span class="line">        <span class="comment">//设置扑克牌的选中状态</span></span><br><span class="line">        panel-&gt;<span class="built_in">setSeclected</span>(!panel-&gt;<span class="built_in">isSelected</span>());    <span class="comment">//设置选择状态(如果之前没有选中，经过该函数就变为选中，之前选中了，经过该函数就是不选中)</span></span><br><span class="line">        <span class="comment">//更新扑克牌在窗口中的显示</span></span><br><span class="line">        <span class="built_in">updatePlayerCards</span>(panel-&gt;<span class="built_in">getOwner</span>());</span><br><span class="line">        <span class="comment">//保存或删除扑克牌窗口对象</span></span><br><span class="line">        QSet&lt;CardPanel*&gt;::const_iterator it = m_selectCards.<span class="built_in">find</span>(panel);</span><br><span class="line">        <span class="keyword">if</span>(it == m_selectCards.<span class="built_in">constEnd</span>())&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">insert</span>(panel);       <span class="comment">//没有找到，将该牌添加到容器里面</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_selectCards.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::SelectCard);          <span class="comment">//播放出牌音乐</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(button == Qt::RightButton)&#123;            <span class="comment">//点击的是右键，就打出牌(如果不满足出牌规则，就不响应)</span></span><br><span class="line">        <span class="comment">//调用出牌按钮对应的槽函数</span></span><br><span class="line">        <span class="built_in">onUserPlayHand</span>();          <span class="comment">//调用处理用户玩家出牌函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPlayHand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断游戏状态</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameStatus != GameControl::PlayingHand)&#123;     <span class="comment">//当前游戏状态不是出牌状态，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断玩家是不是用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;       <span class="comment">//当前玩家如果不是用户玩家，也直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断要出的牌是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(m_selectCards.<span class="built_in">isEmpty</span>())&#123;         <span class="comment">//用户玩家要出的牌容器如果为空，也直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到要打出的牌的牌型(m_selectCards容器不为空)</span></span><br><span class="line">    Cards cs;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        Card card = (*it)-&gt;<span class="built_in">getCard</span>();</span><br><span class="line">        cs.<span class="built_in">add</span>(card);                           <span class="comment">//将用户要打出的牌都放到Cards容器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PlayHand <span class="title">hand</span><span class="params">(cs)</span></span>;</span><br><span class="line">    PlayHand::HandType type = hand.<span class="built_in">getHandType</span>();           <span class="comment">//获取要打出牌的类型</span></span><br><span class="line">    <span class="keyword">if</span>(type==PlayHand::Hand_Unknown)&#123;                       <span class="comment">//如果打出的牌类型是不规则(没有定义)的，也就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前玩家的牌能不能压住上一家的牌</span></span><br><span class="line">    <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>() != m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>())&#123;  <span class="comment">//先判断上一次的出牌玩家是不是用户玩家，如果不是，就不能随意出牌(要大过对方)</span></span><br><span class="line">        Cards cards = m_gameCtl-&gt;<span class="built_in">getPendCards</span>();        <span class="comment">//获取上一次的出牌玩家打出的牌</span></span><br><span class="line">        <span class="keyword">if</span>(!hand.<span class="built_in">canBeat</span>(<span class="built_in">PlayHand</span>(cards)))&#123;             <span class="comment">//判断用户玩家准备打出的牌能否击败对方的牌，不能就直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                  <span class="comment">//出完牌了，停止倒计时</span></span><br><span class="line">    <span class="comment">//通过玩家对象出牌(调用出牌函数)</span></span><br><span class="line">    m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">playHand</span>(cs);      <span class="comment">//playHand()函数里面会从手牌中移除要打出的牌，并发出信号，通知主窗口接收</span></span><br><span class="line">    <span class="comment">//清空容器</span></span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                <span class="comment">//清空用户玩家准备出牌的这个容器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理用户玩家的放弃出牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::onUserPass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown-&gt;<span class="built_in">stopCountDown</span>();                     <span class="comment">//用户玩家放弃出牌，终止倒计时</span></span><br><span class="line">    <span class="comment">//判断是不是用户玩家</span></span><br><span class="line">    Player* curPlayer = m_gameCtl-&gt;<span class="built_in">getCurrentPlayer</span>();          <span class="comment">//获取当前玩家</span></span><br><span class="line">    Player* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();            <span class="comment">//获取用户玩家</span></span><br><span class="line">    <span class="keyword">if</span>(curPlayer != userPlayer)&#123;               <span class="comment">//如果当前玩家不是用户玩家，就直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前用户玩家是不是上一次出牌的玩家(可以不处理)</span></span><br><span class="line">    Player* pendPlayer = m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>();</span><br><span class="line">    <span class="keyword">if</span>(pendPlayer==userPlayer || pendPlayer==<span class="literal">nullptr</span>)&#123; <span class="comment">//如果上一次出牌玩家是自己(其它玩家要不起出的牌)或者第一次出牌，这两种清空都直接退出(因为必须要出牌)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打出一个空的Cards是对象</span></span><br><span class="line">    Cards empty;</span><br><span class="line">    userPlayer-&gt;<span class="built_in">playHand</span>(empty);</span><br><span class="line">    <span class="comment">//清空用户选择的牌(玩家可能选择了一些牌，但是没有打出去)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=m_selectCards.<span class="built_in">begin</span>(); it!=m_selectCards.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        (*it)-&gt;<span class="built_in">setSeclected</span>(<span class="literal">false</span>);         <span class="comment">//将选中的牌都设置为非选中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m_selectCards.<span class="built_in">clear</span>();                  <span class="comment">//清空准备出牌容器</span></span><br><span class="line">    <span class="comment">//更新玩家待出牌区域的牌</span></span><br><span class="line">    <span class="built_in">updatePlayerCards</span>(userPlayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特效动画函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showAnimation</span><span class="params">(GamePanel::AnimationType type, <span class="type">int</span> bet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::LianDui:</span><br><span class="line">    <span class="keyword">case</span> AnimationType::ShunZi:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">150</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showSequence</span>((AnimationWindow::Type)type);          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Plane:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">800</span>, <span class="number">75</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, <span class="number">200</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showPlane</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">180</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::JokerBomb:</span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">250</span>, <span class="number">200</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-70</span>);       <span class="comment">//x和y位置</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showJokerBomb</span>();          <span class="comment">//调用加载动画的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AnimationType::Bet:           <span class="comment">//如果是抢地主分数</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">setFixedSize</span>(<span class="number">160</span>, <span class="number">98</span>);          <span class="comment">//设置窗口的固定大小(为图片的大小)</span></span><br><span class="line">        <span class="comment">//将子窗口移动到主窗口的某一个位置，就要用到move方法</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_animation-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_animation-&gt;<span class="built_in">height</span>())/<span class="number">2</span><span class="number">-140</span>); <span class="comment">//x和y都先取中间位置，y还需要往上移</span></span><br><span class="line">        m_animation-&gt;<span class="built_in">showBetScore</span>(bet);          <span class="comment">//调用加载分数的函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个主要是考虑到其它动画，因为显示分数是在2s后，会将AnimationType窗口隐藏起来，这样其它动画窗口会看不见，所以在这里调用一下显示</span></span><br><span class="line">    m_animation-&gt;<span class="built_in">show</span>();     <span class="comment">//让隐藏的窗口再显示出来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏玩家打出的牌</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::hidePlayerDropCards</span><span class="params">(Player *player)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_contextMap.<span class="built_in">find</span>(player);          <span class="comment">//根据当前玩家得到对应的一些信息的位置(如果没有找到传进去的玩家，就返回迭代器end)</span></span><br><span class="line">    <span class="keyword">if</span>(it != m_contextMap.<span class="built_in">end</span>())&#123;                 <span class="comment">//如果it不等于end，说明找到了</span></span><br><span class="line">        <span class="keyword">if</span>(it-&gt;lastCards.<span class="built_in">isEmpty</span>())&#123;              <span class="comment">//如果为空，说明上次没有出牌</span></span><br><span class="line">            it-&gt;info-&gt;<span class="built_in">hide</span>();                     <span class="comment">//先隐藏对应的提示信息</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Cards ---&gt; Card   注：CardList = QVector&lt;Card&gt;</span></span><br><span class="line">            CardList list = it-&gt;lastCards.<span class="built_in">toCardList</span>();             <span class="comment">//将最后打出的牌全部存入到QVector容器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> last=list.<span class="built_in">begin</span>(); last!=list.<span class="built_in">end</span>(); last++)&#123;        <span class="comment">//遍历每一张牌</span></span><br><span class="line">                m_cardMap[*last]-&gt;<span class="built_in">hide</span>();    <span class="comment">//每一张牌都有对应的CardPanel，存到m_cardMap容器的，进行隐藏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        it-&gt;lastCards.<span class="built_in">clear</span>();                    <span class="comment">//清空玩家最后一次打出的牌容器(不然会堆叠)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示玩家的最终得分(结束面板设置)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::showEndingScorePanel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> islord = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getRole</span>() == Player::Lord?<span class="literal">true</span>:<span class="literal">false</span>;     <span class="comment">//玩家是否是地主</span></span><br><span class="line">    <span class="type">bool</span> isWin = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">isWin</span>();                                   <span class="comment">//玩家是否获胜</span></span><br><span class="line">    EndingPanel* panel = <span class="keyword">new</span> <span class="built_in">EndingPanel</span>(islord, isWin, <span class="keyword">this</span>);       <span class="comment">//创建一个结束面板窗口，参3的this表示在主窗口中显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">show</span>();                                           <span class="comment">//显示</span></span><br><span class="line">    panel-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, -panel-&gt;<span class="built_in">height</span>());       <span class="comment">//结束面板刚开始显示在主窗口外(看不见)</span></span><br><span class="line">    panel-&gt;<span class="built_in">setPlayerScore</span>(m_gameCtl-&gt;<span class="built_in">getLeftRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getRightRobot</span>()-&gt;<span class="built_in">getScore</span>(),</span><br><span class="line">                          m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>()-&gt;<span class="built_in">getScore</span>());</span><br><span class="line">    <span class="comment">//根据玩家的输赢来播放对应的音乐</span></span><br><span class="line">    <span class="keyword">if</span>(isWin)&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        m_bgm-&gt;<span class="built_in">playEndingMusic</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置结束面板的动画效果</span></span><br><span class="line">    QPropertyAnimation *animation = <span class="keyword">new</span> <span class="built_in">QPropertyAnimation</span>(panel, <span class="string">&quot;geometry&quot;</span>, <span class="keyword">this</span>);   <span class="comment">//参1：给哪个对象指定动画效果；参3：父对象</span></span><br><span class="line">    <span class="comment">//动画持续时间</span></span><br><span class="line">    animation-&gt;<span class="built_in">setDuration</span>(<span class="number">1500</span>);           <span class="comment">//1.5s</span></span><br><span class="line">    <span class="comment">//设置窗口的起始位置和终止位置</span></span><br><span class="line">    animation-&gt;<span class="built_in">setStartValue</span>(<span class="built_in">QRect</span>(panel-&gt;<span class="built_in">x</span>(), panel-&gt;<span class="built_in">y</span>(), panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    animation-&gt;<span class="built_in">setEndValue</span>(<span class="built_in">QRect</span>((<span class="built_in">width</span>()-panel-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-panel-&gt;<span class="built_in">height</span>())/<span class="number">2</span>, panel-&gt;<span class="built_in">width</span>(), panel-&gt;<span class="built_in">height</span>()));</span><br><span class="line">    <span class="comment">//设置窗口的运动曲线</span></span><br><span class="line">    animation-&gt;<span class="built_in">setEasingCurve</span>(<span class="built_in">QEasingCurve</span>(QEasingCurve::OutBounce));</span><br><span class="line">    <span class="comment">//播放动画效果</span></span><br><span class="line">    animation-&gt;<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//处理窗口信号(当点击继续游戏按钮，就会发出continueGame信号，然后这里也会接收该信号)</span></span><br><span class="line">    <span class="built_in">connect</span>(panel, &amp;EndingPanel::continueGame, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        panel-&gt;<span class="built_in">close</span>();                  <span class="comment">//关闭结束界面窗口，但没有析构(但由于指定了父对象，所以的父对象没有结束，也就不会析构panel)</span></span><br><span class="line">        panel-&gt;<span class="built_in">deleteLater</span>();            <span class="comment">//手动析构panel结束界面窗口</span></span><br><span class="line">        animation-&gt;<span class="built_in">deleteLater</span>();        <span class="comment">//手动析构动画对象</span></span><br><span class="line">        ui-&gt;btnGroup-&gt;<span class="built_in">selectPanel</span>(ButtonGroup::Empty);               <span class="comment">//按钮组隐藏，显示空按钮的按钮组</span></span><br><span class="line">        <span class="built_in">gameStatusPrecess</span>(GameControl::DispatchCard);                <span class="comment">//将游戏状态设置位发牌状态</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">startBGM</span>(<span class="number">80</span>);              <span class="comment">//播放背景音乐(开始)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::initCountDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_countDown = <span class="keyword">new</span> <span class="built_in">CountDown</span>(<span class="keyword">this</span>);                <span class="comment">//创建一个闹钟类对象，父对象为主窗口</span></span><br><span class="line">    m_countDown-&gt;<span class="built_in">move</span>((<span class="built_in">width</span>()-m_countDown-&gt;<span class="built_in">width</span>())/<span class="number">2</span>, (<span class="built_in">height</span>()-m_countDown-&gt;<span class="built_in">height</span>())/<span class="number">2</span>+<span class="number">30</span>);    <span class="comment">//显示位置</span></span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::notMuchTime, <span class="keyword">this</span>, [=]()&#123;             <span class="comment">//当闹钟秒数减为5s时,会发出信号</span></span><br><span class="line">        <span class="comment">//播放提示音乐</span></span><br><span class="line">        m_bgm-&gt;<span class="built_in">playAssistMusic</span>(BGMControl::Alert);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(m_countDown, &amp;CountDown::timeout, <span class="keyword">this</span>, &amp;GamePanel::onUserPass); <span class="comment">//当秒数减为0s时，会发出信号，执行的槽函数当放弃出牌情况处理</span></span><br><span class="line">    UserPlayer* userPlayer = m_gameCtl-&gt;<span class="built_in">getUserPlayer</span>();               <span class="comment">//得到用户对象</span></span><br><span class="line">    <span class="built_in">connect</span>(userPlayer, &amp;UserPlayer::startCountDown, <span class="keyword">this</span>, [=]()&#123;              <span class="comment">//当用户玩家准备出牌时，会发出信号startCountDown</span></span><br><span class="line">        <span class="comment">//要在主屏幕上显示闹钟，必须是用户玩家可以放弃出牌的情况，比如说上一次出牌玩家不是自己且不是第一次刚开始出牌</span></span><br><span class="line">        <span class="keyword">if</span>(m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=userPlayer &amp;&amp; m_gameCtl-&gt;<span class="built_in">getPendPlayer</span>()!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_countDown-&gt;<span class="built_in">showCountDown</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::paintEvent</span><span class="params">(QPaintEvent *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="function">QPainter <span class="title">p</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">drawPixmap</span>(<span class="built_in">rect</span>(),m_bkImage);         <span class="comment">//参数：窗口矩形区域、</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GamePanel::mouseMoveEvent</span><span class="params">(QMouseEvent *ev)</span>          <span class="comment">//鼠标移动过程中框选多张扑克牌</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Q_UNUSED</span>(ev);</span><br><span class="line">    <span class="comment">//ev-&gt;buttons()里面有多种鼠标按住的移动方式(如左键、右键等)</span></span><br><span class="line">    <span class="keyword">if</span>(ev-&gt;<span class="built_in">buttons</span>() &amp; Qt::LeftButton)&#123;                 <span class="comment">//判断一下是否有鼠标左键(大于0说明左键参与了行动)</span></span><br><span class="line">        QPoint pt = ev-&gt;<span class="built_in">pos</span>();                         <span class="comment">//得到鼠标在窗口中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(!m_cardsRect.<span class="built_in">contains</span>(pt))&#123;               <span class="comment">//如果pt不在出牌区域</span></span><br><span class="line">            m_curSelCard = <span class="literal">nullptr</span>;                  <span class="comment">//将鼠标选择的卡牌窗口置为nullptr</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;                                                      <span class="comment">//如果鼠标按住的位置在卡牌区域，就要找到是哪些卡牌</span></span><br><span class="line">            QList&lt;CardPanel*&gt; list = m_userCards.<span class="built_in">keys</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                CardPanel* panel = list.<span class="built_in">at</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(m_userCards[panel].<span class="built_in">contains</span>(pt) &amp;&amp; m_curSelCard!=panel)&#123;  <span class="comment">//如果找到对应卡牌，且如果一直在一张卡牌上面，也只模拟点击一次</span></span><br><span class="line">                    <span class="comment">//点击这张扑克牌(模拟点击效果)</span></span><br><span class="line">                    panel-&gt;<span class="built_in">clicked</span>();       <span class="comment">//该函数会发出一个信号，接收者是GamePanel</span></span><br><span class="line">                    m_curSelCard = panel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="6-游戏的启动过程"><a href="#6-游戏的启动过程" class="headerlink" title="6. 游戏的启动过程"></a>6. 游戏的启动过程</h1><blockquote>
<p> 在这个斗地主的小游戏中，虽然创建了许多类对象，但基本上会在主窗口类中做初始化，并实现各个类的功能，将每个类的功能结合在一起，就实现了单机版的斗地主小游戏。</p>
</blockquote>
<p>首先是在主窗口类<code>GamePanel</code>中，设置了主窗口的左上角标题和窗口大小，又往主窗口中加载了背景图，背景图有9张，每次启动游戏随机取1张。</p>
<p>在<code>initButtonsGroup()</code>函数中先初始化5个页面的按钮组，选择初始界面的按钮组为开始界面，即只有一个开始按钮。然后通过信号槽机制，当点击开始按钮后，就执行匿名函数(发牌操作)。这个匿名函数会切换按钮组窗口，切换成空按钮的窗口，将所有玩家的得分清0，然后又马上更新每个玩家的得分。通过函数<code>gameStatusPrecess()</code>将游戏状态改为发牌状态。在<code>gameStatusPrecess()</code>函数里，因为传进来的参数是发牌状态的参数，通过switch执行对应的状态分支，即开始发牌函数<code>startDispatchCard()</code>。在该开始发牌函数中，它会设置各个玩家和扑克牌在窗口中显示的一些属性，如玩家的头像显示、玩家的手牌是否可见以及正中间的卡牌。同时，在这个函数中，也启动了一个定时器，该定时器每隔10毫秒会发送一次，该定时器是定义在主窗口类GamePanel的构造函数中的，它是每隔固定时间会执行发牌函数<code>onDispatchCard()</code>，这个函数中，是慢慢移动卡牌位置，然后利用定时器实现一个动态的发牌效果，当还剩下3张牌时，停止定时器，通过函数<code>gameStatusPrecess()</code>切换游戏状态为叫地主状态。在该状态下，通过switch执行了对应的分支。在该分支下，先是将3张底牌隐藏起来，然后调用游戏控制类的开始叫地主<code>startLordCard()</code>函数。这个函数里面执行了从父类继承下来的虚函数<code>prepareCallLord()</code>，机器人玩家和用户玩家作为子类，它们实现的操作不一样。首先是用户玩家，用户玩家在这个虚函数里面没有执行任何操作，然后又向主窗口发出了信号<code>playerStatusChanged</code>，主窗口类的<code>gameControlInit()</code>函数里面通过connect来处理该信号，令<code>onPlayerStatusChanged()</code>槽函数执行相应操作。在该函数里，会先判断是否是用户玩家，如果是用户玩家，就切换按钮组窗口，切换叫地主的一些按钮出来。</p>
<p>用户玩家的叫地主按钮显示出来后，又回到了<code>initButtonsGroup()</code>函数，在该函数，通过信号槽机制connect设置，当点击对应下注按钮时，会携带对应的分数执行匿名函数，在这个匿名函数中，因为用户玩家已经下注了，所以就切换按钮组窗口，切换为空按钮组。同时它会执行Player类的<code>grabLordBet()</code>函数，这个函数会发出信号<code>notifyGrabLordBet</code>，在发出该信号后，在主窗口的构造函数中，游戏控制类初始化函数<code>gameControlInit()</code>里面执行的<code>playerInit()</code>函数，在该函数里面会通过信号槽机制connect来接收信号，并执行槽函数<code>onGrabBet()</code>，在这个函数里面，它会根据用户玩家的下注分数，来判断是否还需要继续执行抢地主的操作，大概有两种情况：</p>
<p>1.用户玩家按的按钮是不抢地主、下注1分或下注2分，这些情况都说明还需要继续执行抢地主状态，就发送一个信号<code>notifyGrabLordBet</code>，主窗口函数会在构造函数的<code>gameControlInit()</code>函数里面通过信号槽来接收处理，执行槽函数<code>onGrabLordBet()</code>，这个函数里面就是显示提示信息和播放对应的背景音乐。然后回到<code>onGrabBet()</code>函数，它会切换玩家，将下一个玩家更新为当前玩家，并向主窗口发出信号<code>playerStatusChanged</code>，主窗口接收该信号后执行的槽函数中，通过switch执行对应的抢地主分支，而抢地主分支是只有用户玩家时，才会切换出叫地主的按钮组，不是用户玩家，就什么都不执行，退出即可。然后回到onGrabBet()函数，通过当前玩家(机器人玩家)对象调用准备叫地主函数<code>prepareCallLord()</code>。在机器人玩家类中，重写的这个函数里面会创建一个叫地主的子线程，该子线程会先睡眠2s(模拟思考效果)，然后执行考虑叫地主函数<code>thinkCallLord()</code>，在该函数里，会分析对应机器人玩家的手牌情况，看是否满足叫地主的条件，通过最后计算出来的权重来断定下注多数分。然后发送信号<code>notifyGrabLordBet</code>，游戏控制类接受信号并执行槽函数<code>onGrabBet()</code>，在这个函数如果不满足某些条件，就会继续切换下一个玩家叫地主，依次下去。当满足一定条件时，就会确定地主玩家，执行成为地主函数<code>becomeLord()</code>。</p>
<p>2.用户玩家下注3分，直接成为地主，执行函数<code>becomeLord()</code>。</p>
<p>在<code>becomeLord()</code>函数中，先是设置各个玩家的身份，将当前地主身份的玩家设置为当前玩家(先出牌)，又将三张底牌添加到地主玩家的手牌中。然后这定义了一个定时器，每隔1s就发送信号<code>gameStatusChanged</code>和<code>playerStatusChanged</code>。其中由主窗口接收信号<code>gameStatusChanged</code>，执行槽函数<code>gameStatusPrecess()</code>，这个槽函数里面就是通过switch语句执行对应的分支，该分支下主要就是将底牌、中间的发牌隐藏、提示信息等，和显示玩家带身份的头像；主窗口也接收<code>playerStatusChanged</code>信号，并执行槽函数<code>onPlayerStatusChanged()</code>，通过执行对应的分支，该分支主要就是判断当前是否是用户玩家，如果是用户玩家，就切换按钮组窗口为出牌情况，不是的话就切换为空按钮主窗口。在处理完两个信号的槽函数后，在定时器中又调用了对应玩家的出牌函数<code>preparePlayHand()</code>，这个出牌函数是用户玩家和机器人玩家执行的程序不一样，用户玩家就执行发出一条信号<code>startCountDown</code>，用于出牌倒计时即可；机器人玩家会创建对应的出牌子线程，在子线程中会执行考虑出牌函数<code>thinkPlayHand()</code>，接下来就是小项目中设定的一些策略了，机器人玩家在什么情况下出什么样的牌。</p>
<h1 id="7-游戏效果"><a href="#7-游戏效果" class="headerlink" title="7. 游戏效果"></a>7. 游戏效果</h1><p>当点击启动程序时，会先显示一个加载的界面，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_13.png"></p>
<p>当加载页面完成后，就会出现游戏场景的页面了，在这个页面中右上角显示的是个玩家的分数，因为才启动程序，所以都是0分。场景的正中间是发卡牌的扑克牌，下面是开始按钮。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_14.png"></p>
<p>当点击开始游戏按钮后，就进入了发牌阶段，只有用户玩家的手牌是显示正面的，其它两个机器人玩家的手牌是显示背面的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_15.png"></p>
<p>当发牌结束后，就游戏就进入了叫地主状态，当用户玩家直接点击3分按钮后，就可以直接成为地主，结束叫地主状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_16.png"></p>
<p>而当用户玩家点击除3分按钮的其它按钮，就会轮到下一个(机器人)玩家考虑是否叫地主。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_17.png"></p>
<p>当3个玩家都下注后，最后由下注分数最大的玩家当地主，其它两个玩家作为农民。并且三张底牌显示在正上方。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_18.png"></p>
<p>叫地主状态结束后，用鼠标选择卡牌，点击出牌即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_19.png"></p>
<p>当出的牌是一些特殊牌型，如炸弹、飞机、顺子等，还会有特效出现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_20.png"></p>
<p>当某个玩家出完牌后，表示胜利，然后正中间出现结束面板，显示当前三个玩家的得分，同时右上角也显示当前三个玩家的得分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_21.png"></p>
<p>当点击继续游戏按钮时，可以马上又进入下一局游戏，主窗口的右上角依然保存三个玩家的得分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_22.png"></p>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(上)</title>
    <url>/2024/07/08/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="1-boost库"><a href="#1-boost库" class="headerlink" title="1. boost库"></a>1. boost库</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>网络编程是现代软件开发中无可替代的一环，无论是构建庞大的分布式系统还是小型的桌面应用，都离不开网络的支持。Boost.Asio起源于Boost库，是一款专为网络I&#x2F;O、定时器、串行端口通信设计的库，提供了同步和异步的编程模型，用以简化网络和低级I&#x2F;O的操作。它的设计初衷是提供一套简洁、一致且功能全面的接口，以满足开发者在多样化网络编程场景下的需求。</p>
<h2 id="1-2-库的特性与优势"><a href="#1-2-库的特性与优势" class="headerlink" title="1.2 库的特性与优势"></a>1.2 库的特性与优势</h2><p> Boost.Asio是一款功能全面的库，其主要特性与优势如下：</p>
<ul>
<li><p>异步编程模型：它通过异步操作和回调机制，允许程序在等待I&#x2F;O操作完成时继续执行其他任务，从而提高了程序的效率和响应速度</p>
</li>
<li><p>多协议支持： 它支持TCP、UDP、SSL等多种协议，可以帮助开发者快速实现各种网络应用</p>
</li>
<li><p>跨平台兼容性： Boost.Asio可以运行在Windows、Linux、macOS等多个平台上，保证了代码的可移植性和可维护性</p>
</li>
<li><p>可扩展性： 开发者可以基于Boost.Asio轻松实现自定义协议和服务，实现特定的业务逻辑</p>
</li>
<li><p>高性能： Boost.Asio的设计充分考虑了性能因素，尤其在高并发环境下表现出色</p>
</li>
</ul>
<h1 id="2-主要函数的创建"><a href="#2-主要函数的创建" class="headerlink" title="2. 主要函数的创建"></a>2. 主要函数的创建</h1><h2 id="2-1-终端节点的创建"><a href="#2-1-终端节点的创建" class="headerlink" title="2.1 终端节点的创建"></a>2.1 终端节点的创建</h2><p>所谓终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其它节点可以连接这个终端节点做通信。</p>
<p>客户端构造终端节点：通过对端的ip和端口构造一个endpoint，用这个endpoint和其通信</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">client_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;     <span class="comment">//对端(服务端)的地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;                   <span class="comment">//对端(服务端)的端口号</span></span><br><span class="line">    </span><br><span class="line">    boost::system::error_code ec;                     <span class="comment">//定义一个错误关键字</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address::<span class="built_in">from_string</span>(raw_ip_address, ec);  <span class="comment">//将字符串形式的IP地址转换为 asio::ip::address 类型的对象</span></span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;                            <span class="comment">//如果转换失败，打印错误码和错误描述</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();                            <span class="comment">//转换失败直接退出返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;   <span class="comment">//转换成功就生成端点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端构造终端端点：则只需根据本地地址绑定就可以生成endpoint</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">server_end_point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;             <span class="comment">//用于指定网络服务监听的端口</span></span><br><span class="line">    asio::ip::address ip_address = asio::ip::address_v6::<span class="built_in">any</span>(); <span class="comment">//表示它将接受发送到服务器上任何 IPv6 地址的数据。</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(ip_address, port_num)</span></span>;       <span class="comment">//生成服务器的端点节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-创建socket"><a href="#2-2-创建socket" class="headerlink" title="2.2 创建socket"></a>2.2 创建socket</h2><p>客户端创建socket分为4步，创建上下文iocontext、选择协议、生成socket、打开socket。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建和配置一个 TCP 套接字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_tcp_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个 asio::io_context 对象 ioc，它是 Asio 库中的核心组件，用于管理 I/O 操作和执行异步任务(上下文服务)</span></span><br><span class="line">    asio::io_context ioc;</span><br><span class="line">    <span class="comment">//创建了一个 asio::ip::tcp 协议的实例 protocol，使用 v4() 指定使用 IPv4 协议</span></span><br><span class="line">    asio::ip::tcp protocol = asio::ip::tcp::<span class="built_in">v4</span>();</span><br><span class="line">    <span class="comment">//创建了一个asio::ip::tcp::socket 对象 sock，它是一个 TCP 套接字，与 ioc 关联以进行 I/O 操作</span></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">    <span class="comment">//声明了一个 boost::system::error_code 对象 ec，用于接收可能发生的错误代码</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    <span class="comment">//调用open方法打开套接字，使用之前创建的protocol对象指定协议,如果操作成功，ec将不会被设置；如果发生错误，ec将包含错误代码</span></span><br><span class="line">    sock.<span class="built_in">open</span>(protocol, ec); </span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;           <span class="comment">//检查 ec 是否包含错误代码。如果 ec.value() 不等于 0，表示发生了错误。</span></span><br><span class="line">        std::cout&lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();           <span class="comment">//发生错误，返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端创建socket，需要生成一个acceptor的socket，用来接收新的连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">create_acceptor_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context ios;</span><br><span class="line">    <span class="comment">//下面表示服务端接收连接，只接收ipv4的连接，并且是发往本地ip,端口3333的</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">a</span><span class="params">(ios, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), <span class="number">3333</span>))</span></span>; <span class="comment">//生成一个asio::ip::tcp::acceptor对象a，是v4的协议</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-绑定acceptor"><a href="#2-3-绑定acceptor" class="headerlink" title="2.3 绑定acceptor"></a>2.3 绑定acceptor</h2><p>服务器要将其绑定到指定的断点,所有连接这个端点的连接都可以被接收到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind_accept_socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;         <span class="comment">//定义端口号</span></span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(), port_num)</span></span>;  <span class="comment">//生成端点，接收任何地址的连接</span></span><br><span class="line">    asio::io_context ios;                  <span class="comment">//创建服务，让服务器知道accepter是绑定在哪个服务上的</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;    <span class="comment">//生成accepter</span></span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    acceptor.<span class="built_in">bind</span>(ep, ec);     <span class="comment">//绑定(生成的acceptor,绑定了一个端点，端点是本地的任何一个地址和端口号9527)</span></span><br><span class="line">    <span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;           <span class="comment">//检查 ec 是否包含错误代码。如果 ec.value() 不等于 0，表示发生了错误。</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to parse the IP address.Error code = &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">        <span class="keyword">return</span> ec.<span class="built_in">value</span>();           <span class="comment">//发生错误，返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接指定的端点，作为客户端可以连接服务器指定的端点进行连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect_to_end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;              <span class="comment">//服务器的地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;                            <span class="comment">//服务器的端口</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;  <span class="comment">//生成了一个端点</span></span><br><span class="line">        asio::io_context ios;</span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios, ep.protocol())</span></span>;   <span class="comment">//创建了个socket，这个sock是绑定在ios这个服务上的，并且它的协议是ep.protocol()</span></span><br><span class="line">        sock.<span class="built_in">connect</span>(ep);                         <span class="comment">//连接到端点，这样就连接到服务器了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器接收连接，当有客户端连接时，服务器需要接收连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept_new_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BACKLOG_SIZE = <span class="number">30</span>;                  <span class="comment">//监听队列的大小为30</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address_v4::any(), port_num)</span></span>;  <span class="comment">//创建一个端点，可以接收任意ipv4的地址，自己绑定的本地地址</span></span><br><span class="line">    asio::io_context ios;      <span class="comment">//创建一个服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ios, ep.protocol())</span></span>;  <span class="comment">//生成一个socketor接收器,第一个参数是服务，第二个参数是服务器要处理的协议(ipv4)</span></span><br><span class="line">        acceptor.<span class="built_in">bind</span>(ep);                  <span class="comment">//接收器进行一个绑定，绑定这个端口</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>(BACKLOG_SIZE);      <span class="comment">//服务器进行监听操作</span></span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ios)</span></span>;    <span class="comment">//再创建一个socket，这个是与客户端通信用的</span></span><br><span class="line">        acceptor.<span class="built_in">accept</span>(sock);              <span class="comment">//接收到的新连接，交给sock来处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-同步读写"><a href="#3-同步读写" class="headerlink" title="3. 同步读写"></a>3. 同步读写</h1><h2 id="3-1-同步写write-some"><a href="#3-1-同步写write-some" class="headerlink" title="3.1 同步写write_some"></a>3.1 同步写write_some</h2><p>boost::asio提供了几种同步写的api，write_some可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写这一部分，返回写入的字节数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_to_socket</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">	std::string buf = <span class="string">&quot;Hello World&quot;</span>;         <span class="comment">//定义要发送的字符串</span></span><br><span class="line">	std::<span class="type">size_t</span> total_bytes_written = <span class="number">0</span>;     <span class="comment">//记录成功发送数据的字节数</span></span><br><span class="line">	<span class="comment">//循环发送</span></span><br><span class="line">	<span class="comment">//write_som返回每次写入的字节数</span></span><br><span class="line">	<span class="keyword">while</span> (total_bytes_written != buf.<span class="built_in">length</span>()) &#123;    <span class="comment">//write_some()函数不能一次性传完</span></span><br><span class="line">		total_bytes_written += sock.<span class="built_in">write_some</span>(asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>() + total_bytes_written, buf.<span class="built_in">length</span>() - total_bytes_written));  <span class="comment">//write_some的第一个参数是buffer类型首地址，第二个参数是未发送的字节数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-同步写send"><a href="#3-2-同步写send" class="headerlink" title="3.2 同步写send"></a>3.2 同步写send</h2><p>write_some使用起来比较麻烦，需要多次调用，asio提供了send函数。send函数会一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_data_by_send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个服务端终端节点</span></span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		<span class="comment">//asio::io_service ios;     //老版本</span></span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接对端</span></span><br><span class="line">		std::string buf = <span class="string">&quot;HEllo world&quot;</span>;</span><br><span class="line">		<span class="type">int</span> send_length = sock.<span class="built_in">send</span>(asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));    <span class="comment">//send函数是tcp没有发完指定数据就阻塞在这里，直到发完</span></span><br><span class="line">		<span class="keyword">if</span> (send_length &lt;= <span class="number">0</span>) &#123;              <span class="comment">//表示发送失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-同步写write"><a href="#3-3-同步写write" class="headerlink" title="3.3 同步写write"></a>3.3 同步写write</h2><p>类似send方法，asio还提供了一个write函数，可以一次性将所有数据发送给对端，如果发送缓冲区满了则阻塞，直到发送缓冲区可用，将数据发送完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send_data_by_write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接对端</span></span><br><span class="line">		std::string buf = <span class="string">&quot;HEllo world&quot;</span>;</span><br><span class="line">		<span class="type">int</span> send_length = asio::<span class="built_in">write</span>(sock, asio::<span class="built_in">buffer</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));    <span class="comment">//write函数是tcp没有发完指定数据就阻塞在这里，直到发完</span></span><br><span class="line">		<span class="keyword">if</span> (send_length &lt;= <span class="number">0</span>) &#123;              <span class="comment">//表示发送失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-同步读read-some"><a href="#3-4-同步读read-some" class="headerlink" title="3.4 同步读read_some"></a>3.4 同步读read_some</h2><p>同步读和同步写类似，提供了读取指定字节数的接口read_some，需要多次调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">read_from_socket</span><span class="params">(asio::ip::tcp::socket&amp; sock)</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> MESSAGE_SIZE = <span class="number">7</span>;       <span class="comment">//要求读的长度</span></span><br><span class="line">	<span class="type">char</span> buf[MESSAGE_SIZE];</span><br><span class="line">	std::<span class="type">size_t</span> total_bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;</span><br><span class="line">		total_bytes_read += sock.<span class="built_in">read_some</span>(asio::<span class="built_in">buffer</span>(buf + total_bytes_read, MESSAGE_SIZE - total_bytes_read));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">string</span>(buf, total_bytes_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-同步读receive"><a href="#3-5-同步读receive" class="headerlink" title="3.5 同步读receive"></a>3.5 同步读receive</h2><p>可以一次性同步接收对方发送的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端请求连接到对端上</span></span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">		<span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">		<span class="type">char</span> receive_length = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));   <span class="comment">//receive函数是发送完指定数据，不然tcp不返回，阻塞</span></span><br><span class="line">		<span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-同步读read"><a href="#3-6-同步读read" class="headerlink" title="3.6 同步读read"></a>3.6 同步读read</h2><p>可以一次性同步读取对方发送的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_data_by_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::string raw_ip_address = <span class="string">&quot;192.168.88.93&quot;</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> port_num = <span class="number">9527</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::address::from_string(raw_ip_address), port_num)</span></span>;</span><br><span class="line">		asio::io_context ioc;</span><br><span class="line">		asio::ip::<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc, ep.protocol())</span></span>;    <span class="comment">//生成一个tcp类型的socket</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(ep);                 <span class="comment">//客户端连接到对端上</span></span><br><span class="line">		<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BUFF_SIZE = <span class="number">7</span>;</span><br><span class="line">		<span class="type">char</span> buffer_receive[BUFF_SIZE];</span><br><span class="line">		<span class="type">char</span> receive_length = asio::<span class="built_in">read</span>(sock,asio::<span class="built_in">buffer</span>(buffer_receive, BUFF_SIZE));   <span class="comment">//read函数是发送完指定数据，不然tcp不返回，阻塞</span></span><br><span class="line">		<span class="keyword">if</span> (receive_length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;receive failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (system::system_error&amp; e) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error occured! Error code = &quot;</span> &lt;&lt; e.<span class="built_in">code</span>() &lt;&lt; <span class="string">&quot;.Message:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">		<span class="keyword">return</span> e.<span class="built_in">code</span>().<span class="built_in">value</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-同步读写客户端和服务端"><a href="#4-同步读写客户端和服务端" class="headerlink" title="4. 同步读写客户端和服务端"></a>4. 同步读写客户端和服务端</h1><h2 id="4-1-客户端设计"><a href="#4-1-客户端设计" class="headerlink" title="4.1 客户端设计"></a>4.1 客户端设计</h2><p>基本思路：根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建上下文服务</span></span><br><span class="line">		boost::asio::io_context ioc;</span><br><span class="line">		<span class="comment">//构造endpoint</span></span><br><span class="line">		<span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;192.168.100.100&quot;</span>), <span class="number">9527</span>)</span></span>;     <span class="comment">//构造服务端的端点</span></span><br><span class="line">		<span class="comment">//创建socket</span></span><br><span class="line">		<span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;    <span class="comment">//第一个参数是服务ioc,第二个参数可以不写</span></span><br><span class="line">		boost::system::error_code error = boost::asio::error::host_not_found; <span class="comment">//创建一个错误码，先赋值一个初值</span></span><br><span class="line">		<span class="comment">//请求连接对端</span></span><br><span class="line">		sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">		<span class="keyword">if</span> (error) &#123;             <span class="comment">//连接失败执行下面</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;connect failed, code is&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;error msg is&quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接成功</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Enter message:&quot;</span>;</span><br><span class="line">		<span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">		std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);     <span class="comment">//每输入完一次按回车，就将信息存到request里面</span></span><br><span class="line">		<span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);   <span class="comment">//获取request里面的长度</span></span><br><span class="line">		boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length)); <span class="comment">//向服务端发送request里面的信息(转换成buffer类型才能发送)</span></span><br><span class="line">		<span class="type">char</span> reply[MAX_LENGTH];               <span class="comment">//用来存放服务端传过来的信息</span></span><br><span class="line">		<span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length)); <span class="comment">//接收从服务端发来的信息(转换成buffer类型才能接收)</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Reply is:&quot;</span>;</span><br><span class="line">		cout.<span class="built_in">write</span>(reply, reply_length);        <span class="comment">//输出到终端</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-服务端设计"><a href="#4-2-服务端设计" class="headerlink" title="4.2 服务端设计"></a>4.2 服务端设计</h2><p>server函数作用：根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session</p>
<p>session函数作用：该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数，类似于回调函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;tcp::socket&gt;socket_ptr;      <span class="comment">//定义指向socket的智能指针类型重命名为socket_ptr</span></span><br><span class="line">std::set&lt;std::shared_ptr&lt;std::thread&gt;&gt;thread_set;    <span class="comment">//线程集合，元素是指向线程的智能指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">session</span><span class="params">(socket_ptr sock)</span> </span>&#123;       <span class="comment">//参数是与客户端之间进行通信的通信描述符(sock智能指针)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">char</span> data[max_length];                       <span class="comment">//接收数据的数组</span></span><br><span class="line">            <span class="built_in">memset</span>(data, <span class="string">&#x27;\0&#x27;</span>, max_length);              <span class="comment">//将该数组清空为0</span></span><br><span class="line">            boost::system::error_code error;             <span class="comment">//创建一个错误码</span></span><br><span class="line">            <span class="comment">//size_t length = boost::asio::read(sockaddr_size, boost::asio::buffer(data, max_length), error); //读客户端发来的数据，要读到max_length才返回</span></span><br><span class="line">            <span class="type">size_t</span> length = sock-&gt;<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data, max_length), error); <span class="comment">//读到多少，返回多少</span></span><br><span class="line">            <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;               <span class="comment">//eof表示对端关闭</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;connection closed by peer&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;                              <span class="comment">//其它错误较严重，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印对端的ip地址(转为字符串打印出来)</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive from &quot;</span> &lt;&lt; sock-&gt;<span class="built_in">remote_endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; endl;  <span class="comment">//sock-&gt;remote_endpoint()是对端的端点</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive message is&quot;</span> &lt;&lt; data &lt;&lt; endl;                 <span class="comment">//打印对端发来的数据</span></span><br><span class="line">            <span class="comment">//这里简单处理，直接将接收到的数据传给对端</span></span><br><span class="line">            boost::asio::<span class="built_in">write</span>(*sock, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception in thread:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">server</span><span class="params">(boost::asio::io_context&amp; io_context, <span class="type">unsigned</span> <span class="type">short</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个accepter,是用来服务器接收客户端的连接的</span></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">a</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), port))</span></span>;   <span class="comment">//第一个参数是上下文，第二个参数是用ipv4的地址绑定本地服务器的地址---&gt;最终是端点形式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="function">socket_ptr <span class="title">socket</span><span class="params">(<span class="keyword">new</span> tcp::socket(io_context))</span></span>; <span class="comment">//创建了一个socket，智能指针指向它，并且初始化好了</span></span><br><span class="line">        <span class="comment">//调用了 tcp::acceptor 对象 a 的 accept 方法，这个方法会阻塞等待直到有一个新的TCP连接请求到达。一旦有客户端发起连接请求，accept 方法就会接受这个连接，并将新连接的套接字信息赋给 *socket，即 socket_ptr 智能指针所指向的 tcp::socket 对象</span></span><br><span class="line">        a.<span class="built_in">accept</span>(*socket);             <span class="comment">//连接成功后，此时的socket智能指针就相当于是通信描述符了</span></span><br><span class="line">        <span class="keyword">auto</span> t = std::<span class="built_in">make_shared</span>&lt;std::thread&gt;(session, socket);  <span class="comment">//创建一个线程，并指向session函数</span></span><br><span class="line">        thread_set.<span class="built_in">insert</span>(t); <span class="comment">//将新创建的线程 t 插入到一个线程集合 thread_set 中，为了后续对线程进行管理或监控</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;         <span class="comment">//定义一个服务，用于处理I/O操作，如网络连接和文件操作</span></span><br><span class="line">        <span class="built_in">server</span>(ioc, <span class="number">10086</span>);                  <span class="comment">//将服务和端口传递给server函数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : thread_set) &#123;         <span class="comment">//遍历线程回收，这样主线程就是最后退出的</span></span><br><span class="line">            t-&gt;<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-同步读写的优劣"><a href="#4-3-同步读写的优劣" class="headerlink" title="4.3 同步读写的优劣"></a>4.3 同步读写的优劣</h2><p>1.缺点：</p>
<ul>
<li>同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态</li>
<li>可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多</li>
<li>该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开</li>
<li>该服务器和客户端未考虑粘包处理</li>
</ul>
<p>2.优点：当客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式，这样能简化编码难度</p>
<h1 id="5-异步读写"><a href="#5-异步读写" class="headerlink" title="5. 异步读写"></a>5. 异步读写</h1><p>这里先封装一个Node信息结构体，用来管理要发送和接收的数据，该结构包含数据域首地址，数据的总长度，以及已经处理的长度(已读的长度或者已写的长度)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//发送结点时的构造方式</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> total_len):_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;  <span class="comment">//参数：一个字符串的首地址(字符串);长度。这里初始化了发送数据的总长度，以及当前发送的字节数为0</span></span><br><span class="line">		_msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];      <span class="comment">//开辟了一块要发送数据长度的空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_msg, msg, total_len);    <span class="comment">//直接将原来的内容copy到_msg中,现在_msg里面解释要发送的数据了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//接受结点时的构造方式</span></span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">int</span> total_len) :_total_len(total_len), _cur_len(<span class="number">0</span>) &#123;  <span class="comment">//参数就是读取数据的长度。这里初始化了要读取数据的总长度，以及当前读取的字节数为0</span></span><br><span class="line">		_msg = <span class="keyword">new</span> <span class="type">char</span>[total_len];    <span class="comment">////开辟了一块要读取数据长度的空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _msg;                <span class="comment">//析构掉手动创建的空间</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> _total_len;            <span class="comment">//消息总长度</span></span><br><span class="line">	<span class="type">int</span> _cur_len;              <span class="comment">//当前接收或发送的字节数</span></span><br><span class="line">	<span class="type">char</span>* _msg;                <span class="comment">//消息的首地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而Session类负责完成异步读和异步写的工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(std::shared_ptr&lt;asio::ip::tcp::socket&gt;socket);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">(<span class="type">const</span> asio::ip::tcp::endpoint&amp; ep)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadFromSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadAllFromSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::queue&lt;std::shared_ptr&lt;MsgNode&gt;&gt; _send_queue; <span class="comment">//定义一个队列，里面的元素是指向信息结构体的智能指针</span></span><br><span class="line">	std::shared_ptr&lt;asio::ip::tcp::socket&gt;_socket;    <span class="comment">//定义一个指向socket智能指针</span></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt;_send_node;   <span class="comment">//定义一个指向信息结构体的智能指针(发送数据类型的)</span></span><br><span class="line">	<span class="type">bool</span> _send_pending;                   <span class="comment">//是否还有未发送完的数据</span></span><br><span class="line"></span><br><span class="line">	std::shared_ptr&lt;MsgNode&gt; _recv_node;  <span class="comment">//定义一个指向信息结构体的智能指针(接收数据类型的)</span></span><br><span class="line">	<span class="type">bool</span> _recv_pending;                   <span class="comment">//是否还有未接收完的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-异步写async-write-some"><a href="#5-1-异步写async-write-some" class="headerlink" title="5.1 异步写async_write_some"></a>5.1 异步写async_write_some</h2><p>该方法可能会多次调用回调函数，比如说我们要求这个_total_len发送12个字节数据，那么调用的回调函数为什么一直返回5个字节勒？这个是因为我们要求它发多长，但是tcp它有一个发送缓冲区，跟我们用户缓冲区是不一致的，tcp的发送缓冲区实际上空闲的空间比我们要求发送的总长度要小，所以它实际发送的长度要比我们要求的少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span> </span>&#123;      <span class="comment">//参数是要发送的数据</span></span><br><span class="line">	<span class="comment">//构造一个发送数据结构体结点，存放buf数据(要发送的)，插入到队列里面(就算因为还有数据未发送完，但也已经插入到队列，这些数据迟早也会发送的)</span></span><br><span class="line">	_send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line">	<span class="keyword">if</span> (_send_pending) &#123;   <span class="comment">//如果有未发送完的数据，直接返回，就不要再调用异步发送了，因为多次调用异步发送会出问题</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没有数据，就调用异步的发送队列</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(buf),std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));  <span class="comment">//发送完不确定数据长度后，才会调用回调函数</span></span><br><span class="line">	_send_pending = <span class="literal">true</span>;         <span class="comment">//设为true，表示数据没有发送完</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数是错误码和才发送完的数据长度(WriteCallBack函数是已经发送完bytes_transferred长度数据后才被调用的)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;              <span class="comment">//有错误，打印错误码和错误信息，然后直接退出</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error,code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();   <span class="comment">//取出第一个元素(发送消息结构体)出来，因为第一个是我们正在发送的数据</span></span><br><span class="line">	send_data-&gt;_cur_len += bytes_transferred; <span class="comment">//正在发送的数据，它的当前发送长度+传回来这次已经发送的长度---&gt;更新成当前长度了</span></span><br><span class="line">	<span class="keyword">if</span> (send_data-&gt;_cur_len &lt; send_data-&gt;_total_len) &#123;  <span class="comment">//更新后当前已发送的长度 &lt; 要求发送的长度，就继续发送</span></span><br><span class="line">        <span class="comment">//buffer里面要做偏移，接下来要发送的位置是数据首地址+已经发送完的数据量；剩余数据量是总的数据量-已经发送数据量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有执行上面if，就说明队列首元素消息结构体数据已经发送完毕了</span></span><br><span class="line">	_send_queue.<span class="built_in">pop</span>();            <span class="comment">//就从队列中抛出这个结点(每个结点都有它的任务，即要发送的数据)</span></span><br><span class="line">	<span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;    <span class="comment">//如果这个结点队列为空了，说明发送完了</span></span><br><span class="line">		_send_pending = <span class="literal">false</span>;    <span class="comment">//将这个变量置为假，以后有数据要发送，就可以直接放入队列，马上执行异步发送的代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;         <span class="comment">//如果结点队列还有，就继续发送队列当前首元素的信息结构体里面的信息</span></span><br><span class="line">		<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();      <span class="comment">//再次取出队列的第一个元素发出</span></span><br><span class="line">        <span class="comment">//第一次发送send_data-&gt;_cur_len为0，但也要写上好一点，因为该变量是会更新的，后面调用就不一定是0了</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-异步写async-send"><a href="#5-2-异步写async-send" class="headerlink" title="5.2 异步写async_send"></a>5.2 异步写async_send</h2><p>socket里面还有另一个异步发送的函数async_sned，它是boost::asio帮我们封装的，它是把数据全部发送完毕，才会调用回调函数。表面上是只做了一次回调，但它底层会多次调用async_write_some函数来帮我们完成数据的读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllToSocket</span><span class="params">(<span class="type">const</span> std::string&amp; buf)</span> </span>&#123;       <span class="comment">//参数是要发送的数据</span></span><br><span class="line">	<span class="comment">//构造一个发送消息结构体结点，存放buf数据(要发送的)，插入到队列里面</span></span><br><span class="line">	_send_queue.<span class="built_in">emplace</span>(<span class="keyword">new</span> <span class="built_in">MsgNode</span>(buf.<span class="built_in">c_str</span>(), buf.<span class="built_in">length</span>()));</span><br><span class="line">	<span class="keyword">if</span> (_send_pending) &#123;    <span class="comment">//如果有未发送完的数据，直接返回，就不要再调用异步发送了，因为多次调用异步发送会出问题</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//保证只调用一次回调，这次回调出来的长度就是我们要求发送的长度</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_send</span>(asio::<span class="built_in">buffer</span>(buf), std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));   <span class="comment">//参数：我们要发送的数据，绑定函数(回调函数，该函数所属的对象，占位符)</span></span><br><span class="line">	_send_pending = <span class="literal">true</span>;            <span class="comment">//置为真，表示有数据在发送</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当发送完指定的数据后，就会调用回调函数WriteAllCallBack(不会多次回调，只会发送完指定数据，才执行回调函数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::WriteAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ec.<span class="built_in">value</span>() != <span class="number">0</span>) &#123;              <span class="comment">//有错误，直接退出</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Error,code is &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;.Message is &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有错误，就说明整条数据发送完毕,因为async_send调用一次回调函数就可以发送完要求发送的数据</span></span><br><span class="line">	_send_queue.<span class="built_in">pop</span>();              <span class="comment">//把队首元素抛出来</span></span><br><span class="line">	<span class="keyword">if</span> (_send_queue.<span class="built_in">empty</span>()) &#123;      <span class="comment">//如果队列为空，说明数据都发送完了，把判断的状态置为空</span></span><br><span class="line">		_send_pending = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!_send_queue.<span class="built_in">empty</span>()) &#123;      <span class="comment">//说明还有结点的数据可以发送</span></span><br><span class="line">		<span class="keyword">auto</span>&amp; send_data = _send_queue.<span class="built_in">front</span>();     <span class="comment">//取出对头元素，继续发送</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;_socket-&gt;<span class="built_in">async_send</span>(asio::<span class="built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len), std::<span class="built_in">bind</span>(&amp;Session::WriteAllCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));   <span class="comment">//参数：我们要发送的数据，绑定函数(回调函数，该函数所属的对象，占位符)</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-异步读async-read-some"><a href="#5-3-异步读async-read-some" class="headerlink" title="5.3 异步读async_read_some"></a>5.3 异步读async_read_some</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_recv_pending) &#123;     <span class="comment">//服务器端处于接受状态，其它的应用层调用该函数，就直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个接收结点</span></span><br><span class="line">	_recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);</span><br><span class="line">	<span class="comment">//异步的读函数，读完后，如果数据读好后，会调用传递给它的回调函数,_total_len定义的长度是1024</span></span><br><span class="line">	_socket-&gt;<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), <span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	_recv_pending = <span class="literal">true</span>;       <span class="comment">//置为true，只要回调被执行完后，给它置为false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	_recv_node-&gt;_cur_len += bytes_transferred;       <span class="comment">//对读取的数据长度进行更新</span></span><br><span class="line">	<span class="keyword">if</span> (_recv_node-&gt;_cur_len &lt; _recv_node-&gt;_total_len) &#123;    <span class="comment">//如果当前读完的长度 &lt; 要求长度</span></span><br><span class="line">		_socket-&gt;<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg + _recv_node-&gt;_cur_len, _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), <span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//没有执行上面if，说明读完了</span></span><br><span class="line">	_recv_pending = <span class="literal">false</span>;</span><br><span class="line">	_recv_node = <span class="literal">nullptr</span>;        <span class="comment">//不写这行也可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-异步读async-receive"><a href="#5-4-异步读async-receive" class="headerlink" title="5.4 异步读async_receive"></a>5.4 异步读async_receive</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllFromSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_recv_pending) &#123;       <span class="comment">//服务器端处于接受状态，其它的应用层调用该函数，就直接返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	_recv_node = std::<span class="built_in">make_shared</span>&lt;MsgNode&gt;(RECVSIZE);   <span class="comment">//创建一个接收结点</span></span><br><span class="line">	<span class="comment">//async_receive是异步的接收，能一次性保证数据接收到我们要求的长度，只触发一次回调函数</span></span><br><span class="line">	_socket-&gt;<span class="built_in">async_receive</span>(asio::<span class="built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;Session::ReadCallBack, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">	_recv_pending = <span class="literal">true</span>;    <span class="comment">//判断状态只为true。虽然是异步，但通过同步的方式去控制它</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为async_receive是读完所有数据才执行回调，所以执行回调的时候，数据已经读取完了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::ReadAllCallBack</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">	_recv_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">	_recv_node = <span class="literal">nullptr</span>;            <span class="comment">//不置为空也可以</span></span><br><span class="line">	_recv_pending = <span class="literal">false</span>;  <span class="comment">//表示这个数据已经接收完，不存在阻塞状态，已经触发回调函数，回调函数已经处理完，下一次又可以创建新的结点进行接收了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：读和写都是一样，发送数据推荐async_send，读数据推荐async_read_some。总结如下：<br>async_receive和async_read_some不能混着用，因为async_receive内部也是多次调用async_read_some，那么它也会多次触发<br>ReadCallBack回调函数，也会多次去发送我们要发送的数据。如果混着用，在boost::asio底层就不会去考虑顺序性，读到的数据就可能是乱的了。</p>
<h1 id="6-异步服务端实现"><a href="#6-异步服务端实现" class="headerlink" title="6. 异步服务端实现"></a>6. 异步服务端实现</h1><h2 id="6-1-头文件"><a href="#6-1-头文件" class="headerlink" title="6.1 头文件"></a>6.1 头文件</h2><p>Session类是用于处理与客户端通信的工作；Server类是用于处理与客户端建立连接的任务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context&amp; ioc) :_socket(ioc) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;               <span class="comment">//获取socket变量的函数</span></span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred)</span></span>; <span class="comment">//错误码；读到的数据数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	<span class="keyword">enum</span> &#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line">	<span class="type">char</span> _data[max_length];        <span class="comment">//存放数据的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port);   <span class="comment">//初始化时，传入ioc和监听的端口号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	boost::asio::io_context&amp; _ioc;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-主要函数"><a href="#6-2-主要函数" class="headerlink" title="6.2 主要函数"></a>6.2 主要函数</h2><p>当有客户端发数据过来的时候，因为这里通过async_read_some监听了读事件，当读事件就绪的时候，会触发读的回调函数，在start函数里，为session绑定了一个读事件，_socket.async_read_some在boost::asio底层就会把这个_socket的读事件添加到epoll表里，这样当_socke有读事件就绪的时候(_socket它的tcp缓冲区由空变成有数据)，就会触发回调函数handle_read，在回调函数里就可以把数据读出来。<br>至于为什么data会自动把新的数据拷贝到data里？因为asio帮我们做的，就是说我们把_data传给异步读函数async_read_some的时候，asio自动的把数据读到了_data里，所以handle_read函数里就直接读出_data的数据即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;     <span class="comment">//定义一个服务</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">        <span class="function">Server <span class="title">s</span><span class="params">(ioc, <span class="number">9527</span>)</span></span>;</span><br><span class="line">        ioc.<span class="built_in">run</span>();             <span class="comment">//底层是让模型在它的线程里去做一个循环的轮询操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数，传了两个参数(上下文，端口)，后面_ioc因为是类成员变量，所以进行了初始化，_acceptor是用来负责接收连接的描述符，给_acceptor传递的参数：上下文、端点(它要绑定的端口)---&gt;匹配本机地址---&gt;_acceptor监听本地地址的port端口号的，只要客户端往这个端口去连接，都会被_acceptor捕获</span></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port) :_ioc(ioc), _acceptor(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Server start success, on part:&quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();   <span class="comment">//服务端算是搭建成功了，等待客户端来连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先创建一个new_session，然后用_acceptor去接收连接，当有连接到来的时候，这个new_session就绑定到这个函数(handle_accept)里,然后这个new_session就专门处理对端的连接信息了，对端发数据、写数据都交给new_session处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Session* new_session = <span class="keyword">new</span> <span class="built_in">Session</span>(_ioc);        <span class="comment">//创建一个Session</span></span><br><span class="line">	<span class="comment">//把这个Session的socket传进去，这样accept才能根据这个socket给我们返回一个新的连接</span></span><br><span class="line">	<span class="comment">//参入的参数：socket(这个socket负责服务与对端的通信)；绑定的函数(new_session是绑定函数的第一个参数，而占位符是占位error位置)</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, placeholders::_1));    <span class="comment">//如果与客户端建立成功，就会执行handle_accept回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(Session* new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;        <span class="comment">//是0的话，就表示成功了</span></span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();       <span class="comment">//让它去接收客户端的收发信息了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">delete</span> new_session;        <span class="comment">//失败就delete掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面就处理完一个连接了，_acceptor还要去接收新的连接</span></span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);       <span class="comment">//将存放数据的_data清空置0</span></span><br><span class="line">    <span class="comment">//buffer参数是：首地址；长度</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2)); <span class="comment">//因为handle_read有两个参数，需要两个占位符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读的回调函数，就是客户端发数据过来，就调用该函数(调用该函数时，数据已经读到了_data中)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;   <span class="comment">//如果没有错，打印客户端发来的数据</span></span><br><span class="line">        <span class="comment">//同读一样，把_socket通过async_write绑定一个写事件，写的数据是_data,写的多少是bytes_transferred。如果异步调用了该写函数，而tcp的发送缓冲区现在又没有可用的空间，它是不会回调async_write函数的；只有当tcp的发送缓冲区给我们的数据发出去后，它就会调用async_write函数了，然后把刚刚收到的数据发送过去。发送数据时，asio就会知道，它会调用我们新绑定的函数对象，把参数传给placeholders::_1所占的位置</span></span><br><span class="line">        boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, placeholders::_1));   <span class="comment">//绑定发送的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                <span class="comment">//如果有错误(对端关闭也属于错误，会执行下面)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;                      <span class="comment">//有错误，直接销毁掉Session，就说明这个连接断开了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用了async_write回调函数时，先将data清除一下(因为已经发送成功)，接下来就直接往这个data里面读数据即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2)); <span class="comment">//因为handle_read有两个参数，需要两个占位符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                       <span class="comment">//如果有错误</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;            <span class="comment">//有错误，直接销毁掉Session，就说明这个连接断开了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面需要了解的是：用户态跟tcp的缓冲区的联系，什么能造成写就绪事件，什么能造成读就绪事件，也就是什么时候能触发写回调，什么时候能触发读回调。触发读回调是因为tcp的缓冲区有数据；触发写回调是因为tcp缓冲区有空闲空间，那么就可用从用户态将信息拷贝到tcp缓冲区，然后tcp再发出去，这时候就能触发写回调。</p>
<h2 id="6-3-伪闭包延长连接生命周期"><a href="#6-3-伪闭包延长连接生命周期" class="headerlink" title="6.3 伪闭包延长连接生命周期"></a>6.3 伪闭包延长连接生命周期</h2><p>上面异步代码在某些情况下，会出现一些隐患，比如说这个服务器将要发送数据给客户端，也就是读到数据后，将要调用async_write去发数据，如果这个时候客户端断掉了，而写事件已经就绪，写事件在写的时候，会触发写回调handle_write，它也会发现对端断掉了，所以它在handle_write函数里面会执行错误处理代码段，因此就会回收数据(delete this)。但是因为对端关闭了，它还会触发一次读回调，而读回调也会捕获到对端关闭了，那么它也会去执行delete this代码。所以这样的话，两次的delete this就会造成内存的二次释放，系统就会崩溃。</p>
<p>上面的情况可以理解为：读到数据过后，在发送数据给对端之前，把连接断掉。</p>
<blockquote>
<p>解决办法：因为c++里面没有闭包的机制，所以这里就用c++11的特性里面的智能指针。因为智能指针是有引用计数的，如果把智能指针传给一个函数对象，这个函数对象不被释放掉，那么这个智能指针就不会被释放掉。如果我们把智能指针传给回调函数(假设它会被放到一个回调的队列里)，那么回调函数就是一个函数对象，这个函数对象没有被调用，没有被释放之前，智能指针也不会被释放。所以我们可以把智能指针作为参数传递给回调函数，函数内部再使用智能指针，智能指针就不会被释放掉了。</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt;  <span class="comment">//继承一个模板类，需要什么样的类型，传入什么</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Session</span>(boost::asio::io_context&amp; ioc, Server* server) :_socket(ioc), _server(server) &#123;</span><br><span class="line">		<span class="comment">//定义一个uuid(通过自定义生成器,它的构造函数生成一个函数对象，函数对象再调用它函数)</span></span><br><span class="line">		boost::uuids::uuid a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">		_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);    <span class="comment">//把生成的uuid经过转换就能生成唯一的_uuid了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">Socket</span><span class="params">()</span> </span>&#123;          <span class="comment">//获取socket变量的函数</span></span><br><span class="line">		<span class="keyword">return</span> _socket;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span> bytes_transferred, shared_ptr&lt;Session&gt; _self_shared)</span></span>;   <span class="comment">//错误码；读到的数据数；接收一个指向当前 Session 对象的shared_ptr</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;Session&gt; _self_shared)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	<span class="keyword">enum</span> &#123;max_length = <span class="number">1024</span>&#125;;</span><br><span class="line">	<span class="type">char</span> _data[max_length];</span><br><span class="line">	Server* _server;                 <span class="comment">//Server成员变量</span></span><br><span class="line">	std::string _uuid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string uuid)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start_accept</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>;</span><br><span class="line">	boost::asio::io_context&amp; _ioc;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, shared_ptr&lt;Session&gt;&gt;_sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数是ioc和端口号，往这个端口去连接，都会被_acceptor捕获</span></span><br><span class="line">Server::<span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, <span class="type">short</span> port) :_ioc(ioc), _acceptor(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Server start success, on part:&quot;</span> &lt;&lt; port &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::start_accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shared_ptr&lt;Session&gt; new_session = <span class="built_in">make_shared</span>&lt;Session&gt;(_ioc, <span class="keyword">this</span>);   <span class="comment">//用智能指针的形式创建</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">Socket</span>(), std::<span class="built_in">bind</span>(&amp;Server::handle_accept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::handle_accept</span><span class="params">(shared_ptr&lt;Session&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;        <span class="comment">//是0的话，就表示成功了</span></span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();              <span class="comment">//让它去接收客户端的收发信息了</span></span><br><span class="line">		_sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session));   <span class="comment">//_sessions就可以管理这些连接了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面就处理完一个连接了，_acceptor还要去接收新的连接</span></span><br><span class="line">	<span class="built_in">start_accept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Server::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	_sessions.<span class="built_in">erase</span>(uuid);           <span class="comment">//从_sessions里将它移除就可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);              <span class="comment">//将存放数据的_data清空置0</span></span><br><span class="line">    <span class="comment">//shared_from_this()是创建了一个指向当前Session对象的shared_ptr。这个shared_ptr被传递给异步操作的回调函数，以确保在异步操作完成时，Session 对象仍然有效。这通常用于确保在异步操作的回调函数执行期间，对象不会被销毁。</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读的回调函数，就是客户端发数据过来，就调用该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_read</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">size_t</span> bytes_transferred, shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;server receive data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;</span><br><span class="line">		boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_data, bytes_transferred), std::<span class="built_in">bind</span>(&amp;Session::handle_write, <span class="keyword">this</span>, placeholders::_1, _self_shared));   <span class="comment">//绑定发送的回调函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;         <span class="comment">//如果有错误(对端关闭也属于错误，会执行下面)</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果handle_read函数进入了错误处理，调用它的ClearSession函数，传入自己_uuid即可,这样该session就会从server中移除</span></span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">Session::GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当调用了async_write回调函数时，先将data清除一下(因为已经发送成功)，接下来就直接往这个data里面读数据即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session::handle_write</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;Session&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(_data, <span class="number">0</span>, max_length);</span><br><span class="line">		_socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, max_length), std::<span class="built_in">bind</span>(&amp;Session::handle_read, <span class="keyword">this</span>, placeholders::_1, placeholders::_2, _self_shared));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;         <span class="comment">//如果有错误</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; endl;</span><br><span class="line">		_server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>伪闭包延长连接声明周期原理：把智能指针作为参数传递给bind函数，bind是按值的方式去绑定的，它绑定一个智能指针的值给新生成的一个函数对象，新生成的函数对象会使用这个智能指针(以值的方式来使用)，也就增加了智能指针的引用计数。我们使用的智能指针引用计数不为0，所以智能指针就不会被释放，则session就不会被释放(智能指针是session类型的)，所以说该智能指针session它的声明周期就和新生成的函数对象的声明周期延长了，延长到和这个新生成的函数对象声明周期一致。因为我们既绑定了读的回调，也绑定了写的回调，所以说这个session，它的引用计数在这里每绑定一次，就会加1。也就不会出现新生成的函数对象被调用之前，这个session就被释放掉的情况(避免了释放已经释放的内存)。</p>
<h2 id="6-4-添加发送队列"><a href="#6-4-添加发送队列" class="headerlink" title="6.4 添加发送队列"></a>6.4 添加发送队列</h2><p>上面介绍了通过智能指针实现伪闭包的方式延长了session的生命周期，而实际使用的服务器并不是应答式，而是全双工通信方式，服务器是一直监听写事件，接收对端数据的，那么当服务器发送数据给对端时，就不能保证数据的有序性。</p>
<blockquote>
<p>解决办法：设计一个数据结点，首先在CSession类里新增一个队列存储要发送的数据，因为我们不能保证每次调用发送接口的时候上一次数据已经发送完(如果上一次没有发送完，而恰巧我们又调用了一次接口，那么boost.asio底层不知道是要发送上一次没有发送完的数据，还是发送新一次调用的数据。所以勒，这样就能造成数据的混乱)，所以就要把要发送的数据放入队列中，通过回调函数不断地发送。而且我们不能保证发送的接口和回调函数的接口在一个线程，所以要增加一个锁保证发送队列安全性。</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">int</span> max_len) &#123;  <span class="comment">//参数：数据的首地址；数据的长度</span></span><br><span class="line">		_data = <span class="keyword">new</span> <span class="type">char</span>[max_len];      <span class="comment">//通过长度new处理一片空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(_data, msg, max_len);    <span class="comment">//把原数据拷贝到现在的成员变量里，保证数据是一个深拷贝，以后操作这个数据即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] _data;                 <span class="comment">//在析构的时候，直接delete掉</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _cur_len;                       <span class="comment">//表示当前已经处理的长度</span></span><br><span class="line">	<span class="type">int</span> _max_len;                       <span class="comment">//表示数据的总长度</span></span><br><span class="line">	<span class="type">char</span>* _data;                        <span class="comment">//数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code &amp; error)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">	boost::asio::io_context &amp;_io_context;</span><br><span class="line">	<span class="type">short</span> _port;</span><br><span class="line">	tcp::acceptor _acceptor;</span><br><span class="line">	std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>:<span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">	~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Ssession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">int</span> max_length)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span></span>;</span><br><span class="line">	tcp::socket _socket;</span><br><span class="line">	std::string _uuid;</span><br><span class="line">	<span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">	CServer* _server;</span><br><span class="line">	std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;     <span class="comment">//队列</span></span><br><span class="line">	std::mutex _send_lock;                          <span class="comment">//锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port),</span><br><span class="line">_acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;      <span class="comment">//建立连接的函数</span></span><br><span class="line">	shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>); <span class="comment">//当前的server也传进去了</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与客户端连接传给后执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">		new_session-&gt;<span class="built_in">Start</span>();    <span class="comment">//没有问题，直接去执行读写操作</span></span><br><span class="line">		_sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//插入map，方便管理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">StartAccept</span>();    <span class="comment">//连接成功一个后，继续去监听连接，等待其它客户端连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">	_sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):</span><br><span class="line">	_socket(io_context), _server(server)&#123;</span><br><span class="line">	boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------下面是开始执行通信的操作---------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    <span class="comment">//读取客户端发来的信息</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当获取到到客户发送的数据后，会执行该回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, shared_ptr&lt;CSession&gt; _self_shared)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">//全双工的方式，收到数据后，就继续监听</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read data is &quot;</span> &lt;&lt; _data &lt;&lt; endl;   <span class="comment">//收到数据会回调HandleRead函数，直接读出来</span></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="built_in">Send</span>(_data, bytes_transferred);       <span class="comment">//把收到的数据给对端发回去</span></span><br><span class="line">        <span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);        <span class="comment">//发完了把data清掉，方便下一次接收</span></span><br><span class="line">        <span class="comment">//下面又绑定它的接收事件，继续读取客户端发来的数据</span></span><br><span class="line">        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _self_shared));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is end &quot;</span> &lt;&lt; endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);    <span class="comment">//如果出错，就直接通过_uuid清除掉对应的Session</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;   <span class="comment">//接收到数据后，回应对端的函数，参数是发发送的数据和长度</span></span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>; <span class="comment">//先默认将该变量设为false(表示上一次的数据已经发完了),为true表示当前的发送列表里有数据，表示上一次的数据没有发完</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;     <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">if</span> (_send_que.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;   <span class="comment">//判断队列是否为空，不为空，说明上一次发送的数据没有发完，将该变量设为true</span></span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个MsgNode节点，把要发送的数据拷贝到该节点，并将该节点放到队列里(用了深拷贝，数据都存放在自己的空间了)</span></span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;     <span class="comment">//再一次判断是否为true，如果为true，说明有数据没有发完，直接返回(已经把要发送的数据放到队列了)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果为false，说明之前队列是为空的，但刚刚将要发送的数据添加到了队列，所以这一次必须是调用要发送的接口了(因为之前的数据发完了，</span></span><br><span class="line">    <span class="comment">// 必须手动的再调用一次接口，调用一下异步发送，这样我们通过回调函数来处理我们发送的结果)</span></span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msg, max_length), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该回调函数是指定数据都发送完了，才会被调用。当被调用的时候，也说明发送完一个节点的数据，所以下面代码可以直接取出一个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, shared_ptr&lt;CSession&gt; _self_shared)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;   <span class="comment">//加锁</span></span><br><span class="line">        _send_que.<span class="built_in">pop</span>();    <span class="comment">//取出队列首结点，刚刚发送的就是该结点。该函数被调用时，就说明队列的首元素已经发送完了</span></span><br><span class="line">        <span class="comment">//判断发送队列是否为空，为空则发送完，否则不断取出队列数据调用async_write发送，直到队列为空。</span></span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;       <span class="comment">//不为空，就取出队列的首元素，再次调用异步的发送函数</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_max_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, _self_shared));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-粘包处理"><a href="#6-5-粘包处理" class="headerlink" title="6.5 粘包处理"></a>6.5 粘包处理</h2><p>1.粘包问题</p>
<p>粘包问题是服务器收发数据常遇到的一个现象，比如说当客户端发送两个Hello World！给服务器，服务器TCP接收缓冲区接收了两次，一次是Hello World!Hello, 第二次是World！</p>
<p>2.粘包原因</p>
<p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！</p>
<p>3.产生粘包问题其它原因</p>
<ul>
<li>客户端的发送频率远高于服务器的接收频率，就会导致数据在服务器的tcp接收缓冲区滞留形成粘连，比如客户端1s内连续发送了两个hello world！,服务器过了2s才接收数据，那一次性读出两个hello world！</li>
<li>tcp底层的安全和效率机制不允许字节数特别少的小包发送频率过高，tcp会在底层累计数据长度到一定大小才一起发送，比如连续发送1字节的数据要累计到多个字节才发送，可以了解下tcp底层的Nagle算法</li>
<li>再就是我们提到的最简单的情况，发送端缓冲区有上次未发送完的数据或者接收端的缓冲区里有未取出的数据导致数据粘连</li>
</ul>
<blockquote>
<p>解决办法：处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)</p>
</blockquote>
<p>头文件代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span>         <span class="comment">//存放数据的节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">CSession</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//发送时使用的构造函数。参数：一个字符串的首地址；该字符串的长度。初始化数据的总长度(数据+头)，初始化当前发送长度为0</span></span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="number">0</span>)&#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len+<span class="number">1</span>]();  <span class="comment">//自己开辟了一块空间存数据，空间大小是总长度+1 ---&gt;最后面多加一个\0</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, &amp;max_len, HEAD_LENGTH);  <span class="comment">//头节点存有效字符串数据的长度max_len</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len); <span class="comment">//偏移两个字节存有效数据字符串</span></span><br><span class="line">        _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;                  <span class="comment">//最后一个字节空间存\0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收时使用的构造函数。参数：接收数据的长度</span></span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">short</span> max_len):_total_len(max_len),_cur_len(<span class="number">0</span>) &#123;  <span class="comment">//初始化了总长度和当前长度为0</span></span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len +<span class="number">1</span>]();         <span class="comment">//开辟了一块空间，存数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;         <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _cur_len;     <span class="comment">//当前发送或接收数据长度</span></span><br><span class="line">    <span class="type">short</span> _total_len;   <span class="comment">//要发送或接受的数据长度</span></span><br><span class="line">    <span class="type">char</span>* _data;        <span class="comment">//存放数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">    ~<span class="built_in">CSession</span>();</span><br><span class="line">    <span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">int</span> max_length)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    tcp::socket _socket;</span><br><span class="line">    std::string _uuid;</span><br><span class="line">    <span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">    CServer* _server;</span><br><span class="line">    <span class="type">bool</span> _b_close;</span><br><span class="line">    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;</span><br><span class="line">    std::mutex _send_lock;</span><br><span class="line">    <span class="comment">//收到的消息结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;  <span class="comment">//用来存储接收到的有效数据消息体</span></span><br><span class="line">    <span class="type">bool</span> _b_head_parse;                       <span class="comment">//表示头部是否解析完成</span></span><br><span class="line">    <span class="comment">//收到的头部结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_head_node; <span class="comment">//用来存储接收到头部消息体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearSession</span><span class="params">(std::string)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt;, <span class="type">const</span> boost::system::error_code &amp; error)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;</span><br><span class="line">    boost::asio::io_context &amp;_io_context;</span><br><span class="line">    <span class="type">short</span> _port;</span><br><span class="line">    tcp::acceptor _acceptor;</span><br><span class="line">    std::map&lt;std::string, shared_ptr&lt;CSession&gt;&gt; _sessions;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现功能的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数传入ioc和监听的端口号，该函数进行初始化成员变量和建立了服务端的终端端点(开始监听连接)</span></span><br><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port), _acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>); <span class="comment">//创建一个session，并初始化</span></span><br><span class="line">    <span class="comment">//异步连接，阻塞监听客户端，当与客户端建立连接成功后，执行绑定的回调函数HandleAccept</span></span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();     <span class="comment">//如果连接没有问题，开始通信</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//将该session添加到map里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">//连接失败，打印错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();    <span class="comment">//继续监听客户端释放发来连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;   <span class="comment">//当出错或断开连接时，将对应的session移出map</span></span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------下面是通信的代码------------------------------</span></span><br><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):_socket(io_context), _server(server), _b_close(<span class="literal">false</span>),_b_head_parse(<span class="literal">false</span>)&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_LENGTH);</span><br><span class="line">&#125;</span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;    <span class="comment">//获取socket</span></span><br><span class="line">    <span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;      <span class="comment">//获取uuid</span></span><br><span class="line">    <span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;           <span class="comment">//开始通信函数</span></span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())); <span class="comment">//异步读数据，读成功执行回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">int</span> max_length)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_send_que.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;MsgNode&gt;(msg, max_length));</span><br><span class="line">    <span class="keyword">if</span> (pending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _socket.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;send data &quot;</span> &lt;&lt; _send_que.<span class="built_in">front</span>()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span><br><span class="line">        _send_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">            boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;   <span class="comment">//读了数据长度bytes_transferred，执行的该函数，数据放到_data中的</span></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;       <span class="comment">//如果读取数据没有出错</span></span><br><span class="line">        <span class="comment">//已经移动的字符数</span></span><br><span class="line">        <span class="type">int</span> copy_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bytes_transferred&gt;<span class="number">0</span>) &#123;   <span class="comment">//只要读取的数据大于0，执行下面函数</span></span><br><span class="line">            <span class="keyword">if</span> (!_b_head_parse) &#123;     <span class="comment">//头部数据是否处理完，如果没有处理完，执行下面</span></span><br><span class="line">                <span class="comment">//如果这次读的字节数+之前处理完的字节数 &lt; 头部应该收到字节数 ---&gt;这种情况说明这次读到的数据全部头部数据，且头部数据还没有读完</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_LENGTH) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+ copy_len, bytes_transferred); <span class="comment">//直接将这次读的全部数据作为头部数据存到_recv_head_node节点</span></span><br><span class="line">                    _recv_head_node-&gt;_cur_len += bytes_transferred; <span class="comment">//更新头部数据读到的位置</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);  <span class="comment">//将_data清0，下一次继续往这里面存读到的数据</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;  <span class="comment">//1.这种情况就退出，下次读回调触发，继续读头部数据。因为头部数据都没有接收到完毕，就没有必要继续执行下去</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//收到的数据+已经处理的头部数据&gt;头部数据，说明这次收到的数据一部分是头部数据，一部分是真实信息数据</span></span><br><span class="line">                <span class="type">int</span> head_remain = HEAD_LENGTH - _recv_head_node-&gt;_cur_len;  <span class="comment">//获取头部剩余未复制的长度</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data+copy_len, head_remain);   <span class="comment">//将头部剩余未处理的字节数全部存到_recv_head_node头节点</span></span><br><span class="line">                copy_len += head_remain;      <span class="comment">//更新已处理的长度</span></span><br><span class="line">                bytes_transferred -= head_remain;   <span class="comment">//更新剩余未处理的长度，剩余就是真实数据的内容一部分</span></span><br><span class="line">                <span class="comment">//获取头部数据(也就是真实数据的长度)</span></span><br><span class="line">                <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;   <span class="comment">//打印真实数据的长度</span></span><br><span class="line">                <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;      <span class="comment">//判断真实数据的长度是否超出规定长度</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);    <span class="comment">//如果超出规定长度，则直接将其移出map</span></span><br><span class="line">                    <span class="keyword">return</span>;   <span class="comment">//不合法直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果合法，定义一个存放真实数据的MsgNode节点</span></span><br><span class="line">                _recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);</span><br><span class="line">				<span class="comment">//处理完头部数据后，剩余消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; data_len) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//这种情况是剩余未处理的bytes_transferred全部是真实数据的一部分，所以全部copy</span></span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;   <span class="comment">//更新数据节点的当前处理长度</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//将_data清0，继续存放下一次读取的数据</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    _b_head_parse = <span class="literal">true</span>;  <span class="comment">//虽然有效数据长度未处理完成，但头部结点处理完成，设未true</span></span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">//2.这种情况退出后，下次继续执行HandleRead函数，读剩余真实数据(注意：此时_b_head_parse = true;)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//处理完头部数据后，剩余消息的长度大于等于头部规定的长度，说明真实数据收全 或 收全全还出现粘包</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, data_len);  <span class="comment">//这种情况，直接将真实数据长度，全部copy到存放数据的节点_recv_msg_node</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += data_len;    <span class="comment">//更新当前处理长度</span></span><br><span class="line">                copy_len += data_len;            <span class="comment">//更新读到的数据_data里面处理的长度</span></span><br><span class="line">                bytes_transferred -= data_len;   <span class="comment">//更新_data还剩未处理的数据长度</span></span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">//真实数据读完，后面加&#x27;\0&#x27;</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;  <span class="comment">//打印真实数据内容(客户端真实数据的内容)</span></span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);  <span class="comment">//发送给客户端</span></span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;  <span class="comment">//处理完一个，继续下一个，将该变量设为false，表示头部未处理</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();  <span class="comment">//把头部结点进行清除，下一次发送用</span></span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;  <span class="comment">//这种情况是没有粘包(刚刚好真实数据读完，_data就无数据要处理了)</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//下面继续挂起读</span></span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//还有数据，出现粘包情况，退出当前循环，执行下一次循环，继续读(包括从头部数据处理开始)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是已经处理完头部(_b_head_parse为真，没有执行上面的if)，处理上次未接受完的消息数据</span></span><br><span class="line">            <span class="comment">//获取真实数据还未处理的长度</span></span><br><span class="line">            <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;  <span class="comment">//如果读到的数据仍小于剩余未处理的长度，说明下次还要继续读真实数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//这次读的全部数据长度bytes_transferred都是真实数据的一部分</span></span><br><span class="line">                _recv_msg_node-&gt;_cur_len += bytes_transferred;  <span class="comment">//更新当前真实数据处理长度</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);    <span class="comment">//清0，存放下一次读的数据</span></span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;      <span class="comment">//退出，真实数据还没有读完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果读到的数据大于等于剩余未处理的长度，说明真实数据读完了 或 读完了并且粘包</span></span><br><span class="line">            <span class="comment">//下面直接先将真实数据未处理的长度处理完</span></span><br><span class="line">            <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">            _recv_msg_node-&gt;_cur_len += remain_msg;  <span class="comment">//更新真实数据当前处理长度</span></span><br><span class="line">            bytes_transferred -= remain_msg;   <span class="comment">//更新_data处理好真实数据后，还剩余处理长度</span></span><br><span class="line">            copy_len += remain_msg;</span><br><span class="line">            _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//真实数据处理完，加&#x27;\0&#x27;</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;   <span class="comment">//打印客户端发来的内容</span></span><br><span class="line">            <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">            <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);   <span class="comment">//发送给客户端</span></span><br><span class="line">            <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">            _b_head_parse = <span class="literal">false</span>;    <span class="comment">//处理完真实数据后，将该变量设未false,下一次继续从头节点开始处理</span></span><br><span class="line">            _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">            <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;    <span class="comment">//这种情况是没有出现粘包</span></span><br><span class="line">                ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//清0，继续挂起读</span></span><br><span class="line">                _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                <span class="keyword">return</span>;    <span class="comment">//直接退出，挂起了继续读</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">//还有数据，出现粘包情况，退出当前循环，执行下一次循环，继续读(包括从头部数据处理开始)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>boost</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(下)</title>
    <url>/2024/07/19/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="1-beast网络库搭建http服务器"><a href="#1-beast网络库搭建http服务器" class="headerlink" title="1. beast网络库搭建http服务器"></a>1. beast网络库搭建http服务器</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>通过asio来实现http服务器也需要严格服从http报文头的格式，其实http报文头的格式就是为了避免我们之前提到的粘包现象，告诉服务器一个数据包的开始和结尾，并在包头里标识请求的类型如get或post等信息。一个标准的HTTP报文头通常由<strong>请求头</strong>和<strong>响应头</strong>两部分组成。</p>
<p>http请求头格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/<span class="number">1.1</span>     <span class="comment">//包含用于描述请求类型、要访问的资源以及所使用的HTTP版本的信息。</span></span><br><span class="line">Host: www.example.com        <span class="comment">//指定被请求资源的主机名或IP地址和端口号。</span></span><br><span class="line">Accept: text/html, application/xhtml+xml    <span class="comment">//指定客户端能够接收的媒体类型列表，用逗号分隔，例如 text/plain, text/html。</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64; rv:<span class="number">123.0</span>) Gecko/<span class="number">20100101</span> Firefox/<span class="number">123.0</span>    <span class="comment">//客户端使用的浏览器类型和版本号，供服务器统计用户代理信息</span></span><br><span class="line">Cookie: sessionid=abcdefg1234567    <span class="comment">//如果请求中包含cookie信息，则通过这个字段将cookie信息发送给Web服务器。</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要持久连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<p>http响应头格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK            <span class="comment">//包含协议版本、状态码和状态消息</span></span><br><span class="line">Content-Type: text/html; charset=UTF<span class="number">-8</span>    <span class="comment">//响应体的MIME类型</span></span><br><span class="line">Content-Length: <span class="number">1024</span>       <span class="comment">//响应体的字节数</span></span><br><span class="line">Set-Cookie: sessionid=abcdefg1234567; HttpOnly; Path=/      <span class="comment">//服务器向客户端发送cookie信息时使用该字段</span></span><br><span class="line">Server: Apache/<span class="number">2.2</span><span class="number">.32</span> (Unix) mod_ssl/<span class="number">2.2</span><span class="number">.32</span> OpenSSL/<span class="number">1.0</span><span class="number">.1</span>e-fips mod_bwlimited/<span class="number">1.4</span>  <span class="comment">//服务器类型和版本号</span></span><br><span class="line">Connection: keep-alive     <span class="comment">//表示是否需要保持长连接（keep-alive）</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-http服务器实现"><a href="#1-2-http服务器实现" class="headerlink" title="1.2 http服务器实现"></a>1.2 http服务器实现</h2><p>首先需要重新定义boost库的命名空间，并且创建了两个函数，方便后面对程序进行检测。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = beast::http;</span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名一个作用域，程序的声明</span></span><br><span class="line"><span class="keyword">namespace</span> my_program_state &#123;    <span class="comment">//定义了两个全局函数</span></span><br><span class="line">    <span class="comment">//统计对端请求的次数</span></span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">request_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> std::<span class="type">size_t</span> count = <span class="number">0</span>;  <span class="comment">//这个值初始化一次，之后访问都是之前的数据</span></span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到现在的时间戳</span></span><br><span class="line">    <span class="function">std::<span class="type">time_t</span> <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数：负责初始化ip和端口的初始化，启动上下文服务轮询</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> address = net::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> port = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">short</span>&gt;(<span class="number">8080</span>);   <span class="comment">//static_cast是静态转换类型</span></span><br><span class="line">        net::io_context ioc&#123; <span class="number">1</span> &#125;;   <span class="comment">//初始化一个io_context,最多支持一个线程去调度</span></span><br><span class="line">        tcp::acceptor acceptor&#123; ioc,&#123;address,port&#125; &#125;;</span><br><span class="line">        tcp::socket socket&#123; ioc &#125;;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);    <span class="comment">//调用http_server函数，进行http连接</span></span><br><span class="line">        ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_server函数实现：http_server中添加了异步接收连接的逻辑，当有新的连接到来时创建<code>http_connection</code>类型的智能指针,并且启动服务，新连接监听对端接收和发送数据。然后http_server继续监听对端的新连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_server</span><span class="params">(tcp::acceptor&amp; acceptor, tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(socket, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;http_connection&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">start</span>();  <span class="comment">//创建一个http_connection的共享指针，创建好就直接启动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">http_server</span>(acceptor, socket);   <span class="comment">//继续监听连接请求</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http_connection连接类的实现：负责读取对端发来数据的请求头，并且设置响应头，通过异步方式发送回给对端</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;http_connection&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//传入一个socket，构造连接,初始化socket_是通过移动构造完成的</span></span><br><span class="line">    <span class="built_in">http_connection</span>(tcp::socket socket):<span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读请求</span></span><br><span class="line">        <span class="built_in">read_request</span>();</span><br><span class="line">        <span class="comment">//判断超时，保证一个链接不要处理太长时间</span></span><br><span class="line">        <span class="built_in">check_deadline</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    tcp::socket socket_;</span><br><span class="line">    beast::flat_buffer buffer_&#123; <span class="number">8192</span> &#125;;     <span class="comment">//接收数据的缓存</span></span><br><span class="line">    http::request&lt;http::dynamic_body&gt;request_;    <span class="comment">//定义一个请求</span></span><br><span class="line">    http::response&lt;http::dynamic_body&gt;response_;  <span class="comment">//定义一个回应</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//steady_timer是boost提供的一种定时器类型</span></span><br><span class="line">    net::steady_timer deadline_&#123;</span><br><span class="line">        <span class="comment">//初始化调度器</span></span><br><span class="line">        socket_.<span class="built_in">get_executor</span>(), std::chrono::<span class="built_in">seconds</span>(<span class="number">60</span>)  <span class="comment">//初始化一个时钟，60秒调度一次</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_request</span><span class="params">()</span> </span>&#123;  <span class="comment">//读请求函数实现</span></span><br><span class="line">        <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>(); <span class="comment">//不能用make_shared创建，因为通过这种方法创建出来的http_connection不与外面使用的共享引用计数</span></span><br><span class="line">        <span class="comment">//read_request() 函数中的 http::async_read 调用是为了从套接字 socket_ 中异步读取数据到 buffer_ 中，然后解析这些数据到request_对象中。request_ 通常是一个HTTP请求解析器对象，用于解析HTTP请求。</span></span><br><span class="line">        <span class="comment">//参数：当前HTTP连接的套接字；存储读取的数据的缓冲区；回调函数，当异步读取操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_read</span>(socket_, buffer_, request_, [self](beast::error_code ec, std::<span class="type">size_t</span> bytes_transferred) &#123;  <span class="comment">//用作async_read的回调函数，参数：错误码；传输的字节数</span></span><br><span class="line">                boost::<span class="built_in">ignore_unused</span>(bytes_transferred); <span class="comment">//使用Boost库中的ignore_unused宏来告诉编译器忽略未使用的bytes_transferred变量，避免编译警告</span></span><br><span class="line">                <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                    self-&gt;<span class="built_in">process_request</span>();    <span class="comment">//处理请求</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测定时器，判断该定时器有无超时，超时就关闭socket</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_deadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();   <span class="comment">//创建http_connection的一个智能指针，与外部使用的http_connection智能指针是共享引用计数的</span></span><br><span class="line">        <span class="comment">//异步等待，60秒后，会执行匿名函数</span></span><br><span class="line">        deadline_.<span class="built_in">async_wait</span>([self](boost::system::error_code ec) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                self-&gt;socket_.<span class="built_in">close</span>(ec);  <span class="comment">//捕获的智能指针self，保证该匿名函数执行期间，http_connection没有被停止掉</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        response_.<span class="built_in">version</span>(request_.<span class="built_in">version</span>());   <span class="comment">//回应的版本，response_是回应头，回应的版本是响应头使用的版本</span></span><br><span class="line">        response_.<span class="built_in">keep_alive</span>(<span class="literal">false</span>);       <span class="comment">//false表示短连接，true表示长连接</span></span><br><span class="line">        <span class="keyword">switch</span> (request_.<span class="built_in">method</span>()) &#123;   <span class="comment">//检测请求类型</span></span><br><span class="line">        <span class="keyword">case</span> http::verb::get:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_response</span>();     <span class="comment">//创建get类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> http::verb::post:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::ok);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Beast&quot;</span>);   <span class="comment">//回复的数据类型</span></span><br><span class="line">            <span class="built_in">create_post_response</span>();   <span class="comment">//创建post类型的请求回应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::bad_request);    <span class="comment">//返回一个状态</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//回复的是纯文本类型content_type</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;Invalid request-method&#x27;&quot;</span> &lt;&lt; std::<span class="built_in">string</span>(request_.<span class="built_in">method_string</span>()) &lt;&lt; <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无论请求是哪种，最后都需要回应请求</span></span><br><span class="line">        <span class="built_in">write_response</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/count&quot;</span>) &#123;   <span class="comment">//如果路由是/count，就进行统计</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Request count &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;There have been &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">request_count</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;requests so far.&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/time&quot;</span>) &#123;  <span class="comment">//如果路由是/time，就获取当前的时间戳</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;head&gt;&lt;title&gt;Cyrrent time &lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;h1&gt;Request count&lt;/h1&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;p&gt;The current time is &quot;</span></span><br><span class="line">                &lt;&lt; my_program_state::<span class="built_in">now</span>()</span><br><span class="line">                &lt;&lt; <span class="string">&quot;seconds since the epoch..&lt;/p&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/body&gt;\n&quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;    <span class="comment">//没有找到路由(路径地址)</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于异步发送HTTP响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        response_.<span class="built_in">content_length</span>(response_.<span class="built_in">body</span>().<span class="built_in">size</span>());  <span class="comment">//设置HTTP响应的Content-Length 头部字段。这个字段告诉客户端响应体的大小</span></span><br><span class="line">        <span class="comment">//启动一个异步写操作，将HTTP响应发送到客户端。参数：当前HTTP连接的套接字；包含HTTP响应的HTTP消息对象；回调函数，当异步写操作完成时会被调用</span></span><br><span class="line">        http::<span class="built_in">async_write</span>(socket_, response_, [self](beast::error_code ec, std::<span class="type">size_t</span>) &#123;</span><br><span class="line">            self-&gt;socket_.<span class="built_in">shutdown</span>(tcp::socket::shutdown_send);  <span class="comment">//首先调用 shutdown 方法关闭套接字的发送部分。参数表示关闭发送方向，但不关闭接收方向</span></span><br><span class="line">            self-&gt;deadline_.<span class="built_in">cancel</span>();    <span class="comment">//取消任何设置的超时</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_post_response</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request_.<span class="built_in">target</span>() == <span class="string">&quot;/email&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; body = <span class="keyword">this</span>-&gt;request_.<span class="built_in">body</span>();         <span class="comment">//获取HTTP请求的主体部分。</span></span><br><span class="line">            <span class="keyword">auto</span> body_str = boost::beast::<span class="built_in">buffers_to_string</span>(body.<span class="built_in">data</span>());   <span class="comment">//将请求主体的缓冲区数据转换为字符串</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive body is &quot;</span> &lt;&lt; body_str &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">this</span>-&gt;response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/json&quot;</span>);  <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/json&quot;</span></span><br><span class="line">            Json::Value root;         <span class="comment">//创建一个JSON值对象 root，用于构建响应的JSON结构</span></span><br><span class="line">            Json::Reader reader;      <span class="comment">//创建一个JSON读取器对象 reader</span></span><br><span class="line">            Json::Value src_root;     <span class="comment">//创建一个源JSON值对象 src_root，用于存储解析后的JSON数据</span></span><br><span class="line">            <span class="comment">//使用 reader 解析请求主体字符串 body_str 到 src_root，并将解析成功与否存储在 parse_success 变量中</span></span><br><span class="line">            <span class="type">bool</span> parse_success = reader.<span class="built_in">parse</span>(body_str, src_root);</span><br><span class="line">            <span class="keyword">if</span> (!parse_success) &#123;    <span class="comment">//如果解析失败</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Failed to parse Json data&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                root[<span class="string">&quot;error&quot;</span>] = <span class="number">1001</span>;    <span class="comment">//在响应的JSON对象中设置错误代码</span></span><br><span class="line">                std::string jsonstr = root.<span class="built_in">toStyledString</span>();    <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">                beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;    <span class="comment">//将JSON字符串写入响应主体</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果解析成功，从解析后的JSON对象中获取 &quot;email&quot; 字段的值</span></span><br><span class="line">            <span class="keyword">auto</span> email = src_root[<span class="string">&quot;email&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;email is &quot;</span> &lt;&lt; email &lt;&lt; std::endl;</span><br><span class="line">            root[<span class="string">&quot;error&quot;</span>] = <span class="number">0</span>;                     <span class="comment">//在响应的JSON对象中设置错误代码为0，表示成功</span></span><br><span class="line">            root[<span class="string">&quot;email&quot;</span>] = src_root[<span class="string">&quot;email&quot;</span>];     <span class="comment">//将电子邮件地址添加到响应的JSON对象中</span></span><br><span class="line">            root[<span class="string">&quot;mag&quot;</span>] = <span class="string">&quot;receive email post success&quot;</span>;   <span class="comment">//添加一条消息到响应的JSON对象中</span></span><br><span class="line">            std::string jsonstr = root.<span class="built_in">toStyledString</span>();   <span class="comment">//将响应的JSON对象转换为格式化的字符串(序列化)</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; jsonstr;   <span class="comment">////将JSON字符串写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">//如果请求的目标不是 &quot;/email&quot;</span></span><br><span class="line">            response_.<span class="built_in">result</span>(http::status::not_found);   <span class="comment">//设置HTTP响应的状态为 404 Not Found。</span></span><br><span class="line">            response_.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);   <span class="comment">//设置HTTP响应的 Content-Type 头部字段为 &quot;text/plain</span></span><br><span class="line">            beast::<span class="built_in">ostream</span>(response_.<span class="built_in">body</span>()) &lt;&lt; <span class="string">&quot;File not found\r\n&quot;</span>;    <span class="comment">//将 &quot;File not found&quot; 消息写入响应主体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后启动http的服务器，如果本地浏览器输入<code>127.0.0.1:8080/count</code>，进入界面后不断刷新，就可以看到严格计数的效果；如果在本地浏览器输入<code>127.0.0.1:8080/time</code>，也可以获得当前的时间戳；对于实现的post类型请求，需要结合软件完成检测。</p>
<h1 id="2-beast网络库实现websocket服务器"><a href="#2-beast网络库实现websocket服务器" class="headerlink" title="2. beast网络库实现websocket服务器"></a>2. beast网络库实现websocket服务器</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>对于如何使用Beast库实现一个WebSocket服务器，以及如何处理不同类型的请求。具体来说，这句话包含了以下几个要点：</p>
<ul>
<li><p><strong>WebSocket协议和HTTP协议的关系</strong>：WebSocket是一种长连接协议，允许服务器和客户端之间进行双向通信。虽然它是在HTTP协议之上建立的，但它在建立连接后升级为WebSocket协议。</p>
</li>
<li><p><strong>请求的区分</strong>：当在浏览器中输入一个以<code>ws://</code>开头的URL（例如<code>ws://127.0.0.1:9501</code>），浏览器会发起一个WebSocket请求，目标是本地服务器的9501端口。</p>
</li>
<li><p><strong>Beast库的作用</strong>：Beast库提供了处理WebSocket协议的功能。它允许我们在一个HTTP服务器的基础上，通过协议升级的方式来处理WebSocket请求。</p>
</li>
<li><p><strong>请求处理逻辑</strong>：当服务器收到一个请求时，需要判断该请求是普通的HTTP请求还是WebSocket请求。如果是WebSocket请求，服务器将升级协议并处理该请求；如果是普通的HTTP请求，则按HTTP请求处理。</p>
</li>
</ul>
<h2 id="2-2-websocket服务器实现"><a href="#2-2-websocket服务器实现" class="headerlink" title="2.2 websocket服务器实现"></a>2.2 websocket服务器实现</h2><p>主函数实现：负责初始化工作任务需要的内容，并启动上下文服务。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	net::io_context ioc;    <span class="comment">//初始化一个上下文</span></span><br><span class="line">	<span class="function">WebSocketServer <span class="title">server</span><span class="params">(ioc, <span class="number">10086</span>)</span></span>;    <span class="comment">//通过该ioc构建一个server,端口是10086</span></span><br><span class="line">	server.<span class="built_in">StartAccept</span>();   <span class="comment">//执行WebSocketServer的StartAccept()函数，server接收新的连接</span></span><br><span class="line">	ioc.<span class="built_in">run</span>();    <span class="comment">//ioc跑起来，启动事件服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管理类ConnectionMgr实现：在类中创建了一个无序的map容器<code>_map_cons</code>，key值是转化为字符串的uuid值，value值是对应的Connection类型的智能指针。并且定义了两个函数，对容器<code>_map_cons</code>对连接进行加入和删除操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------头文件-------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionMgr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> ConnectionMgr&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;     <span class="comment">//实现单例模式</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span></span>;   <span class="comment">//加入连接</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RmvConnection</span><span class="params">(std::string)</span></span>;                         <span class="comment">//移出连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">ConnectionMgr</span>(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;             <span class="comment">//去除拷贝构造函数</span></span><br><span class="line">	ConnectionMgr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ConnectionMgr&amp;) = <span class="keyword">delete</span>;  <span class="comment">//去除赋值构造函数</span></span><br><span class="line">	<span class="built_in">ConnectionMgr</span>();</span><br><span class="line">	boost::unordered_map&lt;std::string, std::shared_ptr&lt;Connection&gt;&gt;_map_cons;   <span class="comment">//无序map,管理连接</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-----------------------函数初始化---------------------------</span></span><br><span class="line"><span class="function">ConnectionMgr&amp; <span class="title">ConnectionMgr::GetInstance</span><span class="params">()</span> </span>&#123;   <span class="comment">//C++11以上的版本，通过这种方式实现单例模式</span></span><br><span class="line">	<span class="type">static</span> ConnectionMgr instance;    <span class="comment">//定义一个局部变量</span></span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::AddConnection</span><span class="params">(std::shared_ptr&lt;Connection&gt;conptr)</span> </span>&#123;</span><br><span class="line">	_map_cons[conptr-&gt;<span class="built_in">GetUid</span>()] = conptr;     <span class="comment">//将连接的uid和对应的连接通过map来进行管理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConnectionMgr::RmvConnection</span><span class="params">(std::string id)</span> </span>&#123;</span><br><span class="line">	_map_cons.<span class="built_in">erase</span>(id);     <span class="comment">//通过id来删除</span></span><br><span class="line">&#125;</span><br><span class="line">ConnectionMgr::<span class="built_in">ConnectionMgr</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebSocketServer类实现：负责不断监听对端的连接，当与对端建立连接后，就调用Connection类的AsyncAccept函数，将协议升级为了websocket。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//----------------------------头文件----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">WebSocketServer</span>(<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;     <span class="comment">//去除拷贝构造</span></span><br><span class="line">	WebSocketServer&amp; <span class="keyword">operator</span> = (<span class="type">const</span> WebSocketServer&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除赋值构造</span></span><br><span class="line">	<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">StartAccept</span><span class="params">()</span></span>;          <span class="comment">//接收连接，是TCP上的接收连接</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	net::ip::tcp::acceptor _acceptor;    <span class="comment">//接收连接的一个接收器</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------------------函数实现-------------------------------------</span></span><br><span class="line">WebSocketServer::<span class="built_in">WebSocketServer</span>(net::io_context&amp; ioc, <span class="type">unsigned</span> <span class="type">short</span> port) :_ioc(ioc),</span><br><span class="line">_acceptor(ioc, net::ip::tcp::<span class="built_in">endpoint</span>(net::ip::tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Server start on port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;   <span class="comment">//开始连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WebSocketServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> con_ptr = std::<span class="built_in">make_shared</span>&lt;Connection&gt;(_ioc);        <span class="comment">//创建一个Connection类型的智能指针</span></span><br><span class="line">	<span class="comment">//接收连接</span></span><br><span class="line">	_acceptor.<span class="built_in">async_accept</span>(con_ptr-&gt;<span class="built_in">GetSocket</span>(), [<span class="keyword">this</span>, con_ptr](error_code err) &#123; <span class="comment">//GetSocket()返回的是connection最低层的socket(tcp的socket)</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;     <span class="comment">//没有错误</span></span><br><span class="line">				con_ptr-&gt;<span class="built_in">AsyncAccept</span>();    <span class="comment">//相当于升级了，将协议升级为了websocket</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;acceptor async_accept failed, err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;  <span class="comment">//连接失败，打印原因</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">StartAccept</span>();    <span class="comment">//server接收新的连接</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;async_accept error is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Connection类实现：负责将协议生成websocketm，当与对端建立成功后，异步接收数据和异步发送数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------头文件-------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Connection</span> :<span class="keyword">public</span> std::enable_shared_from_this&lt;Connection&gt; &#123;  <span class="comment">//连接通过智能指针去管理，允许从内部去构造智能指针，并且与外部使用的智能指针共享引用计数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Connection</span>(net::io_context&amp; ioc);</span><br><span class="line">	<span class="function">std::string <span class="title">GetUid</span><span class="params">()</span></span>;                <span class="comment">//返回uid</span></span><br><span class="line">	<span class="comment">//connect内部是管理websocket，而websocket底层是通过tcp来实现的，所以它底层有一个socket</span></span><br><span class="line">	net::ip::<span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;   <span class="comment">//该函数返回该底层的socket(外面可能会用到)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncAccept</span><span class="params">()</span></span>;    <span class="comment">//在tcp层面建立好连接后，还要在websocket层面做一个升级，升级就可以调用这个异步的连接函数进行升级</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;           <span class="comment">//接收对端的数据的，进行收发的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">AsyncSend</span><span class="params">(std::string msg)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::unique_ptr&lt;stream&lt;tcp_stream&gt;&gt;_ws_ptr;   <span class="comment">//用unique_ptr管理外部websocket</span></span><br><span class="line">	std::string _uuid;      <span class="comment">//有唯一的id</span></span><br><span class="line">	net::io_context&amp; _ioc;</span><br><span class="line">	flat_buffer _recv_buffer;        <span class="comment">//存储接收的数据</span></span><br><span class="line">	std::queue&lt;std::string&gt;_send_que;    <span class="comment">//发送队列</span></span><br><span class="line">	std::mutex _send_mtx;      <span class="comment">//发送的一个锁</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------函数实现--------------------------------------</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>(net::io_context&amp; ioc):_ioc(ioc),</span><br><span class="line">_ws_ptr(std::make_unique&lt;stream&lt;tcp_stream&gt;&gt;(<span class="built_in">make_strand</span>(ioc)))  <span class="comment">//构造一个stream&lt;tcp_stream&gt;类型的智能指针。通过上下文构造一个strand执行器，则这里的执行器与上下文的执行器就是同一个了</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//生成唯一的uuid</span></span><br><span class="line">	boost::uuids::random_generator generator;   <span class="comment">//生成generator</span></span><br><span class="line">	boost::uuids::uuid uuid = <span class="built_in">generator</span>();      <span class="comment">//通过generator来生成唯一的uuid</span></span><br><span class="line">	_uuid = boost::uuids::<span class="built_in">to_string</span>(uuid);      <span class="comment">//为了存储该uuid,需要转换为string类型</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">Connection::GetUid</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line">net::ip::<span class="function">tcp::socket&amp; <span class="title">Connection::GetSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//socket()是会返回websocket内部管理的最底层的socket的引用，只要的wensocke不被释放，返回的socket也不会被释放</span></span><br><span class="line">	<span class="keyword">return</span> boost::beast::<span class="built_in">get_lowest_layer</span>(*_ws_ptr).<span class="built_in">socket</span>();  <span class="comment">//返回智能指针_ws_ptr所指向的websocket的最底层(是tcp类型的socket)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步的接收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//生成一个自己的智能指针，通过这种方式生成的智能指针和其它的共享指针共享引用计数</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();    <span class="comment">//其它智能指针可能也在管理connection，为了不与它们同步引用计数，所以需要shared_from_this</span></span><br><span class="line">	<span class="comment">//websocket异步接收连接,结果相当于是在tcp的基础上，将协议生成websocket</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_accept</span>([self](boost::system::error_code err) &#123;  <span class="comment">//防止回调函数在没有调用之前，connection被智能指针释放掉，所以需要它的引用计数+1</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!err) &#123;   <span class="comment">//没有错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">AddConnection</span>(self); <span class="comment">//添加连接，将self智能指针加到管理类来管理</span></span><br><span class="line">				self-&gt;<span class="built_in">Start</span>();             <span class="comment">//接收读写</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket accept failed,err is&quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket async accept exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">	<span class="comment">//异步读</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_read</span>(_recv_buffer, [self](error_code err, std::<span class="type">size_t</span> buffer_bytes) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (err) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;websocket async read error is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl; <span class="comment">//打印错误信息</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			self-&gt;_ws_ptr-&gt;<span class="built_in">text</span>(self-&gt;_ws_ptr-&gt;<span class="built_in">got_text</span>());   <span class="comment">//设置传输的类型，默认是对方发什么，就回什么类型</span></span><br><span class="line">			std::string recv_data = boost::beast::<span class="built_in">buffers_to_string</span>(self-&gt;_recv_buffer.<span class="built_in">data</span>()); <span class="comment">//存储收到的数据，并将收到的buffer类型数据转成string类型</span></span><br><span class="line">			self-&gt;_recv_buffer.<span class="built_in">consume</span>(self-&gt;_recv_buffer.<span class="built_in">size</span>());    <span class="comment">//清空_recv_buffer，为下次接收准备</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;websocket recvive msg is &quot;</span> &lt;&lt; recv_data &lt;&lt; std::endl;      <span class="comment">//打印接收的数据</span></span><br><span class="line">			<span class="comment">//发送操作</span></span><br><span class="line">			self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(recv_data));   <span class="comment">//异步发送，为了减少拷贝，用move()操作</span></span><br><span class="line">			self-&gt;<span class="built_in">Start</span>();        <span class="comment">//发送完，就继续监听对方发送数据</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span> (std::exception&amp; exp) &#123;    <span class="comment">//接收异常</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; exp.<span class="built_in">what</span>() &lt;&lt; std::endl;    <span class="comment">//打印错误信息</span></span><br><span class="line">			ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());   <span class="comment">//将该连接从管理者移出</span></span><br><span class="line">		&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Connection::AsyncSend</span><span class="params">(std::string msg)</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(_send_mtx);    <span class="comment">//对队列加锁</span></span><br><span class="line">		<span class="type">int</span> que_len = _send_que.<span class="built_in">size</span>();            <span class="comment">//取出队列的长度</span></span><br><span class="line">		_send_que.<span class="built_in">push</span>(msg);                       <span class="comment">//往队列添加发送的数据</span></span><br><span class="line">		<span class="keyword">if</span> (que_len &gt; <span class="number">0</span>) &#123;             <span class="comment">//如果没有放入队列之前，队列长度&gt;0，说明之前数据没有发送完，直接退出</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;    <span class="comment">//执行到这里的时候，进行析构，自动解锁</span></span><br><span class="line">	<span class="keyword">auto</span> self = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    <span class="comment">//创建一个buffer，参数是消息的首地址，长度和lambda表达式(捕获发送对方的结果)</span></span><br><span class="line">	_ws_ptr-&gt;<span class="built_in">async_write</span>(boost::asio::<span class="built_in">buffer</span>(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>()), [self](error_code err, std::<span class="type">size_t</span> nsize) &#123;   <span class="comment">//错误码 和 没有发生错误情况下，发送了多少</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (err) &#123;</span><br><span class="line">					std::cout &lt;&lt; <span class="string">&quot;async_send err is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">					ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;<span class="built_in">GetUid</span>());     <span class="comment">//通过uid移出连接</span></span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				std::string send_msg;</span><br><span class="line">				&#123;   <span class="comment">//局部作用域</span></span><br><span class="line">					std::lock_guard&lt;std::mutex&gt;<span class="built_in">lck_guard</span>(self-&gt;_send_mtx);   <span class="comment">//对队列加锁</span></span><br><span class="line">					self-&gt;_send_que.<span class="built_in">pop</span>();        <span class="comment">//弹出队列首元素(上面的异步发送，是发送完成才回执行到这里)，队首的元素就是刚刚发送完毕的</span></span><br><span class="line">					<span class="keyword">if</span> (self-&gt;_send_que.<span class="built_in">empty</span>()) &#123;     <span class="comment">//再判断队列是否为空</span></span><br><span class="line">						<span class="keyword">return</span>;       <span class="comment">//为空就返回</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//不为空，说明还有数据，需要继续发送</span></span><br><span class="line">					send_msg = self-&gt;_send_que.<span class="built_in">front</span>();     <span class="comment">//把队首元素进行一个拷贝</span></span><br><span class="line">				&#125;  <span class="comment">//自动解锁</span></span><br><span class="line">				self-&gt;<span class="built_in">AsyncSend</span>(std::<span class="built_in">move</span>(send_msg)); <span class="comment">//异步发送，这里的移动操作字符串对于系统来说，差别不大，如果是结构体，用move效果会明显一点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">catch</span> (std::exception&amp; exp) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;async_send exception is &quot;</span> &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; std::endl;   <span class="comment">//打印错误</span></span><br><span class="line">				ConnectionMgr::<span class="built_in">GetInstance</span>().<span class="built_in">RmvConnection</span>(self-&gt;_uuid);     <span class="comment">//通过uid将异常连接移出</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-执行效果"><a href="#2-3-执行效果" class="headerlink" title="2.3 执行效果"></a>2.3 执行效果</h2><p>1.启动服务器后，会跳出如下页面，这也表示服务器开始监听对端发来的连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_7.png"></p>
<p>2.在WebSocket的一个在线测试网站进行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_8.png"></p>
<p>3.点击发送，接收服务器发送来的信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_9.png"></p>
<p>4.服务器终端情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_10.png"></p>
<h1 id="3-windows配置和使用grpc"><a href="#3-windows配置和使用grpc" class="headerlink" title="3. windows配置和使用grpc"></a>3. windows配置和使用grpc</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>当在windows环境配置好grpc，接下来是使用visual studio配置grpc，可以将之前编译好的库配置到项目中来完成grpc通信。</p>
<h2 id="3-2-项目配置"><a href="#3-2-项目配置" class="headerlink" title="3.2 项目配置"></a>3.2 项目配置</h2><p>1.创建Grpc-Server项目，在项目的根目录下创建一个名字为<code>demo.proto</code>的文件，编写程序如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">rpc</span> SayHello(HelloRequest) <span class="keyword">returns</span>(HelloReply)</span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span>&#123;</span><br><span class="line">	<span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在<code>demo.proto</code>所在文件打开Powershell窗口(终端好像也可)，然后利用grpc编译后生成的<code>proc.exe</code>生成proto的头文件和源文件，即执行如下命令生成<code>demo.grpc.pb.h</code>和<code>demo.grpc.pb.cc</code>文件(这两个文件是为grpc服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe  <span class="literal">-I</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--grpc_out</span>=<span class="string">&quot;.&quot;</span> <span class="literal">--plugin</span>=protoc<span class="literal">-gen-grpc</span>=<span class="string">&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</span> <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>命令解释：</p>
<ul>
<li><p><code>C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe</code>：是存放protoc.exe所在的路径，也可以将其配置到环境变量，然后直接使用protoc.exe就行</p>
</li>
<li><p><code>-I=&quot;.&quot;</code> ：指定 <code>demo.proto</code>所在的路径为当前路径</p>
</li>
<li><p><code>--grpc_out=&quot;.&quot;</code> ：表示生成的pb.h和pb.cc文件的输出位置为当前目录</p>
</li>
<li><p><code>--plugin=protoc-gen-grpc=&quot;C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot;</code>：表示要用到的插件是<code>protoc-gen-grpc</code>，位置在<code>C:\cppsoft\grpc\visualpro\Debug\grpc_cpp_plugin.exe</code></p>
</li>
<li><p><code>&quot;demo.proto&quot;</code>：要编译的proto文件</p>
</li>
</ul>
<p>3.因为要序列化数据，所以需要生成grpc类需要的pb文件，即在demo.proto所在目录下打开powershell窗口，执行如下命令，就会生成demo.pb.h和demo.pb.cc文件(这两个文件是为消息服务的)。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug\protoc.exe <span class="literal">--cpp_out</span>=. <span class="string">&quot;demo.proto&quot;</span></span><br></pre></td></tr></table></figure>

<p>4.为项目中配置grpc库的包含目录和库目录。先配置Debug版本，方便调试。</p>
<p>右键vs里面的项目，选择：属性 —&gt; c&#x2F;c++ — &gt; 常规 —&gt; 附加包含目录 —&gt; 编辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_11.png"></p>
<p>点击编辑后，在弹出的窗口中添加如下文件目录(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\include</span><br><span class="line">C:\cppsoft\grpc\third_party\protobuf\src</span><br><span class="line">C:\cppsoft\grpc\third_party\abseil-cpp</span><br><span class="line">C:\cppsoft\grpc\third_party\address_sorting\include</span><br><span class="line">C:\cppsoft\grpc\third_party\re2</span><br></pre></td></tr></table></figure>

<p>5.再配置库路径, 选择：链接器 —&gt; 常规 —&gt; 附加库目录 —&gt; 编辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_12.png"></p>
<p>点击编辑后，在弹出的窗口添加以下路径(根据自己存放的文件目录添加)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\cppsoft\grpc\visualpro\third_party\re2\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\types\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\synchronization\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\status\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\random\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\flags\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\debugging\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\container\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\hash\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\boringssl-with-bazel\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\numeric\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\time\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\base\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\abseil-cpp\absl\strings\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\protobuf\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\zlib\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\Debug</span><br><span class="line">C:\cppsoft\grpc\visualpro\third_party\cares\cares\lib\Debug</span><br></pre></td></tr></table></figure>

<p>6.配置好库目录后，还要将要使用的库链接到项目。选择：链接器 —&gt; 输入 —&gt; 附加依赖项 —&gt; 编辑</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_13.png"></p>
<p>点击编辑后，在弹出的窗口添加依赖的库名字(以下)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libprotobufd.lib</span><br><span class="line">gpr.lib</span><br><span class="line">grpc.lib</span><br><span class="line">grpc++.lib</span><br><span class="line">grpc++_reflection.lib</span><br><span class="line">address_sorting.lib</span><br><span class="line">ws2_32.lib</span><br><span class="line">cares.lib</span><br><span class="line">zlibstaticd.lib</span><br><span class="line">upb.lib</span><br><span class="line">ssl.lib</span><br><span class="line">crypto.lib</span><br><span class="line">absl_bad_any_cast_impl.lib</span><br><span class="line">absl_bad_optional_access.lib</span><br><span class="line">absl_bad_variant_access.lib</span><br><span class="line">absl_base.lib</span><br><span class="line">absl_city.lib</span><br><span class="line">absl_civil_time.lib</span><br><span class="line">absl_cord.lib</span><br><span class="line">absl_debugging_internal.lib</span><br><span class="line">absl_demangle_internal.lib</span><br><span class="line">absl_examine_stack.lib</span><br><span class="line">absl_exponential_biased.lib</span><br><span class="line">absl_failure_signal_handler.lib</span><br><span class="line">absl_flags.lib</span><br><span class="line">absl_flags_config.lib</span><br><span class="line">absl_flags_internal.lib</span><br><span class="line">absl_flags_marshalling.lib</span><br><span class="line">absl_flags_parse.lib</span><br><span class="line">absl_flags_program_name.lib</span><br><span class="line">absl_flags_usage.lib</span><br><span class="line">absl_flags_usage_internal.lib</span><br><span class="line">absl_graphcycles_internal.lib</span><br><span class="line">absl_hash.lib</span><br><span class="line">absl_hashtablez_sampler.lib</span><br><span class="line">absl_int128.lib</span><br><span class="line">absl_leak_check.lib</span><br><span class="line">absl_leak_check_disable.lib</span><br><span class="line">absl_log_severity.lib</span><br><span class="line">absl_malloc_internal.lib</span><br><span class="line">absl_periodic_sampler.lib</span><br><span class="line">absl_random_distributions.lib</span><br><span class="line">absl_random_internal_distribution_test_util.lib</span><br><span class="line">absl_random_internal_pool_urbg.lib</span><br><span class="line">absl_random_internal_randen.lib</span><br><span class="line">absl_random_internal_randen_hwaes.lib</span><br><span class="line">absl_random_internal_randen_hwaes_impl.lib</span><br><span class="line">absl_random_internal_randen_slow.lib</span><br><span class="line">absl_random_internal_seed_material.lib</span><br><span class="line">absl_random_seed_gen_exception.lib</span><br><span class="line">absl_random_seed_sequences.lib</span><br><span class="line">absl_raw_hash_set.lib</span><br><span class="line">absl_raw_logging_internal.lib</span><br><span class="line">absl_scoped_set_env.lib</span><br><span class="line">absl_spinlock_wait.lib</span><br><span class="line">absl_stacktrace.lib</span><br><span class="line">absl_status.lib</span><br><span class="line">absl_strings.lib</span><br><span class="line">absl_strings_internal.lib</span><br><span class="line">absl_str_format_internal.lib</span><br><span class="line">absl_symbolize.lib</span><br><span class="line">absl_synchronization.lib</span><br><span class="line">absl_throw_delegate.lib</span><br><span class="line">absl_time.lib</span><br><span class="line">absl_time_zone.lib</span><br><span class="line">absl_statusor.lib</span><br><span class="line">re2.lib</span><br></pre></td></tr></table></figure>

<p>当完成这些配置，就可以通过grpc来进行服务器和客户端的通信了。</p>
<h1 id="4-grpc通信"><a href="#4-grpc通信" class="headerlink" title="4. grpc通信"></a>4. grpc通信</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>gRPC(Remote Procedure Call)是一种高性能、开源的远程过程调用(RPC)框架。它能够在不同的环境中进行跨语言的通信，并且使用HTTP&#x2F;2作为其传输协议，提供诸如负载均衡、跟踪、健康检查和认证等功能。</p>
<p>gRPC通信过程包括服务器端和客户端的代码，其中通过协议定义文件(proto文件)来定义消息格式和服务接口。</p>
<h2 id="4-2-proto文件"><a href="#4-2-proto文件" class="headerlink" title="4.2 proto文件"></a>4.2 proto文件</h2><p>proto文件定义了通信协议的消息格式和服务接口。在这里的proto文件定义了一个名为<code>hello</code>的包，包含一个<code>Greeter</code>服务和两个消息类型<code>HelloRequest</code>和<code>HelloReply</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;      <span class="comment">//声明的proto的版本</span></span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给外部提供服务的，可以生成一个Greeter对象，外部可以调用这个接口，Greeter就可以返回对应的消息</span></span><br><span class="line">service Greeter&#123;</span><br><span class="line">	<span class="function">rpc <span class="title">SayHello</span><span class="params">(HelloRequest)</span> <span class="title">returns</span><span class="params">(HelloReply)</span></span>&#123;&#125;    <span class="comment">//定义一个接口(一个请求，一个回包)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个请求的消息体</span></span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">	string message = <span class="number">1</span>;    <span class="comment">//第一个是string类型的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个回复的消息体</span></span><br><span class="line">message HelloReply&#123;</span><br><span class="line">	string message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-服务器实现"><a href="#4-3-服务器实现" class="headerlink" title="4.3 服务器实现"></a>4.3 服务器实现</h2><p>服务器代码实现了proto文件中定义的<code>Greeter</code>服务。服务器启动后，监听指定的端口，等待客户端的请求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用grpc的一些作用域</span></span><br><span class="line"><span class="keyword">using</span> grpc::Server;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerBuilder;</span><br><span class="line"><span class="keyword">using</span> grpc::ServerContext;      <span class="comment">//server上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> hello::Greeter;   <span class="comment">//要用到的一个服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//final表示终极的继承，GreeterServicelmpl继承public Greeter::Service后，其它的类就不能再继承了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreeterServicelmpl</span> <span class="keyword">final</span> :<span class="keyword">public</span> Greeter::Service &#123;</span><br><span class="line">    <span class="comment">//Status是返回的一个状态，grpc服务给别人提供调用的接口，都会返回一个状态</span></span><br><span class="line">    ::<span class="function">grpc::Status <span class="title">SayHello</span><span class="params">(::grpc::ServerContext* ccontext, <span class="type">const</span>::hello::HelloRequest* request, ::hello::HelloReply* response)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">prefix</span><span class="params">(<span class="string">&quot;llfc grpc server has received:&quot;</span>)</span></span>;</span><br><span class="line">        response-&gt;<span class="built_in">set_message</span>(prefix + request-&gt;<span class="built_in">message</span>());    <span class="comment">//修改一下回应(进行拼接)</span></span><br><span class="line">        <span class="keyword">return</span> Status::OK;     <span class="comment">//返回一个状态</span></span><br><span class="line">    &#125;  <span class="comment">//重写了父类Greeter的一个Service函数接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">server_address</span><span class="params">(<span class="string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;</span><br><span class="line">    GreeterServicelmpl service;</span><br><span class="line">    ServerBuilder builder;    <span class="comment">//创建服务的时候，需要ServerBuilder(规则)</span></span><br><span class="line">    builder.<span class="built_in">AddListeningPort</span>(server_address, grpc::<span class="built_in">InsecureServerCredentials</span>());   <span class="comment">//绑定端口。</span></span><br><span class="line">    builder.<span class="built_in">RegisterService</span>(&amp;service);     <span class="comment">//注册服务，将该服务注册给builder。服务就可以在后台执行了</span></span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Server&gt;<span class="built_in">server</span>(builder.<span class="built_in">BuildAndStart</span>());   <span class="comment">//将端口和服务都绑定好的builder传递给server，</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;</span><br><span class="line">    server-&gt;<span class="built_in">Wait</span>();    <span class="comment">//阻塞，底层轮询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RunServer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补：<code>127.0.0.1</code>和<code>0.0.0.0</code>的区别：<code>127.0.0.0</code>是本地回路地址，不能网络，如果是本地客户端请求本地服务器，是可以的，但其它客户端访问不到。</p>
<h2 id="4-4-客户端实现"><a href="#4-4-客户端实现" class="headerlink" title="4.4 客户端实现"></a>4.4 客户端实现</h2><p>客户端代码创建一个与服务器通信的通道，通过这个通道，客户端可以调用服务器提供的服务(如<code>SayHello</code>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> grpc::ClientContext;     <span class="comment">//Clinent的上下文</span></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;         <span class="comment">//发送消息，需要通道，通过该通道与服务器通信</span></span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> hello::HelloReply;</span><br><span class="line"><span class="keyword">using</span> hello::HelloRequest;</span><br><span class="line"><span class="keyword">using</span> hello::Greeter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端不用继承服务，直接写即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FCClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//参数是通道类型，利用通道与服务端通信</span></span><br><span class="line">    <span class="built_in">FCClient</span>(std::shared_ptr&lt;Channel&gt;channel) :<span class="built_in">stub_</span>(Greeter::<span class="built_in">NewStub</span>(channel)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">SayHello</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">        ClientContext context;       <span class="comment">//构造客户端的上下文</span></span><br><span class="line">        HelloReply reply;            <span class="comment">//回复</span></span><br><span class="line">        HelloRequest request;        <span class="comment">//请求</span></span><br><span class="line">        request.<span class="built_in">set_message</span>(name);     <span class="comment">//设置消息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置好请求，下面是发过去</span></span><br><span class="line">        <span class="comment">//客户端发送消息，把request字符串通过protobuf序列化发送给服务器，服务器把数据修改好后，传回来，客户端收到数据后存到reply里</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">SayHello</span>(&amp;context, request, &amp;reply);   <span class="comment">//调用的是服务端的SayHello,对reply进行了修改，所以这里第三个参数传的是地址</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> reply.<span class="built_in">message</span>();    <span class="comment">//收到对方回应，如果是正常的就返回字符串即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;failure &quot;</span> + status.<span class="built_in">error_message</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;Greeter::Stub&gt;stub_;    <span class="comment">//stub_可以理解为客户端</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行通信就必须创建channel管道，相当于是asio里面的端点，与谁通信</span></span><br><span class="line">    <span class="keyword">auto</span> channel = grpc::<span class="built_in">CreateChannel</span>(<span class="string">&quot;127.0.0.1:50051&quot;</span>, grpc::<span class="built_in">InsecureChannelCredentials</span>());</span><br><span class="line">    <span class="function">FCClient <span class="title">client</span><span class="params">(channel)</span></span>;</span><br><span class="line">    <span class="comment">//客户端调用了SayHello函数，把参数(字符串消息)传给了服务器，返回服务器的发过来的数据</span></span><br><span class="line">    std::string result = client.<span class="built_in">SayHello</span>(<span class="string">&quot;hello lxx93.online!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get result [%s]\n&quot;</span>, result.<span class="built_in">c_str</span>());   <span class="comment">//打印获取的消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-通信过程"><a href="#4-5-通信过程" class="headerlink" title="4.5 通信过程"></a>4.5 通信过程</h2><p>1.定义服务接口和消息格式</p>
<ul>
<li>在proto文件中，定义了一个名为<code>Greeter</code>的服务，包含一个RPC方法<code>SayHello</code>，该方法接受一个<code>HelloRequest</code>消息并返回一个<code>HelloReply</code>消息。</li>
</ul>
<p>2.生成代码</p>
<ul>
<li>使用protoc编译器从proto文件生成C++代码，包括消息类(如<code>HelloRequest</code>和<code>HelloReply</code>)和服务接口类(如<code>Greeter::Service</code>)</li>
</ul>
<p>3.实现服务器逻辑</p>
<ul>
<li>在服务器端，继承生成的<code>Greeter::Service</code>类，并实现<code>SayHello</code>方法。这个方法接收客户端的请求(<code>HelloRequest</code>)，处理后返回响应(<code>HelloReply</code>)。</li>
</ul>
<p>4.启动服务器</p>
<ul>
<li>服务器代码使用<code>ServerBuilder</code>配置和启动gRPC服务器，并在指定端口上监听客户端请求。</li>
</ul>
<p>5.客户端调用</p>
<ul>
<li>客户端创建一个通道，通过这个通道与服务器通信。客户端创建一个<code>Greeter::Stub</code>对象，这是一个客户端代理，通过它调用服务器端的<code>SayHello</code>方法。</li>
</ul>
<ul>
<li>在客户端调用<code>SayHello</code>方法时，客户端将<code>HelloRequest</code>消息序列化并发送给服务器。服务器接收请求后，处理并返回<code>HelloReply</code>消息。客户端接收响应并解码得到结果。</li>
</ul>
<h2 id="4-6-为什么客户端可以调用服务端的函数"><a href="#4-6-为什么客户端可以调用服务端的函数" class="headerlink" title="4.6 为什么客户端可以调用服务端的函数"></a>4.6 为什么客户端可以调用服务端的函数</h2><p>客户端并不直接调用服务端的函数，而是通过gRPC框架生成的客户端存根(stub)来间接调用。客户端调用存根的<code>SayHello</code>方法，gRPC框架负责处理网络通信，将请求发送到服务器，并接收服务器的响应。</p>
<p>步骤如下(结合上面编写的服务器和客户端)：</p>
<ol>
<li><p>客户端构建请求：创建并填充<code>HelloRequest</code>消息。</p>
</li>
<li><p>发送请求：通过调用<code>stub_-&gt;SayHello</code>将请求发送到服务器。</p>
</li>
<li><p>服务器处理请求：服务器接收请求，调用<code>GreeterServiceImpl::SayHello</code>方法进行处理，并构建<code>HelloReply</code>响应。</p>
</li>
<li><p>发送响应：服务器将响应发送回客户端。</p>
</li>
<li><p>客户端接收响应：客户端接收并解析<code>HelloReply</code>消息，从而得到服务器处理后的结果</p>
</li>
</ol>
]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>boost</tag>
        <tag>IOServicePool</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++全栈聊天项目</title>
    <url>/2024/08/29/c++%E5%85%A8%E6%A0%88%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本项目为c++全栈聊天项目实战，包括PC端QT界面编程，asio异步服务器设计，beast网络库搭建http网关，nodejs搭建验证服务，各服务间用grpc通信，server和client用asio通信等，也包括用户信息的录入等，实现跨平台设计，先设计windows的server，之后再考虑移植到linux中，较为全面的展示c++在实际项目中的应用。</p>
<p>在QT创建一个主界面：</p>
<p>新建—&gt;Application—&gt;Qt Widgets Application—&gt;项目名称为lxxchat—&gt;类名为MainWindow—&gt;基类为QMainWindow</p>
<p>创建一个登录的对话框：</p>
<p>新建—&gt;Qt—&gt;Qt设计师界面类—&gt;选择界面模板：Dialog without Buttons—&gt;类名为：LoginDialog—&gt;</p>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly主题美化</title>
    <url>/2024/07/19/butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-页面底部footer跳动的心"><a href="#1-页面底部footer跳动的心" class="headerlink" title="1. 页面底部footer跳动的心"></a>1. 页面底部footer跳动的心</h1><h2 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h2><p>编辑C:\blog\themes\Butterfly\layout\includes\footer.pug文件</p>
<p>1.将以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125; By $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;theme.footer.owner.since&#125; - $&#123;nowYear + &#x27; &#x27;&#125; <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">&quot;heartbeat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>2.将以下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;nowYear&#125; By $&#123;config.author&#125; </span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;copy;</span>$&#123;nowYear + &#x27; &#x27;&#125; <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">&quot;heartbeat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> $&#123;config.author&#125;</span><br></pre></td></tr></table></figure>

<p>3.将以下内容添加到footer.pug文件的最后一行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-效果图"><a href="#1-2-效果图" class="headerlink" title="1.2 效果图"></a>1.2 效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_1.png"></p>
<h1 id="2-修改标题样式"><a href="#2-修改标题样式" class="headerlink" title="2. 修改标题样式"></a>2. 修改标题样式</h1><h2 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h2><p>1.在C:\blog\source\css文件下新建 css 文件，并命名为 custom.css(文件名没有严格要求)，将以下代码复制到新建的custom.css中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#article-container h1:before,</span><br><span class="line">#article-container h2:before,</span><br><span class="line">#article-container h3:before,</span><br><span class="line">#article-container h4:before,</span><br><span class="line">#article-container h5:before,</span><br><span class="line">#article-container h6:before,</span><br><span class="line">#post .post-outdate-notice:before,</span><br><span class="line">.fontawesomeIcon,</span><br><span class="line">.note:not(.no-icon)::before,</span><br><span class="line">hr:before &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    font-weight: 600;</span><br><span class="line">    font-style: normal;</span><br><span class="line">    font-variant: normal;</span><br><span class="line">    font-family: &#x27;Font Awesome 5 Free&#x27;;</span><br><span class="line">    text-rendering: auto;</span><br><span class="line">    -webkit-font-smoothing: antialiased</span><br><span class="line">&#125;</span><br><span class="line">#article-container h1:before,</span><br><span class="line">#article-container h2:before,</span><br><span class="line">#article-container h3:before,</span><br><span class="line">#article-container h4:before,</span><br><span class="line">#article-container h5:before,</span><br><span class="line">#article-container h6:before &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    color: #f47466;</span><br><span class="line">    /* 回形针 */</span><br><span class="line">    content: &#x27;\f0c1&#x27;;  </span><br><span class="line">    line-height: 1;</span><br><span class="line">    -webkit-transition: all .2s ease-out;</span><br><span class="line">    -moz-transition: all .2s ease-out;</span><br><span class="line">    -o-transition: all .2s ease-out;</span><br><span class="line">    -ms-transition: all .2s ease-out;</span><br><span class="line">    transition: all .2s ease-out;</span><br><span class="line">    /* 若要使用风车效果，请去掉下面的注释 */</span><br><span class="line">    /* content: &#x27;\f863&#x27;; </span><br><span class="line">    animation: avatar_turn_around 1s linear infinite; */</span><br><span class="line">&#125;</span><br><span class="line">#article-container h1 &#123;</span><br><span class="line">    padding-left: 1.4rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1 code &#123;</span><br><span class="line">    font-size: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1:before &#123;</span><br><span class="line">    margin-left: -1.3rem;</span><br><span class="line">    top: calc(50% - .5rem);</span><br><span class="line">    font-size: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h1:hover &#123;</span><br><span class="line">    padding-left: 1.6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2 &#123;</span><br><span class="line">    padding-left: 1.3rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2 code &#123;</span><br><span class="line">    font-size: .9rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2:before &#123;</span><br><span class="line">    margin-left: -1.4rem;</span><br><span class="line">    top: calc(50% - .45rem);</span><br><span class="line">    font-size: .9rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h2:hover &#123;</span><br><span class="line">    padding-left: 1.5rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3 &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3 code &#123;</span><br><span class="line">    font-size: .8rem;</span><br><span class="line">    top: calc(50% - .4rem);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3:before &#123;</span><br><span class="line">    margin-left: -1.2rem;</span><br><span class="line">    top: calc(50% - .4rem);</span><br><span class="line">    font-size: .8rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h3:hover &#123;</span><br><span class="line">    padding-left: 1.4rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4 &#123;</span><br><span class="line">    padding-left: 1.1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4 code &#123;</span><br><span class="line">    font-size: .7rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4:before &#123;</span><br><span class="line">    margin-left: -1rem;</span><br><span class="line">    top: calc(50% - .35rem);</span><br><span class="line">    font-size: .7rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h4:hover &#123;</span><br><span class="line">    padding-left: 1.3rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5 &#123;</span><br><span class="line">    padding-left: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5 code &#123;</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5:before &#123;</span><br><span class="line">    margin-left: -.8rem;</span><br><span class="line">    top: calc(50% - .3rem);</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h5:hover &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6 &#123;</span><br><span class="line">    padding-left: 1rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6 code &#123;</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6:before &#123;</span><br><span class="line">    margin-left: -.8rem;</span><br><span class="line">    top: calc(50% - .3rem);</span><br><span class="line">    font-size: .6rem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#article-container h6:hover &#123;</span><br><span class="line">    padding-left: 1.2rem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在主题配置文件_config.butterfly.yml中的以下位置引入刚刚创建的css文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom.css&quot;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2-效果"><a href="#2-2-效果" class="headerlink" title="2.2 效果"></a>2.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_2.png"></p>
<h1 id="3-哔哩哔哩番剧页面插件"><a href="#3-哔哩哔哩番剧页面插件" class="headerlink" title="3. 哔哩哔哩番剧页面插件"></a>3. 哔哩哔哩番剧页面插件</h1><h2 id="3-1-步骤"><a href="#3-1-步骤" class="headerlink" title="3.1 步骤"></a>3.1 步骤</h2><p>1.安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-bilibili-bangumi --save</span><br></pre></td></tr></table></figure>

<p>2.修改站点配置文件_config.yml，添加如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">bangumi: # 追番设置</span></span><br><span class="line">  enable: true</span><br><span class="line">  path:</span><br><span class="line">  vmid: 483341512</span><br><span class="line">  title: &#x27;生命不息，追番不止！&#x27;</span><br><span class="line">  quote: &#x27;Where there is life, there is life.&#x27;</span><br><span class="line">  show: 1</span><br><span class="line">  lazyload: false</span><br><span class="line">  loading:</span><br><span class="line">  metaColor:</span><br><span class="line">  color:</span><br><span class="line">  webp:</span><br><span class="line">  progress:</span><br><span class="line">  extra_options:</span><br><span class="line">    key: value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ul>
<li>enable: 是否启用</li>
<li>vmid: 哔哩哔哩番剧页面的 vmid(uid), 如何获取？</li>
<li>title: 该页面的标题</li>
<li>quote: 写在页面开头的一段话，支持 html 语法</li>
<li>show: 初始显示页面：0: 想看 , 1: 在看 , 2: 看过，默认为 1</li>
<li>loading: 图片加载完成前的 loading 图片</li>
</ul>
<p>其中，vmid需要配置自己b站的一个uid，登录哔哩哔哩后前往 <a href="https://space.bilibili.com/xxx">https://space.bilibili.com/xxx</a>，网址最后的一串数字就是你的uid。</p>
<p>3.刷新追番页</p>
<p>每次在hexo g之后，就可以执行<code>hexo bangumi -u</code>对追番页进行刷新</p>
<h2 id="3-2-效果"><a href="#3-2-效果" class="headerlink" title="3.2 效果"></a>3.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_3.png"></p>
<h1 id="4-主页冒泡特效"><a href="#4-主页冒泡特效" class="headerlink" title="4. 主页冒泡特效"></a>4. 主页冒泡特效</h1><h2 id="4-1-步骤"><a href="#4-1-步骤" class="headerlink" title="4.1 步骤"></a>4.1 步骤</h2><p>1.在C:\blog\themes\Butterfly\source\js目录下创建一个chocolate.js文件，直接添加一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: tzy1997</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 气泡</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bubble</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#page-header&#x27;</span>).<span class="title function_">circleMagic</span>(&#123;</span><br><span class="line">            <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">density</span>: <span class="number">.2</span>,</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;rgba(255,255,255,.4)&#x27;</span>,</span><br><span class="line">            <span class="attr">clearOffset</span>: <span class="number">0.99</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;! <span class="keyword">function</span>(<span class="params">p</span>) &#123;</span><br><span class="line">        p.<span class="property">fn</span>.<span class="property">circleMagic</span> = <span class="keyword">function</span>(<span class="params">t</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> o, a, n, r, e = !<span class="number">0</span>,</span><br><span class="line">                i = [],</span><br><span class="line">                d = p.<span class="title function_">extend</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;rgba(255,0,0,.5)&quot;</span>, <span class="attr">radius</span>: <span class="number">10</span>, <span class="attr">density</span>: <span class="number">.3</span>, <span class="attr">clearOffset</span>: <span class="number">.2</span> &#125;, t),</span><br><span class="line">                l = <span class="variable language_">this</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123; e = !(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> &gt; a) &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>) &#123; o = l.<span class="property">clientWidth</span>, a = l.<span class="property">clientHeight</span>, l.<span class="property">height</span> = a <span class="string">&quot;px&quot;</span>, n.<span class="property">width</span> = o, n.<span class="property">height</span> = a &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">in</span> r.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, o, a), i) i[t].<span class="title function_">draw</span>();</span><br><span class="line">                <span class="title function_">requestAnimationFrame</span>(h)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> t = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">function</span> <span class="title function_">e</span>(<span class="params"></span>) &#123; t.<span class="property">pos</span>.<span class="property">x</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>() * o, t.<span class="property">pos</span>.<span class="property">y</span> = a <span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(), t.<span class="property">alpha</span> = <span class="number">.1</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() * d.<span class="property">clearOffset</span>, t.<span class="property">scale</span> = <span class="number">.1</span> <span class="number">.3</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(), t.<span class="property">speed</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>(), <span class="string">&quot;random&quot;</span> === d.<span class="property">color</span> ? t.<span class="property">color</span> = <span class="string">&quot;rgba(&quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">0</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">0</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>()) <span class="string">&quot;, &quot;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toPrecision</span>(<span class="number">2</span>) <span class="string">&quot;)&quot;</span> : t.<span class="property">color</span> = d.<span class="property">color</span> &#125;</span><br><span class="line">                t.<span class="property">pos</span> = &#123;&#125;, <span class="title function_">e</span>(), <span class="variable language_">this</span>.<span class="property">draw</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; t.<span class="property">alpha</span> &lt;= <span class="number">0</span> &amp;&amp; <span class="title function_">e</span>(), t.<span class="property">pos</span>.<span class="property">y</span> -= t.<span class="property">speed</span>, t.<span class="property">alpha</span> -= <span class="number">5e-4</span>, r.<span class="title function_">beginPath</span>(), r.<span class="title function_">arc</span>(t.<span class="property">pos</span>.<span class="property">x</span>, t.<span class="property">pos</span>.<span class="property">y</span>, t.<span class="property">scale</span> * d.<span class="property">radius</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, !<span class="number">1</span>), r.<span class="property">fillStyle</span> = t.<span class="property">color</span>, r.<span class="title function_">fill</span>(), r.<span class="title function_">closePath</span>() &#125;</span><br><span class="line">            &#125;! <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                o = l.<span class="property">offsetWidth</span>, a = l.<span class="property">offsetHeight</span>,</span><br><span class="line">                    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> t = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">                        t.<span class="property">id</span> = <span class="string">&quot;canvas&quot;</span>, t.<span class="property">style</span>.<span class="property">top</span> = <span class="number">0</span>, t.<span class="property">style</span>.<span class="property">zIndex</span> = <span class="number">0</span>, t.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&quot;absolute&quot;</span>, l.<span class="title function_">appendChild</span>(t), t.<span class="property">parentElement</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&quot;hidden&quot;</span></span><br><span class="line">                    &#125;(), (n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>)).<span class="property">width</span> = o, n.<span class="property">height</span> = a, r = n.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; o * d.<span class="property">density</span>; t++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> e = <span class="keyword">new</span> f;</span><br><span class="line">                    i.<span class="title function_">push</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="title function_">h</span>()</span><br><span class="line">            &#125;(), <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, c, !<span class="number">1</span>), <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, s, !<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(jQuery);</span><br><span class="line">    <span class="comment">// 调用气泡方法</span></span><br><span class="line">    <span class="title function_">bubble</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2.在主题配置文件_config.butterfly.yml中，添加jquery.min.js和chocolate.js，代码如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">inject:</span></span><br><span class="line">  head:</span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script defer src=<span class="string">&quot;https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    - &lt;script data-pjax defer src=<span class="string">&quot;https://npm.elemecdn.com/tzy-blog/lib/js/theme/chocolate.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-效果"><a href="#4-2-效果" class="headerlink" title="4.2 效果"></a>4.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_4.png"></p>
<h1 id="5-全局吸底APlayer"><a href="#5-全局吸底APlayer" class="headerlink" title="5. 全局吸底APlayer"></a>5. 全局吸底APlayer</h1><h2 id="5-1-步骤"><a href="#5-1-步骤" class="headerlink" title="5.1 步骤"></a>5.1 步骤</h2><p>1.在博客根目录，打开cmd命令窗口，在终端执行以下命令，下载插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>2.修改站点配置文件_config.yml，配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>3.修改主题配置文件_config.butterfly.yml，将enable和per_page都设为true，因为全局(每个页面)都插入 aplayer 和 meting 资源，所以需要防止重复加载。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayerInject:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>4.在主题配置文件_config.butterfly.yml中加入如下代码，在下面代码中，需要修改的是data-id和data-server。data-server&#x3D;”netease”表示使用的播放器是网易云音乐；data-id&#x3D;”12221117397”的12221117397是我的网易云音乐的一个歌单id。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">	<span class="comment">#载入音乐aplayer</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;12221117397&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span>   <span class="string">data-order=&quot;list&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-preload=&quot;auto&quot;</span> <span class="string">data-autoplay=&quot;false&quot;</span> <span class="string">data-mutex=&quot;true&quot;</span> <span class="string">&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.如果你想切换页面时，音乐不会中断。可将主题配置文件_config.butterfly.yml的 “pjax” 设为 “true” 。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-效果"><a href="#5-2-效果" class="headerlink" title="5.2 效果"></a>5.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_5.png"></p>
<h1 id="6-音乐背景"><a href="#6-音乐背景" class="headerlink" title="6. 音乐背景"></a>6. 音乐背景</h1><h2 id="6-1-步骤"><a href="#6-1-步骤" class="headerlink" title="6.1 步骤"></a>6.1 步骤</h2><p>1.创建音乐界面，在blog的根目录下打开终端，执行hexo n music，在C:\blog\source\music\index.md文件里添加如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">title: music</span></span><br><span class="line"><span class="section">date: 2024-07-17 22:29:18</span></span><br><span class="line"><span class="section">type: &quot;music&quot;</span></span><br><span class="line"><span class="section">top_img: false</span></span><br><span class="line"><span class="section">aplayer: true</span></span><br><span class="line"><span class="section">comments: false</span></span><br><span class="line"><span class="section">aside: false</span></span><br></pre></td></tr></table></figure>

<p>2.创建页面，在文件夹<code>C:\blog\themes\Butterfly\layout\includes\page</code>下新建music.pug文件，这样方便后续可以使用 css 将页面(page)本身的样式给去除。其中id可以填写自己的歌单id，server是对应的音乐平台。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#anMusic-page</span></span><br><span class="line">  <span class="string">meting-js(id=&quot;12221117397&quot;</span> <span class="string">server=&quot;netease&quot;</span> <span class="string">type=&quot;playlist&quot;</span> <span class="string">mutex=&quot;true&quot;</span> <span class="string">preload=&quot;auto&quot;</span> <span class="string">theme=&quot;var(--anzhiyu-main)&quot;</span> <span class="string">order=&quot;list&quot;)</span></span><br></pre></td></tr></table></figure>

<p>3.修改<code>blog\themes\Butterfly\layout\page.pug</code>文件夹内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#page</span></span><br><span class="line">	<span class="string">if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span>  <span class="string">-----&gt;</span> <span class="string">删除这行</span></span><br><span class="line">    <span class="string">if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span> <span class="string">&amp;&amp;</span> <span class="string">page.type</span> <span class="type">!=</span> <span class="string">&#x27;music&#x27;</span>  <span class="string">-----&gt;</span> <span class="string">添加这行</span></span><br><span class="line">      <span class="string">h1.page-title=</span> <span class="string">page.title</span></span><br><span class="line"></span><br><span class="line">    <span class="string">case</span> <span class="string">page.type</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;tags&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/tags.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;link&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/flink.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;categories&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/categories.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;music&#x27;</span>  <span class="string">-----添加这行</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/music.pug</span>  <span class="string">-----&gt;</span> <span class="string">添加这行</span></span><br><span class="line">      <span class="string">default</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/default-page.pug</span></span><br><span class="line"></span><br><span class="line">    <span class="string">if</span> <span class="string">page.comments</span> <span class="type">!==</span> <span class="literal">false</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments.use</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">var</span> <span class="string">commentsJsLoad</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">      <span class="type">!=partial(&#x27;includes/third</span><span class="string">-party/comments/index&#x27;,</span> &#123;&#125;<span class="string">,</span> &#123;<span class="attr">cache:</span> <span class="literal">true</span>&#125;<span class="string">)</span></span><br></pre></td></tr></table></figure>

<p>4.创建背景元素，修改<code>blog\themes\Butterfly\layout\includes\layout.pug</code>文件内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">body</span></span><br><span class="line">    <span class="string">if</span> <span class="string">theme.background</span></span><br><span class="line">      <span class="comment">#web_bg</span></span><br><span class="line">      <span class="comment">#an_music_bg  -----&gt; 添加这行</span></span><br></pre></td></tr></table></figure>

<p>5.在文件<code>blog\source\js\anzhiyu.js</code>中添加如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anzhiyu = &#123;</span><br><span class="line">  <span class="comment">// 音乐节目切换背景</span></span><br><span class="line">  <span class="attr">changeMusicBg</span>: <span class="keyword">function</span> (<span class="params">isChangeBg = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> != <span class="string">&quot;/music/&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> anMusicBg = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;an_music_bg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isChangeBg) &#123;</span><br><span class="line">      <span class="comment">// player listswitch 会进入此处</span></span><br><span class="line">      <span class="keyword">const</span> musiccover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#anMusic-page .aplayer-pic&quot;</span>);</span><br><span class="line">      anMusicBg.<span class="property">style</span>.<span class="property">backgroundImage</span> = musiccover.<span class="property">style</span>.<span class="property">backgroundImage</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次进入，绑定事件，改背景</span></span><br><span class="line">      <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> musiccover = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#anMusic-page .aplayer-pic&quot;</span>);</span><br><span class="line">        <span class="comment">// 确保player加载完成</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(anMusicBg);</span><br><span class="line">        <span class="keyword">if</span> (musiccover) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          anMusicBg.<span class="property">style</span>.<span class="property">backgroundImage</span> = musiccover.<span class="property">style</span>.<span class="property">backgroundImage</span>;</span><br><span class="line">          <span class="comment">// 绑定事件</span></span><br><span class="line">          anzhiyu.<span class="title function_">addEventListenerChangeMusicBg</span>();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 暂停nav的音乐</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#nav-music meting-js&quot;</span>).<span class="property">aplayer</span> &amp;&amp;</span><br><span class="line">            !<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#nav-music meting-js&quot;</span>).<span class="property">aplayer</span>.<span class="property">audio</span>.<span class="property">paused</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            anzhiyu.<span class="title function_">musicToggle</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">addEventListenerChangeMusicBg</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> anMusicPage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;anMusic-page&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> aplayerIconMenu = anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;.aplayer-info .aplayer-time .aplayer-icon-menu&quot;</span>);</span><br><span class="line"></span><br><span class="line">    anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;meting-js&quot;</span>).<span class="property">aplayer</span>.<span class="title function_">on</span>(<span class="string">&quot;loadeddata&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      anzhiyu.<span class="title function_">changeMusicBg</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;player loadeddata&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    aplayerIconMenu.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="property">style</span>.<span class="property">animation</span> = <span class="string">&quot;0.5s ease 0s 1 normal none running to_show&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;menu-mask&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">pathname</span> != <span class="string">&quot;/music/&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">      anMusicPage.<span class="title function_">querySelector</span>(<span class="string">&quot;.aplayer-list&quot;</span>).<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;aplayer-list-hide&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">anzhiyu.<span class="title function_">changeMusicBg</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>6.在文件<code>blog\source\css\music.css</code>中添加如下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局样式*/</span></span><br><span class="line"><span class="selector-id">#page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;     <span class="comment">/* 移除页面的边框 */</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;             <span class="comment">/* 移除页面的阴影 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;                           <span class="comment">/* 移除页面的内边距 */</span></span><br><span class="line">  <span class="attribute">background</span>: transparent <span class="meta">!important</span>;     <span class="comment">/* 将页面背景设为透明 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*背景样式*/</span></span><br><span class="line"><span class="selector-id">#an_music_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;          <span class="comment">/* 默认隐藏背景 */</span></span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">63px</span>);      <span class="comment">/* 添加模糊效果 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;              <span class="comment">/* 设置背景的不透明度 */</span></span><br><span class="line">  <span class="attribute">position</span>: fixed;         <span class="comment">/* 使背景固定 */</span></span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">999</span>;            <span class="comment">/* 将背景放置在最底层 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: local;            <span class="comment">/* 背景附着在本地视口 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;       <span class="comment">/* 背景图居中对齐 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;                          <span class="comment">/* 背景图覆盖整个容器 */</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;             <span class="comment">/* 背景图不重复 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;                                              <span class="comment">/* 背景宽度设为原来的两倍 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;                                              <span class="comment">/* 背景高度设为原来的两倍 */</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">50%</span>;                                                   <span class="comment">/* 背景从顶部开始偏移 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50%</span>;                                                   <span class="comment">/* 背景从左侧开始偏移 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);                           <span class="comment">/* 不旋转背景 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#an_music_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;                               <span class="comment">/* 包含 #anMusic-page 时显示背景 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">198</span>,<span class="number">115</span>);      <span class="comment">/* 包含 #anMusic-page 时设置背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*APlayer 样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> meting-js <span class="selector-class">.aplayer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;                                <span class="comment">/* 使播放器使用 Flexbox 布局 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse;       <span class="comment">/* 元素按行反向排列 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);     <span class="comment">/* 设置背景为透明 */</span></span><br><span class="line">  <span class="attribute">border</span>: none;                               <span class="comment">/* 移除边框 */</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: none;                     <span class="comment">/* 移除阴影 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#web_bg</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#footer</span>,</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#nav-music</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                        <span class="comment">/* 隐藏网页背景、页脚和导航音乐 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*APlayer 详细样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;                <span class="comment">/* 设置播放器主体的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">75vh</span>;              <span class="comment">/* 设置播放器主体的高度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffffff33</span>;       <span class="comment">/* 悬停时设置项目背景色 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;            <span class="comment">/* 设置圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-pic</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: none;                        <span class="comment">/* 不浮动 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">180px</span>;                     <span class="comment">/* 设置封面宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">180px</span>;                   <span class="comment">/* 设置封面高度 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;         <span class="comment">/* 设置封面圆角 */</span></span><br><span class="line">  <span class="attribute">margin</span>: auto;                    <span class="comment">/* 设置居中对齐 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                 <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;                               <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;          <span class="comment">/* 设置信息区域的外边距 */</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: none;          <span class="comment">/* 移除下边框 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;                    <span class="comment">/* 设置文字居中对齐 */</span></span><br><span class="line">  <span class="attribute">height</span>: auto;                             <span class="comment">/* 高度自适应 */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span>;                            <span class="comment">/* 设置外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> <span class="selector-class">.aplayer-author</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-music</span> <span class="selector-class">.aplayer-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;                  <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;                <span class="comment">/* 设置字体粗细 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;                            <span class="comment">/* 设置字体颜色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800%</span>;                               <span class="comment">/* 设置歌词区域高度 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">80px</span>;                       <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">  <span class="attribute">mask-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#0000</span>, <span class="number">#0000</span>);    <span class="comment">/* 设置渐变遮罩 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;                  <span class="comment">/* 设置歌词字体大小 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;                           <span class="comment">/* 设置歌词字体颜色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-lrc</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                     <span class="comment">/* 隐藏伪元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制器样式 */</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;                 <span class="comment">/* 固定位置 */</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1500px</span>;          <span class="comment">/* 设置最大宽度 */</span></span><br><span class="line">  <span class="attribute">margin</span>: auto;                    <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;                              <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">50px</span>;                   <span class="comment">/* 设置底部外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-bar-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">160px</span> <span class="number">0</span> <span class="number">150px</span>;       <span class="comment">/* 设置进度条包裹元素的外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-played</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">var</span>(--anzhiyu-white) <span class="meta">!important</span>;       <span class="comment">/* 设置已播放部分的背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-thumb</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: none;          <span class="comment">/* 取消缩放 */</span></span><br><span class="line">  <span class="attribute">transform</span>: none;                          <span class="comment">/* 取消缩放 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span> <span class="meta">!important</span>;     <span class="comment">/* 设置背景色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span>,</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;                <span class="comment">/* 显示图标 */</span></span><br><span class="line">  <span class="attribute">position</span>: fixed;               <span class="comment">/* 固定位置 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;        <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;                   <span class="comment">/* 设置宽度 */</span></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">21px</span>;                <span class="comment">/* 设置底部外边距 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;                        <span class="comment">/* 设置高度 */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;                  <span class="comment">/* 使用 Flexbox 布局 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;        <span class="comment">/* 右对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">18px</span>;         <span class="comment">/* 设置右外边距 */</span></span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">8px</span>;           <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;            <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左对齐 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;              <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">40px</span>;                              <span class="comment">/* 左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;               <span class="comment">/* 绝对定位 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">80px</span>;                                <span class="comment">/* 左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;                          <span class="comment">/* 设置图标宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2rem</span>;                        <span class="comment">/* 设置图标高度 */</span></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">15px</span>;                 <span class="comment">/* 设置左外边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-menu</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;                        <span class="comment">/* 隐藏菜单图标 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span> path &#123;</span><br><span class="line">  fill: <span class="built_in">var</span>(--anzhiyu-white);        <span class="comment">/* 设置图标路径的填充色 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;                              <span class="comment">/* 设置透明度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*歌曲列表样式*/</span></span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60%</span>;                                      <span class="comment">/* 设置列表宽度 */</span></span><br><span class="line">  <span class="attribute">max-height</span>: none <span class="meta">!important</span>;       <span class="comment">/* 取消最大高度限制 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;                                   <span class="comment">/* 设置列表高度 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">75vh</span> <span class="meta">!important</span>;       <span class="comment">/* 设置最大高度 */</span></span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">25px</span>;                      <span class="comment">/* 设置右内边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid transparent;     <span class="comment">/* 设置项目的顶部边框 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;                                      <span class="comment">/* 设置字体大小 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">255</span> <span class="number">255</span> <span class="number">255</span> / <span class="number">20%</span>);      <span class="comment">/* 设置背景色 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">6px</span>;                       <span class="comment">/* 设置圆角*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white);       <span class="comment">/* 设置列表项中的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-class">.aplayer-list-cur</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;         <span class="comment">/* 隐藏当前播放的标记 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;            <span class="comment">/* 设置作者名的透明度为 60% */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导航栏样式 */</span></span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#nav</span> &#123;</span><br><span class="line">  backdrop-<span class="attribute">filter</span>: none <span class="meta">!important</span>;       <span class="comment">/* 取消背景滤镜 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">0</span> <span class="number">0</span> <span class="meta">!important</span>;                 <span class="comment">/* 取消背景颜色 */</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: none <span class="meta">!important</span>;       <span class="comment">/* 移除底部边框 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span><span class="selector-class">.not-top-img</span> <span class="selector-id">#nav</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span> <span class="selector-id">#nav</span> <span class="selector-class">.back-home-button</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white);             <span class="comment">/* 设置导航栏链接和返回首页按钮的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-class">.s-sticker</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--anzhiyu-white) <span class="meta">!important</span>;       <span class="comment">/* 设置 .s-sticker 中 div 元素的文本颜色为自定义的白色 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon</span><span class="selector-class">.aplayer-icon-loop</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">15px</span>;          <span class="comment">/* 设置循环图标的右边距 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[data-theme=<span class="string">&quot;dark&quot;</span>]</span> <span class="selector-class">.page</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page-header</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;      <span class="comment">/* 设置暗色主题下页面头部的伪元素背景颜色为透明 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* **** 移动端样式 ***** */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#rightside</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;                <span class="comment">/* 在移动端隐藏右侧侧边栏 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#content-inner</span>,</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-pseudo">:has</span>(<span class="selector-id">#anMusic-page</span>) <span class="selector-id">#page</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: auto;               <span class="comment">/* 设置内容和页面的 z-index 为自动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 歌曲列表 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;            <span class="comment">/* 固定位置 */</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1002</span>;              <span class="comment">/* 设置 z-index 为 1002，以便在其他元素之上 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                <span class="comment">/* 宽度为 100% */</span></span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">76%</span>;             <span class="comment">/* 设置底部位置偏移 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                            <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">var</span>(--sidebar-bg);         <span class="comment">/* 设置背景色为自定义侧边栏背景色 */</span></span><br><span class="line">    <span class="attribute">height</span>: auto;                                          <span class="comment">/* 高度自动调整 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span> <span class="number">15px</span> <span class="number">0px</span> <span class="number">0px</span>;       <span class="comment">/* 设置圆角 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">0px</span>;                                <span class="comment">/* 设置内边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-list</span><span class="selector-class">.aplayer-list-hide</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0%</span> <span class="meta">!important</span>;                   <span class="comment">/* 隐藏列表时将底部位置调整为 0% */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &#123;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">60vh</span> <span class="meta">!important</span>;            <span class="comment">/* 设置最大高度为视口高度的 60% */</span></span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">0px</span>;                            <span class="comment">/* 移除右侧内边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;                                         <span class="comment">/* 使用 Flexbox 布局 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;                                    <span class="comment">/* 设置左右外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">var</span>(--font-color);                      <span class="comment">/* 设置列表项文本颜色为自定义的字体颜色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-title</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;                                           <span class="comment">/* 设置标题宽度为 30% */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#33a673</span>;                        <span class="comment">/* 设置选中列表项的背景色 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">20px</span>;                             <span class="comment">/* 设置内边距 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;                          <span class="comment">/* 设置圆角 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;                                          <span class="comment">/* 设置选中列表项的文本颜色为白色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-title</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">55%</span>;                     <span class="comment">/* 设置标题最大宽度 */</span></span><br><span class="line">    <span class="attribute">width</span>: auto;                             <span class="comment">/* 宽度自动调整 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;             <span class="comment">/* 使用 WebKit 特有的 Flexbox 布局 */</span></span><br><span class="line">    -webkit-line-clamp: <span class="number">1</span>;            <span class="comment">/* 限制文本为一行 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;                    <span class="comment">/* 隐藏超出的文本 */</span></span><br><span class="line">    -webkit-box-orient: vertical;      <span class="comment">/* 设置盒子布局方向为纵向 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;                  <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;                               <span class="comment">/* 设置右边距 */</span></span><br><span class="line">    <span class="attribute">width</span>: auto;                              <span class="comment">/* 宽度自动调整 */</span></span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">35%</span>;                      <span class="comment">/* 设置最大宽度 */</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-box;               <span class="comment">/* 使用 WebKit 特有的 Flexbox 布局 */</span></span><br><span class="line">    -webkit-line-clamp: <span class="number">1</span>;             <span class="comment">/* 限制文本为一行 */</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;                     <span class="comment">/* 隐藏超出的文本 */</span></span><br><span class="line">    -webkit-box-orient: vertical;    <span class="comment">/* 设置盒子布局方向为纵向 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-tag">ol</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.aplayer-list-light</span> <span class="selector-tag">span</span><span class="selector-class">.aplayer-list-author</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">15px</span>;                              <span class="comment">/* 调整选中列表项中作者名的右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 歌词信息 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                             <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">position</span>: fixed;                          <span class="comment">/* 固定位置 */</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;                            <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 左侧对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                          <span class="comment">/* 右侧对齐 */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;                      <span class="comment">/* 设置顶部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;             <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">    <span class="attribute">height</span>: auto;                      <span class="comment">/* 高度自动调整 */</span></span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">200%</span>;            <span class="comment">/* 设置最大高度为 200% */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;             <span class="comment">/* 设置最小高度为 100% */</span></span><br><span class="line">    <span class="attribute">mask-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#000</span>, <span class="number">#0000</span>, <span class="number">#0000</span>);  * 设置渐变遮罩 */</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-lrc</span> <span class="selector-tag">p</span><span class="selector-class">.aplayer-lrc-current</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#33a673</span>;               <span class="comment">/* 设置当前歌词的颜色 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 控制按键和进度条 */</span></span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">100px</span>;           <span class="comment">/* 设置底部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-bar-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">30px</span>;              <span class="comment">/* 设置左右外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">40px</span>;              <span class="comment">/* 设置底部位置 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;            <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;                       <span class="comment">/* 设置宽度为 100% */</span></span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">0</span>;                  <span class="comment">/* 移除右边距 */</span></span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">33px</span>;            <span class="comment">/* 设置顶部外边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> <span class="selector-class">.aplayer-dtime</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;              <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">30px</span>;                           <span class="comment">/* 设置右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-time-inner</span> <span class="selector-class">.aplayer-ptime</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;             <span class="comment">/* 绝对定位 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35px</span>;                             <span class="comment">/* 设置左边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-back</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                      <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">110px</span>;                         <span class="comment">/* 设置右边距 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-play</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                      <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                                <span class="comment">/* 设置右边距为 0 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;                                  <span class="comment">/* 设置左边距为 0 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-forward</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;                 <span class="comment">/* 居中对齐 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">110px</span>;                     <span class="comment">/* 设置左边距 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;                           <span class="comment">/* 设置右边距为 0 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-order</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;         <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">22px</span>;                         <span class="comment">/* 距离左侧 22 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-loop</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;       <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">25px</span>;                    <span class="comment">/* 距离右侧 25 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-time</span> <span class="selector-class">.aplayer-icon-menu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;               <span class="comment">/* 设置元素为行内元素，使其在同一行内显示 */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;      <span class="comment">/* 绝对定位，使元素相对于最近的已定位祖先元素进行定位 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">25px</span>;                   <span class="comment">/* 距离右侧 25 像素 */</span></span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">90px</span>;                    <span class="comment">/* 距离顶部 -90 像素，这里使用负值使其向上移动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer-volume-bar-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0px</span>;                <span class="comment">/* 距离底部 0 像素 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">7px</span>;                     <span class="comment">/* 距离右侧 7 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-id">#anMusic-page</span> <span class="selector-class">.aplayer</span> <span class="selector-class">.aplayer-info</span> <span class="selector-class">.aplayer-controller</span> <span class="selector-class">.aplayer-volume-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">66px</span>;                     <span class="comment">/* 距离左侧 -66 像素，这里使用负值使其向左移动 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.将上面写的css和js文件引入主题配置文件。在这条配置文件_config.butterfly.yml中添加如下代码，其中我们使用的是meting2 的版本，为了不与设置的全局吸底APlayer冲突，就在这里引入<code>https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js</code>，而不是在最后面的CDN-option-meting_js:处引入。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">async</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/js/anzhiyu.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/music.css&quot;&gt;</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt;</span> <span class="comment">#为了与全局吸底不产生冲突</span></span><br></pre></td></tr></table></figure>

<h1 id="7-悬挂灯笼"><a href="#7-悬挂灯笼" class="headerlink" title="7. 悬挂灯笼"></a>7. 悬挂灯笼</h1><h2 id="7-1-步骤"><a href="#7-1-步骤" class="headerlink" title="7.1 步骤"></a>7.1 步骤</h2><p>1.在<code>blog\themes\Butterfly\source\css</code>文件夹下新建lantern.css文件，并在lantern.css文件中添加以下内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 灯笼 Start */</span></span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 移动端显示/隐藏 /none/block，可自定义显示一个 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">970px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.d-box1</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.dengl</span> <span class="selector-class">.d-box</span> &#123;</span><br><span class="line">        <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">40px</span>;</span><br><span class="line">        <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.dengl</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* .d-box,.d-box1&#123;</span></span><br><span class="line"><span class="comment">    z-index: 9;</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的位置 */</span></span><br><span class="line">    <span class="attribute">right</span>: <span class="number">85px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的位置 */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼大小 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改灯笼的字体 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;虎年大吉&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;万事顺遂&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.d-box1</span> <span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f01f1a</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的阴影 */</span></span><br><span class="line">    <span class="comment">/* box-shadow: 0 5px 61px rgba(255, 240, 29, 0.88); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d2</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>,</span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f01f1a</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="comment">/* 自定义灯笼的阴影 */</span></span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">61px</span> <span class="number">#ff1d1d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">82px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span>,</span><br><span class="line"><span class="selector-class">.d2</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">animation</span>: swing <span class="number">4s</span> linear infinite;</span><br><span class="line">    <span class="attribute">transform-origin</span>: top center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">80px</span>/<span class="number">49px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">123px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">62px</span>/<span class="number">52px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">69px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">41px</span>/<span class="number">49px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">84px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">49px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">31px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">2.5px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">3.5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">47px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d1</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">19px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span>,</span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">128px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">199px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">128px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">61px</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">122px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">98px</span>/<span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">143px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">69px</span>/<span class="number">67px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自定义背景图片 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">51px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">57px</span>/<span class="number">89px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">https://bu.dusays.com/2021/02/03/7e1a77cf800cf.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">92px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">123px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">68px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">19px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">121px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">53px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">3px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">59px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">53px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">9px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ffe31d</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#5c1713</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.d2</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">21px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">54px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> swing &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">25%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">13deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">75%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">13deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 灯笼 END */</span></span><br></pre></td></tr></table></figure>

<p>2.在<code>blog\themes\Butterfly\layout\includes</code>文件夹下新建lantern.pug文件，并添加以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">.dengl</span></span><br><span class="line">  <span class="string">.d-box</span></span><br><span class="line">    <span class="string">.d1</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">    <span class="string">.d2</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">  <span class="string">.d-box1</span></span><br><span class="line">    <span class="string">.d1</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">    <span class="string">.d2</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">      <span class="string">span</span></span><br><span class="line">        <span class="string">p</span></span><br><span class="line">      <span class="string">ul</span></span><br><span class="line">        <span class="string">li</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span></span><br><span class="line">          <span class="string">span</span></span><br><span class="line">        <span class="string">li</span>  </span><br><span class="line">        <span class="string">li</span>   </span><br></pre></td></tr></table></figure>

<p>3.在<code>blog\themes\Butterfly\layout\includes\layout.pug</code>文件中引入lantern.pug文件，参考如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">head</span></span><br><span class="line">    <span class="string">include</span> <span class="string">./head.pug</span></span><br><span class="line">    <span class="string">include</span> <span class="string">./lantern.pug</span>  <span class="string">-----&gt;</span> <span class="string">添加这一行</span></span><br></pre></td></tr></table></figure>

<p>4.在主题配置文件_config.butterfly.yml中，inject的head下面引入刚刚添加的lantern.css文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">	 <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/lantern.css&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-效果"><a href="#7-2-效果" class="headerlink" title="7.2 效果"></a>7.2 效果</h2><p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/butterfly/4_6.png"></p>
]]></content>
      <categories>
        <category>魔改美化</category>
      </categories>
      <tags>
        <tag>butterfly</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络编程小项目-在线词典</title>
    <url>/2024/07/24/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%B0%8F%E9%A1%B9%E7%9B%AE-%E5%9C%A8%E7%BA%BF%E8%AF%8D%E5%85%B8/</url>
    <content><![CDATA[<h1 id="1-项目概述"><a href="#1-项目概述" class="headerlink" title="1. 项目概述"></a>1. 项目概述</h1><p>在线词典项目是在linux系统下结合c语言、网络编程和sqlite3数据库等技术来实现的一个在线的英译英单词解释，当客户端成功连接到服务器后，客户端登录账号后输入想查询的单词，服务器端会在词库(网上找的)中寻找这个单词的解释并发送给客户端，从而实现在线查询。服务端同时也会向数据库存储该用户的一个查询记录，方便管理的同时，也方便客户端查询。</p>
<h1 id="2-实现的功能"><a href="#2-实现的功能" class="headerlink" title="2. 实现的功能"></a>2. 实现的功能</h1><ul>
<li><p>用户注册和登录验证，服务器端将用户信息和历史记录保存在数据库中。</p>
</li>
<li><p>客户端输入用户名和密码，服务器端在数据库中查找、匹配，返回查询结果</p>
</li>
<li><p>根据客户端输入的单词在字典文件中搜索，将查询结果返回</p>
</li>
<li><p>历史记录查询</p>
</li>
</ul>
<h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-服务器"><a href="#3-1-服务器" class="headerlink" title="3.1 服务器"></a>3.1 服务器</h2><p>主函数和一些基本信息：这部分定义了一个双方通信的信息结构体，其中type是R时，表示客户端发来了注册请求；是L时，客户端发来了登录请求；是Q时，客户端发来了查询请求；是H时，客户端发来了观看历史请求。主函数实现的就是打开后台数据库，创建进程，与客户端成功连接后，子进程完成与对端的通信任务，父进程则继续监听与客户端的连接。这样就实现了服务器的一个并发功能，即同时可以连接处理多个客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R 1    <span class="comment">//user - register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 2    <span class="comment">//user - login</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q 3    <span class="comment">//user - query</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H 4    <span class="comment">//user - history</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATABASE <span class="string">&quot;my.db&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义通信双方的信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> name[N];</span><br><span class="line">    <span class="type">char</span> data[<span class="number">256</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;                      <span class="comment">//监听描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span>   <span class="comment">//存放服务器的信息结构体</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="type">int</span> acceptfd;         <span class="comment">//通信描述符</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    sqlite3 *db;          <span class="comment">//数据库的一个地址指针</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage:%s serverip port.\n&quot;</span>,argv[<span class="number">0</span>]);  <span class="comment">//执行时没有输入ip和端口会退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开数据库</span></span><br><span class="line">    <span class="keyword">if</span>(sqlite3_open(DATABASE, &amp;db) != SQLITE_OK)&#123;    <span class="comment">//通过数据库指针打开数据库my.db</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sqlite3_errmsg(db));          <span class="comment">//失败打印具体错误信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open DATABASE success\n&quot;</span>);           <span class="comment">//成功就打印该行代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);          <span class="comment">//得到监听描述符</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));           <span class="comment">//对服务器结构体置0，下面初始化信息</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));      <span class="comment">//因为argv[]传进来的是字符串，所以先要将端口转换为整数，再转换为网络字节序， atoi是转换为整数用的</span></span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]); <span class="comment">//将点分十进制(是一种表示IP地址的字符串形式)转化为网络字节序</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));   <span class="comment">//端口复用</span></span><br><span class="line">    <span class="keyword">if</span>(bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr))&lt;<span class="number">0</span>)&#123;  <span class="comment">//服务端进行绑定</span></span><br><span class="line">        perror(<span class="string">&quot;fail to bind...\n&quot;</span>);   <span class="comment">//如果绑定失败，打印错误信息并退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd, <span class="number">5</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to listen...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理僵尸进程</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="comment">//监听描述符创建成功和服务端绑定成功后，进入循环，让服务器一直监听连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((acceptfd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">//进行监听连接，得到通信描述符</span></span><br><span class="line">            perror(<span class="string">&quot;fail to accept&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与客户端成功连接后，就创建进程</span></span><br><span class="line">        <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;fail to fork&quot;</span>);   <span class="comment">//生成进程失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;         <span class="comment">//儿子进程：处理与客户端的通信</span></span><br><span class="line">            <span class="comment">//处理客户端具体的信息</span></span><br><span class="line">            close(sockfd);         <span class="comment">//关闭监听进程</span></span><br><span class="line">            do_client(acceptfd, db);  <span class="comment">//进入与客户端的通信函数。参数是通信描述符、数据库指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                    <span class="comment">//父亲进程，用来监听客户端的请求的</span></span><br><span class="line">            close(acceptfd);     <span class="comment">//关闭通信描述符，继续循环，监听，等待其它客户端连接</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通信函数：当服务器与客户端成功连接后，等待接收客户端发来的信息，通过发来信息的不同请求，服务器执行不同的处理函数，处理完后，继续循环监听接收客户端发的信息，当客户端断开连接后，服务器就会退出监听接收循环，从而退出与该客户端的通信函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_client</span><span class="params">(<span class="type">int</span> acceptfd, sqlite3 *db)</span>&#123;   <span class="comment">//与客户端通信的函数，参数是通信描述符和数据库指针</span></span><br><span class="line">    MSG msg;                <span class="comment">//定义了装信息的结构体</span></span><br><span class="line">    <span class="keyword">while</span>(recv(acceptfd, &amp;msg, <span class="keyword">sizeof</span>(msg), <span class="number">0</span>) &gt; <span class="number">0</span>)&#123;   <span class="comment">//接收客户端发来的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;type:%d\n&quot;</span>, msg.type);      <span class="comment">//先打印客户端需要的请求序号</span></span><br><span class="line">        <span class="comment">//通过不同的请求序号，服务器执行不同的处理函数</span></span><br><span class="line">        <span class="keyword">switch</span>(msg.type)&#123;</span><br><span class="line">            <span class="comment">//参数是通信描述符、信息结构体MSG地址，数据库指针</span></span><br><span class="line">            <span class="keyword">case</span> R:</span><br><span class="line">                do_register(acceptfd, &amp;msg, db); <span class="comment">//如果是1，就进入注册函数。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> L:</span><br><span class="line">                do_login(acceptfd, &amp;msg, db);   <span class="comment">//如果是2，就进入登录函数。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Q:</span><br><span class="line">                do_query(acceptfd, &amp;msg, db);   <span class="comment">//如果是3，就进入查询函数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> H:</span><br><span class="line">                do_history(acceptfd, &amp;msg, db); <span class="comment">//如果是4，就进入历史查询函数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid data msg...\n&quot;</span>); <span class="comment">//如果是其它内容，就输入该行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//退出循环，表示该客户端执行的内容完了</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client exit...\n&quot;</span>);</span><br><span class="line">    close(acceptfd);      <span class="comment">//关闭通信描述符                                               </span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);       <span class="comment">//退出进程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;      <span class="comment">//这行执行不了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">注册函数实现</button><button type="button" class="tab " data-href="test4-2">登录函数实现</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>这部分实现的就是处理客户端的注册请求任务，将客户端发送来的用户名和密码存储在后台的数据库中，服务器如果存储失败，则返回给客户端注册失败的信息；存储成功，则返回给客户端<code>ok</code>，表示注册成功。最后执行完该函数后，会继续监听该客户端的下一个请求任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_register</span><span class="params">(<span class="type">int</span> acceptfd, MSG *msg, sqlite3 *db)</span>&#123;     <span class="comment">//响应客户端注册的函数</span></span><br><span class="line">    <span class="type">char</span> *errmsg;                 <span class="comment">//存放描述错误信息</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">128</span>];                <span class="comment">//存放sql语句</span></span><br><span class="line">    <span class="comment">//拼接一条向数据库的usr用户表中插入数据(用户名，密码)的语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into usr values(&#x27;%s&#x27;, %s);&quot;</span>,msg-&gt;name, msg-&gt;data); <span class="comment">//拼接sql语句，然后存放在sql中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sql);       <span class="comment">//打印拼接的sql语句</span></span><br><span class="line">    <span class="keyword">if</span>(sqlite3_exec(db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg) != SQLITE_OK)&#123; <span class="comment">//执行sql语句，如果报错，errmsg就存放错误原因</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, errmsg);            <span class="comment">//打印错误原因</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data, <span class="string">&quot;usr name already exist...&quot;</span>);  <span class="comment">//报错了，就将该行内容存放在data中，等下发送给客户端</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client register ok!\n&quot;</span>);  <span class="comment">//如果执行sql成功，就打印该行内容</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data, <span class="string">&quot;OK!&quot;</span>);         <span class="comment">//将ok存放在data中，等下发送给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;    <span class="comment">//将注册是否成功的信息发送给客户端</span></span><br><span class="line">        perror(<span class="string">&quot;fail to send&quot;</span>);    <span class="comment">//如果发送失败就打印错误信息并直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;   <span class="comment">//处理完该函数后，直接退出，继续在外面中循环，等待客户端的下一个请求序号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>这部分实现的就是处理客户端的登录请求任务，将客户端发送来的用户名和密码在后台数据库中的用户名usr表中查询，如果查询到了，则返回给客户端<code>ok</code>，表示登录成功；没有查询到，则发送<code>usr/passwd wrong...</code>给客户端，表示登录失败。最后执行完该函数后，会继续监听该客户端的下一个请求任务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_login</span><span class="params">(<span class="type">int</span> acceptfd, MSG *msg, sqlite3 *db)</span>&#123;   <span class="comment">//登录函数</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">128</span>] = &#123;&#125;;    <span class="comment">//存放sql语句</span></span><br><span class="line">    <span class="type">char</span> *errmsg;</span><br><span class="line">    <span class="type">int</span>  nrow;</span><br><span class="line">    <span class="type">int</span> ncloumn;</span><br><span class="line">    <span class="type">char</span> **resultp;</span><br><span class="line">    <span class="comment">//通过客户端发来的用户名和密码，拼接在数据库中的usr用户表中查询的语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql, <span class="string">&quot;select * from usr where name = &#x27;%s&#x27; and pass = &#x27;%s&#x27;;&quot;</span>,msg-&gt;name,msg-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, sql);    <span class="comment">//打印拼接的语句</span></span><br><span class="line">    <span class="comment">//进行查询</span></span><br><span class="line">    <span class="keyword">if</span>(sqlite3_get_table(db,sql,&amp;resultp,&amp;nrow,&amp;ncloumn,&amp;errmsg)!=SQLITE_OK)&#123;  <span class="comment">//参数：数据库指针;sql语句;查询的结果;查询的到行数;查询到的列数;存放失败原因</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, errmsg);     <span class="comment">//语句执行不成功，打印具体错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get_table ok!\n&quot;</span>);     <span class="comment">//只是上面那句话执行成功，但并不代表数据库中有要查询的用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nrow == <span class="number">1</span>)&#123;     <span class="comment">//如果查询到的行数等于1，表示查询成功，数据库中拥有此用户</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data,<span class="string">&quot;OK&quot;</span>);     <span class="comment">//将ok存到data，发送给客户端</span></span><br><span class="line">        send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>);     <span class="comment">//发送给客户端查询的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nrow == <span class="number">0</span>)&#123;            <span class="comment">//这种情况是密码或用户名错误</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data,<span class="string">&quot;usr/passwd wrong...&quot;</span>);</span><br><span class="line">        send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>);   <span class="comment">//发送查询失败的信息给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//数据库中无该用户会返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>搜索单词函数实现：这部分实现的就是处理客户端的查询单词的请求任务，通过客户端发送来的单词，服务器在词库中进行逐一查询，查询成功就返回单词的注释给客户端，查询失败，就返回给客户端信息<code>Not dound!</code>。同时，服务器也会在数据库中记录该用户的查询记录(用户名，查询时间，查询单词)。最后执行完该函数后，会继续监听该客户端的下一个请求任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_query</span><span class="params">(<span class="type">int</span> acceptfd, MSG *msg, sqlite3 *db)</span>&#123;  <span class="comment">//1.查询客户端传过来的单词---&gt;同时保留用户的查找记录，为另一个功能做铺垫</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">64</span>];                     <span class="comment">//装查询的单词</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> date[<span class="number">128</span>];                    <span class="comment">//装查询时间的</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">128</span>];                     <span class="comment">//用于存放拼接的sql语句</span></span><br><span class="line">    <span class="type">char</span> *errmsg;</span><br><span class="line">    <span class="comment">//拿出msg结构体中，要查询的单词</span></span><br><span class="line">    <span class="built_in">strcpy</span>(word, msg-&gt;data);           <span class="comment">//复制要查询的单词到word</span></span><br><span class="line">    found = do_searchword(acceptfd, msg, word);    <span class="comment">//如果找到了单词，就返回1，没有就返回0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示找到了单词，那么此时应该将用名、时间、单词插入到历史记录表中去</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">1</span>)&#123;</span><br><span class="line">        get_date(date);     <span class="comment">//获取系统时间</span></span><br><span class="line">        <span class="comment">//拼接插入数据库记录record表中数据(用户名，时间，单词)的语句</span></span><br><span class="line">        <span class="built_in">sprintf</span>(sql,<span class="string">&quot;insert into record values(&#x27;%s&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;)&quot;</span>,msg-&gt;name,date,word);   <span class="comment">//拼接sql语句</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,sql);         <span class="comment">//打印拼接的sql语句</span></span><br><span class="line">        <span class="keyword">if</span>(sqlite3_exec(db,sql,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;errmsg) != SQLITE_OK)&#123;    <span class="comment">//将拼接的sql语句插入数据库，主要是为了历史查询</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,errmsg);       <span class="comment">//打印错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;          <span class="comment">//表示没有找到客户端要查询的单词</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data, <span class="string">&quot;Not dound!&quot;</span>);           <span class="comment">//如果没有找到该单词，就返回没有找到的信息给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将查询的结果，发送给客户端</span></span><br><span class="line">    send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);           <span class="comment">//找到与否，上面都将信息写到了msg-&gt;data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_searchword</span><span class="params">(<span class="type">int</span> acceptfd, MSG *msg, <span class="type">char</span> word[])</span>&#123;  <span class="comment">//2.查询客户端传过来的单词---&gt;从另一个函数过来的</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">//打开文件，读取文件，进行对比</span></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">&quot;dict.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)&#123;     <span class="comment">//以只读方式打开文件dict.txt,如果等于NULL就是打开文件失败</span></span><br><span class="line">        perror(<span class="string">&quot;fail to fopen...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data, <span class="string">&quot;failed to open dict.txt&quot;</span>);  <span class="comment">//失败就返回打开词库失败的信息给客户端</span></span><br><span class="line">        send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);        <span class="comment">//打开文件失败，将该信息发送给客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;                            <span class="comment">//打开文件失败，直接退出，进入接收命令状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找出客户端要查询的单词(词库是按升序排列的)</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(word);                   <span class="comment">//查询单词的长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, len = %d\n&quot;</span>, word, len);      <span class="comment">//打印到终端要查询的单词和长度</span></span><br><span class="line">    <span class="comment">//读文件，来查询单词</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(temp, <span class="number">512</span>, fp) != <span class="literal">NULL</span>)&#123;          <span class="comment">//每次最多从文件读取512个字符,读满或遇到换行符就结束(说明这一次性是只读了一行数据)</span></span><br><span class="line">        result = <span class="built_in">strncmp</span>(temp,word,len);          <span class="comment">//对单词进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;       <span class="comment">//这种情况是在词库中，查询的当前行单词比客户端要查询的单词小，说明，还需要往后查</span></span><br><span class="line">            <span class="keyword">continue</span>;         <span class="comment">//退出这种循环，继续下一次循环查询</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result&gt;<span class="number">0</span> || ((result == <span class="number">0</span>) &amp;&amp; (temp[len]!=<span class="string">&#x27; &#x27;</span>)))&#123;   <span class="comment">//这种情况是在词库中找不到客户端要查询的单词</span></span><br><span class="line">            <span class="keyword">break</span>;                      <span class="comment">//跳出循环，说明没有找到该单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示找到了，查询的单词</span></span><br><span class="line">        p = temp + len;         <span class="comment">//让p到达了单词末尾</span></span><br><span class="line">        <span class="keyword">while</span>(*p == <span class="string">&#x27; &#x27;</span>)&#123;       <span class="comment">//去掉空格</span></span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跳跃过所以的空格，找到了注释</span></span><br><span class="line">        <span class="built_in">strcpy</span>(msg-&gt;data, p);         <span class="comment">//拷贝注释到data</span></span><br><span class="line">        fclose(fp);                   <span class="comment">//注释拷贝完毕之后，关闭文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                     <span class="comment">//找到了该单词的注释，就返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);                     <span class="comment">//表示没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                       <span class="comment">//没有找到，就返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_date</span><span class="params">(<span class="type">char</span> *date)</span>&#123;           <span class="comment">//3.获取当前时间</span></span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tp</span>;</span></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    <span class="comment">//进行时间格式转换(得到的是从1970年到现在的秒数)</span></span><br><span class="line">    tp = localtime(&amp;t);</span><br><span class="line">    <span class="built_in">sprintf</span>(date,<span class="string">&quot;%d-%d-%d %d:%d:%d&quot;</span>,tp-&gt;tm_year+<span class="number">1900</span>, tp-&gt;tm_mon+<span class="number">1</span>, tp-&gt;tm_mday, tp-&gt;tm_hour, tp-&gt;tm_min, tp-&gt;tm_sec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询历史记录：这部分实现的就是处理客户端的查询历史记录的请求任务，通过客户端的用户名，服务器在数据库的record表中进行查询该用户产生的历史记录，并逐一发来客户端。最后执行完该函数后，会继续监听该客户端的下一个请求任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_history</span><span class="params">(<span class="type">int</span> acceptfd, MSG *msg, sqlite3 *db)</span>&#123;    <span class="comment">//a只能查询a的历史记录，b只能查询b的历史记录</span></span><br><span class="line">    <span class="type">char</span> sql[<span class="number">128</span>] = &#123;&#125;;          <span class="comment">//存放sql语句</span></span><br><span class="line">    <span class="type">char</span> *errmsg;</span><br><span class="line">    <span class="comment">//通过用户名，拼接在数据库record表中查询该用户产生的的记录的语句</span></span><br><span class="line">    <span class="built_in">sprintf</span>(sql,<span class="string">&quot;select * from record where name = &#x27;%s&#x27;&quot;</span>,msg-&gt;name);     <span class="comment">//这里是查询某个用户执行查询的历史记录</span></span><br><span class="line">    <span class="comment">//执行该语句，查询数据库</span></span><br><span class="line">    <span class="keyword">if</span>(sqlite3_exec(db,sql,history_callback,(<span class="type">void</span> *)&amp;acceptfd, &amp;errmsg) != SQLITE_OK)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,errmsg);                       <span class="comment">//查询数据库失败，打印具体错误原因</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query record done...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有的记录查询发送完毕之后(查到几条数据，回调函数就执行了几次)，给客户端发出一个结束的信息，客户端那边接受到了&#x27;\0&#x27;就知道所有的记录的发送完毕</span></span><br><span class="line">    msg-&gt;data[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    send(acceptfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);          <span class="comment">//像客户端发送发送完毕的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到查询结果(查到n条记录，就执行n次回调函数)，并且需要将历史记录发送给客户端</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">history_callback</span><span class="params">(<span class="type">void</span>* arg, <span class="type">int</span> f_num, <span class="type">char</span>** f_value, <span class="type">char</span>** f_name)</span>&#123; <span class="comment">//从sqlite3_callback传过来的参数;查询结果的列数；存放列数的结果；列的名字</span></span><br><span class="line">    <span class="comment">//record：name,data,word ---&gt;name就是客户端登录的时候，保存的客户名</span></span><br><span class="line">    <span class="type">int</span> acceptfd = *((<span class="type">int</span> *)arg);    <span class="comment">//将传过来的参数强制转换，并取值</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="built_in">sprintf</span>(msg.data, <span class="string">&quot;%s , %s&quot;</span>,f_value[<span class="number">1</span>], f_value[<span class="number">2</span>]);</span><br><span class="line">    send(acceptfd, &amp;msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>);        <span class="comment">//每一次执行回调函数都是只将一条记录发送给客户端</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-客户端"><a href="#3-2-客户端" class="headerlink" title="3.2 客户端"></a>3.2 客户端</h2><p>主函数和一些基本信息：这部分定义了一个双方通信的信息结构体，其中type是R时，表示用户要求完成注册任务；是L时，表示用户要求完成登录任务；是Q时，表示用户要求完成查询任务；是H时，表示用户要求完成历史查询任务。客户端完成了任务函数后，又会继续等待用户从终端输入请求序号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R 1    <span class="comment">//user - register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 2    <span class="comment">//user - login</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q 3    <span class="comment">//user - query</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H 4    <span class="comment">//user - history</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义通信双方的信息结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">char</span> name[N];</span><br><span class="line">    <span class="type">char</span> data[<span class="number">256</span>];</span><br><span class="line">&#125;MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span>    <span class="comment">//存放服务器信息的结构体</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;                    <span class="comment">//说明执行命令的时候，密钥输入ip和端口，直接退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage:%s serverip port.\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//获取通信描述符</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;fail to socket...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bzero(&amp;serveraddr,<span class="keyword">sizeof</span>(serveraddr));               <span class="comment">//对结构体里的内容进行清空</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr))&lt;<span class="number">0</span>)&#123;      <span class="comment">//连接服务端</span></span><br><span class="line">        perror(<span class="string">&quot;fail to connect...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功连接服务端后，就进入下面界面</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*****************************************************************************\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* 1.register                   2.login                   3.quit             *\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;*****************************************************************************\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please choose:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);              <span class="comment">//接收终端传来的命令序号</span></span><br><span class="line">        getchar();                    <span class="comment">//去掉垃圾字符(回车字符)</span></span><br><span class="line">        <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                do_register(sockfd, &amp;msg);    <span class="comment">//输入的是1，进入注册函数。参数是通信描述符、MSG结构体的一个地址</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(do_login(sockfd, &amp;msg) == <span class="number">1</span>)&#123;   <span class="comment">//输入的是2，则进入登录函数(输入的账号和密码存在则返回1)，否则返回0，继续循环该界面</span></span><br><span class="line">                    <span class="keyword">goto</span> next;             <span class="comment">//返回1，则登录成功，跳转到二级菜单</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                close(sockfd);             <span class="comment">//输入的是3，关闭通信描述符，直接退出，断开与服务端的连接</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);                   <span class="comment">//退出进程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid data cmd...\n&quot;</span>);    <span class="comment">//输入的是其他东西，打印该行内容，然后继续循环该界面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">next:</span><br><span class="line">    <span class="comment">//登录成功，进入下面二级界面</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;- 1.query_word                  2.history_record                  3.quit      -\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please choose:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        getchar();                     <span class="comment">//去掉垃圾字符(回车字符)</span></span><br><span class="line">        <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                do_query(sockfd, &amp;msg);           <span class="comment">//输入的是1，进入单词查询界面。参数是通信描述符、MSG结构体的地址</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                do_history(sockfd, &amp;msg);         <span class="comment">//输入的是2，进入查询历史函数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                close(sockfd);                    <span class="comment">//输入的是3，关闭通信描述符，直接退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Invalid data cmd...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对应的功能函数实现：根据用户输入的请求序号，执行对应的处理任务。</p>
<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">注册函数实现</button><button type="button" class="tab " data-href="test4-2">登录函数实现</button><button type="button" class="tab " data-href="test4-3">查询单词实现</button><button type="button" class="tab " data-href="test4-4">查询历史记录实现</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>这部分负责处理用户的注册请求，用户从终端输入用户名和密码，客户端将该信息发送给服务器，服务器完成成功与否都会发送信息会客户端，客户端打印服务器发送来的信息告知用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_register</span><span class="params">(<span class="type">int</span> sockfd, MSG *msg)</span>&#123;       <span class="comment">//注册函数，参数：通信描述符 和 发送消息结构体</span></span><br><span class="line">    msg-&gt;type = R;                           <span class="comment">//对type赋值1     </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input name:&quot;</span>);                   <span class="comment">//提示输入姓名</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msg-&gt;name);                  <span class="comment">//接收用户输入的姓名，存到name</span></span><br><span class="line">    getchar();                               <span class="comment">//去掉残留的垃圾字符</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input passwd:&quot;</span>);                      <span class="comment">//提示输入密码</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,msg-&gt;data);                        <span class="comment">//接收密码，存到data</span></span><br><span class="line">    <span class="keyword">if</span>(send(sockfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;     <span class="comment">//发送给服务端R(服务端接收R就通过R进入对应的函数执行)、姓名、密码信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to send...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(recv(sockfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;    <span class="comment">//接收服务端那边是否完成注册任务的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to recv...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,msg-&gt;data);                    <span class="comment">//打印传过来的内容，ok表示注册成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                    <span class="comment">//返回0，直接退出，继续循环该界面，接收命令序号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>这部分负责处理用户的登录请求，用户从终端输入用户名和密码，客户端将这些信息发送给服务器，服务器返回处理的结果。登录成功的话，用户进入二级目录，等待用户请求指令；登录失败的话，用户继续在一级目录，等待用户的请求指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_login</span><span class="params">(<span class="type">int</span> sockfd, MSG *msg)</span>&#123;                  <span class="comment">//登录函数</span></span><br><span class="line">    msg-&gt;type = L;                           <span class="comment">//对type赋值为2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input name:&quot;</span>);                   <span class="comment">//接收姓名</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msg-&gt;name);</span><br><span class="line">    getchar();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input passwd:&quot;</span>);                 <span class="comment">//接收密码</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,msg-&gt;data);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(send(sockfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;   <span class="comment">//发送给服务端L、姓名、密码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to send...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(recv(sockfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;   <span class="comment">//接收服务端传过来的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to recv...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收到服务端发来的信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(msg-&gt;data, <span class="string">&quot;OK&quot;</span>,<span class="number">3</span>) == <span class="number">0</span>)&#123;       <span class="comment">//服务端发来OK表示数据库有该用户</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Login ok!\n&quot;</span>);       <span class="comment">//则打印成功登录</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                    <span class="comment">//返回1，进入二级目录</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                            <span class="comment">//数据库没有该用户，打印服务端发来的信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,msg-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;      <span class="comment">//这种情况是登录失败，返回0，继续在一级目录循环等待用户的请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-3"><p>这部分负责处理用户的查询单词请求，用户从终端输入要查询的单词，客户端将该单词发送给服务器，服务器在底层进行查询，将查询的结果返回给客户端，客户端向终端打印服务器发送来的查询结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_query</span><span class="params">(<span class="type">int</span> sockfd, MSG *msg)</span>&#123;              <span class="comment">//查询单词</span></span><br><span class="line">    msg-&gt;type = Q;                               <span class="comment">//type赋值为3</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input word:&quot;</span>);               <span class="comment">//输入查询单词</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, msg-&gt;data);              <span class="comment">//将单词赋值给data</span></span><br><span class="line">        <span class="comment">//用户输入#，返回上一级菜单</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(msg-&gt;data,<span class="string">&quot;#&quot;</span>,<span class="number">1</span>)==<span class="number">0</span>)&#123;     <span class="comment">//如果输入的是#，退出循环(查询状态)，进入二级界面(说明退出查询)</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将要查询的单词发送给服务器</span></span><br><span class="line">        <span class="keyword">if</span>(send(sockfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fail to send...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待接受服务器，传递回来的单词的注释信息</span></span><br><span class="line">        <span class="keyword">if</span>(recv(sockfd, msg, <span class="keyword">sizeof</span>(MSG),<span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fail to recv...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg-&gt;data);        <span class="comment">//输出服务端传来的信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-4"><p>这部分负责处理用户的查询历史记录请求，客户端只需要将请求序号赋值到type，发送给服务器即可，服务器接收到信息是type是H，就会通过该用户的用户名进行历史记录查询，将查询到的结果返回给客户端，客户端向终端打印查询的记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_history</span><span class="params">(<span class="type">int</span> sockfd, MSG *msg)</span>&#123;             <span class="comment">//查看历史查询</span></span><br><span class="line">    msg-&gt;type = H;</span><br><span class="line">    send(sockfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>);        <span class="comment">//发送给服务端信息---&gt;主要是传送H</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接受服务器，传递回来的历史记录信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        recv(sockfd, msg, <span class="keyword">sizeof</span>(MSG), <span class="number">0</span>);    <span class="comment">//接收服务端传来的结果</span></span><br><span class="line">        <span class="keyword">if</span>(msg-&gt;data[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;             <span class="comment">//当服务端将所有历史记录发送完毕后，会发送&#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">break</span>;                        <span class="comment">//查询完毕，退出循环，进入二级目录，等待下一个命令</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出历史记录信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,msg-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时不应该关闭sockfd,因为一个客户端在查询完历史记录后，不代表，它要退出，也可能还要执行其他业务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<h1 id="4-执行效果"><a href="#4-执行效果" class="headerlink" title="4. 执行效果"></a>4. 执行效果</h1><p>第一个用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_1.png"></p>
<p>第二个用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_2.png"></p>
<p>两个用户产生的数据库中的数据情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_3.png"></p>
<p>词库的单词情况，大约20000个单词</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_4.png"></p>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>网络编程</tag>
        <tag>sqlite3</tag>
      </tags>
  </entry>
  <entry>
    <title>grpc在windows环境下的配置与编译</title>
    <url>/2024/07/22/grpc%E5%9C%A8windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>gRPC(全称为<strong>gRPC Remote Procedure Call</strong>)是一种高性能、开源的远程过程调用(RPC)框架。由Google开发，gRPC基于HTTP&#x2F;2协议，并使用Protocol Buffers(Protobufs)作为接口描述语言。以下是gRPC的一些关键特性和优势：</p>
<ul>
<li><p><strong>高性能</strong>：gRPC利用HTTP&#x2F;2的特性，例如多路复用和二进制协议，提高了传输效率和性能。</p>
</li>
<li><p><strong>多语言支持</strong>：gRPC支持多种编程语言，包括C++、Java、Python、Go、Ruby、C#等，使得开发人员可以在不同的编程环境中使用它。</p>
</li>
<li><p><strong>简化开发</strong>：通过使用Protobufs，gRPC提供了一种简洁和高效的方式来定义服务接口和消息结构。</p>
</li>
<li><p><strong>双向流</strong>：gRPC支持客户端和服务器之间的双向流通信，使得它在需要实时通信的应用场景中表现尤为出色。</p>
</li>
<li><p><strong>负载均衡和命名解析</strong>：gRPC内置了负载均衡和命名解析功能，使其更易于在分布式系统中使用。</p>
</li>
</ul>
<h2 id="1-1-主要组成部分"><a href="#1-1-主要组成部分" class="headerlink" title="1.1 主要组成部分"></a>1.1 主要组成部分</h2><ol>
<li><p><strong>服务定义</strong>：开发者使用Protobufs定义服务和消息。</p>
</li>
<li><p><strong>客户端和服务器代码生成</strong>：gRPC使用Protobufs定义生成相应的客户端和服务器代码。</p>
</li>
<li><p><strong>传输层</strong>：基于HTTP&#x2F;2协议进行高效的数据传输。</p>
</li>
</ol>
<h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><ol>
<li><p><strong>微服务架构</strong>：在微服务架构中，gRPC常被用来实现服务间的高效通信。</p>
</li>
<li><p><strong>实时通信应用</strong>：由于支持双向流，gRPC非常适用于需要实时通信的应用，例如聊天应用、视频流应用等。</p>
</li>
<li><p><strong>跨语言服务</strong>：gRPC的多语言支持使得它非常适合跨语言的服务调用场景。</p>
</li>
</ol>
<h1 id="2-grpc配置"><a href="#2-grpc配置" class="headerlink" title="2. grpc配置"></a>2. grpc配置</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h2><p>由于国内环境，grpc下载极其困难的。目前在Gitee上只能找到gRPC依赖的部分”官方”镜像仓库，而网上提供的镜像仓库较旧，所以这里我构造的是v1.34.0版本。通过下面代码，选择一个稳定的分支进行克隆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.34.0 https://gitee.com/mirrors/grpc-framework.git grpc</span><br></pre></td></tr></table></figure>

<p>选择一个存放grpc项目的文件，按下Shift+鼠标右键，就会弹出如下目录，点击<code>Open Git Bash here</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_1.png"></p>
<p>弹出bash终端，输入上述代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_2.png"></p>
<p>下载完成后，在你选择的目录下出现一个grpc的文件夹，就表示克隆完成。</p>
<h2 id="2-2-修改文件内容"><a href="#2-2-修改文件内容" class="headerlink" title="2.2 修改文件内容"></a>2.2 修改文件内容</h2><p>在克隆下来的grpc文件中，有一个.gitmodules文件，里面存放的是我们需要的grpc子模块的网址，一般方式是访问不了的，所以需要修改成我们能够访问的国内的gitee上仓库的地址。这里直接将下面代码复制去替换.gitmodules文件里面的内容。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/zlib&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/zlib</span></span><br><span class="line">    <span class="comment">#url = https://github.com/madler/zlib</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/zlib.git</span></span><br><span class="line">    <span class="comment"># When using CMake to build, the zlib submodule ends up with a</span></span><br><span class="line">    <span class="comment"># generated file that makes Git consider the submodule dirty. This</span></span><br><span class="line">    <span class="comment"># state can be ignored for day-to-day development on gRPC.</span></span><br><span class="line">    <span class="string">ignore</span> <span class="string">=</span> <span class="string">dirty</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/protobuf&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/protobuf</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/protobuf.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/protobuf.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/googletest&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/googletest</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/googletest.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/googletest.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/benchmark&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/benchmark</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/benchmark</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/google-benchmark.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/boringssl-with-bazel&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/boringssl-with-bazel</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/boringssl.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/boringssl.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/re2&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/re2</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/re2.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/re2.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/cares/cares&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/cares/cares</span></span><br><span class="line">    <span class="comment">#url = https://github.com/c-ares/c-ares.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/c-ares.git</span></span><br><span class="line">    <span class="string">branch</span> <span class="string">=</span> <span class="string">cares-1_12_0</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/bloaty&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/bloaty</span></span><br><span class="line">    <span class="comment">#url = https://github.com/google/bloaty.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/bloaty.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/abseil-cpp&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/abseil-cpp</span></span><br><span class="line">    <span class="comment">#url = https://github.com/abseil/abseil-cpp.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/abseil-cpp.git</span></span><br><span class="line">    <span class="string">branch</span> <span class="string">=</span> <span class="string">lts_2020_02_25</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/envoy-api&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/envoy-api</span></span><br><span class="line">    <span class="comment">#url = https://github.com/envoyproxy/data-plane-api.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/data-plane-api.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/googleapis&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/googleapis</span></span><br><span class="line">    <span class="comment">#url = https://github.com/googleapis/googleapis.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/googleapis.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/protoc-gen-validate&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/protoc-gen-validate</span></span><br><span class="line">    <span class="comment">#url = https://github.com/envoyproxy/protoc-gen-validate.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/protoc-gen-validate.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/udpa&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/udpa</span></span><br><span class="line">    <span class="comment">#url = https://github.com/cncf/udpa.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/local-grpc/udpa.git</span></span><br><span class="line">[<span class="string">submodule</span> <span class="string">&quot;third_party/libuv&quot;</span>]</span><br><span class="line">    <span class="string">path</span> <span class="string">=</span> <span class="string">third_party/libuv</span></span><br><span class="line">    <span class="comment">#url = https://github.com/libuv/libuv.git</span></span><br><span class="line">    <span class="string">url</span> <span class="string">=</span> <span class="string">https://gitee.com/mirrors/libuv.git</span></span><br></pre></td></tr></table></figure>

<p>然后使用如下指令更新gRPC所有依赖：在grpc目录下点击<code>Open Git Bash here</code>，在弹出的bash终端输入下面指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<h1 id="3-编译"><a href="#3-编译" class="headerlink" title="3. 编译"></a>3. 编译</h1><h2 id="3-1-创建存放生成的vs项目位置"><a href="#3-1-创建存放生成的vs项目位置" class="headerlink" title="3.1 创建存放生成的vs项目位置"></a>3.1 创建存放生成的vs项目位置</h2><p>在grpc目录下创建一个visualpro文件夹，用于存放生成的windows所用的项目。</p>
<h2 id="3-2-启动CMake"><a href="#3-2-启动CMake" class="headerlink" title="3.2 启动CMake"></a>3.2 启动CMake</h2><p>启动CMake后，会出现下面界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_3.png"></p>
<p>点击Configure后，出现以下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_4.png"></p>
<p>点击Finish后，等待编译，完成后就得到以下界面，不需要修改，直接点击Configure，生成配置。**(到这里可以先完成go和NASM的安装，因为不确定在接下来的grpc编译和生成中会不会需要它们)**</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_5.png"></p>
<p>配置完成后，点击Generate直接生成。生成成功后，在visualpro目录下会出现生成的文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_10.png"></p>
<p>其中grpc.sln是创建的工程的路径，点击打开，出现以下界面，找到ALL_BUILD，右键选择重新生成(时间有点长)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_11.png"></p>
<p>上面生成的是Debug版本，下面在重新生成Release的版本。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_12.png"></p>
<p>当visualpro目录下出现Debug和Release文件时，说明生成完毕！</p>
<h2 id="3-3-下载并配置NASM"><a href="#3-3-下载并配置NASM" class="headerlink" title="3.3 下载并配置NASM"></a>3.3 下载并配置NASM</h2><p>编译grpc需要准备nasm，下载网址为<a href="https://www.nasm.us/">https://www.nasm.us/</a>，点击网址后进入NASM官网，点击右上角的DOWNLOAD，选择版本2.16，选择系统Win64，然后下载NASM的可执行文件<code>nasm-2.16-installer-x64.exe</code>，下载好后得到以下可执行文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_6.png"></p>
<p>然后点击该可执行文件，安装步骤是一直next即可。</p>
<p>找到刚刚安装的目录，复制该路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_7.png"></p>
<p>将该路径配置到环境变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_8.png"></p>
<h1 id="4-安装go"><a href="#4-安装go" class="headerlink" title="4. 安装go"></a>4. 安装go</h1><p>windows环境下下载go，安装地址：<a href="https://studygolang.com/dl">https://studygolang.com/dl</a>。根据自己系统下载，什么版本都可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/grpc/5_9.png"></p>
<p>下载好后，进行安装，一直next即可，安装好后go会自动写入我们的环境变量。然后打开终端，执行<code>go version</code>，出现对应的go版本，就表示安装成功。</p>
<p>替换代理，在终端执行以下代码，换成国内网络直连的模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>配置环境</category>
      </categories>
      <tags>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2024/07/04/makefile/</url>
    <content><![CDATA[<p>使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Visual C++的nmake，QtCreator的qmake等。</p>
<p>makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p>
<p>makefile文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make这个目录下的 makefile 文件就会被加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中</p>
<h1 id="1-gcc工作流程"><a href="#1-gcc工作流程" class="headerlink" title="1. gcc工作流程"></a>1. gcc工作流程</h1><blockquote>
<p>GCC编译器对程序的编译下图所示，分为4个阶段：预处理(预编译)、编译和优化、汇编和链接。GCC的编译器可以将这4个步骤合并成一个。</p>
</blockquote>
<ul>
<li><p>预处理：在这个阶段主要做了三件事：展开头文件、宏替换、求掉注释行。这个阶段需要GCC调用预处理器来完成，最终得到的还是源文件，文本格式。</p>
</li>
<li><p>这个阶段需要GCC调用编译器对文件进行编译，最终得到一个汇编文件。</p>
</li>
<li><p>这个阶段需要GCC调用汇编器对文件进行汇编，最终得到一个二进制文件。</p>
</li>
<li><p>这个阶段需要GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">文件名后缀</th>
<th align="center">说明</th>
<th align="center">gcc参数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.c</td>
<td align="center">源文件</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">.i</td>
<td align="center">预处理后的c文件</td>
<td align="center">-E</td>
</tr>
<tr>
<td align="center">.s</td>
<td align="center">编译之后得到的汇编语言的源文件</td>
<td align="center">-S</td>
</tr>
<tr>
<td align="center">.o</td>
<td align="center">汇编后得到的二进制文件</td>
<td align="center">-C</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编程：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法1:</span></span><br><span class="line">gcc -E mycode1.c -o mycode1.i   #生成预处理文件</span><br><span class="line">gcc -S mycode1.i -o mycode1.s   #生成汇编文件</span><br><span class="line">gcc -c mycode1.s -o mycode1.o   #生成二进制文件</span><br><span class="line">gcc mycode1.o -o mycode1        #链接，生成可执行文件</span><br><span class="line">./mycode1                       #执行可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法2</span></span><br><span class="line">gcc mycode1.c -o aa            #直接生成可执行文件</span><br><span class="line">./aa                           #执行可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">方法3</span></span><br><span class="line">gcc mycode1.c                  #默认会生成a.out这个文件</span><br><span class="line">./a.out                        #执行可执行文件</span><br></pre></td></tr></table></figure>

<h1 id="2-gcc参数与g"><a href="#2-gcc参数与g" class="headerlink" title="2. gcc参数与g++"></a>2. gcc参数与g++</h1><blockquote>
<p>下面的表格中列出了常用的一些gcc参数, 这些参数在 gcc命令中没有位置要求，只需要编译程序的时候将需要的参数指定出来即可</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">gcc编译选项</th>
<th align="center">选项的意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-E</td>
<td align="center">预处理指定的源文件，不进行编译</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">编译指定的源文件，但是不进行汇编</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">编译、汇编指定的源文件，但是不进行链接</td>
</tr>
<tr>
<td align="center">-I directory (大写的i)</td>
<td align="center">指定 include 包含文件的搜索目录</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">在编译的时候，生成调试信息，该程序可以被调试器调试</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">在程序编译的时候，指定一个宏</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">不生成任何警告信息, 不建议使用, 有些时候警告就是错误</td>
</tr>
<tr>
<td align="center">-L</td>
<td align="center">指定编译的时候，搜索的库的路径</td>
</tr>
<tr>
<td align="center">-fPIC&#x2F;fpic</td>
<td align="center">生成与位置无关的代码</td>
</tr>
<tr>
<td align="center">-shared</td>
<td align="center">生成共享目标文件。通常用在建立共享库时</td>
</tr>
<tr>
<td align="center">-std</td>
<td align="center">指定C方言，如:-std&#x3D;c99，gcc默认的方言是GNU C</td>
</tr>
</tbody></table>
<blockquote>
<p>关于对gcc和g++的理解，下边从三个方面介绍一下二者的区别：</p>
</blockquote>
<ol>
<li><p>在代码编译阶段(第二个阶段)：</p>
<ul>
<li><p>后缀为 .c 的，gcc 把它当作是C程序，而 g++ 当作是 C++ 程序</p>
</li>
<li><p>后缀为.cpp的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些</p>
</li>
<li><p>g++会调用gcc，对于C++代码，两者是等价的, 也就是说 gcc 和 g++ 都可以编译 C&#x2F;C++代码</p>
</li>
</ul>
</li>
<li><p>在链接阶段(最后一个阶段)</p>
</li>
</ol>
<ul>
<li>gcc 和 g++ 都可以自动链接到标准C库</li>
<li>g++ 可以自动链接到标准C++库, gcc如果要链接到标准C++库需要加参数 -lstdc++</li>
</ul>
<blockquote>
<p>综上所述：</p>
<ul>
<li>不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同</li>
<li>g++可以直接编译C++程序， gcc 编译 C++程序需要添加额外参数 -lstdc++</li>
</ul>
</blockquote>
<h1 id="3-makefile规则语法格式"><a href="#3-makefile规则语法格式" class="headerlink" title="3. makefile规则语法格式"></a>3. makefile规则语法格式</h1><blockquote>
<p>每条规则由三个部分组成分别是目标，依赖和命令。下面通过一个例子来阐述一下:</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举例1: 假设有源文件a.c、b.c、c.c和head.h, 现在需要生成可执行程序test1</span></span><br><span class="line"><span class="comment"># 有一个目标，多个依赖，一条命令</span></span><br><span class="line"><span class="comment">################# 例1 #################</span></span><br><span class="line"><span class="section">test1:a.c b.c c.c</span></span><br><span class="line">	gcc a.c b.c c.c -o test1</span><br><span class="line"></span><br><span class="line"><span class="comment">################# 例2 #################</span></span><br><span class="line"><span class="comment"># 举例2: 假设有源文件a.c、b.c、c.c和d.c, 现在需要生成可执行程序test1,test2</span></span><br><span class="line"><span class="comment"># 有多个目标, 多个依赖, 多个命令</span></span><br><span class="line"><span class="section">test1,test2:a.c b.c c.c d.c</span></span><br><span class="line">	gcc a.c b.c -o test1</span><br><span class="line">	gcc c.c d.c -o test2</span><br><span class="line">	</span><br><span class="line"><span class="comment">################# 例3 #################	</span></span><br><span class="line"><span class="comment"># 举例3: 假设有源文件a.c、b.c、c.c和head.h, 现在需要生成可执行程序test1</span></span><br><span class="line"><span class="comment"># 有一个目标，多个依赖，多条命令</span></span><br><span class="line"><span class="section">test1:a.o b.o c.o</span></span><br><span class="line">	gcc a.o b.o c.o -o test1</span><br><span class="line"><span class="comment"># a.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">a.o:a.c</span></span><br><span class="line">	gcc -c a.c</span><br><span class="line"><span class="comment"># b.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">b.o:b.c</span></span><br><span class="line">	gcc -c b.c</span><br><span class="line"><span class="comment"># c.o 是第一条规则中的依赖</span></span><br><span class="line"><span class="section">c.o:c.c</span></span><br><span class="line">	gcc -c c.c</span><br></pre></td></tr></table></figure>

<h1 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4. 工作原理"></a>4. 工作原理</h1><p>在调用make命令编辑程序的时候，make会首先找到该目录下的makefile文件中的第一条规则，分析并执行相关操作，但需要注意的是，好多时候要执行的动作(命令)中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。</p>
<p>对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。</p>
<p>这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make的任务也就完成了。</p>
<h2 id="4-1-目标文件的更新"><a href="#4-1-目标文件的更新" class="headerlink" title="4.1 目标文件的更新"></a>4.1 目标文件的更新</h2><ol>
<li><p>依赖文件存在，目标文件不存在，make就会根据依赖来生成目标文件</p>
</li>
<li><p>依赖和目标都是存在的：</p>
<ul>
<li><p>目标的时间大于依赖的时间，此时不更新目标文件；</p>
</li>
<li><p>目标的时间小于依赖的时间，此时make会根据依赖更新目标文件；</p>
</li>
</ul>
</li>
</ol>
<h2 id="4-2-自动推导"><a href="#4-2-自动推导" class="headerlink" title="4.2 自动推导"></a>4.2 自动推导</h2><blockquote>
<p>虽然make需要根据makefile中指定的规则来完成源文件的编译，但是我们会发现当漏写一些构建规则时，程序还是会被编译成功，这是因为make有自动推导的能力，不会完全依赖makefile。</p>
</blockquote>
<p>注意：命令行前面是一个tab健距离；</p>
<h2 id="4-3-变量"><a href="#4-3-变量" class="headerlink" title="4.3 变量"></a>4.3 变量</h2><blockquote>
<p>使用makefile进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile中的变量分为三种：自定义变量、预定义变量和自动变量。</p>
</blockquote>
<ol>
<li><p>自定义变量：用makefile进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。</p>
</li>
<li><p>预定义变量：在makefile中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量名</th>
<th align="center">含义</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AR</td>
<td align="center">生成静态库库文件的程序名称</td>
<td align="center">ar</td>
</tr>
<tr>
<td align="center">AS</td>
<td align="center">汇编编译器的名称</td>
<td align="center">as</td>
</tr>
<tr>
<td align="center">CC</td>
<td align="center">C 语言编译器的名称</td>
<td align="center">cc</td>
</tr>
<tr>
<td align="center">CPP</td>
<td align="center">C 语言预编译器的名称</td>
<td align="center">$(CC) -E</td>
</tr>
<tr>
<td align="center">CXX</td>
<td align="center">C++语言编译器的名称</td>
<td align="center">g++</td>
</tr>
<tr>
<td align="center">FC</td>
<td align="center">FORTRAN 语言编译器的名称</td>
<td align="center">f77</td>
</tr>
<tr>
<td align="center">RM</td>
<td align="center">删除文件程序的名称</td>
<td align="center">rm -f</td>
</tr>
<tr>
<td align="center">ARFLAGS</td>
<td align="center">生成静态库库文件程序的选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">ASFLAGS</td>
<td align="center">汇编语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CFLAGS</td>
<td align="center">C 语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CPPFLAGS</td>
<td align="center">C 语言预编译的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">CXXFLAGS</td>
<td align="center">C++语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">FFLAGS</td>
<td align="center">FORTRAN 语言编译器的编译选项</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个规则，普通写法</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量和预定义变量</span></span><br><span class="line">obj=add.o  div.o  main.o  mult.o  sub.o</span><br><span class="line">target=calc</span><br><span class="line">CFLAGS=-O3 <span class="comment"># 代码优化</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">        <span class="variable">$(CC)</span>  <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span> <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自动变量：自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$*</td>
<td align="center">表示目标文件的名称，不包含目标文件的扩展名</td>
</tr>
<tr>
<td align="center">$+</td>
<td align="center">表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件</td>
</tr>
<tr>
<td align="center">$&lt;</td>
<td align="center">表示依赖项中第一个依赖文件的名称</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">表示目标文件的名称，包含文件扩展名</td>
</tr>
<tr>
<td align="center">$^</td>
<td align="center">依赖项中，所有不重复的依赖文件，这些文件之间以空格分开</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># *****************#例1********************</span></span><br><span class="line">target=calc</span><br><span class="line">obj=add.o div.o main.o mult.o sub.o</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="comment">#简化后的代码：$&lt;和-c互换位置也可以</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> -c</span><br><span class="line"><span class="comment"># ****************************************</span></span><br><span class="line"><span class="comment"># *****************#例2********************</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc  </span><br><span class="line"><span class="comment"># 这是一个规则，里边使用了自定义变量</span></span><br><span class="line"><span class="comment"># 使用自动变量, 替换相关的内容</span></span><br><span class="line"><span class="section">calc:add.o  div.o  main.o  mult.o  sub.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> 			<span class="comment"># 自动变量只能在规则的命令中使用</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-wildcard函数"><a href="#4-4-wildcard函数" class="headerlink" title="4.4 wildcard函数"></a>4.4 wildcard函数</h2><blockquote>
<p>这个函数的主要作用是获取指定目录下指定类型的文件名，器返回值是以空格分割的、指定目录下的所有符合条件的文件列表。</p>
</blockquote>
<p>使用：$(wildcard,参数,参数,…..)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> /home/robin/a/*.c /home/robin/b/*.c *.c)</span>  <span class="comment"># *.c == ./*.c</span></span><br><span class="line"><span class="comment"># 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔</span></span><br><span class="line">/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c</span><br></pre></td></tr></table></figure>

<h2 id="4-5-patsubst函数"><a href="#4-5-patsubst函数" class="headerlink" title="4.5 patsubst函数"></a>4.5 patsubst函数</h2><p>这个函数的功能是按照指定的模式替换指定文件名的后缀。</p>
<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = a.cpp b.cpp c.cpp e.cpp              <span class="comment"># 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(src)</span>)</span>       <span class="comment"># obj 的值为: a.o b.o c.o e.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#**************修改后的代码*********************</span></span><br><span class="line"></span><br><span class="line">target=calc</span><br><span class="line"><span class="comment">#搜索当前目录下的源文件</span></span><br><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"><span class="comment">#后缀的替换</span></span><br><span class="line">obj=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(src)</span>)</span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(obj)</span></span><br><span class="line">	gcc <span class="variable">$(obj)</span> -o <span class="variable">$(target)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc <span class="variable">$&lt;</span> .c</span><br><span class="line"><span class="comment">#构建伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm <span class="variable">$(obj)</span> <span class="variable">$(target)</span>     <span class="comment">#添加伪目标后，以后可以直接通过make clean方便第删除*.p和calc文件</span></span><br></pre></td></tr></table></figure>

<p>补：在命令前面加上-，当该命令不能执行时，也可以继续执行下面的的命令(-mkdir &#x2F;abc)</p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>makefile</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本编程</title>
    <url>/2024/07/06/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Shell脚本入门"><a href="#1-Shell脚本入门" class="headerlink" title="1. Shell脚本入门"></a>1. Shell脚本入门</h1><h2 id="1-1-脚本格式要求"><a href="#1-1-脚本格式要求" class="headerlink" title="1.1 脚本格式要求"></a>1.1 脚本格式要求</h2><ol>
<li><p>脚本以#!&#x2F;bin&#x2F;bash开头</p>
</li>
<li><p>脚本需要有执行权限</p>
</li>
</ol>
<h2 id="1-2-shell脚本的执行方式"><a href="#1-2-shell脚本的执行方式" class="headerlink" title="1.2 shell脚本的执行方式"></a>1.2 shell脚本的执行方式</h2><ol>
<li><p>输入脚本的绝对路径或相对路径</p>
<ul>
<li>需要对脚本+x权限，再执行脚本</li>
</ul>
</li>
<li><p>sh + 脚本</p>
<ul>
<li>不需要对脚本+x权限，直接执行即可</li>
</ul>
</li>
</ol>
<p>案例：创建一个shell脚本，输出hello,world：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/shcode              #创建一个写shell脚本的文件夹</span><br><span class="line">vim hello.sh                    #在shcode目录下以vim文本编辑器编辑脚本</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入内容如下：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo “hello,world”              #保存退出 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一种方式执行(终端输入)</span></span><br><span class="line">chmod u+x hello.sh             #让该用户对文件有执行的权限</span><br><span class="line">./hello.sh                     #1相对路径执行</span><br><span class="line">/root/shcode/hello.sh          #2绝对路径执行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二种方式执行(不需要权限,终端直接输入)</span></span><br><span class="line">sh hello.sh                    #1相对路径执行</span><br><span class="line">sh /root/shcode/hello.sh       #2绝对路径执行</span><br></pre></td></tr></table></figure>

<h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><h2 id="2-1-shell变量"><a href="#2-1-shell变量" class="headerlink" title="2.1 shell变量"></a>2.1 shell变量</h2><blockquote>
<p>Linux shell中的变量分为，系统和用户自定义变量</p>
</blockquote>
<ol>
<li><p>系统变量：$HOME、$PWD、$SHELL、$USER等等，比如echo $HOME</p>
<ul>
<li>显示当前shell中所有变量：set</li>
</ul>
</li>
<li><p>shell变量的定义（自定义变量）</p>
<ul>
<li><p>定义变量：变量名&#x3D;值</p>
</li>
<li><p>撤销变量：unset 变量</p>
</li>
<li><p>声明静态变量，声明后不能unset：readonly 变量</p>
</li>
</ul>
</li>
<li><p>定义变量的规则</p>
<ul>
<li><p>变量名可以由字母、数字和下划线组成，但是不能以数字开头，</p>
</li>
<li><p>等号两侧不能有空格，如：A&#x3D;100</p>
</li>
<li><p>变量名称一般习惯为大写，这是一个规范</p>
</li>
</ul>
</li>
<li><p>将命令的返回值赋给变量</p>
<ul>
<li><p>A&#x3D;’date’反引号(键盘左上角第二颗键)，运行里面的命令，并把结果返回给变量A</p>
</li>
<li><p>A&#x3D;$(date)等价于反引号</p>
</li>
</ul>
</li>
</ol>
<p>案例：在var.sh里自定义变量、撤销变量、声明静态变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：定义变量</span></span><br><span class="line">A=100</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出变量需要加上$</span></span><br><span class="line">echo A=$A                  #第1种方法输出变量A</span><br><span class="line">echo &quot;A=$A&quot;                #第2种方法输出变量A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：撤销变量A</span></span><br><span class="line">unset A</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销后输出不会报错，但会无结果</span></span><br><span class="line">echo &quot;A=$A&quot;                #输出无结果</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3：声明静态的变量B=2，不能<span class="built_in">unset</span></span></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B                  #输出变量B</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">撤销静态变量会报错</span></span><br><span class="line">unset B                    #报错</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将指令返回的结果赋给变量</span></span><br><span class="line">C=`date`                   #第1种方式将命令的返回值赋给变量</span><br><span class="line">D=$(date)                  #第2种方式将命令的返回值赋给变量</span><br><span class="line">echo C=$C</span><br><span class="line">echo &quot;D=$D&quot; </span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/1.png"></p>
<h2 id="2-2-设置环境变量"><a href="#2-2-设置环境变量" class="headerlink" title="2.2 设置环境变量"></a>2.2 设置环境变量</h2><ol>
<li>将shell变量输出为环境变量&#x2F;全局变量(&#x2F;etc&#x2F;profile文件夹)</li>
</ol>
<ul>
<li>export 变量名&#x3D;变量值</li>
</ul>
<ol start="2">
<li>配置文件，让修改后的配置信息立即生效(终端输入)</li>
</ol>
<ul>
<li>source</li>
</ul>
<ol start="3">
<li>查询环境变量的值</li>
</ol>
<ul>
<li>echo $变量名</li>
</ul>
<p>案例：在&#x2F;etc&#x2F;profile文件中定义TOMCAT_HOME环境变量，并查询其环境变量值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以vim文本编辑器形式打开文件profile</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在最后一行输入这条命令，保存并退出</span></span><br><span class="line">export TOMCAT_HOME=/opt/tomcat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">令修改的信息立即生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后就可以在shell程序中使用了</span></span><br><span class="line">echo $TOMCAT_HOME</span><br></pre></td></tr></table></figure>

<p>补：shell脚本的多行注释：:&lt;&lt;! 内容 !   ——-&gt;后面的!需要单独起行</p>
<h2 id="2-3-位置参数变量"><a href="#2-3-位置参数变量" class="headerlink" title="2.3 位置参数变量"></a>2.3 位置参数变量</h2><blockquote>
<p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。比如：.&#x2F;myshell.sh 100 200，这个就是一个执行shell的命令行，可以在myshell脚本中获取到参数信息。</p>
</blockquote>
<ul>
<li><p>$n：n为数字，$n代表本身，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}；</p>
</li>
<li><p>$*：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整数</p>
</li>
<li><p>$@：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</p>
</li>
<li><p>$#：这个变量代表命令行中所有参数的个数</p>
</li>
</ul>
<p>案例：编写一个shell脚本position.sh，在脚本中获取到命令行的各个参数信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以vim文本编辑器打开</span></span><br><span class="line">vim /root/shcode/myshell.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内容代码</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;0=$0 1=$1 2=$2&quot;     #打印第0、1、2位置的参数</span><br><span class="line">echo &quot;所有的参数=$*&quot;        #输出所有参数，不包括$0</span><br><span class="line">echo &quot;$@&quot;                 #输出所有参数，不包括$0</span><br><span class="line">echo &quot;参数的个数=$#&quot;        #输出参数的个数</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/2.png"></p>
<h2 id="2-4-预定义变量"><a href="#2-4-预定义变量" class="headerlink" title="2.4 预定义变量"></a>2.4 预定义变量</h2><blockquote>
<p>就是shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
</blockquote>
<ul>
<li><p>$$：当前进程的进程好PID；</p>
</li>
<li><p>$!：后台运行的最后一个进程的进程号PID；</p>
</li>
<li><p>$?：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，有命令自己来决定)，则证明上一个命令执行不正确。</p>
</li>
</ul>
<p>案例：在一个shell脚本中简单使用一下预定义变量preVar.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前执行的进程id=$$&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以后台方式运行一个脚本，并获取它的进程号</span></span><br><span class="line">/root/shcode/myshell.sh &amp;</span><br><span class="line">echo &quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="line">echo &quot;执行的结果是=$?&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/3.png"></p>
<h2 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5 运算符"></a>2.5 运算符</h2><ol>
<li><p>$((运算符))或$[运算符]或者expr m 运算符 n</p>
</li>
<li><p>注意expr运算符间要有空格，如果希望将expr的结果赋给某个变量，使用&#96;&#96;(左上角键)</p>
</li>
<li><p>expr m 运算符 n 方式下的运算符</p>
<ul>
<li>expr *，&#x2F;，%  ———–&gt;乘，除，取余</li>
</ul>
</li>
</ol>
<p>案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：计算(2+3)*4的值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第1种方式:</span></span><br><span class="line">res1=$(((2+3)*4))</span><br><span class="line">echo &quot;res1=$res1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第2种方式:</span></span><br><span class="line">res2=$[(2+3)*4]</span><br><span class="line">echo res2=$res2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第3种方式(数字之间要要空格):</span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES3=`expr $TEMP \* 4`</span><br><span class="line">echo res3=$RES3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2:请求出命令行的前两个参数的和(20+50)</span></span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo sum=$SUM</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/4.png"></p>
<h1 id="3-shell进阶"><a href="#3-shell进阶" class="headerlink" title="3. shell进阶"></a>3. shell进阶</h1><h2 id="3-1-条件判断"><a href="#3-1-条件判断" class="headerlink" title="3.1 条件判断"></a>3.1 条件判断</h2><p>基本语法：</p>
<ul>
<li>[ condition ]  括号非空返回true,可以使用$?验证</li>
<li>[ condition ] &amp;&amp; echo ok || echo notok  条件满足，执行后面的语句</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/5.png"></p>
<p>应用实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：23是否大于等于22</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;大于等于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3：/root/shcode/aaa.txt 文件是否存在</span></span><br><span class="line">if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;存在&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例4：测试空</span></span><br><span class="line">if [ lxx ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;hello world&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/6.png"></p>
<h2 id="3-2-流程控制"><a href="#3-2-流程控制" class="headerlink" title="3.2 流程控制"></a>3.2 流程控制</h2><blockquote>
<p>1.多分支</p>
<p>if [ 条件判断式 ]</p>
<p>then</p>
<p>​	代码</p>
<p>elif [ 条件判断式 ]</p>
<p>then</p>
<p>​	代码</p>
<p>fi</p>
</blockquote>
<p>注：[ 条件判断式 ]，中括号和条件判断式之间必须有空格，fi表示结束</p>
<p>案例：请编写一个shell程序，如果输入的参数。大于等于60，则输出”及格了”，如果小于60，则输出”不及格”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!bin/bash</span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;不及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/7.png"></p>
<blockquote>
<p>2.case语句</p>
<p>case $变量名 in</p>
<p>“值1”)</p>
<p>如果变量的值等于1，则执行程序1</p>
<p>;;</p>
<p>“值2”)</p>
<p>如果变量的值等于2，则执行程序2</p>
<p>;;</p>
<p>….省略其他分支…</p>
<p>*)</p>
<p>如果变量的值都不是以上的值，则执行此程序</p>
<p>;;</p>
<p>esac</p>
</blockquote>
<p>案例：当命令行参数是1时，输出”周一”，是2时，就输出”周二”，其他情况输出”other”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other...&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/8.png"></p>
<blockquote>
<p>3.for循环(第1种)</p>
<p>for 变量 in 值1 值2 值3</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>案例：打印命令行输入的参数[这里可以看出$*和$@的区别]：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意 $*是把输出的参数，当作一个整体，所以只会输出一句</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用<span class="variable">$@</span>来获取输入的参数，注意，这时是分别对待，所以有几个参数，就输出几句</span></span><br><span class="line">echo &quot;------------------------------&quot;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;num is $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/9.png"></p>
<blockquote>
<p>4.for循环(第2种)</p>
<p>for((初始值;循环控制条件;变量变化))</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>案例：从1加到100的值输出显示(若想将1001变为一个变量，可以将100改为$1)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0                  #定义一个变量SUM</span><br><span class="line">for((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">写业务代码</span></span><br><span class="line">	SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;总和SUM=$SUM&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/10.png"></p>
<blockquote>
<p>5.while循环</p>
<p>while [ 条件判断式 ]</p>
<p>do</p>
<p>程序&#x2F;代码</p>
<p>done</p>
</blockquote>
<p>注意：while和[有空格，条件判断式和[也有空格</p>
<p>案例：从命令行输入一个数n，统计从1+…+n的值是多少</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0;                    #定义一个变量SUM</span><br><span class="line">i=0;</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">写业务代码</span></span><br><span class="line">	SUM=$[$SUM+$i]</span><br><span class="line">	i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;执行结果=$SUM&quot;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/11.png"></p>
<h1 id="4-read读取控制台输入"><a href="#4-read读取控制台输入" class="headerlink" title="4. read读取控制台输入"></a>4. read读取控制台输入</h1><p>基本语法：read (选项) (参数)</p>
<p>选项：</p>
<ul>
<li><p>-p：指定读取值时的提示符；</p>
</li>
<li><p>-t：指定读取值时等待的时间(秒)，如果没有在指定的时间内输入，就不再等待了；</p>
</li>
</ul>
<p>参数：</p>
<ul>
<li>指定读取值的变量名</li>
</ul>
<p>案例：读取控制台输入一个NUM1值；读取控制台输入一个NUM2值，在10秒内输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取控制台输入一个NUM1</span></span><br><span class="line">read -p &quot;请输入一个NUM1=&quot; NUM1</span><br><span class="line">echo &quot;您输入的NUM1=$NUM1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取控制台输入一个NUM2，并要求在10秒内输入</span></span><br><span class="line">read -t 10 -p &quot;请输入一个数NUM2=&quot; NUM2</span><br><span class="line">echo &quot;您输入的NUM2=$NUM2&quot;</span><br></pre></td></tr></table></figure>

<p>输出的结果如下(第一次是在10秒内输入了93，第二次是没有在10秒内输入数据)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/12.png"></p>
<h1 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h1><p>shell编程和其他编程语言一样，有系统函数，也可以有自定义函数，下面介绍2个</p>
<h2 id="5-1-系统函数"><a href="#5-1-系统函数" class="headerlink" title="5.1 系统函数"></a>5.1 系统函数</h2><ul>
<li><p>basename：返回完整路径最后&#x2F;的部分，常用于获取文件名</p>
</li>
<li><p>dirname：返回完整路径最后&#x2F;的前面的部分，常用于返回路径部分</p>
</li>
</ul>
<p>案例：请返回&#x2F;home&#x2F;aaa&#x2F;test.txt的test.txt部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/13.png"></p>
<p>案例：请返回&#x2F;home&#x2F;aaa&#x2F;test.txt的&#x2F;home&#x2F;aaa部分</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/14.png"></p>
<h2 id="5-2-自定义函数"><a href="#5-2-自定义函数" class="headerlink" title="5.2 自定义函数"></a>5.2 自定义函数</h2><p>案例：计算输入两个参数的和(动态获取)getSum</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function getSum()&#123;</span><br><span class="line">	SUM=$[$n1+$n2]</span><br><span class="line">	echo &quot;和是=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入两个值</span></span><br><span class="line">read -p &quot;请输入一个数n1=&quot; n1</span><br><span class="line">read -p &quot;请输入一个数n2=&quot; n2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用自定义函数</span></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/shell/15.png"></p>
]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell编程</tag>
      </tags>
  </entry>
  <entry>
    <title>boost库asio编程(中)</title>
    <url>/2024/07/11/boost%E5%BA%93asio%E7%BC%96%E7%A8%8B(%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="1-asio的通信流程"><a href="#1-asio的通信流程" class="headerlink" title="1. asio的通信流程"></a>1. asio的通信流程</h1><p>首先是在应用层调用async_read()函数，就相当于是往io_context里面注册读事件，并且注册读回调函数。然后io_context会把对应的读事件、socket和回调都写到epoll模型或iocp模型里，即注册给这两个模型。而在应用层调用io_context.run的时候，实际上是一个死循环，它会调用linux的epoll模型或windows的iocp模型，以死循环的方式不断的轮询，不断的去检测我们注册的那些socket那些就绪了</p>
<p>如果有socket就绪了，比如说我们注册了一个socket监听对端的一个发送事件，对端发送过来了，我们这个读事件就会就绪了。读事件就绪的话，就会把读事件对应的回调函数写到就绪的队列里。如果是单线程的话，这些事件的回调函数放到就绪的队列里，系统直接就会把就绪队列里的回调函数一个一个取出来，按顺序来给我们回调，顺序就是我们在底层去轮询，发现哪个socket回调函数先就绪了，就先放到就绪队列里。如果是写的事件，它也会被放到该就绪队列里，最后由asio统一派发。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_1.png"></p>
<h1 id="2-字节序处理"><a href="#2-字节序处理" class="headerlink" title="2. 字节序处理"></a>2. 字节序处理</h1><h2 id="2-1-字节序的问题"><a href="#2-1-字节序的问题" class="headerlink" title="2.1 字节序的问题"></a>2.1 字节序的问题</h2><p>在计算机网络中，由于不同的计算机使用的 CPU 架构和字节顺序可能不同，因此在传输数据时需要对数据的字节序进行统一，以保证数据能够正常传输和解析。具体来说，计算机内部存储数据的方式有两种：大端序和小端序。在大端序中，高位字节存储在低地址处，而低位字节存储在高地址处；在小端序中，高位字节存储在高地址处，而低位字节存储在低地址处。</p>
<p>在网络通信过程中，通常使用的是大端序。这是因为早期的网络硬件大多采用了 Motorola 处理器，而 Motorola 处理器使用的是大端序。此外，大多数网络协议规定了网络字节序必须为大端序。因此，在进行网络编程时，需要将主机字节序转换为网络字节序，也就是将数据从本地字节序转换为大端序。可以使用诸如 htonl、htons、ntohl 和 ntohs 等函数来实现字节序转换操作。</p>
<p>综上所述，网络字节序的主要作用是统一不同计算机间的数据表示方式，以保证数据在网络中的正确传输和解析。</p>
<p>判断当前本机的字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前系统的字节序是大端序还是小端序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_endian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span>*)&amp;num == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前系统为小端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前系统为大端序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-服务器中使用字节序"><a href="#2-2-服务器中使用字节序" class="headerlink" title="2.2 服务器中使用字节序"></a>2.2 服务器中使用字节序</h2><p>1.主机字节序转换为网络字节序</p>
<ul>
<li><p>boost::asio::detail::socket_ops::host_to_network_long() ：将一个32位无符号整数从主机字节序转换为网络字节序</p>
</li>
<li><p>boost::asio::detail::socket_ops::host_to_network_short() ：将一个16位无符号整数从主机字节序转换为网络字节序</p>
</li>
</ul>
<p>2.网络字节序转换为主机字节序</p>
<ul>
<li><p>boost::asio::detail::socket_ops::network_to_host_short()：将网络字节序转换为16位无符号整数主机字节序</p>
</li>
<li><p>boost::asio::detail::socket_ops::network_to_host_long()：将网络字节序转换为32位无符号整数主机字节序</p>
</li>
</ul>
<p>在异步处理的服务器中，当接受客户端发来的数据时，需要将其进行转换，从网络字节序转换为本地字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> data_len = <span class="number">0</span>;            <span class="comment">//存放转换后的结果</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH); <span class="comment">//将头部数据内容copy到data_len，此时还是网络字节序</span></span><br><span class="line"><span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">data_len=boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(data_len);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;data_len is &quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在服务器的发送数据时会构造消息节点，构造消息节点时，将发送长度由本地字节序转化为网络字节序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MsgNode</span>(<span class="type">char</span> * msg, <span class="type">short</span> max_len):_total_len(max_len + HEAD_LENGTH),_cur_len(<span class="number">0</span>)&#123;  <span class="comment">//发送数据节点</span></span><br><span class="line">    _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len+<span class="number">1</span>]();      <span class="comment">//开辟一块存发送数据的空间</span></span><br><span class="line">    <span class="comment">//转为网络字节序</span></span><br><span class="line">    <span class="type">int</span> max_len_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data, &amp;max_len_host, HEAD_LENGTH);    <span class="comment">//将转换的结果存到_data头部(前面)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data+ HEAD_LENGTH, msg, max_len);     <span class="comment">//继续往_data后面存储真实数据</span></span><br><span class="line">    _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//最后加上&#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-asio处理粘包的另一种方式"><a href="#3-asio处理粘包的另一种方式" class="headerlink" title="3. asio处理粘包的另一种方式"></a>3. asio处理粘包的另一种方式</h1><p>我们之前使用的一种方式是通过async_read_some函数监听读事件，并且绑定了读事件的回调函数HandleRead。async_read_some 这个函数的特点是只要对端发数据，服务器接收到数据，即使没有收全对端发送的数据也会触发HandleRead函数，所以我们会在HandleRead回调函数里判断接收的字节数，接收的数据可能不满足头部长度，可能大于头部长度但小于消息体的长度，可能大于消息体的长度，还可能大于多个消息体的长度，所以要切包等，这些逻辑写起来很复杂。</p>
<p>所以我们可以通过读取指定字节数，直到读完这些字节才触发回调函数，那么可以采用async_read函数，这个函数指定读取指定字节数，只有完全读完才会触发回调函数。</p>
<h2 id="3-1-获取头部数据"><a href="#3-1-获取头部数据" class="headerlink" title="3.1 获取头部数据"></a>3.1 获取头部数据</h2><p>当服务器与客户端建立完毕，进入通信工作，先就绪读头部数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _recv_head_node-&gt;<span class="built_in">Clear</span>();    <span class="comment">//将存头部数据的节点_data清0，当前处理长度设为0</span></span><br><span class="line">    <span class="comment">//先读头部的两个字节数据，一次性读完的，只有读完才会触发HandleReadHead回调函数</span></span><br><span class="line">    boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    <span class="comment">//SharedSelf()是通过自己再生成应该智能指针，这个智能指针与其它的智能指针共享引用计数，保证Session不被异常释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对端发来指定大小HEAD_LENGTH数据，并存到_recv_head_node-&gt;_data时，触发回调函数HandleReadHead。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadHead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;    <span class="comment">//如果没有报错</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_transferred &lt; HEAD_LENGTH) &#123;     <span class="comment">//这种情况也是不正常的，因为指定读HEAD_LENGTH长度数据，却没有读完</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;read head length error&quot;</span>;</span><br><span class="line">            <span class="built_in">Close</span>();   <span class="comment">//这里是把socket关闭掉，会关闭socket的事件处理机制。底层asio会把socket从它监听的epoll事件里面移出，socket就不会触发改回调函数</span></span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);          <span class="comment">//将其session移出，减少它的引用计数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有问题情况下，bytes_transferred一定是等于头部长度的</span></span><br><span class="line">        <span class="comment">//头部收全，解析头部</span></span><br><span class="line">        <span class="type">short</span> data_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;data_len, _recv_head_node-&gt;_data, HEAD_LENGTH);    <span class="comment">//获取真实数据的大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;data len is&quot;</span> &lt;&lt; data_len &lt;&lt; endl;                 <span class="comment">//打印真实数据的大小</span></span><br><span class="line">        <span class="keyword">if</span> (data_len &gt; MAX_LENGTH) &#123;               <span class="comment">//如果真实数据大于规定的最大值，说明不合法</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;invalid data length is&quot;</span> &lt;&lt; data_len &lt;&lt; endl;</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);                          <span class="comment">//将其session移出map</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果正常，就读取真实数据</span></span><br><span class="line">        _recv_msg_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(data_len);   <span class="comment">//下面开始读真实数据，读真实数据总长度_total_len，存到改数据节点中</span></span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data,_recv_msg_node-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadMsg, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;       <span class="comment">//出错了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read head failed,error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();                       <span class="comment">//关闭socket</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);  <span class="comment">//减少session的引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-获取信息体"><a href="#3-2-获取信息体" class="headerlink" title="3.2 获取信息体"></a>3.2 获取信息体</h2><p>当获取完头部数据后，就可以在其回调函数里执行异步读async_read，直接获取信息数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleReadMsg</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">//数据都读到了数据节点，再最后面加上&#x27;\0&#x27;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;  <span class="comment">//打印接收的数据</span></span><br><span class="line">        <span class="built_in">Send</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len);      <span class="comment">//发送接收的数据给客户端</span></span><br><span class="line">        <span class="comment">//再次接收头部数据</span></span><br><span class="line">        _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleReadHead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;       <span class="comment">//出错了</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;handle read Msg failed,error is&quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Close</span>();                 <span class="comment">//关闭socket</span></span><br><span class="line">        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);  <span class="comment">//减少session的引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-结合Json实现粘包处理tlv"><a href="#4-结合Json实现粘包处理tlv" class="headerlink" title="4. 结合Json实现粘包处理tlv"></a>4. 结合Json实现粘包处理tlv</h1><p>我们之前的消息头仅包含数据域的长度，但是要进行逻辑处理，就需要传递一个id字段表示要处理的消息id，当然可以不在包头传id字段，将id序列化到消息体也是可以的，但是我们为了便于处理也便于回调逻辑层对应的函数，最好是将id写入包头。结构图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_2.png"></p>
<p>为了减少耦合和歧义，这里重新设计消息节点。</p>
<ul>
<li><code>MsgNode</code>表示消息节点的基类，头部的消息用这个结构存储</li>
<li><code>RecvNode</code>表示接收消息的节点</li>
<li><code>SendNode</code>表示发送消息的节点</li>
</ul>
<h2 id="4-1-信息节点类"><a href="#4-1-信息节点类" class="headerlink" title="4.1 信息节点类"></a>4.1 信息节点类</h2><p>MsgNode.h头文件定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MsgNode</span>(<span class="type">short</span> max_len) :_total_len(max_len), _cur_len(<span class="number">0</span>) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_total_len + <span class="number">1</span>]();</span><br><span class="line">        _data[_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">MsgNode</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destruct MsgNode&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, _total_len);</span><br><span class="line">        _cur_len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">short</span> _cur_len;       <span class="comment">//当前处理的长度(接收或发送)</span></span><br><span class="line">    <span class="type">short</span> _total_len;     <span class="comment">//要处理的总长度</span></span><br><span class="line">    <span class="type">char</span>* _data;          <span class="comment">//存放数据的首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//接收数据的节点类定义，继承了MsgNode类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecvNode</span> :<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id);  <span class="comment">//传入数据的长度和信息id</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//发送数据的节点类定义，继承了MsgNode类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendNode</span>:<span class="keyword">public</span> MsgNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg,<span class="type">short</span> max_len, <span class="type">short</span> msg_id);   <span class="comment">//传入发送数据，数据长度和信息id</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">short</span> _msg_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接受数据节点和发送数据节点初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收数据节点类初始化，将传进去的max_len用来给MsgNode类初始化，msg_id给id初始化</span></span><br><span class="line">RecvNode::<span class="built_in">RecvNode</span>(<span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len),_msg_id(msg_id)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送数据节点类初始化，数据长度+头节点长度=总长度</span></span><br><span class="line">SendNode::<span class="built_in">SendNode</span>(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">short</span> max_len, <span class="type">short</span> msg_id):<span class="built_in">MsgNode</span>(max_len + HEAD_TOTAL_LEN), _msg_id(msg_id)&#123;</span><br><span class="line">    <span class="comment">//先发送id, 转为网络字节序</span></span><br><span class="line">    <span class="type">short</span> msg_id_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msg_id);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data, &amp;msg_id_host, HEAD_ID_LEN);    <span class="comment">//将转换好的id存到_data第一部分</span></span><br><span class="line">    <span class="comment">//转为网络字节序</span></span><br><span class="line">    <span class="type">short</span> max_len_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(max_len);</span><br><span class="line">    <span class="built_in">memcpy</span>(_data + HEAD_ID_LEN, &amp;max_len_host, HEAD_DATA_LEN);   <span class="comment">//将转换好的数据长度存到_data第二部分</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data + HEAD_ID_LEN + HEAD_DATA_LEN, msg, max_len);   <span class="comment">//将真实数据存到_data第三部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Session类"><a href="#4-2-Session类" class="headerlink" title="4.2 Session类"></a>4.2 Session类</h2><p>Session类头节点如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSession</span>: <span class="keyword">public</span> std::enable_shared_from_this&lt;CSession&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server);</span><br><span class="line">    ~<span class="built_in">CSession</span>();</span><br><span class="line">    <span class="function">tcp::socket&amp; <span class="title">GetSocket</span><span class="params">()</span></span>;    <span class="comment">//获取socket函数</span></span><br><span class="line">    <span class="function">std::string&amp; <span class="title">GetUuid</span><span class="params">()</span></span>;      <span class="comment">//获取uuid函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;                <span class="comment">//开始通信函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(<span class="type">char</span>* msg,  <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span></span>;  <span class="comment">//发送数据send</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span></span>;               <span class="comment">//接收数据send</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Close</span><span class="params">()</span></span>;                <span class="comment">//关闭socket函数</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;CSession&gt; <span class="title">SharedSelf</span><span class="params">()</span></span>;   <span class="comment">//添加智能指针引用计数的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>;</span><br><span class="line">    tcp::socket _socket;</span><br><span class="line">    std::string _uuid;</span><br><span class="line">    <span class="type">char</span> _data[MAX_LENGTH];</span><br><span class="line">    CServer* _server;</span><br><span class="line">    <span class="type">bool</span> _b_close;</span><br><span class="line">    std::queue&lt;shared_ptr&lt;MsgNode&gt; &gt; _send_que;</span><br><span class="line">    std::mutex _send_lock;</span><br><span class="line">    <span class="comment">//收到的消息结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_msg_node;</span><br><span class="line">    <span class="type">bool</span> _b_head_parse;        <span class="comment">//头部节点释放读取完毕</span></span><br><span class="line">    <span class="comment">//收到的头部结构</span></span><br><span class="line">    std::shared_ptr&lt;MsgNode&gt; _recv_head_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Session类实现功能：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CSession::<span class="built_in">CSession</span>(boost::asio::io_context&amp; io_context, CServer* server):_socket(io_context), _server(server), _b_close(<span class="literal">false</span>),_b_head_parse(<span class="literal">false</span>)&#123;</span><br><span class="line">    boost::uuids::uuid  a_uuid = boost::uuids::<span class="built_in">random_generator</span>()();</span><br><span class="line">    _uuid = boost::uuids::<span class="built_in">to_string</span>(a_uuid);</span><br><span class="line">    _recv_head_node = <span class="built_in">make_shared</span>&lt;MsgNode&gt;(HEAD_TOTAL_LEN);</span><br><span class="line">&#125;</span><br><span class="line">CSession::~<span class="built_in">CSession</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~CSession destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tcp::socket&amp; <span class="title">CSession::GetSocket</span><span class="params">()</span> </span>&#123;     <span class="comment">//获取socket函数实现</span></span><br><span class="line">    <span class="keyword">return</span> _socket;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">CSession::GetUuid</span><span class="params">()</span> </span>&#123;       <span class="comment">//获取uuid函数实现</span></span><br><span class="line">    <span class="keyword">return</span> _uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span></span>&#123;                 <span class="comment">//与客户端通信开始函数</span></span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//先将_data清0</span></span><br><span class="line">    <span class="comment">//异步读async_read_some，将读到的数据放到了_data,读完后，并触发回调函数HandleRead</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(std::string msg, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">length</span>(), msgid));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Send</span><span class="params">(<span class="type">char</span>* msg, <span class="type">short</span> max_length, <span class="type">short</span> msgid)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">    <span class="type">int</span> send_que_size = _send_que.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (send_que_size &gt; MAX_SENDQUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;session: &quot;</span> &lt;&lt; _uuid &lt;&lt; <span class="string">&quot; send que fulled, size is &quot;</span> &lt;&lt; MAX_SENDQUE &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _send_que.<span class="built_in">push</span>(<span class="built_in">make_shared</span>&lt;SendNode&gt;(msg, max_length, msgid));</span><br><span class="line">    <span class="keyword">if</span> (send_que_size&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, <span class="built_in">SharedSelf</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _socket.<span class="built_in">close</span>();</span><br><span class="line">    _b_close = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;CSession&gt;CSession::<span class="built_in">SharedSelf</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleWrite</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, std::shared_ptr&lt;CSession&gt; shared_self)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//增加异常处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_send_lock)</span></span>;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;send data &quot; &lt;&lt; _send_que.front()-&gt;_data+HEAD_LENGTH &lt;&lt; endl;</span></span><br><span class="line">            _send_que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!_send_que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; msgnode = _send_que.<span class="built_in">front</span>();</span><br><span class="line">                boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle write failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception code : &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当异步读，读到数据后触发该回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::HandleRead</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, <span class="type">size_t</span>  bytes_transferred, std::shared_ptr&lt;CSession&gt; shared_self)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;            <span class="comment">//如果没有出错</span></span><br><span class="line">            <span class="type">int</span> copy_len = <span class="number">0</span>;    <span class="comment">//已经移动的字符数</span></span><br><span class="line">            <span class="keyword">while</span> (bytes_transferred &gt; <span class="number">0</span>) &#123;    <span class="comment">//如果bytes_transferred大于0</span></span><br><span class="line">                <span class="keyword">if</span> (!_b_head_parse) &#123;          <span class="comment">//如果头部数据还没有处理完</span></span><br><span class="line">                    <span class="comment">//这次收到的数据不足头部大小，则这次收到的bytes_transferred长度数据都是头部数据，HEAD_TOTAL_LEN=4(id占2，数据长度占2)</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred + _recv_head_node-&gt;_cur_len &lt; HEAD_TOTAL_LEN) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, bytes_transferred);    <span class="comment">//将这次读到的全部数据全部存到头部节点</span></span><br><span class="line">                        _recv_head_node-&gt;_cur_len += bytes_transferred;  <span class="comment">//更新头部节点的当前处理位置</span></span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);     <span class="comment">//清0，继续读，存放下一次读到的数据</span></span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        <span class="keyword">return</span>;   <span class="comment">//这种情况直接退出，继续读数据(头部)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//收到的数据比头部多(没有执行上面if),说明这次读到的数据一部分是头部数据，一部分是真实数据</span></span><br><span class="line">                    <span class="type">int</span> head_remain = HEAD_TOTAL_LEN - _recv_head_node-&gt;_cur_len; <span class="comment">//头部剩余未处理的长度</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_head_node-&gt;_data + _recv_head_node-&gt;_cur_len, _data + copy_len, head_remain);    <span class="comment">//将头部剩余未处理的长度，全部处理完(存到头部节点)</span></span><br><span class="line">                    <span class="comment">//更新已处理的data长度和剩余未处理的长度</span></span><br><span class="line">                    copy_len += head_remain;</span><br><span class="line">                    bytes_transferred -= head_remain;</span><br><span class="line">                    <span class="comment">//获取头部MSGID数据</span></span><br><span class="line">                    <span class="type">short</span> msg_id = <span class="number">0</span>;     <span class="comment">//用来存放信息id</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN); <span class="comment">//从头部数据获取id</span></span><br><span class="line">                    <span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">                    msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;    <span class="comment">//如果id非法</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;invalid msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; endl;</span><br><span class="line">                        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);   <span class="comment">//从map移出对应uuid，减少该session的引用计数</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果id合法，继续读取信息长度</span></span><br><span class="line">                    <span class="type">short</span> msg_len = <span class="number">0</span>;    <span class="comment">//用来存真实信息长度</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data+HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">                    <span class="comment">//网络字节序转化为本地字节序</span></span><br><span class="line">                    msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg_len is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;     <span class="comment">//如果真实数据长度非法</span></span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;invalid data length is &quot;</span> &lt;&lt; msg_len &lt;&lt; endl;</span><br><span class="line">                        _server-&gt;<span class="built_in">ClearSession</span>(_uuid);   <span class="comment">//从map移出对应uuid，减少该session的引用计数</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    _recv_msg_node = <span class="built_in">make_shared</span>&lt;RecvNode&gt;(msg_len, msg_id);   <span class="comment">//存放真实数据内容节点</span></span><br><span class="line">                    <span class="comment">//消息的长度小于头部规定的长度，说明数据未收全，则先将部分消息放到接收节点里</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &lt; msg_len) &#123;</span><br><span class="line">                        <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                        _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        _b_head_parse = <span class="literal">true</span>;   <span class="comment">//头部处理完成，将该变量设为true</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果读到数据&gt;=头部读到的真实数据长度，说明可能出现粘包情况</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, msg_len);    <span class="comment">//这时就处理头部节点读到的真实数据长度</span></span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += msg_len;</span><br><span class="line">                    copy_len += msg_len;</span><br><span class="line">                    bytes_transferred -= msg_len;   <span class="comment">//先减去真实数据长度</span></span><br><span class="line">                    _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">//结尾加结束符</span></span><br><span class="line">                    <span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    Json::Value root;      <span class="comment">//用来存放反序列化的值</span></span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;    <span class="comment">//反序列化后，读取客户端发来的值</span></span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">                    std::string return_str = root.<span class="built_in">toStyledString</span>();   <span class="comment">//又将root的值序列化</span></span><br><span class="line">                    <span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());    <span class="comment">//发送给客户端</span></span><br><span class="line">                    <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                    _b_head_parse = <span class="literal">false</span>;  <span class="comment">//因为上面已经处理完一个节点数据，又要从头节点开始处理</span></span><br><span class="line">                    _recv_head_node-&gt;<span class="built_in">Clear</span>();       <span class="comment">//清理头节点，为下一次读做准备</span></span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;   <span class="comment">//如果bytes_transferred已经&lt;=0,说明没有出现粘包情况</span></span><br><span class="line">                        ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);   <span class="comment">//清理_data,继续挂起读</span></span><br><span class="line">                        _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//出现粘包情况，就不执行下面了，_b_head_parse已经为false，可以重新循环执行下一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已经处理完头部，处理上次未接受完的真实消息数据</span></span><br><span class="line">                <span class="comment">//接收的数据仍不足剩余未处理的</span></span><br><span class="line">                <span class="type">int</span> remain_msg = _recv_msg_node-&gt;_total_len - _recv_msg_node-&gt;_cur_len;</span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt; remain_msg) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, bytes_transferred);</span><br><span class="line">                    _recv_msg_node-&gt;_cur_len += bytes_transferred;</span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;    <span class="comment">//这种情况是真实数据还未处理完，退出继续读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这次接收的数据&gt;=真实数据未处理的长度，可能出现粘包情况</span></span><br><span class="line">                <span class="built_in">memcpy</span>(_recv_msg_node-&gt;_data + _recv_msg_node-&gt;_cur_len, _data + copy_len, remain_msg);</span><br><span class="line">                _recv_msg_node-&gt;_cur_len += remain_msg;</span><br><span class="line">                bytes_transferred -= remain_msg;</span><br><span class="line">                copy_len += remain_msg;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; &quot;receive data is &quot; &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">//此处可以调用Send发送测试</span></span><br><span class="line">                Json::Reader reader;</span><br><span class="line">                Json::Value root;</span><br><span class="line">                reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), root);</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;recevie msg id  is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>() &lt;&lt; <span class="string">&quot; msg data is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>() &lt;&lt; endl;</span><br><span class="line">                root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;server has received msg, msg data is &quot;</span> + root[<span class="string">&quot;data&quot;</span>].<span class="built_in">asString</span>();</span><br><span class="line">                std::string return_str = root.<span class="built_in">toStyledString</span>();</span><br><span class="line">                <span class="built_in">Send</span>(return_str, root[<span class="string">&quot;id&quot;</span>].<span class="built_in">asInt</span>());</span><br><span class="line">                <span class="comment">//继续轮询剩余未处理数据</span></span><br><span class="line">                _b_head_parse = <span class="literal">false</span>;  <span class="comment">//处理完一个节点，将该变量设为false</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">                <span class="keyword">if</span> (bytes_transferred &lt;= <span class="number">0</span>) &#123;   <span class="comment">//这种情况是没有出现粘包</span></span><br><span class="line">                    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">                    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, shared_self));</span><br><span class="line">                    <span class="keyword">return</span>;   <span class="comment">//挂起读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;    <span class="comment">//出现粘包，就继续循环,因为bytes_transferred还大于0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;handle read failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception code is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于server类，没有出现其它变化，与之前代码差不多。</p>
<h1 id="5-asio多线程模型IOServicePool"><a href="#5-asio多线程模型IOServicePool" class="headerlink" title="5. asio多线程模型IOServicePool"></a>5. asio多线程模型IOServicePool</h1><p>前面的设计，我们对asio的使用都是单线程模式，为了提升网络io并发处理的效率，这一次我们设计多线程模式下asio的使用方式。总体来说asio有两种多线程模型，第一个是启动多个线程，每个线程管理一个iocontext；第二种是只启动一个iocontext，被多个线程共享。这里主要使用第一种模式，多个线程，每个线程管理独立的iocontext服务。</p>
<p>下面先介绍多线程的第一种模式：一个IOServicePool开启n个线程和n个iocontext，每个线程内独立运行iocontext, 各个iocontext监听各自绑定的socket是否就绪，如果就绪就在各自线程里触发回调函数。为避免线程安全问题，我们将网络数据封装为逻辑包投递给逻辑系统，逻辑系统有一个单独线程处理，这样将网络IO和逻辑处理解耦合，极大的提高了服务器IO层面的吞吐率。</p>
<h2 id="5-1-单线程与多线程"><a href="#5-1-单线程与多线程" class="headerlink" title="5.1 单线程与多线程"></a>5.1 单线程与多线程</h2><p>之前使用的单线程模型如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_3.png"></p>
<p>IOServicePool类型的多线程模型如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_4.png"></p>
<p>IOServicePool多线程模式特点：</p>
<ul>
<li><p>每一个io_context跑在不同的线程里，所以同一个socket会被注册在同一个io_context里，它的回调函数也会被单独的一个线程回调，那么对于同一个socket，他的回调函数每次触发都是在同一个线程里，就不会有线程安全问题，网络io层面上的并发是线程安全的。</p>
</li>
<li><p>但是对于不同的socket，回调函数的触发可能是同一个线程(两个socket被分配到同一个io_context)，也可能不是同一个线程(两个socket被分配到不同的io_context里)。所以如果两个socket对应的上层逻辑处理，如果有交互或者访问共享区，会存在线程安全问题。比如socket1代表玩家1，socket2代表玩家2，玩家1和玩家2在逻辑层存在交互，比如两个玩家都在做工会任务，他们属于同一个工会，工会积分的增加就是共享区的数据，需要保证线程安全。可以通过加锁或者逻辑队列的方式解决安全问题，我们目前采取了后者。</p>
</li>
<li><p>多线程相比单线程，极大的提高了并发能力，因为单线程仅有一个io_context服务用来监听读写事件，就绪后回调函数在一个线程里串行调用, 如果一个回调函数的调用时间较长肯定会影响后续的函数调用，毕竟是穿行调用。而采用多线程方式，可以在一定程度上减少前一个逻辑调用影响下一个调用的情况，比如两个socket被部署到不同的iocontext上，但是当两个socket部署到同一个iocontext上时仍然存在调用时间影响的问题。不过我们已经通过逻辑队列的方式将网络线程和逻辑线程解耦合了，不会出现前一个调用时间影响下一个回调触发的问题。</p>
</li>
</ul>
<h2 id="5-2-服务端实现"><a href="#5-2-服务端实现" class="headerlink" title="5.2 服务端实现"></a>5.2 服务端实现</h2><p>主函数：先初始化服务池，创建一个负责监听的io_context，通过asio提供的异步等待函数和线程来完成信号的捕捉，当触发SIGINT和SIGTERM信号时，停止io服务，即不在监听处理客户端发来的请求连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioIOServicePool::<span class="built_in">GetInstance</span>();     <span class="comment">//先将服务池初始化好</span></span><br><span class="line">        boost::asio::io_context io_context;  <span class="comment">//该io_context只负责监听，监听客户端是否请求发来连接</span></span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//初始化一个信号集，将要捕获的信号SIGINT, SIGTERM注册到服务io里</span></span><br><span class="line">        <span class="comment">//异步等待，等待信号被触发，触发了会执行回调函数(匿名函数表示)，io_context是用引用方式来捕获，auto：几个参数，就写几个auto</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;io_context](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123; <span class="comment">//信号集异步等待，信号集里面的信号触发了，就会执行这个回调函数(匿名函数)</span></span><br><span class="line">            io_context.<span class="built_in">stop</span>();        <span class="comment">//停止io服务</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//上面因为是异步等待，所以不会阻塞，如果回调函数没有触发，会继续执行后面的代码</span></span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(io_context, <span class="number">10086</span>)</span></span>;</span><br><span class="line">        io_context.<span class="built_in">run</span>();     <span class="comment">//轮询</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CServer类实现：这部分负责实现监听客户端的连接和获取服务池的io_context。每与客户端建立成功一次，就从服务池中获取一个io_context来负责处理与连接的客户端的一些业务，实现了一个线程一个io_context的多线程模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CServer::<span class="built_in">CServer</span>(boost::asio::io_context&amp; io_context, <span class="type">short</span> port):_io_context(io_context), _port(port),</span><br><span class="line">_acceptor(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(),port))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该函数初始化了_acceptor，里面的参数io_context是单独创建的，就负责用来监听客户端	</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Server start success, listen on port : &quot;</span> &lt;&lt; _port &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">StartAccept</span>();    <span class="comment">//处理连接的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当有客户端发来请求连接时，就从服务池里面取出一个io_context来负责这次连接的业务处理</span></span><br><span class="line">    <span class="comment">//GetIOService()函数实现的是从下标为0开始获取io_context，获取完一次，下标进行+1，当达到服务池里面提供的io_context的个数时，又从下标为0的io_context开始获取，所以当客户端连接的数量过多时，可能是多个客户端同时拥有同一个io_context</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetIOService</span>();</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));  <span class="comment">//异步连接，域客户端成功连接后，执行回调函数HandleAccept()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::HandleAccept</span><span class="params">(shared_ptr&lt;CSession&gt; new_session, <span class="type">const</span> boost::system::error_code&amp; error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        new_session-&gt;<span class="built_in">Start</span>();   <span class="comment">//去session执行通信的业务</span></span><br><span class="line">        _sessions.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(new_session-&gt;<span class="built_in">GetUuid</span>(), new_session)); <span class="comment">//连接成功将对应的信息存入到map,方便管理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;session accept failed, error is &quot;</span> &lt;&lt; error.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">StartAccept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::ClearSession</span><span class="params">(std::string uuid)</span> </span>&#123;</span><br><span class="line">    _sessions.<span class="built_in">erase</span>(uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsioIOServicePool类服务池的头文件实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AsioIOServicePool就形成了单例模式，因为他继承了Singleton&lt;AsioIOServicePool&gt;模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOServicePool</span>:<span class="keyword">public</span> Singleton&lt;AsioIOServicePool&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> Singleton&lt;AsioIOServicePool&gt;;  <span class="comment">//这样Singleton&lt;AsioIOServicePool&gt;就可以访问AsioIOServicePool的构造函数(私有)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOService = boost::asio::io_context;    <span class="comment">//IOServer是io_context的别名</span></span><br><span class="line">    <span class="keyword">using</span> Work = boost::asio::io_context::work;   <span class="comment">//work是防止io_context在没有注册事件的时候退出(因为对于多线程我们需要先创建多个io_context)</span></span><br><span class="line">    <span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;       <span class="comment">//Work是上面io_context::work的别名。这里是让Work不被拷贝，只能移动，从头用到尾</span></span><br><span class="line">    ~<span class="built_in">AsioIOServicePool</span>();</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>(<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;   <span class="comment">//取消拷贝构造，拷贝构造时，里面加了canst后要加&amp;，不然会造成递归构造的危险</span></span><br><span class="line">    AsioIOServicePool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> AsioIOServicePool&amp;) = <span class="keyword">delete</span>;    <span class="comment">//赋值操作也取消掉</span></span><br><span class="line">    <span class="comment">//使用round-robin的方式返回一个io_context</span></span><br><span class="line">    boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;     <span class="comment">//返回一个io_context</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">AsioIOServicePool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>());  <span class="comment">//hardware_concurrency()获取cpu的核数，一般是电脑有几个核，就开几个io_context</span></span><br><span class="line">    std::vector&lt;IOService&gt;_ioServices;</span><br><span class="line">    std::vector&lt;WorkPtr&gt;_works;</span><br><span class="line">    std::vector&lt;std::thread&gt;_threads;</span><br><span class="line">    std::<span class="type">size_t</span> _nextIOService;         <span class="comment">//记录的下标索引</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AsioIOServicePool类服务池的功能实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AsioIOServicePool默认传的是cpu的核数，也可以自己指定，并初始化size个io_context，size个指针(默认是空指针)，下标索初始化为0</span></span><br><span class="line">AsioIOServicePool::<span class="built_in">AsioIOServicePool</span>(std::<span class="type">size_t</span> size) :_ioServices(size), _works(size), _nextIOService(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//works初始化分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">//将左值赋值给unique_ptr是不行的，而作为右值去赋值是可以的</span></span><br><span class="line">        _works[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(_ioServices[i]));    <span class="comment">//work是绑定io_context的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历多个ioservice，创建多个线程，每个线程内部启动ioservice</span></span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _ioServices.<span class="built_in">size</span>(); i++) &#123;       <span class="comment">//装线程的_threads开始默认大小为0</span></span><br><span class="line">        <span class="comment">//方法：通过遍历的方式，每次都为_threads插入一个线程。用push_back是以右值的形式将其挪进来，而用emplace_back是直接传入线程</span></span><br><span class="line">        <span class="comment">//执行插入操作，就默认调用了线程的回调函数了，下面emplace_back相当于是给线程插入了一个回调函数，就直接跑起来了</span></span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]() &#123;<span class="comment">//这是是快速构造，防止拷贝造成的开销。emplace_back传入的是匿名函数，第一个先绑定this(io_service)，</span></span><br><span class="line">            _ioServices[i].<span class="built_in">run</span>();</span><br><span class="line">        &#125;); <span class="comment">//这样，该线程就跑起来了。c11的标准，只要定义了一个线程，线程就跑起来了</span></span><br><span class="line">        <span class="comment">/*    //其它方式创建线程，但存在问题</span></span><br><span class="line"><span class="comment">        thread t([this, i]() &#123;        //先初始化一个线程</span></span><br><span class="line"><span class="comment">        	_ioService[i].run();</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        _threads.push_back(t); //又拷贝了一个线程，这种情况是线程初始化时就跑起来了，现在又push进来，会造成开销，而且跑了两个线程</span></span><br><span class="line"><span class="comment">        _threads.push_back(move(t)); //这种情况是相当于把上面t的生命周期进行一个接管，原来线程就失效了，但不能保证它能停下来，除非用stop销毁它    */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">AsioIOServicePool::~<span class="built_in">AsioIOServicePool</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AsioIOServicePool destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取io_Service函数(io_Service是io_context的别名)</span></span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioIOServicePool::GetIOService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; service = _ioServices[_nextIOService++];       <span class="comment">//从0下标开始取</span></span><br><span class="line">    <span class="keyword">if</span> (_nextIOService == _ioServices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _nextIOService = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioIOServicePool::Stop</span><span class="params">()</span> </span>&#123;   <span class="comment">//要让每一个io_context都停止，就需要把绑定在它们身上的work reset掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Work : _works) &#123;</span><br><span class="line">        Work.<span class="built_in">reset</span>();        <span class="comment">//这相当于把work智能指针释放掉，智能指针一旦释放掉，就会析构WorkPtr,而WorkPtr绑定的就是work(unique_ptr类型)，</span></span><br><span class="line">        <span class="comment">//所以就会调用work的析构，work就会把绑定的所有东西解除，从而保证io_context退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要等所有线程都结束了(io_service.run运行完)，该函数才退出，所以调用了这个函数，不会立即执行完</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : _threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于监听客户端是否发来连接用的是刚开始初始化的io_context，后面与客户端的读写事件监听用的是服务池里面的io_context，所以当与客户端建立成功后，之后处理监听读写事件的io_context就需要从服务池里面去取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多线程服务池模式：当有客户端发来请求连接时，就从服务池里面取出一个io_context来负责这次连接的业务处理</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; io_context = AsioIOServicePool::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">GetIOService</span>();</span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-3-客户端实现"><a href="#5-3-客户端实现" class="headerlink" title="5.3 客户端实现"></a>5.3 客户端实现</h2><p>客户端实现的是创建100个线程，每个线程都通过json序列化一个信息包发送给服务端，并将从服务器接收的信息包反序列化，这样重复500次。测试一下等所有线程都执行完，并且都被回收所需要花费的时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;thread&gt; vec_threads;    <span class="comment">//定义一个存放连接线程的容器</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();  <span class="comment">//获取现在开始时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;        <span class="comment">//循环100次，可以理解为向服务器发送建立了100次连接</span></span><br><span class="line">        vec_threads.<span class="built_in">emplace_back</span>([]() &#123;    <span class="comment">//将回调函数(线程需要执行)通过emplace_back放入容器</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建上下文服务</span></span><br><span class="line">                boost::asio::io_context ioc;</span><br><span class="line">                <span class="comment">//构造服务器的endpoint信息</span></span><br><span class="line">                tcp::endpoint <span class="built_in">remote_ep</span>(address::<span class="built_in">from_string</span>(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>);</span><br><span class="line">                tcp::socket <span class="built_in">sock</span>(ioc);   <span class="comment">//创建一个socket</span></span><br><span class="line">                boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">                sock.<span class="built_in">connect</span>(remote_ep, error);    <span class="comment">//向服务器发送连接请求</span></span><br><span class="line">                <span class="keyword">if</span> (error) &#123;    <span class="comment">//连接失效，直接退出</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot; error msg is &quot;</span> &lt;&lt; error.<span class="built_in">message</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//连接成功执行下面，向服务器发送和接收各500次</span></span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">500</span>) &#123;      <span class="comment">//发500次内容</span></span><br><span class="line">                    Json::Value root;</span><br><span class="line">                    root[<span class="string">&quot;id&quot;</span>] = <span class="number">1001</span>;    <span class="comment">//消息id</span></span><br><span class="line">                    root[<span class="string">&quot;data&quot;</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">                    std::string request = root.<span class="built_in">toStyledString</span>();  <span class="comment">//序列化为字符串形式</span></span><br><span class="line">                    <span class="type">size_t</span> request_length = request.<span class="built_in">length</span>();    <span class="comment">//获取序列化后的字符串长度</span></span><br><span class="line">                    <span class="type">char</span> send_data[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> msgid = <span class="number">1001</span>;</span><br><span class="line">                    <span class="comment">//将信息id转换为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> msgid_host = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(msgid);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data, &amp;msgid_host, <span class="number">2</span>);  <span class="comment">//存放到发送节点</span></span><br><span class="line">                    <span class="comment">//序列化后的数据长度转为网络字节序</span></span><br><span class="line">                    <span class="type">int</span> request_host_length = boost::asio::detail::socket_ops::<span class="built_in">host_to_network_short</span>(request_length);</span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">2</span>, &amp;request_host_length, <span class="number">2</span>);  <span class="comment">//存放到发送节点</span></span><br><span class="line">                    <span class="built_in">memcpy</span>(send_data + <span class="number">4</span>, request.<span class="built_in">c_str</span>(), request_length); <span class="comment">//最后就是存放序列化后的数据</span></span><br><span class="line">                    <span class="comment">//将信息序列化后，以包的形式发送给服务器</span></span><br><span class="line">                    boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(send_data, request_length + <span class="number">4</span>));</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;begin to receive...&quot;</span> &lt;&lt; endl;  <span class="comment">//下面开始接收</span></span><br><span class="line">                    <span class="type">char</span> reply_head[HEAD_TOTAL];</span><br><span class="line">                    <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply_head, HEAD_TOTAL));</span><br><span class="line">                    msgid = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msgid, reply_head, HEAD_LENGTH);</span><br><span class="line">                    <span class="type">short</span> msglen = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">memcpy</span>(&amp;msglen, reply_head + <span class="number">2</span>, HEAD_LENGTH);</span><br><span class="line">                    <span class="comment">//转为本地字节序</span></span><br><span class="line">                    msglen = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msglen);</span><br><span class="line">                    msgid = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msgid);</span><br><span class="line">                    <span class="type">char</span> msg[MAX_LENGTH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">size_t</span>  msg_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(msg, msglen));</span><br><span class="line">                    Json::Reader reader;</span><br><span class="line">                    reader.<span class="built_in">parse</span>(std::<span class="built_in">string</span>(msg, msg_length), root);  <span class="comment">//将反序列化后的信息皴法哦root</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;msg id is &quot;</span> &lt;&lt; root[<span class="string">&quot;id&quot;</span>] &lt;&lt; <span class="string">&quot; msg is &quot;</span> &lt;&lt; root[<span class="string">&quot;data&quot;</span>] &lt;&lt; endl;</span><br><span class="line">                    i++;   <span class="comment">//发送一个包和接收完一个包后，i++。说明一个线程要完成发送和接收，共1000个包</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Exception：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>)); <span class="comment">//不能一直创线程建立连接，每创建一个线程连接就睡一秒，不然就是一直向服务器发送请求连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vec_threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();    <span class="comment">//等全部线程结束回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();   <span class="comment">//执行完后，获取结束时的时间</span></span><br><span class="line">    <span class="keyword">auto</span> duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);   <span class="comment">//获取时间差，并转换为微妙</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time spent:&quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-asio多线程模式IOThreadPool"><a href="#6-asio多线程模式IOThreadPool" class="headerlink" title="6. asio多线程模式IOThreadPool"></a>6. asio多线程模式IOThreadPool</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><p>下面介绍多线程实现的第二种模式，即多线程模式IOThreadPool，我们只初始化一个iocontext用来监听服务器的读写事件，包括新连接到来的监听也用这个iocontext。只是我们让<code>iocontext.run</code>在多个线程中调用，这样回调函数就会被不同的线程触发，从这个角度看回调函数被并发调用了。</p>
<p>线程池模式的多线程模型调度结构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_5.png"></p>
<p>构造函数中实现了一个线程池，线程池里每个线程都会运行<code>_service.run</code>函数，<code>_service.run</code>函数内部就是从iocp或者epoll获取就绪描述符和绑定的回调函数，进而调用回调函数，因为回调函数是在不同的线程里调用的，所以会存在不同的线程调用同一个socket的回调函数的情况。<br><code>_service.run</code> 内部在Linux环境下调用的是<code>epoll_wait</code>返回所有就绪的描述符列表，在windows上会循环调用<code>GetQueuedCompletionStatus</code>函数返回就绪的描述符，二者原理类似，进而通过描述符找到对应的注册的回调函数，然后调用回调函数。</p>
<p>iocp的流程：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">IOCP的使用主要分为以下几步：</span><br><span class="line">1 创建完成端口(iocp)对象</span><br><span class="line">2 创建一个或多个工作线程，在完成端口上执行并处理投递到完成端口上的I/O请求</span><br><span class="line">3 Socket关联iocp对象，在Socket上投递网络事件</span><br><span class="line">4 工作线程调用GetQueuedCompletionStatus函数获取完成通知封包，取得事件信息并进行处理</span><br></pre></td></tr></table></figure>

<p>epoll的流程：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1 调用epoll_creat在内核中创建一张epoll表</span><br><span class="line">2 开辟一片包含n个epoll_event大小的连续空间</span><br><span class="line">3 将要监听的socket注册到epoll表里</span><br><span class="line">4 调用epoll_wait，传入之前我们开辟的连续空间，epoll_wait返回就绪的epoll_event列表，epoll会将就绪的socket信息写入我们之前开辟的连续空间</span><br></pre></td></tr></table></figure>

<p>所以IOThreadPool模式有一个隐患，同一个socket的就绪后，触发的回调函数可能在不同的线程里，比如第一次是在线程1，第二次是在线程3，如果这两次触发间隔时间不大，那么很可能出现不同线程并发访问数据的情况，比如在处理读事件时，第一次回调触发后我们从socket的接收缓冲区读数据出来，第二次回调触发，还是从socket的接收缓冲区读数据，就会造成两个线程同时从socket中读数据的情况，会造成数据混乱。</p>
<h2 id="6-2-利用strand改进"><a href="#6-2-利用strand改进" class="headerlink" title="6.2 利用strand改进"></a>6.2 利用strand改进</h2><p>对于多线程触发回调函数的情况，我们可以利用asio提供的串行类strand封装一下，这样就可以被串行调用了，其基本原理就是在线程各自调用函数时取消了直接调用的方式，而是利用一个strand类型的对象将要调用的函数投递到strand管理的队列中，再由一个统一的线程调用回调函数，调用是串行的，解决了线程并发带来的安全问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/asio/3_6.png"></p>
<p>上面结构图中当socket就绪后并不是由多个线程调用每个socket注册的回调函数，而是将回调函数投递给strand管理的队列，再由strand统一调度派发。</p>
<h2 id="6-3-相关代码"><a href="#6-3-相关代码" class="headerlink" title="6.3 相关代码"></a>6.3 相关代码</h2><p>主函数实现：通过signals.async_wait异步等待，创建了一个子线程负责监听退出信号，当退出信号长生，就会触发该子线程执行，它会停止io_context和线程池，并唤醒阻塞在主线程的锁。主线程就是负责也客户端的一系列监听事件，并阻塞在条件变量cond_quit。等待退出子线程唤醒后，主线程退出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> bstop = <span class="literal">false</span>;</span><br><span class="line">std::condition_variable cond_quit;</span><br><span class="line">std::mutex mutex_quit;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> pool = AsioThreadPool::<span class="built_in">GetInstance</span>();        <span class="comment">//先将线程池初始化好</span></span><br><span class="line">        boost::asio::io_context io_context;</span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//初始化一个信号集，将要捕获的信号SIGINT, SIGTERM注册到服务io里</span></span><br><span class="line">        <span class="comment">//异步等待，等待信号被触发，触发了会执行回调函数(匿名函数表示)，io_context是用引用方式来捕获，auto是几个参数，就写几个auto</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([pool, &amp;io_context](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;   <span class="comment">//信号集异步等待，信号集里面的信号触发了，就会执行这个回调函数(匿名函数)</span></span><br><span class="line">            io_context.<span class="built_in">stop</span>();        <span class="comment">//停止io服务</span></span><br><span class="line">            pool-&gt;<span class="built_in">Stop</span>();       <span class="comment">//停止线程池</span></span><br><span class="line">            std::unique_lock&lt;std::mutex&gt;<span class="built_in">lock</span>(mutex_quit);    <span class="comment">//加锁，对bstop进行修改</span></span><br><span class="line">            bstop = <span class="literal">true</span>;</span><br><span class="line">            cond_quit.<span class="built_in">notify_one</span>();   <span class="comment">//通知退出(唤醒)</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//上面因为是异步等待，所以不会阻塞，如果回调函数没有触发，会继续执行后面的代码</span></span><br><span class="line">        <span class="function">CServer <span class="title">s</span><span class="params">(pool-&gt;GetIOService(), <span class="number">10086</span>)</span></span>;</span><br><span class="line">        &#123;   <span class="comment">//这个括号的代码是为了不让主线程直接退出，等子线程退出，主线程再退出</span></span><br><span class="line">            std::unique_lock&lt;std::mutex&gt;<span class="built_in">lock</span>(mutex_quit);</span><br><span class="line">            <span class="keyword">while</span> (!bstop) &#123;</span><br><span class="line">                cond_quit.<span class="built_in">wait</span>(lock);    <span class="comment">//没有结束之前，会阻塞在这里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AsioThreadPool类头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsioThreadPool</span>:<span class="keyword">public</span> Singleton&lt;AsioThreadPool&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;AsioThreadPool&gt;;   <span class="comment">//使其基类Singleton&lt;AsioThreadPool&gt;可以访问它的私有函数</span></span><br><span class="line">    ~<span class="built_in">AsioThreadPool</span>() &#123;&#125;</span><br><span class="line">    AsioThreadPool&amp; <span class="keyword">operator</span> = (<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;   <span class="comment">//取消赋值构造</span></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;      <span class="comment">//取消拷贝构造</span></span><br><span class="line">    boost::<span class="function">asio::io_context&amp; <span class="title">GetIOService</span><span class="params">()</span></span>;      <span class="comment">//获取io_context</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;      <span class="comment">//停止该线程池类，友好退出</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">int</span> threadNum = std::thread::<span class="built_in">hardware_concurrency</span>());  <span class="comment">//hardware_concurrency()是硬件允许的并行数</span></span><br><span class="line">    boost::asio::io_context _service;</span><br><span class="line">    std::unique_ptr&lt;boost::asio::io_context::work&gt;_work;  <span class="comment">//因为不注册读事件和写事件，_service调用.run就会退出，_work负责防止这种情况退出</span></span><br><span class="line">    std::vector&lt;std::thread&gt;_threads;  <span class="comment">//装线程的容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AsioThreadPool类初始化：用c11特性，直接定义了线程，线程就可以执行。则将线程放到threads容器，线程就可以开始执行了。通过emplace_back插入一个回调函数，表示线程启动后要执行的内容。emplace_back是直接减少一层构造函数的开销，直接调用thread原始的构造函数，即直接传入一个回调函数即可，继而构造成一个线程，插入到_threads里面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AsioThreadPool::<span class="built_in">AsioThreadPool</span>(<span class="type">int</span> threadNum):_work(<span class="keyword">new</span> boost::asio::io_context::<span class="built_in">work</span>(_service)) &#123;</span><br><span class="line">    <span class="comment">//开辟threadNum个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">        _threads.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]() &#123; <span class="comment">//下面用到的_service是AsioThreadPool的成员，匿名函数只有对器进行捕获了，才能使用</span></span><br><span class="line">            _service.<span class="built_in">run</span>(); <span class="comment">//this-&gt;_service.run();也可以。_service.run()返回了就说明结束了，该线程也就会退出</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">boost::<span class="function">asio::io_context&amp; <span class="title">AsioThreadPool::GetIOService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsioThreadPool::Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _work.<span class="built_in">reset</span>();    <span class="comment">//表示把unique_ptr类型的指针work释放掉，则就会调用_work的析构函数，那么_work开辟的空间就会被回收掉，</span></span><br><span class="line">    <span class="comment">//则_service就没有_work去管理它，这时候，如果没有事件到来，_service就会stop了，这种情况就是_service.run会直接返回，不在一直轮询</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : _threads) &#123;  <span class="comment">//等待所有线程退出，一个一个回收</span></span><br><span class="line">        t.<span class="built_in">join</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立连接函数：由于监听客户端是否发来连接用的是刚开始初始化的io_context，后面与客户端的读写事件监听也是用的同一个io_context，所以当与客户端建立成功后，之后的监听读写事件读由该io_context来处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CServer::StartAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多线程线程池模式：不需要有多个io_context，统一使用刚开始传进来的io_context</span></span><br><span class="line">    shared_ptr&lt;CSession&gt; new_session = <span class="built_in">make_shared</span>&lt;CSession&gt;(_io_context, <span class="keyword">this</span>);</span><br><span class="line">    _acceptor.<span class="built_in">async_accept</span>(new_session-&gt;<span class="built_in">GetSocket</span>(), std::<span class="built_in">bind</span>(&amp;CServer::HandleAccept, <span class="keyword">this</span>, new_session, placeholders::_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Session类中添加一个成员变量_strand，如下所示。strand是个模板，需要声明它的类型。strand他有一个执行类型，要求这个执行类型是上下文的执行类型，也就是跟io_context匹配的执行类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::strand&lt;boost::asio::io_context::executor_type&gt;_strand;</span><br></pre></td></tr></table></figure>

<p>为了让回调函数被派发到strand的队列，我们只需要在注册回调函数时加一层strand的包装即可。</p>
<p>因为在asio中无论iocontext还是strand，底层都是通过executor调度的，可以将他理解为调度器，如果多个iocontext和strand的调度器是一个，那他们的消息派发统一由这个调度器执行。所以我们利用iocontext的调度器构造strand，这样他们统一由一个调度器管理。在绑定回调函数的调度器时，我们选择strand绑定即可。</p>
<p>比如我们在Start函数里添加读事件绑定 ，将回调函数的调用者绑定为_strand。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::<span class="built_in">memset</span>(_data, <span class="number">0</span>, MAX_LENGTH);</span><br><span class="line">    <span class="comment">//生成一个新的执行器，告诉asio底层，读事件就绪的时候，会调用执行器bind_executor来执行。该执行器会调用_strand队列里的线程，来派发该回调函数。</span></span><br><span class="line">    <span class="comment">//也就是说将_strand和回调处理进行绑定生成一个新的执行者，该执行者来派发所有的消息。</span></span><br><span class="line">    <span class="comment">//该执行者是唯一的，因为它是通过_stand来绑定的，而_strand只有一个调度器，这个调度器和对应的回调函数绑定起来</span></span><br><span class="line">    _socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(_data, MAX_LENGTH), boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleRead, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, <span class="built_in">SharedSelf</span>())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写事件绑定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">boost::asio::<span class="built_in">async_write</span>(_socket, boost::asio::<span class="built_in">buffer</span>(msgnode-&gt;_data, msgnode-&gt;_total_len), boost::asio::<span class="built_in">bind_executor</span>(_strand, std::<span class="built_in">bind</span>(&amp;CSession::HandleWrite, <span class="keyword">this</span>, std::placeholders::_1, shared_self)));</span><br></pre></td></tr></table></figure>

<p>如果不绑定执行器bind_executor，这个回调函数会默认让线程来调用。而绑定到_strand上，就由_strand来调用。底层是通过_strand的独立线程来调用。其次还有好处就是，各个线程的回调函数就绪的时候，会自动投递到stran队列里。</p>
<h2 id="6-4-多线程模式使用建议"><a href="#6-4-多线程模式使用建议" class="headerlink" title="6.4 多线程模式使用建议"></a>6.4 多线程模式使用建议</h2><p>实际的生产和开发中，我们尽可能利用C++特性，使用多核的优势，将iocontext分布在不同的线程中效率更可取一点，但也要防止线程过多导致cpu切换带来的时间片开销，所以尽量让开辟的线程数小于或等于cpu的核数，从而利用多核优势。</p>
<h1 id="7-asio协程实现并发服务器"><a href="#7-asio协程实现并发服务器" class="headerlink" title="7. asio协程实现并发服务器"></a>7. asio协程实现并发服务器</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p><strong>ASIO协程</strong>是一种编程技术，‌它允许程序员以更简洁和直观的方式编写异步代码，‌特别是在处理网络编程时。‌ASIO协程通过提供一种无栈协程(stackless coroutine)的方式，‌简化了异步编程的复杂性，‌尤其是在内存管理方面。‌这种技术通过提供一种更高级别的抽象，‌使得程序员可以更加专注于业务逻辑的实现，‌而不是陷入底层细节的处理中。‌</p>
<p>利用协程实现并发程序有两个好处：</p>
<ul>
<li>将回调函数改写为顺序调用，提高开发效率。</li>
<li>协程调度比线程调度更轻量化，因为协程是运行在用户空间的，线程切换需要在用户空间和内核空间切换。</li>
</ul>
<h2 id="7-2-协程的简单实现"><a href="#7-2-协程的简单实现" class="headerlink" title="7.2 协程的简单实现"></a>7.2 协程的简单实现</h2><p>在下面的协程实现中：</p>
<ul>
<li>awaitable<void>表示声明了一个函数，那么这个函数就变为可等待的函数了，比如<code>listener</code>被添加<code>awaitable&lt;void&gt;</code>之后，就可以被协程调用和等待了。</void></li>
<li><code>co_spawn</code>表示启动一个协程，参数分别为调度器，执行的函数，以及启动方式, 比如我们启动了一个协程，deatched表示将协程对象分离出来，这种启动方式可以启动多个协程，他们都是独立的，如何调度取决于调度器，在用户的感知上更像是线程调度的模式，类似于并发运行，其实底层都是串行的。</li>
<li>当<code>acceptor</code>接收到连接后，继续调用<code>co_spawn</code>启动一个协程，用来执行echo逻辑。echo逻辑里也是通过co_wait的方式接收和发送数据的，如果对端不发数据，执行echo的协程就会挂起，另一个协程启动，继续接收新的连接。当没有连接到来，接收新连接的协程挂起，如果所有协程都挂起，则等待新的就绪事件(对端发数据，或者新连接)到来唤醒。</li>
</ul>
<p>服务端实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"><span class="keyword">using</span> boost::asio::awaitable;    <span class="comment">//异步等待</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::co_spawn;</span><br><span class="line"><span class="keyword">using</span> boost::asio::detached;    <span class="comment">//让协程与主线程分离(协程独立启动)</span></span><br><span class="line"><span class="keyword">using</span> boost::asio::use_awaitable;</span><br><span class="line"><span class="keyword">namespace</span> this_coro = boost::asio::this_coro;   <span class="comment">//返回当前协程可执行的环境</span></span><br><span class="line"><span class="comment">//负责通信协程的执行函数</span></span><br><span class="line">awaitable &lt;<span class="type">void</span>&gt;<span class="built_in">echo</span>(tcp::socket socket) &#123;  <span class="comment">//传过来与对端连接的socket</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//将异步变成同步，变成可等待的，通过协程的方式来使用。co_await表示阻塞时会释放占有的资源，交个iqt协程和主线程</span></span><br><span class="line">            std::<span class="type">size_t</span> n = <span class="keyword">co_await</span> socket.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), use_awaitable); </span><br><span class="line">            <span class="function"><span class="keyword">co_await</span> <span class="title">async_write</span><span class="params">(socket, boost::asio::buffer(data, n), use_awaitable)</span></span>; <span class="comment">//同步的发送给对端</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;echo exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//负责监听对端连接协程的执行函数</span></span><br><span class="line">awaitable &lt;<span class="type">void</span>&gt; <span class="built_in">listener</span>() &#123;  <span class="comment">//awaitable是可等待的。协程就可以直接执行这个函数了,返回一个可执行对象</span></span><br><span class="line">    <span class="comment">//获取一个调度器</span></span><br><span class="line">    <span class="keyword">auto</span> executor = <span class="keyword">co_await</span> this_coro::executor; <span class="comment">//返回一个协程的调度器。co_await表示异步的去查询调度器，一直找不到，就先挂起，把使用权交给主线程和其它协程</span></span><br><span class="line">    <span class="comment">//监听对端的连接，acceptor调度是用的执行器executor，该执行器是协程的执行器，而协程执行器是主函数co_spawn里面的io_context</span></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(executor, &#123; tcp::v4(),<span class="number">10086</span> &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//acceptor.async_accept是我们之前的异步处理，后面需要传递一个回调函数。因为这是异步的，不能阻塞的去等待，asio底层是通过回调函数来通知我们的。但使用协程，加上co_await关键字后，就可以写成这种同步式的代码，即可以阻塞等待接收，但这是协程内部的阻塞，他会通过co_await来释放使用权，把协程占用的资源都释放出来(看起来是阻塞，但不会影响主线程向下的执行)</span></span><br><span class="line">        tcp::socket socket = <span class="keyword">co_await</span> acceptor.<span class="built_in">async_accept</span>(use_awaitable); <span class="comment">//当收到对端的连接，就返回一个socket。use_awaitable是在使用异步函数的时候，告诉asio，通过协程的方式来使用(即将异步函数变成可等待的函数)</span></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;connect is successful&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="comment">//建立连接成功，再启动一个协程，负责通信</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(executor, <span class="built_in">echo</span>(std::<span class="built_in">move</span>(socket)), detached); <span class="comment">//执行器；要执行的函数；分离。socket通过移动操作传过去，这边的socket就不能用了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::<span class="function">asio::io_context <span class="title">io_context</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//将使用一个工作线程来执行所有的异步操作</span></span><br><span class="line">        boost::<span class="function">asio::signal_set <span class="title">signals</span><span class="params">(io_context, SIGINT, SIGTERM)</span></span>; <span class="comment">//创建了一个信号集，绑定在上下文服务上，信号集处理的信号是 SIGINT、SIGTERM</span></span><br><span class="line">        <span class="comment">//异步等待。捕获引用，把前面所有到的变量都用引用捕获。()里面是要处理的参数，几个信号，就传几个参数</span></span><br><span class="line">        signals.<span class="built_in">async_wait</span>([&amp;](<span class="keyword">auto</span>, <span class="keyword">auto</span>) &#123;</span><br><span class="line">            io_context.<span class="built_in">stop</span>();     <span class="comment">//收到两个信号，就服务停止</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">//启动协程。将上下文里面的调度器与协程绑定起来(协程的调度是交给io_context内部的调度器来调度的)，并且协程要执行listener()</span></span><br><span class="line">        <span class="built_in">co_spawn</span>(io_context, <span class="built_in">listener</span>(), detached);   <span class="comment">//detached可以理解为分离出来，严谨地说是先让协程独立运行，不会阻塞在这里</span></span><br><span class="line">        io_context.<span class="built_in">run</span>(); <span class="comment">//io_context在没有绑定任何事件的时候，会直接退出，这程序就会执行完(退出)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context ioc;</span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">remote_ep</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10086</span>)</span></span>; <span class="comment">//传入回送地址，也是可以理解为本地地址</span></span><br><span class="line">        <span class="function">tcp::socket <span class="title">sock</span><span class="params">(ioc)</span></span>;</span><br><span class="line">        boost::system::error_code error = boost::asio::error::host_not_found;</span><br><span class="line">        sock.<span class="built_in">connect</span>(remote_ep, error);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;    <span class="comment">//不为0，就说明报错了</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect failed, code is &quot;</span> &lt;&lt; error.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;error msg is&quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Enter message:&quot;</span>;  <span class="comment">//终端打印提示信息</span></span><br><span class="line">        <span class="type">char</span> request[MAX_LENGTH];</span><br><span class="line">        std::cin.<span class="built_in">getline</span>(request, MAX_LENGTH);    <span class="comment">//读取终端输入的信息，存到request</span></span><br><span class="line">        <span class="type">size_t</span> request_length = <span class="built_in">strlen</span>(request);  <span class="comment">//获取输入信息长度</span></span><br><span class="line">        boost::asio::<span class="built_in">write</span>(sock, boost::asio::<span class="built_in">buffer</span>(request, request_length));  <span class="comment">//同步发送给服务器</span></span><br><span class="line">        <span class="type">char</span> reply[MAX_LENGTH];</span><br><span class="line">        <span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(sock, boost::asio::<span class="built_in">buffer</span>(reply, request_length));  <span class="comment">//同步接收服务器的信息</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;reply is &quot;</span> &lt;&lt; <span class="built_in">string</span>(reply, reply_length) &lt;&lt; endl;   <span class="comment">//打印出服务端发来的信息</span></span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;EXception is&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-协程改进服务器"><a href="#7-3-协程改进服务器" class="headerlink" title="7.3 协程改进服务器"></a>7.3 协程改进服务器</h2><p>我们可以通过协程改进服务器编码流程，用一个iocontext管理绑定acceptor用来接收对端新的连接，再从服务池IOServicePool里取其它的io_contex来管理连接的收发操作，将之前服务器中每个连接的接收数据操作改为启动一个协程，通过顺序的方式读取收到的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSession::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//start开始，后面就需要结合协程来完成了</span></span><br><span class="line">    <span class="keyword">auto</span> shared_this = <span class="built_in">shared_from_this</span>();  <span class="comment">//防止协程的智能指针被意外的释放，引用计数+1</span></span><br><span class="line">    <span class="comment">//开启协程接收</span></span><br><span class="line">    <span class="comment">//[=]表示以值的方式去捕获局部变量，捕获的局部变量引用计数可以加+；-&gt;awaitable&lt;void&gt;表示匿名函数要返回的类型</span></span><br><span class="line">    boost::asio::<span class="built_in">co_spawn</span>(_io_context, [=]()-&gt;boost::asio::awaitable&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; !_b_close;) &#123;    <span class="comment">//当变量_b_close置为true时，会退出该协程</span></span><br><span class="line">                _recv_head_node-&gt;<span class="built_in">Clear</span>();    <span class="comment">//先初始化头部节点(清0，方便存下一次的数据)</span></span><br><span class="line">                <span class="comment">//先读头部数据，异步变成同步了。只有读到指定长度HEAD_DATA_LEN数据才返回，读不到该协程就挂起，让出使用权,给其它协程或主线程</span></span><br><span class="line">                std::<span class="type">size_t</span> n = <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_head_node-&gt;_data, HEAD_DATA_LEN), boost::asio::use_awaitable);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">//接收长度为0，说明对端关闭了</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;    <span class="comment">//使用协程内部的一个返回函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取头部MSGID数据</span></span><br><span class="line">                <span class="type">short</span> msg_id = <span class="number">0</span>;    <span class="comment">//存的头部数据的id</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;msg_id, _recv_head_node-&gt;_data, HEAD_ID_LEN);<span class="comment">//将读到头部数据的前2个字节(id)存到变量里</span></span><br><span class="line">                msg_id = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_id);   <span class="comment">//将id转为本地字节序</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;msg_id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (msg_id &gt; MAX_LENGTH) &#123;   <span class="comment">//如果读到的id超过规定的id范围，则是异常</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid msg id is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//开始读数据长度</span></span><br><span class="line">                <span class="type">short</span> msg_len = <span class="number">0</span>;   <span class="comment">//存放数据长度变量</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;msg_len, _recv_head_node-&gt;_data + HEAD_ID_LEN, HEAD_DATA_LEN);</span><br><span class="line">                msg_len = boost::asio::detail::socket_ops::<span class="built_in">network_to_host_short</span>(msg_len); <span class="comment">//将数据长度转为本地字节序</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;msg len is &quot;</span> &lt;&lt; msg_id &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">if</span> (msg_len &gt; MAX_LENGTH) &#123;   <span class="comment">//如果读到的数据长度超过规定的最大长度，则是异常</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;invalid msg len is &quot;</span> &lt;&lt; msg_len &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//异步读出包体</span></span><br><span class="line">                n == <span class="keyword">co_await</span> boost::asio::<span class="built_in">async_read</span>(_socket, boost::asio::<span class="built_in">buffer</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len), boost::asio::use_awaitable);</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;   <span class="comment">//对端关闭</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;receive peer closed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">Close</span>();</span><br><span class="line">                    _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">                    <span class="keyword">co_return</span>;    <span class="comment">//使用协程内部的一个返回函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                _recv_msg_node-&gt;_data[_recv_msg_node-&gt;_total_len] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">//在数据最后面加上一个结尾符</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;receive data is &quot;</span> &lt;&lt; _recv_msg_node-&gt;_data &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">//投递到逻辑线程处理</span></span><br><span class="line">                LogicSystem::<span class="built_in">GetInstance</span>().<span class="built_in">PostMsgToQue</span>(std::<span class="built_in">make_shared</span>&lt;LogicNode&gt;(<span class="built_in">shared_from_this</span>(), _recv_msg_node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;exception is &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">Close</span>();</span><br><span class="line">            _server-&gt;<span class="built_in">ClearSession</span>(_uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, boost::asio::detached);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于其它部分，和之前的服务器逻辑一样，出于性能的考虑，没有把服务器的接收数据和发送数据都通过协程来完成，而只是将接收数据通过协程来完成，发送数据还是通过异步写的形式来完成的。</p>
]]></content>
      <categories>
        <category>asio网络编程</category>
      </categories>
      <tags>
        <tag>asio</tag>
        <tag>异步编程</tag>
        <tag>网络编程</tag>
        <tag>粘包</tag>
        <tag>Json</tag>
        <tag>高并发</tag>
        <tag>boost</tag>
        <tag>IOServicePool</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>图床实现(通过百度智能云、七牛云、PicGo软件完成)</title>
    <url>/2024/07/03/%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="1-给域名添加新的解析"><a href="#1-给域名添加新的解析" class="headerlink" title="1.给域名添加新的解析"></a>1.给域名添加新的解析</h1><p>进入百度智能云官网：<a href="https://cloud.baidu.com/">https://cloud.baidu.com/</a>，点击右上角的控制台</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/1.png"></p>
<p>找到域名服务，点击域名管理，这里有你之前买的域名(没有买的最好买一个，很便宜)，下面要为域名添加一共新的解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/2.png"></p>
<p>在添加解析记录的界面中，主机记录可以随便填，例如填image，记录类型选择CNAME记录，记录值先随便乱填(后期会改)，填写完上面内容后，点击确定，完成添加解析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/3.png"></p>
<h1 id="2-创建存储图片的空间"><a href="#2-创建存储图片的空间" class="headerlink" title="2.创建存储图片的空间"></a>2.创建存储图片的空间</h1><p>进入七牛云官网：<a href="https://marketing.qiniu.com/">https://marketing.qiniu.com/</a>，点击右上角的控制台</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/4.png"></p>
<p>点击左上角的菜单，选择对象存储</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/5.png"></p>
<p>进入后，选择空间管理，然后新建空间，存储空间的名称可以随便填，存储区域建议选择亚太-新加坡，访问控制选择公开，最好点击确定，完成空间建立</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/6.png"></p>
<p>建立完成后，点击创建的空间名称，进入图床控制面板，选择域名管理，绑定域名</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/7.png"></p>
<p>进入后，在添加域名的界面，其中加速域名是之前添加解析记录时填写的主机记录，而且后缀要加上你的域名(我因为之前填写过改域名，所以会提示创建过)。使用场景选择图片小文件，然后下面点击使用推荐配置，点击创建即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/8.png"></p>
<p>绑定完成后，复制图上箭头所指的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/9.png"></p>
<p>然后对刚刚在百度智能云上添加的解析进行修改，将复制的内容粘贴到记录值，点击确定即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/10.png"></p>
<h1 id="3-完成连接"><a href="#3-完成连接" class="headerlink" title="3.完成连接"></a>3.完成连接</h1><p>通过该网址下载PicGo：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p>
<p>下载完后，进入该软件，点击图床设置，选择七牛云</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/11.png"></p>
<p>这样就进入了七牛云设置，首先是图库配置名，这里随便填；其次是AK和SK，这里需要填写七牛云米密匙管理中的AK和SK；然后设定Bucket这里填之前创建的空间名称；设定访问网址填写的是我们刚才填写的加速域名，这里前面要加http:&#x2F;&#x2F;；而设定存储区域这里是填as0（这里仅限刚刚与我选择的区域一样的情况，如果选择的区域不是亚太-新加坡则不是填这个）；最后是设定存储路径，这里可以先在七牛云的中创建存储图片的目录，然后这里就填写该目录名即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/12.png"></p>
<p>点击了密匙管理就进入下面页面，然后分别复制AK和SK到PicGo对应位置，这里需要注意的是SK复制时，必须要打开显示复制，如果不打开显示复制，后面会出现问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/13.png"></p>
<p>PicGo软件中七牛云设置填写完毕后，点击确定即可，这样就完成了图床的配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/14.png"></p>
<p>完成配置后，在上传区，直接添加你要上传的本地图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/15.png"></p>
<p>上传完成后，然后到七牛云的空间管理中，点击picture目录就可以看见刚刚上传的图片</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/16.png"></p>
<p>这样，以后要在博客或者其它平台上要用到的这些图片时，可以直接用下面图中箭头指的地方的图片网址或者七牛云中上传图片的外链即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/tu_chuang/17.png"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>七牛云</tag>
        <tag>域名</tag>
        <tag>PicGo</tag>
        <tag>解析</tag>
      </tags>
  </entry>
  <entry>
    <title>c++并发编程(下)</title>
    <url>/2024/08/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="1-引用计数实现无锁并发栈"><a href="#1-引用计数实现无锁并发栈" class="headerlink" title="1. 引用计数实现无锁并发栈"></a>1. 引用计数实现无锁并发栈</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>在C++并发编程中提出了两种计数，一种是外部计数，一种是内部计数，二者加起来就是有效的引用计数，下面提出一种新的方法，利用引用计数实现无锁并发的栈。</p>
<h2 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h2><p>栈结构函数：栈函数里面实现了栈的默认构造函数、析构函数和创建了一个原子类型的头部节点，同时也定义好了栈的内部节点类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">single_ref_stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">single_ref_stack</span>():<span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;        <span class="comment">//默认构造函数</span></span><br><span class="line">    ~<span class="built_in">single_ref_stack</span>() &#123;                      <span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">pop</span>());     <span class="comment">//循环出栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;                      <span class="comment">//引用节点(栈的内部节点)</span></span><br><span class="line">        std::shared_ptr&lt;T&gt;  _data;         <span class="comment">//1 数据域智能指针</span></span><br><span class="line">        std::atomic&lt;<span class="type">int</span>&gt; _ref_count;       <span class="comment">//2 引用计数</span></span><br><span class="line">        ref_node* _next;                   <span class="comment">//3  下一个节点</span></span><br><span class="line">        <span class="comment">//构造函数，接收外部传来的数据，根据数据构造一个节点</span></span><br><span class="line">        <span class="built_in">ref_node</span>(T <span class="type">const</span>&amp; data_):_data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)), _ref_count(<span class="number">1</span>), _next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//头部节点</span></span><br><span class="line">    std::atomic&lt;ref_node*&gt; head;           <span class="comment">//会被多个线程操作，设为原子类型的头部节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>push操作函数：这段程序就是解决两个线程同时push的情况，但同一时刻也只有一个线程会成功，那么另一个线程在while进行比较的时候，就会发现它的new_node的next与head不相等，那么它就会继续循环，而且将新的head值赋值给new_node的next，这样在没有其它线程抢先指向while的话，该线程就会更新head的值，将head指向了它的new_node，并退出循环，这样该线程就完成了节点的push。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;              <span class="comment">//参数是要push的T类型的数据</span></span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">ref_node</span>(data);      <span class="comment">//通过data创建出一个新的ref_node类型节点，并得到其指针</span></span><br><span class="line">    new_node-&gt;next = head.<span class="built_in">load</span>();            <span class="comment">//新节点的next要指向头部节点</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node-&gt;next, new_node));     <span class="comment">//通过重试的方式更新头部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop操作函数：在下面程序中，是通过引用计数为0或1来判断该节点是否可以直接delete。比如说当线程1进入2处的if，线程2这时候就只能进入7处else，如果线程1在4处，将引用计数-2后，发现还等于1，那么线程1是回收不了该节点的，此时如果线程2发现该节点的引用计数为1，则此时只有它在访问该节点，所以线程2就可以进行回收。但当线程1执行4处时，引用计数为0，说明只有它在访问，这样线程1就可以对该节点进行回收。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node* old_head = head.<span class="built_in">load</span>();             <span class="comment">//先取出头部元素</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!old_head) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();          <span class="comment">//如果为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 只要执行pop就对引用计数+1</span></span><br><span class="line">        ++(old_head-&gt;_ref_count);</span><br><span class="line">        <span class="comment">//2 比较head和old_head想等则交换，更新head,返回true；否则说明head已经被其他线程更新,返回false</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, old_head-&gt;_next)) &#123;</span><br><span class="line">            <span class="comment">//此时head已经为old_head的next了</span></span><br><span class="line">            <span class="keyword">auto</span> cur_count = old_head-&gt;_ref_count.<span class="built_in">load</span>();    <span class="comment">//取出原来头部节点的引用计数</span></span><br><span class="line">            <span class="keyword">auto</span> new_count;</span><br><span class="line">            <span class="comment">//3  循环重试保证引用计数安全更新</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//4 减去本线程增加的1次和初始的1次,如果为0，说明没有其它线程访问该节点</span></span><br><span class="line">                new_count = cur_count - <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!old_head-&gt;_ref_count.<span class="built_in">compare_exchange_weak</span>(cur_count,  new_count));</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;            <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(old_head-&gt;_data);    <span class="comment">//5 交换数据，取出要删除节点old_head的值，此时old_head的值为0了</span></span><br><span class="line">            <span class="comment">//6</span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count == <span class="number">0</span>) &#123;    <span class="comment">//继续判断，如果此时old_head的引用计数还为0，就delete掉</span></span><br><span class="line">                <span class="keyword">delete</span> old_head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//7 </span></span><br><span class="line">            <span class="keyword">if</span> (old_head-&gt;_ref_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> old_head;     <span class="comment">//如果判断引用计数等于1的，说明也只有它应该在使用该节点，也可以直接delete</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上pop操作函数的大体流程如下：</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_7.png" style="zoom:67%;">

<p>从流程上来看，该程序存在着很大的问题，在刚开没有pop前，所有节点的引用计数都为1；如果两个线程进入pop函数后，head的引用计数进行++，变为了3，此时线程1的old_head和线程2的old_head都指向head；当线程1先执行操作2时，它会更新head的指向，并且进入if程序里面，而线程2再来执行操作2时，因为此时的head被更改了，所以它会将它的old_head执行新的head，并执行else里面的程序，这时线程1将引用计数减2后为1，它就负责只将要删除的节点值返回，而没有delete掉要删除的节点(原头节点)，以为线程2会delete掉该节点，而线程2判断当前old_head指向的节点引用计数为1，它以为指向的是原节点，所以就会直接delete，但指向的是要删除节点的下一个节点，这样系统就会崩溃。</p>
<p>所以为了解决这些问题，可以将引用计数提出来，不放在指针里，和指针解耦。下面程序是将原来的节点结构拆成两个，并且新增<code>_dec_count</code>表示减少的引用计数，放在node结构里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt;  _data;          <span class="comment">//1 数据域智能指针</span></span><br><span class="line">    ref_node _next;                     <span class="comment">//2  下一个节点</span></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : _data(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_)) &#123;&#125;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt;  _dec_count;       <span class="comment">//减少的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_node</span> &#123;</span><br><span class="line">    <span class="type">int</span> _ref_count;                <span class="comment">// 引用计数</span></span><br><span class="line">    node* _node_ptr;</span><br><span class="line">    <span class="built_in">ref_node</span>( T <span class="type">const</span> &amp; data_):_node_ptr(<span class="keyword">new</span> <span class="built_in">node</span>(data_)), _ref_count(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ref_node</span>():_node_ptr(<span class="literal">nullptr</span>),_ref_count(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//头部节点</span></span><br><span class="line">std::atomic&lt;ref_node&gt; head;            <span class="comment">//将栈中的head结构变为ref_node类型的原子变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ref_node old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ref_node new_head;               <span class="comment">//1 只要执行pop就对引用计数+1并更新到head中</span></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            new_head = old_head;</span><br><span class="line">            new_head._ref_count += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, new_head));</span><br><span class="line">        old_head = new_head;</span><br><span class="line">        <span class="keyword">auto</span>* node_ptr = old_head._node_ptr;       <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (node_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  std::<span class="built_in">shared_ptr</span>&lt;T&gt;();        <span class="comment">//为空就放回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 比较head和old_head相等则交换否则说明head已经被其他线程更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, node_ptr-&gt;_next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;             <span class="comment">//要返回的值</span></span><br><span class="line">            res.<span class="built_in">swap</span>(node_ptr-&gt;_data);          <span class="comment">//交换智能指针</span></span><br><span class="line">            <span class="type">int</span> increase_count = old_head._ref_count - <span class="number">2</span>;      <span class="comment">//5 增加的数量 </span></span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_add</span>(increase_count) == -increase_count) &#123;  <span class="comment">//6 </span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_ptr-&gt;_dec_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;    <span class="comment">//7</span></span><br><span class="line">                <span class="keyword">delete</span> node_ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-内存模型回顾"><a href="#2-内存模型回顾" class="headerlink" title="2. 内存模型回顾"></a>2. 内存模型回顾</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>之前实现的那些无锁并发的栈结构，它们对于原子变量的读，写以及读改写操作默认采用的是<code>memory_order_seq_cst</code>，<code>memory_order_seq_cst</code>为全局顺序模型，即所有线程看到的执行顺序是一致的。这种模型对性能消耗较大，所以可以在无锁栈的基础上通过更为宽松的模型提升性能。</p>
<h2 id="2-2-release-acquire同步"><a href="#2-2-release-acquire同步" class="headerlink" title="2.2 release-acquire同步"></a>2.2 release-acquire同步</h2><p>在之前了解的6中内存顺序，其中可以通过<code>release</code>和<code>acquire</code>的方式实现同步的效果。也就是说，线程A执行store操作，采用<code>memory_order_release</code>顺序模型，线程B执行load操作采用<code>memory_order_acquire</code>顺序模型。如果线程B的load操作读取到线程A的store操作的数值，就可以称线程A的store操作 synchronizes-with(同步) 线程B的load操作。</p>
<h2 id="2-3-happens-before先行"><a href="#2-3-happens-before先行" class="headerlink" title="2.3 happens-before先行"></a>2.3 happens-before先行</h2><p>如果 a-&gt;store 同步于 b-&gt;load， 则 a-&gt;store 先行于 b-&gt;load。只要同步就能推出先行，所谓先行就是逻辑执行的顺序，一定是a-&gt;store 先于 b-&gt;load。先行还包括一种情况，sequenced-before(顺序执行)， 所谓顺序执行就是单线程中执行的顺序为从上到下的顺序。</p>
<p>先行具有传递性 操作1 <code>happens-before</code> 操作2，操作2 <code>happens-before</code> 操作3，则操作1 <code>happens-before</code> 操作3</p>
<p>在下面程序中， 操作2处使用了release内存序，保证操作1会排在操作2之前。 操作3采用了acquire内存序，保证操作4排在操作3之后，且如果操作3能读到操作2的写入值，则保证操作1已经先于操作3执行完。因为while重试的机制，保证操作2同步于操作3，即操作2先于操作3执行，又因为操作1先于操作2执行，而操作3先于操作4执行，所以得出操作1先于操作4执行，那么操作4处断言正确就不会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>;                                           <span class="comment">//1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release);            <span class="comment">//2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.load(std::memory_order_acquire));       <span class="comment">//3 </span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>);                                  <span class="comment">//4</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-释放序列的扩展"><a href="#2-4-释放序列的扩展" class="headerlink" title="2.4 释放序列的扩展"></a>2.4 释放序列的扩展</h2><blockquote>
<p>如果存储操作的标记是memory_order_release、memory_order_acq_rel或memory_order_seq_cst，而载入操作则以memory_order_consume、memory_order_acquire或memory_order_seq_cst标记，这些操作前后相扣成链，每次载入的值都源自前面的存储操作，那么该操作链由一个<strong>释放序列</strong>组成。若最后的载入操作服从内存次序memory_order_acquire或memory_order_seq_cst，则最初的存储操作与它构成同步关系。但如果该载入操作服从的内存次序是memory_order_consume，那么两者构成前序依赖关系。操作链中，每个“读-改-写”操作都可选用任意内存次序，甚至也能选用memory_order_relaxed次序。</p>
</blockquote>
<p>release-sequnece：针对一个原子变量M的release操作A完成后, 接下来M上可能还会有一连串的其他操作。如果这一连串操作是由</p>
<ol>
<li>同一线程上的写操作</li>
<li>或者任意线程上的 read-modify-write(可以是任意内存顺序) 操作</li>
</ol>
<p>这两种构成的，则称这一连串的操作为以release操作A为首的release sequence。这里的写操作和read-modify-write操作可以使用任意内存顺序。</p>
<p>同步：一个acquire操作在同一个原子变量上读到了一个release操作写入的值，或者读到了以这个release操作为首的release sequence写入的值，那么这个release操作 “synchronizes-with” 这个 acquire 操作。所以release-sequence不一定构成同步，只有acquire到release的值才算作同步。</p>
<p>下面程序中，在入队函数的操作1处使用的是<code>memory_order_release</code>内存序来记录入队的数量，这样一方面保证了它之前的代码都执行完了，另一方在出队函数的操作3处有<code>memory_order_acquire</code>的载入操作，这样它们就构成了同步关系。<code>fetch_sub</code>是一个原子操作函数，用于从原子变量 <code>count</code> 的当前值中减去指定的值，即1，并返回操作前的原始值。所以就可以通过该函数来完成队列数据的读取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; queue_data;                <span class="comment">//存储数据的队列</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;                     <span class="comment">//记录入队的数量</span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; store_finish = <span class="literal">false</span>;     <span class="comment">//表示是否存储完成</span></span><br><span class="line"><span class="comment">//入队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">const</span> number_of_items = <span class="number">20</span>;</span><br><span class="line">    queue_data.<span class="built_in">clear</span>();                     <span class="comment">//队列清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_items; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        queue_data.<span class="built_in">push_back</span>(i);       <span class="comment">//从0到20，往队列放入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1 最初的存储操作</span></span><br><span class="line">    count.<span class="built_in">store</span>(number_of_items, std::memory_order_release); <span class="comment">//记录入队数量，内存序用的是memory_order_release</span></span><br><span class="line">    store_finish.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);   <span class="comment">//将store_finish置未true，不太关注时效性和同步性，所以就用宽松的内存序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2 循环等待存储完成，使用的是宽松的内存序</span></span><br><span class="line">        <span class="keyword">while</span> (!store_finish.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">        <span class="type">int</span> item_index;</span><br><span class="line">        <span class="comment">//3 读—改—写”操作</span></span><br><span class="line">        <span class="keyword">if</span> ((item_index = count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acquire)) &lt;= <span class="number">0</span>)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;    <span class="comment">//当count为0的时候，会执行到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4 从内部容器queue_data 读取数据项是安全行为</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;queue_data is  &quot;</span> &lt;&lt; queue_data[item_index<span class="number">-1</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseSeq2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_8.png" style="zoom:67%;">

<p>从打印结果可以看到消费者线程b和c并没有打印重复的数据，说明他们互斥访问count，每个线程取到的count不一样进而访问queue_data中的不同数据。</p>
<p>如果单从线程角度考虑，b和c并不能构成同步，但是线程b和c必然有一个线程会先执行执行fetch_sub(原子变量的操作任何顺序模型都能保证操作的原子性)。假设b先执行，和a构成release-sequence关系，b读取到a执行的count.store的结果， b处于以a线程的release为首的释放序列中，则b的store操作会和c的读-改-写(fetch操作，只限这一段代码)构成同步。</p>
<p>如下图所示：实线表示先行关系，虚线标识释放序列</p>
<img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_9.jpg" style="zoom:67%;">

<p>结论如下：</p>
<ol>
<li>a线程和b线程构成release-sequence的释放序列。</li>
<li>即使b线程和c线程不构成同步，但是b线程的读改写操作处于release-sequence中，且c线程采用acquire方式读改写，则b的读改写和c线程的读改写构成同步，以a线程的release为首的sequence序列和c线程的读改写构成同步。</li>
<li>这里要强调一点，如果a release-sequence b，a和b不一定构成同步，但是b sychronizes with c，则a synchronizes with c。也就是说处于release序列中的任意读改写操作和其他的线程构成同步，那么我们就能得出release-sequence为首的操作和其他线程同步。</li>
</ol>
<h1 id="3-优化无锁栈"><a href="#3-优化无锁栈" class="headerlink" title="3. 优化无锁栈"></a>3. 优化无锁栈</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>对于想要更好的优化无锁栈，可以结合释放序列这一技术来完成。当有数据入栈时，那么pop时要读取最新入栈的数据。所以我们要让push操作同步给pop操作，想到的办法很简单，push对head的修改采用release内存序列，pop对head的读改写采用acquire内存序列。多个线程并发pop，执行读改写操作，这些线程本来是无法同步的，但是最先pop的线程会和push线程构成同步关系，且形成release-sequence。那之后的线程pop就会和第一个pop的线程的写操作形成同步。</p>
<p>如果没有元素入栈，这时多个线程pop也不会产生问题，可以根据head内部的ptr指向为空判断空栈直接返回空指针。</p>
<p>总的来说，就是以下两方面含义：</p>
<ol>
<li>因为要保证pop操作时节点的数据是有效的。push和pop要构成同步关系，即push采用release内存序修改head；pop采用acquire内存序修改head</li>
<li>第一个pop的线程的写操作和之后的pop线程读操作要构成同步关系</li>
</ol>
<h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><p>push操作函数：该函数就是创建一个新节点，将新节点的next指向head，最后操作1处执行比较交换操作，当head等于新节点的next时，使用的是release内存序，并返回true；当head不等于新节点的next时(head被其它线程更新)，使用的是relaxed内存序(因为要重试，所以什么内存序都可以)，并返回false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_node;               <span class="comment">//定义一个新的节点指针</span></span><br><span class="line">    new_node.ptr = <span class="keyword">new</span> <span class="built_in">count_node</span>(data);     <span class="comment">//通过yao创建的data数据，来构造一个节点</span></span><br><span class="line">    new_node.external_count = <span class="number">1</span>;             <span class="comment">//将该节点的引用计数置1</span></span><br><span class="line">    new_node.ptr-&gt;next = head.<span class="built_in">load</span>();        <span class="comment">//另新节点的next指向head</span></span><br><span class="line">    <span class="comment">//1 比较交换操作</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(new_node.ptr-&gt;next, new_node, memory_order::memory_order_release, memory_order::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop操作函数：在<code>increase_head_count</code>函数中，操作7的比较交换成功时，使用的是acquire的内存序，这样也是为了与push操作函数中操作1处的比较交换的release内存序构成同步关系。如果考虑两个线程并发执行，有两种情况发生：</p>
<ol>
<li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程2先执行完操作5，则内部引用计数就为-1(线程2因为不满足条件，不能进入释放ptr，留给线程1释放ptf)，这时操作2就不会再用ptr了，线程1的操作4就可以进入if释放ptr了。</li>
<li>线程1执行if，线程2执行else if，在操作3处<code>count_increase</code>就为1，而内部引用计数internal_count初始化是为0的，如果线程1先执行操作4，那么它会将内部引用计数变为1，并且返回0，不满足条件就不能释放ptr，就退出了。线程2这时执行操作5就能满足条件，从而释放ptr。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();     <span class="comment">//取出head</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);             <span class="comment">//增加引用计数</span></span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;      <span class="comment">//获取old_head的指向</span></span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();           <span class="comment">//如果为空，返回空指针即可</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始头部更新，如果线程1的old_head与head相等，说明还没有其它线程抢占到head，线程1就负责回收数据和将外部引用计数转为内部引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next)) &#123;</span><br><span class="line">            std::shared_ptr&lt;T&gt; res;              <span class="comment">//返回头部数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);                 <span class="comment">//交换数据</span></span><br><span class="line">            <span class="comment">//3 因为外部引用计数初始化为1，该进行进来时又+1，所以减2，可以统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase) == -count_increase) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>) == <span class="number">1</span>) &#123;       <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//如果old_head与head不相等，有两种情况：其它线程把head更新了；还有就是该线程先将head引用计数++，后面又被其它线程将head引用计数++了，因为该线程的old_head是局部变量的一个缓存，所以head引用计数更新了，old_head还是旧数据</span></span><br><span class="line">            <span class="comment">//该线程负责减少内部引用计数(该进程进pop的时候，加的是外部引用计数)，最后是判断，外部的引用计数和内部引用计数相加为0，就做回收操作</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;    <span class="comment">//当前线程减少内部引用计数，返回之前值为1说明指针仅被当前线程引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加头部节点引用数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase_head_count</span><span class="params">(counted_node_ptr&amp; old_counter)</span> </span>&#123;</span><br><span class="line">    counted_node_ptr new_counter;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        new_counter = old_counter;</span><br><span class="line">        ++new_counter.external_count;</span><br><span class="line">    &#125;<span class="comment">//7 循环判断保证head和old_counter相等时做更新,多线程情况保证引用计数原子递增。</span></span><br><span class="line">    <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_strong</span>(old_counter,  new_counter, std::memory_order_acquire, std::memory_order_relaxed));</span><br><span class="line">    <span class="comment">//8 走到此处说明head的external_count已经被更新了</span></span><br><span class="line">    old_counter.external_count = new_counter.external_count; <span class="comment">//因为old_counter是引用传进来的，所以external_count更新了想要传给它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>对于一个原子变量M，其释放序列中的读改写操作无论采用何种模型都能读取M的最新值(原子变量来保证的)。</li>
<li>为了保证原子变量上下程序的操作能和其它线程同步，可以利用内存顺序模型用来保证数据在多个线程的可见顺序。</li>
</ul>
<h2 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h2><p>虽然以上程序优化了无锁栈，但还需要保证ptr的data在被删除之前swap到res里。</p>
<p>改进后的pop函数：在下面程序中，线程1如果是进入了操作4处执行delete，那么是需要保证swap操作先于fetch_add之后的delete操作，所以fetch_add可以采用release模型；而对于线程2执行操作5，内部delete操作之前，也需要保证其它线程执行的swap操作完成，所以操作5处的fetch_sub要采用acquire内存序，这样它就和操作4构成同步关系，即操作4先于操作5，而操作4完成之前可以保证它上面的程序执行完，所以swap就可以先于操作5了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counted_node_ptr old_head = head.<span class="built_in">load</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">increase_head_count</span>(old_head);</span><br><span class="line">        count_node* <span class="type">const</span> ptr = old_head.ptr;</span><br><span class="line">        <span class="comment">//1  判断为空责直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2 本线程如果抢先完成head的更新</span></span><br><span class="line">        <span class="keyword">if</span> (head.<span class="built_in">compare_exchange_strong</span>(old_head, ptr-&gt;next,  std::memory_order_relaxed)) &#123;</span><br><span class="line">            <span class="comment">//返回头部数据</span></span><br><span class="line">            std::shared_ptr&lt;T&gt; res;</span><br><span class="line">            <span class="comment">//交换数据</span></span><br><span class="line">            res.<span class="built_in">swap</span>(ptr-&gt;data);</span><br><span class="line">            <span class="comment">//3 减少外部引用计数，先统计到目前为止增加了多少外部引用</span></span><br><span class="line">            <span class="type">int</span> <span class="type">const</span> count_increase = old_head.external_count - <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//4 将内部引用计数添加</span></span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(count_increase, std::memory_order_release) == -count_increase) &#123;</span><br><span class="line">                <span class="keyword">delete</span>  ptr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ptr-&gt;internal_count.<span class="built_in">fetch_add</span>(<span class="number">-1</span>, std::memory_order_acquire) == <span class="number">1</span>) &#123; <span class="comment">//5</span></span><br><span class="line">            <span class="comment">//ptr-&gt;internal_count.load(std::memory_order_acquire);</span></span><br><span class="line">            <span class="keyword">delete</span> ptr;     <span class="comment">//6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，操作5处使用内存序relaxed也可以的，只要保证swap操作相较于delete先执行完即可，所以在操作6的delete上面添加内部引用计数的acquire内存序加载，即可和前面的释放序列构成同步关系。</p>
<h1 id="4-双引用实现无锁队列"><a href="#4-双引用实现无锁队列" class="headerlink" title="4. 双引用实现无锁队列"></a>4. 双引用实现无锁队列</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>队列和栈容器它们的结构是不同的，对于队列结构，push()和pop()分别访问其不同部分，而在栈容器上，这两项操作都访问头节点，所以两种数据结构所需的同步操作相异。如果某线程在队列一端做出改动，而另一线程同时访问队列另一端，程序就要保证前者的改动过程能正确地为后者所见。</p>
<h2 id="4-2-单线程队列"><a href="#4-2-单线程队列" class="headerlink" title="4.2 单线程队列"></a>4.2 单线程队列</h2><p>下面程序是一个单线程情况下实现的队列操作，在单线程情况下是不会出现问题的，但在多线程情况下，push和pop都会出现问题。</p>
<p>对于push操作，当两个线程都执行push，如果线程1在操作3先创建了新节点p1，然后数据交换，并让尾指针指向了p1，正准备执行操作7，更新尾指针位置，这时时间片被线程2抢到了，线程2就会覆盖线程1执行的操作，令尾指针指next向p2，并执行了操作7，移动尾指针，让尾指针指向了p2，这时线程1在执行操作7，就令尾指针指向p1。这样就导致数据混乱了，即队列中最后连接的是p2，但尾指针指向p1去了。</p>
<p>对于pop操作，当两个线程都执行pop时，当线程1通过old_head取出头节点时，正准备执行操作1，这时轮到线程2执行了，线程2也通过old_head取出头节点后，并且先执行了操作1，将head头指针更新为了原头节点的next，这时线程1有执行操作1，由于它的old_head是原头节点，所以它执行完操作7，还是将head头指针更新为原头节点的next。这样就导致，两个进行调用pop，结果head头指针只移动一个位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePopPush</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>            <span class="comment">//节点的结构类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;     <span class="comment">//节点的数据域</span></span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::atomic&lt;node*&gt; head;            <span class="comment">//头指针</span></span><br><span class="line">    std::atomic&lt;node*&gt; tail;            <span class="comment">//尾指针</span></span><br><span class="line">    <span class="comment">//弹出头部节点</span></span><br><span class="line">    <span class="function">node* <span class="title">pop_head</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>();       <span class="comment">//接收头指针</span></span><br><span class="line">        <span class="keyword">if</span> (old_head == tail.<span class="built_in">load</span>())              <span class="comment">//如果头指针和尾指针相等，则是空的，直接返回空指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1 没有空，就直接更新头指针，指向删除节点的next</span></span><br><span class="line">        head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> old_head;          <span class="comment">//返回要删除的节点指针</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SinglePopPush</span>():<span class="built_in">head</span>(<span class="keyword">new</span> node), <span class="built_in">tail</span>(head.<span class="built_in">load</span>())&#123;&#125;       <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">SinglePopPush</span>(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePopPush&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePopPush&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">SinglePopPush</span>()&#123;</span><br><span class="line">        <span class="keyword">while</span> (node* <span class="type">const</span> old_head = head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//循环取出头指针，为空就返回，不为空就delete掉</span></span><br><span class="line">            head.<span class="built_in">store</span>(old_head-&gt;next);</span><br><span class="line">            <span class="keyword">delete</span> old_head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>                <span class="comment">//出队函数(消费者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node* old_head = <span class="built_in">pop_head</span>();        <span class="comment">//先取出要删除的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (!old_head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();         <span class="comment">//为空，就返回头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不为空，就取出要删除节点的数据值</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(old_head-&gt;data)</span></span>;</span><br><span class="line">        <span class="keyword">delete</span> old_head;           <span class="comment">//delete要删除的头节点</span></span><br><span class="line">        <span class="keyword">return</span> res;                <span class="comment">//返回数据值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>                 <span class="comment">//入队函数(生产者)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(std::make_shared&lt;T&gt;(new_value))</span></span>;     <span class="comment">//先构造好数据</span></span><br><span class="line">        node* p = <span class="keyword">new</span> node;             <span class="comment">//3 创建一个新节点</span></span><br><span class="line">        node* <span class="type">const</span> old_tail = tail.<span class="built_in">load</span>();       <span class="comment">//4 获取尾节点指针</span></span><br><span class="line">        old_tail-&gt;data.<span class="built_in">swap</span>(new_data);      <span class="comment">//5 数据交换(old_tail-&gt;data原来是没有数据的空指针)</span></span><br><span class="line">        old_tail-&gt;next = p;           <span class="comment">//6 令尾节点的next指向p</span></span><br><span class="line">        tail.<span class="built_in">store</span>(p);                <span class="comment">//7 更新尾指针，令尾指针存储新节点p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-多线程push"><a href="#4-3-多线程push" class="headerlink" title="4.3 多线程push"></a>4.3 多线程push</h2><p>为了解决多线程push的竞争问题，可以采用以下程序来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;T&gt; <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> T(new_value))</span></span>;   <span class="comment">//先创建处要push的数据</span></span><br><span class="line">    counted_node_ptr new_next;           <span class="comment">//定义一个可计数的节点指针，有两个参数</span></span><br><span class="line">    new_next.ptr=<span class="keyword">new</span> node;               <span class="comment">//ptr指向新建的一个节点</span></span><br><span class="line">    new_next.external_count=<span class="number">1</span>;           <span class="comment">//外部引用计数为1</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        node* <span class="type">const</span> old_tail=tail.<span class="built_in">load</span>();        <span class="comment">//1 将尾部节点加载出来(它的data和next开始都是空的)</span></span><br><span class="line">        T* old_data=<span class="literal">nullptr</span>;                     <span class="comment">//定义并初始化T类型的old_data为空</span></span><br><span class="line">        <span class="comment">//2 尾节点的data如果还是空的，就更新尾节点的data为new_data的数据data，并返回true</span></span><br><span class="line">        <span class="keyword">if</span>(old_tail-&gt;data.<span class="built_in">compare_exchange_strong</span>(old_data, new_data.<span class="built_in">get</span>()))   </span><br><span class="line">        &#123;</span><br><span class="line">            old_tail-&gt;next=new_next;         <span class="comment">//将尾节点的next指向一个空的可计数的节点</span></span><br><span class="line">            tail.<span class="built_in">store</span>(new_next.ptr);        <span class="comment">//3 更新尾指针为最后连接的一个节点</span></span><br><span class="line">            new_data.<span class="built_in">release</span>();          <span class="comment">//解绑new_data的裸指针，因为该指针已经交给old_tail的data管理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是将data指针原子化，通过比较-交换操作来设置它的值。如果比较-交换操作成功，所操作的节点即为真正的尾节点，我们便可安全地设定next指针，使之指向新节点。若比较-交换操作失败，就表明有另一线程同时存入了数据，我们应该进行循环，重新读取tail指针并从头开始操作。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性</title>
    <url>/2024/08/26/c++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="1-原始自变量"><a href="#1-原始自变量" class="headerlink" title="1. 原始自变量"></a>1. 原始自变量</h1><p>定义原始字符串的方式为：R “xxx(原始字符串)xxx”，其中()两边的字符串可以省略(不省略的时候就要求一样)。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p>
<p>用途：主要是防止一些特殊字符，如\t，\n等对想输出的字符串产生影响。</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string str1 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;     <span class="comment">//后面的hello为world就会报错</span></span><br><span class="line">	cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">	string str2 = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">	&lt;head&gt;</span></span><br><span class="line"><span class="string">	&lt;title&gt;</span></span><br><span class="line"><span class="string">	海贼王</span></span><br><span class="line"><span class="string">	&lt;/title&gt;</span></span><br><span class="line"><span class="string">	&lt;/head&gt;</span></span><br><span class="line"><span class="string">	&lt;body&gt;</span></span><br><span class="line"><span class="string">	&lt;p&gt;</span></span><br><span class="line"><span class="string">	我是要成为海贼王的男人</span></span><br><span class="line"><span class="string">	&lt;/p&gt;</span></span><br><span class="line"><span class="string">	&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;)&quot;</span>;</span><br><span class="line">	cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">D:\hello\world\test.text</span><br><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">        海贼王</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">        我是要成为海贼王的男人</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="2-指针空值类型nullptr"><a href="#2-指针空值类型nullptr" class="headerlink" title="2. 指针空值类型nullptr"></a>2. 指针空值类型nullptr</h1><p>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在c++11标准下，相比NULL和0，使用nullptr初始化空指针可以令编写的程序更加健壮。</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;void func(char *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span>* ptr3 = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">NULL</span>);        <span class="comment">//在c中，NULL是(void*)0---&gt;对0强制转换；而在c++中，NULL就是0</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">nullptr</span>);    <span class="comment">//c++中，对指针初始化用nullptr，它可以隐式转换为各种类型指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">void func(int p)</span><br><span class="line">void func(int p)</span><br><span class="line">void func(char *p)</span><br></pre></td></tr></table></figure>

<h1 id="3-constexpr修饰常量表达式"><a href="#3-constexpr修饰常量表达式" class="headerlink" title="3. constexpr修饰常量表达式"></a>3. constexpr修饰常量表达式</h1><p>C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接4个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>注：const和constexpr是等价的，都可以在程序的编译阶段计算出结果。</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;          <span class="comment">//对结构体用constexpr是不行的，只能在初始化一个结构体时才可以用该常量</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">13</span>;</span><br><span class="line">	<span class="comment">//a = 12;         报错，不能对常量进行修改了</span></span><br><span class="line">	<span class="keyword">constexpr</span> T t&#123; <span class="number">13</span> &#125;;</span><br><span class="line">	<span class="comment">//t.a = 12;       报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-自动类型推导"><a href="#4-自动类型推导" class="headerlink" title="4. 自动类型推导"></a>4. 自动类型推导</h1><p>当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字。<br>当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字。</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">auto</span> b = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">auto</span> c = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;     <span class="comment">//a1是const int类型 ---&gt; const相当于是int</span></span><br><span class="line">	<span class="keyword">auto</span> a2 = a1;            <span class="comment">//因为a2既没有指针也没有引用，所以a2是int类型,不是const int类型(const被消除了)</span></span><br><span class="line">	<span class="comment">//保留赋值的const方法(加解引用或指针)</span></span><br><span class="line">	<span class="keyword">auto</span>&amp; a3 = a1;           <span class="comment">//a3是const int类型</span></span><br><span class="line">	<span class="keyword">auto</span>* pt1 = &amp;a1;         <span class="comment">//pt1是const int*类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不允许使用auto的四个场景：</p>
<p>1.不能作为函数参数使用，因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;                    <span class="comment">//错误的</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.不能用于类的非静态成员变量的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">auto</span> v1 = <span class="number">0</span>;                       <span class="comment">//错误</span></span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;                <span class="comment">//错误，类的静态非常量成员不允许在类的内部直接初始化</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;         <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.不能使用auto关键字定义数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;            <span class="comment">//定义数组</span></span><br><span class="line">	<span class="keyword">auto</span> t1 = array;                        <span class="comment">//正确，t1被推导为int*类型</span></span><br><span class="line">	<span class="keyword">auto</span> t2[] = array;                      <span class="comment">//错误，t2相当于是重新定义数组，是无法成功的</span></span><br><span class="line">	<span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;              <span class="comment">//错误，auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.无法使用auto推导出模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">	Test&lt;<span class="keyword">auto</span>&gt;t1 = t;                 <span class="comment">//错误，无法推导出模板类型</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-decltype类型推导"><a href="#5-decltype类型推导" class="headerlink" title="5. decltype类型推导"></a>5. decltype类型推导</h1><p>它的作用是在编译器编译的时候推导出一个表达式的类型，如decltype (表达式)；</p>
<p>测试程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure>

<p>decltype的应用多数出现在泛型编程中，下面编写一个类模板，在里边添加遍历容器的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//T::iterator m_it;                   // 这里不能确定迭代器类型</span></span><br><span class="line">    <span class="comment">//这样就能够推导出对应的T容器它的迭代器类型，基于这个类型定义出了它的迭代器变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;           <span class="comment">//通过T()来得到有个对象，调用它的begin()方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; st1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;list&lt;<span class="type">int</span>&gt;&gt; c;</span><br><span class="line">    c.<span class="built_in">func</span>(st1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历常量的迭代器容器(只读迭代器)</span></span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; st2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; c2;</span><br><span class="line">    c2.<span class="built_in">func</span>(st2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype返回值类型后置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;           <span class="comment">//模板函数1</span></span><br><span class="line"><span class="function">R <span class="title">add1</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;                      <span class="comment">//模板函数2</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;               <span class="comment">//auto可以通过后面的decltype来判断</span></span><br><span class="line">	<span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">3</span>;</span><br><span class="line">	<span class="type">double</span> u = <span class="number">3.14</span>;</span><br><span class="line">	<span class="comment">//模板函数1：可以编译，但不合理，外部调用的人，一般不会知道模板函数内部的代码内容，即不知道最后返回值是t+u</span></span><br><span class="line">	<span class="keyword">auto</span> a = <span class="built_in">add1</span>&lt;<span class="keyword">decltype</span>(t + u), <span class="type">int</span>, <span class="type">double</span>&gt;(t , u);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//模板函数2：</span></span><br><span class="line">	<span class="keyword">auto</span> b = <span class="built_in">add2</span>(t, u);</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-final和overrid关键字的使用"><a href="#6-final和overrid关键字的使用" class="headerlink" title="6. final和overrid关键字的使用"></a>6. final和overrid关键字的使用</h1><h2 id="6-1-final"><a href="#6-1-final" class="headerlink" title="6.1 final"></a>6.1 final</h2><p><code>final</code>关键字来限制某个类不能被继承，或者某个虚函数不能被重写。</p>
<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">修饰函数</button><button type="button" class="tab " data-href="test4-2">修饰类</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>如果用final来修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了。</p>
<p>解释：当test()是基类中的一个虚函数时，在子类中重写了这个方法，但是不希望孙子类中继续重写这个方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只能使用，而不能进行重写了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//父类虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>        <span class="comment">//用final修饰从父类继承下来的虚函数，表示之后的累继承Child类时，不能再重写Test</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span>             <span class="comment">// 语法错误, 不允许重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>如果使用final关键字来修饰类的话，表示该类是不允许被继承的，也就是说这个类不能有派生类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>                                 <span class="comment">//父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span>: <span class="keyword">public</span> Base            <span class="comment">//子类继承父类，同时加上了final关键字</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child           <span class="comment">//语法错误，不能在继承Child类了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<h2 id="6-2-override"><a href="#6-2-override" class="headerlink" title="6.2 override"></a>6.2 override</h2><p><code>override</code>关键字确保在派生类中声明的重写函数与基类的虚函数有相同的名字，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span>                <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span>              <span class="comment">//重写从父类继承下来的虚函数(当函数名不和父类的虚函数名一样时，会提示错误)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-委托构造函数和继承构造函数"><a href="#7-委托构造函数和继承构造函数" class="headerlink" title="7.委托构造函数和继承构造函数"></a>7.委托构造函数和继承构造函数</h1><h2 id="7-1-委托构造函数"><a href="#7-1-委托构造函数" class="headerlink" title="7.1 委托构造函数"></a>7.1 委托构造函数</h2><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类也可以通过以下方式来继承父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;一个参数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">test</span>(num)&#123;                     <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;两个参数：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">test</span>(num, sum) &#123;      <span class="comment">//调用同一个类中的另一个构造函数</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;一个参数：&quot; &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;二个参数：&quot; &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;三个参数：&quot;</span> &lt;&lt; tum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-继承构造函数"><a href="#7-2-继承构造函数" class="headerlink" title="7.2 继承构造函数"></a>7.2 继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num)&#123;&#125;</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num),<span class="built_in">b</span>(sum),<span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	child(int num) :base(num)&#123;&#125;</span></span><br><span class="line"><span class="comment">	child(int num, int sum) :base(num,sum) &#123;&#125;</span></span><br><span class="line"><span class="comment">	child(int num, int sum, int tum) :base(num, sum,tum) &#123;&#125;*/</span></span><br><span class="line">	<span class="keyword">using</span> base::base;        <span class="comment">//可以直接这样写(相当于上面3行代码)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">child <span class="title">x</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; x.a &lt;&lt; x.b &lt;&lt; x.c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num) :<span class="built_in">a</span>(num) &#123;&#125;</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum) &#123;&#125;</span><br><span class="line">	<span class="built_in">base</span>(<span class="type">int</span> num, <span class="type">int</span> sum, <span class="type">int</span> tum) :<span class="built_in">a</span>(num), <span class="built_in">b</span>(sum), <span class="built_in">c</span>(tum) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot;and&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> base::base;</span><br><span class="line">	<span class="keyword">using</span> base::func;               <span class="comment">//也可以通过这行来解决隐藏了父类同名函数的情况</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;                   <span class="comment">//写了有个与父类中的同名函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;lxx&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;             <span class="comment">//这里必须是带参的构造函数，因为父类中没有默认构造函数</span></span><br><span class="line">    c.base::<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);     <span class="comment">//通过加定义域的方式来得到与父类相同的同名函数</span></span><br><span class="line">	c.<span class="built_in">func</span>(<span class="number">39</span>,<span class="number">93</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，如果基类没有默认构造函数，子类也不能自动生成默认构造函数。这是因为子类对象的构造需要先构造基类的部分，如果基类没有默认构造函数，子类在构造时就无法调用基类的构造函数来初始化基类部分。</p>
<h1 id="8-可调用对象包装器和绑定器"><a href="#8-可调用对象包装器和绑定器" class="headerlink" title="8 .可调用对象包装器和绑定器"></a>8 .可调用对象包装器和绑定器</h1><h2 id="8-1-可调用对象"><a href="#8-1-可调用对象" class="headerlink" title="8.1 可调用对象"></a>8.1 可调用对象</h2><p>在c++中有四种可调用对象的定义</p>
<p>1.是一个函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print;      <span class="comment">// 定义函数指针，指向刚定义的函数</span></span><br></pre></td></tr></table></figure>

<p>2.是一个具有operator()成员函数的类对象(仿函数)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ()操作符重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">&quot;lxxlxxlxx&quot;</span>);          	<span class="comment">// 仿函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.是一个可被转换为函数指针的类对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里返回的必须是静态的成员函数，因为静态的是属于类，非静态的属于对象，在还没有定义对象之前，非静态的成员函数是不存在的，而静态成员函数是存在的。</span></span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 对象转换为函数指针, 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.是一个类成员函数指针或者类成员指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using func_ptr = void(*)(int, string);</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义类成员函数指针指向类成员函数</span></span><br><span class="line">    <span class="built_in">void</span> (Test::*func_ptr)(<span class="type">int</span>, string) = &amp;Test::print;</span><br><span class="line">    <span class="comment">// 类成员指针指向类成员变量</span></span><br><span class="line">    <span class="type">int</span> Test::*obj_ptr = &amp;Test::m_num;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 通过类成员函数指针调用类成员函数</span></span><br><span class="line">    (t.*func_ptr)(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过类成员指针初始化类成员变量</span></span><br><span class="line">    t.*obj_ptr = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;number is: &quot;</span> &lt;&lt; t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-可调用对象包装器"><a href="#8-2-可调用对象包装器" class="headerlink" title="8.2 可调用对象包装器"></a>8.2 可调用对象包装器</h2><p>可调用对象的包装器是<code>std::function</code>。它是一个类模板，可以容纳除了类(非静态)成员(函数)指针之外的所有可调用对象。使用<code>std::function</code>，必须包含头文件<code>functional</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个普通函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;          <span class="comment">//打包之后的名字是f1，包装的函数是add</span></span><br><span class="line">    <span class="comment">// 绑定一个类的静态函数</span></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = T1::sub;      <span class="comment">//包装的函数需要指明具体的类和函数名</span></span><br><span class="line">    <span class="comment">// 绑定一个仿函数</span></span><br><span class="line">    T2 t;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = t;</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num, string name)</span> </span>&#123;             <span class="comment">//普通函数</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> funcptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);          <span class="comment">//声明了一个函数指针别名，返回值是void，参数是int和string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;仿函数：&quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">world</span><span class="params">(<span class="type">int</span> a, string s)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数参数是一个包装器对象(可以给构造函数传入相同类型的可调用对象，然后通过可调用对象包装器进行打包，保存在了callback里面)</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>(<span class="type">int</span>, string)&gt;&amp; f) :<span class="built_in">callback</span>(f) &#123;&#125;</span><br><span class="line">	<span class="comment">//相当于回调操作，通过函数指针就可以进行回调(传入一个函数指针的地址给另一个函数，在另一个函数里面就可以调用该指针，执行对应的函数体)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">(<span class="type">int</span> id, string name)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">callback</span>(id, name);       <span class="comment">//调用通过构造函数得到的函数指针</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, string)&gt;callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">A <span class="title">aa</span><span class="params">(print)</span></span>;                 <span class="comment">//传入一种可调用对象</span></span><br><span class="line">	aa.<span class="built_in">notify</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function">A <span class="title">ab</span><span class="params">(Test::world)</span></span>;           <span class="comment">//传入一种可调用对象</span></span><br><span class="line">	ab.<span class="built_in">notify</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在编写程序的时候要用到多种类型的可调用对象，那么就可以通过可调用对象包装器对它们进行打包。因为只要给参数指定为可调用对象包装器类型，只要传进任意一种可调用对象类型(参数和返回值要求是相同类型)，它都会进行隐式的类型转换。通过可调用对象的包装器把这些不同类型的可调用对象封装成一种类型，这样程序就显得更加简洁和灵活。</p>
<h2 id="8-3-绑定器"><a href="#8-3-绑定器" class="headerlink" title="8.3 绑定器"></a>8.3 绑定器</h2><p><code>std::bind</code>用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用<code>std::function</code>进行保存，并延迟调用到任何我们需要的时候。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用绑定器绑定可调用对象和参数，并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();            <span class="comment">//绑定了普通函数output，指定了2个参数，()表示调用了该仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">3</span>);     <span class="comment">//第一个参数指定了占位符，是后面()中的3</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">9</span>);     <span class="comment">//第二个参数指定了占位符，是后面()中的9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// error, 调用时没有第二个参数</span></span><br><span class="line">    <span class="comment">// bind(output, 2, placeholders::_2)(10);   //占位符_2会去找()里面的第二个实参，会出问题，应该是_1</span></span><br><span class="line">    <span class="comment">// 调用时第一个参数10被吞掉了，没有被使用</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);   <span class="comment">//这种情况是参数1会用2，而不是会用10</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可调用对象包装器<code>std::function</code>是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器<code>std::bind</code>的配合之后，就可以完美的解决这个问题了。</p>
<p>在下面程序中，使用绑定器函数bind()绑定了某一个可调用对象，最终得到一个仿函数f或f1，其实这个仿函数对应的还是绑定的那个可调用对象(参数1)，绑定的时候可以给它指定固定的参数(参数2和参数3)，固定的参数可以是一个变量也可以是一个常量。如果绑定的时候不给它指定一个固定的数值，可以指定占位符，当指定占位符后，它就需要从仿函数调用时候的参数列表里面去读对应的数值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定器和包装器结合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&amp; f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">f</span>(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\t x+y=&quot;</span> &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//当绑定后，就得到一个仿函数f了 ---&gt; 也是可调用对象的一种</span></span><br><span class="line">        <span class="keyword">auto</span> f = <span class="built_in">bind</span>(output_add, i+<span class="number">100</span>, i+<span class="number">200</span>);     <span class="comment">//参2和参3已经指定了函数output_add的具体参数</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f);                             <span class="comment">//这里的i和i参数不会影响output_add的参数了</span></span><br><span class="line">        <span class="keyword">auto</span> f1 = <span class="built_in">bind</span>(output_add, placeholders::_1, placeholders::_2);   <span class="comment">//参2和参3已经指定的是占位符</span></span><br><span class="line">        <span class="built_in">testFunc</span>(i,i,f1);                            <span class="comment">//这里的i和i参数会影响output_add的参数了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x=100    y=200   x+y=300</span><br><span class="line">x=0      y=0     x+y=0</span><br><span class="line">x=102    y=202   x+y=304</span><br><span class="line">x=2      y=2     x+y=4</span><br><span class="line">x=104    y=204   x+y=308</span><br><span class="line">x=4      y=4     x+y=8</span><br><span class="line">x=106    y=206   x+y=312</span><br><span class="line">x=6      y=6     x+y=12</span><br><span class="line">x=108    y=208   x+y=316</span><br><span class="line">x=8      y=8     x+y=16</span><br></pre></td></tr></table></figure>

<p>下面程序是对类的成员函数以及类的成员变进行绑定和封装。因为可调用包装器<code>std::function</code>不能对类成员函数和变量进行包装，但可以对仿函数进行包装，所以可以先通过绑定器bind来对类成员函数和变量进行绑定，然后可以得到对应的一个仿函数。这样包装器就可以间接的对其进行包装了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员函数绑定</span></span><br><span class="line">	Test t;</span><br><span class="line">	<span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);   <span class="comment">//&amp;t是output所属对象的地址，得到一个仿函数f2</span></span><br><span class="line">	function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f22 = <span class="built_in">bind</span>(&amp;Test::output, &amp;t, <span class="number">520</span>, placeholders::_1);    <span class="comment">//用包装器对可调用对象f2进行包装(间接包装)</span></span><br><span class="line">	<span class="built_in">f2</span>(<span class="number">1314</span>);       <span class="comment">//通过绑定，将一个二元函数变成一元函数</span></span><br><span class="line">	<span class="comment">//成员变量绑定(因为成员变量没有参数，所以bind就没有参3和参4)</span></span><br><span class="line">	<span class="keyword">auto</span> f3 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t);  <span class="comment">//f3是一个仿函数，而下面的f33是一个将仿函数进行包装的包装器类型</span></span><br><span class="line">	function&lt;<span class="type">int</span>&amp; (<span class="type">void</span>)&gt;f33 = <span class="built_in">bind</span>(&amp;Test::m_number, &amp;t); <span class="comment">//如果要f33是可读可写，就使用取地址符&amp;</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;     <span class="comment">//大于f3的值，它代表的是绑定的变量</span></span><br><span class="line">	<span class="built_in">f3</span>() = <span class="number">666</span>;                 <span class="comment">//修改成员变量的值</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">f3</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中，f3和f33的类型是不一样的，绑定器bind绑定完后得到的是一个仿函数，而f33它是把仿函数进行了包装，得到一个包装器类型，所以这两个不是等价的。需要了解的是，f33这一行是做了隐式的类型转换，f3这一行是做了自动的类型推导。</p>
<h1 id="9-lambda表达式"><a href="#9-lambda表达式" class="headerlink" title="9. lambda表达式"></a>9. lambda表达式</h1><p><code>lambda</code>表达式的捕获列表可以捕获一定范围内的变量，具体如下：</p>
<ul>
<li>[]                     不捕抓任何变量</li>
<li>[&amp;]                  捕获外部作用域所有的变量，并作为引用在函数体内使用(按引用捕获)</li>
<li>[&#x3D;]                   捕获外部作用域所有的变量，并作为副本在函数体内使用(按值捕获) —&gt;拷贝的副本在匿名函数体内部是只读的</li>
<li>[&#x3D;,%foo]         按值捕获外部作用域中的所有变量，并按引用捕获外部变量foo</li>
<li>[bar]                按值捕获bar变量，同时不捕获其他变量</li>
<li>[&amp;bar]             按引用捕获bar变量，同时不捕获其他变量</li>
<li>[this]               捕获当前类中的this指针</li>
</ul>
<p><code>lambda</code>表达式的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">9</span>;</span><br><span class="line">	[=, &amp;x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">		<span class="type">int</span> c = a;      <span class="comment">//拷贝得来的</span></span><br><span class="line">		<span class="type">int</span> d = x;      <span class="comment">//引用得来的</span></span><br><span class="line">		b++;            <span class="comment">//如果没有加上mutable，则只能读外部变量</span></span><br><span class="line">		cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">		&#125;();       <span class="comment">//不加()只是被定义，而没有被调用(如果上面()里面有参数，则这里也要相应的加上参数)</span></span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;    <span class="comment">//lambda内部修改了值但不影响外面，因为是拷贝进去的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于通过值拷贝的方式捕获的外部变量是只读的原因：</p>
<ol>
<li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</li>
<li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li>
</ol>
<p>所以<code>mutable</code>选项的作用就在于取消operator()的const属性。</p>
<p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">using</span> ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//1.当[]里面为空时，该匿名函数可以看成是一个函数指针</span></span><br><span class="line">    ptr p1 = [](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">p1</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">/*2.当[]里面有捕获外部变量时，该匿名函数不能看成是一个函数指针，它是一个仿函数</span></span><br><span class="line"><span class="comment">    ptr p2 = [=](int x)&#123;                //这里是有问题的，一个函数指针指的是仿函数</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    p2(9) */</span></span><br><span class="line">    <span class="comment">//3.用包装器包装lambda表达式(直接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff = [=](<span class="type">int</span> x)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fff</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//4.用绑定器绑定lambda表达式(通过绑定器间接包装)</span></span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; fff1 = <span class="built_in">bind</span>([=](<span class="type">int</span> x)&#123;     <span class="comment">//返回的是一个仿函数，包装到包装器对象里面</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;,placeholders::_1);</span><br><span class="line">    <span class="built_in">fff1</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-右值引用"><a href="#10-右值引用" class="headerlink" title="10. 右值引用"></a>10. 右值引用</h1><p>在C++11中增加了一个新的类型，即右值引用，标记为 &amp;&amp;。</p>
<ul>
<li><p><code>左值</code>是指存储在内存中、有明确存储地址(可取地址)的数据</p>
</li>
<li><p><code>右值</code>是指可以提供数据值的数据(不可取地址)</p>
</li>
</ul>
<p>区别方法：可以对表达式取地址(&amp;)就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//左值</span></span><br><span class="line">	<span class="type">int</span> num = <span class="number">9</span>;</span><br><span class="line">	<span class="comment">//左值引用</span></span><br><span class="line">	<span class="type">int</span>&amp; a = num;           <span class="comment">//a不占用额外的内存地址，它是num的别名</span></span><br><span class="line">	<span class="comment">//右值</span></span><br><span class="line">	<span class="comment">//右值引用</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; b = <span class="number">8</span>;            <span class="comment">//必须是使用右值来初始化，左值不行</span></span><br><span class="line">	<span class="comment">//常量右值引用</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp;&amp; d = <span class="number">6</span>;</span><br><span class="line">	<span class="comment">//常量左值引用可以通过同类型的左值、同类型的右值引用、同类型的常量右值引用、同类型的常量右值引用都可以初始化</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; c = num;     <span class="comment">//c只能是num的别名，因为它是一个常量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; f = b;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; g = d;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; h = d;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//const int&amp;&amp; e = b;       //错误，常量的右值引用不能通过右值引用来初始化</span></span><br><span class="line">	<span class="comment">//int&amp;&amp; f = b;             //错误。普通的右值引用也不能通过右值引用来初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面程序可以得出结论：右值引用只能通过右值来初始化；常量的左值引用是一个万能的引用类型，可以通过同类型的各种引用来初始化左值引用。</p>
<p>在下面程序中，是通过右值引用来模拟浅拷贝。移动构造(右值引用)是把临时对象的指针成员移动走了，临时对象析构的时候析构了一个空指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;m_num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造(作用是防止浅拷贝)</span></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数 -&gt; 复用其它对象中的资源(堆内存) ---&gt; 移动构造就是要使用浅拷贝</span></span><br><span class="line">    <span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num) &#123;                 <span class="comment">//让新对象的m_num指向了a里面的m_num(浅拷贝)</span></span><br><span class="line">        a.m_num = <span class="literal">nullptr</span>;         <span class="comment">//令a的m_num指向空，这样a析构的时候，释放的就是空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move construct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test class .....&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> m_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结论：如果给某一个类指定了移动构造函数，在赋值的时候就有两种方式了，即直接赋值和通过右值引用的方式赋值(不管是哪种方式，要求右边的对象是临时对象)</span></span><br><span class="line">    Test t = <span class="built_in">getObj</span>();</span><br><span class="line">    Test&amp;&amp; t1 = <span class="built_in">getObj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_num的地址： &quot;</span> &lt;&lt; &amp;t1.m_num &lt;&lt; endl;     <span class="comment">//地址不变</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不带参数的构造函数和移动构造都可以实现浅拷贝，区别在于：不带参的构造函数使用浅拷贝，指针资源不会转移，是两个对象的指针指向同一块内存，析构就会出问题。而使用移动构造是实实在在的对资源进行了转移，转移完了之后，原来这个对象就不拥有这块资源了。</p>
<p>为什么在添加了移动构造函数之后，main函数里面的赋值操作的时候调用的是移动构造函数，而不是拷贝构造函数：因为在添加了移动构造函数后，在进行赋值操作的时候，编译器就会判断右边的这个对象是否是临时变量，如果是临时变量，编译器就会调用移动构造函数；如果不是临时变量，调用的就是拷贝构造函数。</p>
<p>右值可以分为两种：一个是将亡值，另一个是纯右值。</p>
<ul>
<li>纯右值：非引用返回的临时变量，运算表达式产生的临时变量、原始字面量和lambda表达式等。</li>
<li>将亡值：与右值引用相关的表达式，如T&amp;&amp;类型函数的返回值、std::move的返回值等。</li>
</ul>
<h2 id="10-1-的特性"><a href="#10-1-的特性" class="headerlink" title="10.1 &amp;&amp;的特性"></a>10.1 &amp;&amp;的特性</h2><p>在C++中，并不是所有情况下<code>&amp;&amp;</code>都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为<code>T&amp;&amp;</code>，如果是自动类型推导需要指定为<code>auto &amp;&amp;</code>，在这两种场景下<code>&amp;&amp;</code>被称作未定的引用类型。另外还有一点需要额外注意<code>const T&amp;&amp;</code>表示一个右值引用，不是未定引用类型(是不需要推导的)。</p>
<p>在C++11中引用折叠的规则如下：</p>
<ul>
<li><p>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型</p>
</li>
<li><p>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子1</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">//这种是需要根据传进来的参数进行推导的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;        <span class="comment">//这种是不需要根据传进来的参数进行推导，就一定为右值引用类型</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);                           <span class="comment">//传入10(右值)，推导出为右值引用类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);                            <span class="comment">//传入x(左值)，推导出为左值引用类型</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">10</span>);                          <span class="comment">// 不需要推导，就为右值引用类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;                          <span class="comment">//x和y都为左值</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v1 = x;                                  <span class="comment">//推导出v1为左值引用类型</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;                                <span class="comment">//推导出v2为右值引用类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(x)&amp;&amp; v3 = y;  <span class="comment">//可以得出decltype(x)为int，那么就为int&amp;&amp;，是int型的右值引用(不需要推导)，给它赋了一个左值，该语法是错误的</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot;, v2: &quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子3</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;                         <span class="comment">//a1为右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;                       <span class="comment">//因为a1本身是一个左值，得到bb是一个int型的左值引用(int&amp; bb)</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;                       <span class="comment">//bb1是一个右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;                           <span class="comment">//a2是左值</span></span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;                         <span class="comment">//a3是左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;                       <span class="comment">//cc是一个左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;                      <span class="comment">//cc1是左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;                  <span class="comment">//s1是常量左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;                 <span class="comment">//s2是常量的右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;                       <span class="comment">//dd是常量的左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;                       <span class="comment">//ee是常量的左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;                   <span class="comment">//常量的右值引用</span></span><br></pre></td></tr></table></figure>

<p>还有一种情况需要注意，例如在下面程序中，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;i)</span>                       <span class="comment">//参数在左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> &amp;&amp;i)</span>                      <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> &amp;&amp;k)</span>                        <span class="comment">//参数是右值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//传进来右值后，k为右值引用，但如果对它进行传递，那么它就是左值引用(k为它的名字)</span></span><br><span class="line">    <span class="built_in">printValue</span>(k);                           <span class="comment">//用右值引用进行传递，会被看成是左值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">520</span>;                     <span class="comment">//i是左值</span></span><br><span class="line">    <span class="built_in">printValue</span>(i);                   <span class="comment">//调用的是左值引用的函数</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="number">1314</span>);                <span class="comment">//调用的是右值引用的函数</span></span><br><span class="line">    forward(<span class="number">250</span>);                    <span class="comment">//传入参数右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">l-value: 520</span></span><br><span class="line"><span class="section">r-value: 1314</span></span><br><span class="line"><span class="section">l-value: 250</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</li>
<li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li>
<li>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型(上面有例子)。</li>
<li>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</li>
</ul>
<h1 id="11-转移和完美转发"><a href="#11-转移和完美转发" class="headerlink" title="11. 转移和完美转发"></a>11. 转移和完美转发</h1><h2 id="11-1-move方法"><a href="#11-1-move方法" class="headerlink" title="11.1 move方法"></a>11.1 move方法</h2><p>std::move可以给右值引用进行初始化，把一些左值转换为右值；还有就是可以进行资源的转移，如果某一个对象后面不再被使用了，并且需要拷贝这个对象里面的数据到另一个对象中，这种情况下就可以进行资源转移，减少拷贝的次数，提高析构的允许效果。</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//move作用1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;                   <span class="comment">//左值</span></span><br><span class="line">    Test &amp;&amp; v1 = t;          <span class="comment">// 通过左值对右值引用进行初始化是错误的，会报错</span></span><br><span class="line">    Test &amp;&amp; v2 = <span class="built_in">move</span>(t);    <span class="comment">// 通过move，将左值转换为右值，再对右值引用进行初始化，是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//move作用2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">39</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">move</span>(a);           <span class="comment">//a失效了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-2-forward方法"><a href="#11-2-forward方法" class="headerlink" title="11.2 forward方法"></a>11.2 forward方法</h2><p>std::forward()函数实现的功能称之为完美转发。因为当一个<code>右值引用</code>作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，就可以使用forward()方法。</p>
<blockquote>
<p>std::forward<T>(t);</T></p>
<p>当T为左值引用类型时，t将被转换为T类型的左值<br>当T不是左值引用类型时，t将被转换为T类型的右值</p>
</blockquote>
<p>测试程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>对于<span class="built_in">testForward</span>(<span class="number">520</span>);            <span class="comment">//传入的是右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>对于<span class="built_in">testForward</span>(num);            <span class="comment">//传入的是左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>          <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));   <span class="comment">//因为int不是左值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>对于<span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));   <span class="comment">//因为int&amp;是左值引用类型，参数就被转换为左值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为左值引用，实参就为左值 ---&gt;打印左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));     <span class="comment">//因为int是右值引用类型，参数就被转换为右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span>                <span class="comment">//右值引用，如果用它来传递的话，就会变为左值引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);                <span class="comment">//实参为左值引用 ---&gt;打印左</span></span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));          <span class="comment">//通过move将左值引用转为了右值，实参为右值 ---&gt;打印右</span></span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));    <span class="comment">//通过forward进行了类型转换，T为右值引用，实参就为右值 ---&gt;打印右</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="12-智能指针"><a href="#12-智能指针" class="headerlink" title="12. 智能指针"></a>12. 智能指针</h1><p>智能指针能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。它的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。它的头文件是<code>#include &lt;memory&gt;</code>。</p>
<p>C++11中提供了如下三种智能指针：</p>
<ol>
<li>std::shared_ptr：共享的智能指针</li>
<li>std::unique_ptr：独占的智能指针</li>
<li>std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li>
</ol>
<h2 id="12-1-共享智能指针"><a href="#12-1-共享智能指针" class="headerlink" title="12.1 共享智能指针"></a>12.1 共享智能指针</h2><p>共享智能指针shared_ptr 是一个模板类，它可以让多个智能指针同时管理同一块有效的内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;       <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;      <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;                    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//结果为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;           <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;             <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;                     <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为2</span></span><br><span class="line">    </span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                   <span class="comment">//调用拷贝赋值函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;         <span class="comment">//调用移动构造函数(ptr1失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);    <span class="comment">//调用移动构造函数(ptr2失效了)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;            <span class="comment">//结果为3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过reset方法，它既可以初始化，也可以重置：对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存(通过make_shared来初始化智能指针)</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);        <span class="comment">//引用计数为1了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;                         <span class="comment">//引用计数为2了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;                         <span class="comment">//引用计数为3了</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;                         <span class="comment">//引用计数为4了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为4</span></span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();       <span class="comment">//重置指针ptr4，原来指向的内存引用计数-1，现在ptr4没有指向任何内存，所以引用计数为0</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//结果为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化和使用方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">		m_num = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//通过构造函数初始化</span></span><br><span class="line">	<span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过移动构造和拷贝函数初始化</span></span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr1 use_count:&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//移动资源了，ptr1失效了，引用计数为0</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt;ptr3 = ptr2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr2 use_count:&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr3 use_count:&quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;           <span class="comment">//引用计数为2</span></span><br><span class="line">	<span class="comment">//通过std::make_shared初始化</span></span><br><span class="line">	shared_ptr&lt;<span class="type">int</span>&gt;ptr4 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">8</span>);</span><br><span class="line">	shared_ptr&lt;Test&gt;ptr5 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">8</span>);                  <span class="comment">//通过int型构造类对象</span></span><br><span class="line">	shared_ptr&lt;Test&gt;ptr6 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;hello, world&quot;</span>);     <span class="comment">//通过字符串构造类对象</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过reset初始化</span></span><br><span class="line">	ptr6.<span class="built_in">reset</span>();                 <span class="comment">//指针重置，现在ptr6引用计数为0，字符串构成的类对象调用析构函数(没有指针指向它)，</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr6 use_count:&quot;</span> &lt;&lt; ptr6.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//引用计数为0</span></span><br><span class="line">	ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;hello&quot;</span>));                                <span class="comment">//原来ptr5指向的对象会调用析构函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr5 use_count:&quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;        <span class="comment">//初始化指针了，引用计数为1，指向完main，</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过智能指针对象取出原始地址，基于原始地址调用函数</span></span><br><span class="line">	Test* t = ptr5.<span class="built_in">get</span>();         <span class="comment">//这里是通过智能指针对象调用它所对应的类，该类是shared_ptr类里面提供的标准api，所以是加.</span></span><br><span class="line">	t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">	t-&gt;<span class="built_in">print</span>();</span><br><span class="line">	<span class="comment">//通过智能指针对象直接操作</span></span><br><span class="line">	ptr5-&gt;<span class="built_in">setValue</span>(<span class="number">999</span>);      <span class="comment">//这时通过智能指针对象去调用它管理的内存对应的类里面的api函数，就按照指针的方式使用对象，所以加-&gt;</span></span><br><span class="line">	ptr5-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定删除器：当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。当然我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为<code>删除器</code>，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>() &#123;                                  <span class="comment">//默认构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> x) : <span class="built_in">m_num</span>(x) &#123;                  <span class="comment">//带参数int的构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(string str) &#123;                        <span class="comment">//带参数string的构造函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>() &#123;                                 <span class="comment">//析构函数</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destruct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;                    <span class="comment">//赋值m_num</span></span><br><span class="line">		m_num = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;                            <span class="comment">//打印m_num的值</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;m_num:&quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">pp</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">39</span>),[](Test* t)&#123;   <span class="comment">//在这里，不手动添加删除器也可以，系统会调用默认的删除器</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//释放内存的操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cout&lt;&lt;<span class="string">&quot;-----------------------&quot;</span>&lt;&lt;endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> t;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt; p1(new Test[5]);     //这样会报错，因为只构造5个对象了，但没有析构对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test[]&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;     <span class="comment">//这样不会报错</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], [](Test* t) &#123;      <span class="comment">//正确</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">delete</span>[] t;</span></span></span><br><span class="line"><span class="params"><span class="function">	&#125;)</span></span>;</span><br><span class="line">    <span class="comment">//调用c++提供的默认删除器函数</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>], default_delete&lt;Test[]&gt;())</span></span>;   <span class="comment">//这样也正确，默认删除器要指出删除的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：shared_ptr在通过指针对象去管理一块数组内存的时候，必须手动添加删除器，如果不是数组，智能指针默认提供的删除器就会删除这块内存。</p>
<h2 id="12-2-独占智能指针"><a href="#12-2-独占智能指针" class="headerlink" title="12.2 独占智能指针"></a>12.2 独占智能指针</h2><p><code>std::unique_ptr</code>是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个<code>unique_ptr</code>赋值给另一个<code>unique_ptr</code>。</p>
<p>初始化和使用的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">9</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过移动构造函数初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);       <span class="comment">//ptr1失效了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过reset初始化</span></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">8</span>));                  <span class="comment">//ptr2原来指向的内存被析构了，重新指向了新的内存块</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用 ---&gt; 和共享智能指针一样</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Test&gt; <span class="title">ptr3</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">1</span>))</span></span>;</span><br><span class="line">    Test* pt = ptr3.<span class="built_in">get</span>();                <span class="comment">//获取原始指针</span></span><br><span class="line">    pt-&gt;<span class="built_in">setValue</span>(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    ptr3-&gt;<span class="built_in">setValue</span>(<span class="number">9</span>);                    <span class="comment">//直接使用指针调用指向的内存块里面的api</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除器：<code>unique_ptr</code>指定删除器和<code>shared_ptr</code>指定删除器是有区别的，<code>unique_ptr</code>指定删除器的时候需要确定删除器的类型，所以它不能像<code>shared_ptr</code>那样直接指定删除器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;	  <span class="comment">// 正确的，不需要指定删除器类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;	  <span class="comment">// 错误的，没有指定删除器的类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//情况1：删除器的[]里面为空，则对应的lambda是函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);             <span class="comment">//定义一个函数指针类型</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;   <span class="comment">//需要在前面指定删除器类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//情况2：删除器的[]里面添加了=，则对应的lambda是仿函数类型，就需要通过可调用对象包装器对其类型进行包装，</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [=](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;        <span class="comment">//这种写法会报错</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);    <span class="comment">//正确的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//独占的智能指针可以管理数组类型的地址，能够自动释放</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//这是正确的</span></span><br><span class="line">    <span class="comment">//在c++11中shared_ptr不支持下面的写法，c++11之后才支持的</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;       <span class="comment">//现在这是正确的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回忆：对于lambda表达式，[]里面为空，则对应的lambda表达式为函数指针类型；否则为仿函数类型。</p>
<h2 id="12-3-弱引用智能指针"><a href="#12-3-弱引用智能指针" class="headerlink" title="12.3 弱引用智能指针"></a>12.3 弱引用智能指针</h2><p><code>std::weak_ptr</code>可以看做是<code>shared_ptr</code>的助手，它不管理<code>shared_ptr</code>内部的指针。<code>weak_ptr</code>没有重载操作符*和-&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在。</p>
<p>初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;                <span class="comment">//wp1没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;           <span class="comment">//wp2也没有被实例化</span></span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;            <span class="comment">//wp3是被实例化了</span></span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;                        <span class="comment">//直接通过赋值的方式来初始化(实例化)</span></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;                       <span class="comment">//实例化了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他常用方法：</p>
<ul>
<li>通过调用<code>weak_ptr</code>类提供的<code>use_count()</code>方法可以获得当前所观测资源的引用计数。</li>
<li>通过调用<code>weak_ptr</code>类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，如果观察的资源的引用计数为0了，返回的就是true，否则返回false。</li>
<li>通过调用<code>weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的<code>shared_ptr</code>对象。</li>
<li>通过调用<code>weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源。</li>
</ul>
<p>演示程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);            <span class="comment">//给sp1管理了一块int类型的内存</span></span><br><span class="line">    wp = sp1;                                    <span class="comment">//初始化了wp，它可以观察sp1管理的内存了</span></span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();                             <span class="comment">//通过wp.lock()返回的共享指针的实例，初始化了sp2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;      <span class="comment">//现在就有2个共享指针指向那块内存了，打印为2</span></span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();                                 <span class="comment">//sp1不管理该内存了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;       <span class="comment">//现在只有sp2管理该内存块，打印1</span></span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();   <span class="comment">//因为wp检测了那块内存还没有被释放，所以还可以返回对应的共享指针对象，实例化sp1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;     <span class="comment">//现在是sp1和sp2两个共享指针管理该内存，打印2</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;      <span class="comment">//打印520</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-4-智能指针的注意事项"><a href="#12-4-智能指针的注意事项" class="headerlink" title="12.4 智能指针的注意事项"></a>12.4 智能指针的注意事项</h2><p><code>shared_ptr</code>使用的注意事项：</p>
<p>1.<code>不能使用一个原始地址初始化多个共享智能指针</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class Test is disstruct...&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//这种情况会报错，因为析构了两次</span></span><br><span class="line">    Test* t = <span class="keyword">new</span> Test;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(t);</span><br><span class="line">    <span class="comment">//shared_ptr&lt;Test&gt;ptr2(t);      //这种情况会报错，因为析构了两次</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1;    <span class="comment">//这种就正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<code>函数不能返回管理了this的共享智能指针对象</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);      <span class="comment">//返回一个共享指针对象，管理的是this,即外面new出来的一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();   <span class="comment">//因为里面的this指的是ptr1初始化时的new Test，所以本质上是犯了注意事项1的问题，会报错</span></span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;              <span class="comment">//打印1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中使用同一个指针this构造了两个智能指针对象ptr1和ptr2，这二者之间是没有任何关系的，因为ptr2并不是通过ptr1初始化得到的实例对象。在离开作用域之后this将被构造的两个智能指针各自析构，导致重复析构的错误。</p>
<p>这个问题可以通过一个模板类叫做<code>std::enable_shared_from_this&lt;T&gt;</code>来解决，这个类中有一个方法叫做<code>shared_from_this()</code>，通过这个方法可以返回一个共享智能指针，在该函数的底层就是使用<code>weak_ptr</code>来监测this对象，并通过调用<code>weak_ptr</code>的<code>lock()</code>方法返回一个<code>shared_ptr</code>对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : enable_shared_from_this&lt;Test&gt;&#123;        <span class="comment">//把当前的类型指定在模板类型里面</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();       <span class="comment">//底层是通过弱引用类型对象返回一个share_ptr对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//weak_ptr初始化的地方：在ptr1初始化时，new出了一块内存Test让ptr1来管理，而Test类继承了enable_shared_from_this，那么其里面的weak_ptr被实例化了，指向了ptr1</span></span><br><span class="line">    shared_ptr&lt;Test&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> Test);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt;ptr2 = ptr1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<code>共享智能指针不能循环引用</code></p>
<h1 id="13-POD类型"><a href="#13-POD类型" class="headerlink" title="13. POD类型"></a>13. POD类型</h1><p>POD指的就是普通的旧数据 。它通常用于说明一个类型的属性，尤其是用户自定义类型的属性。</p>
<p>在C++11中将 POD划分为两个基本概念的合集，即∶平凡的(trivial) 和标准布局的(standard layout)。</p>
<p>## 13 .1 平凡类型</p>
<p>一个平凡的类或者结构体应该符合以下几点要求：</p>
<ol>
<li>拥有平凡的默认构造函数(trivial constructor)和析构函数(trivial destructor)。</li>
<li>拥有平凡的拷贝构造函数(trivial copy constructor)和移动构造函数(trivial move constructor)。</li>
<li>拥有平凡的拷贝赋值运算符(trivial assignment operator)和移动赋值运算符(trivial move operator)。</li>
<li>不包含虚函数以及虚基类。</li>
</ol>
<h2 id="13-2-非受限联合体"><a href="#13-2-非受限联合体" class="headerlink" title="13.2 非受限联合体"></a>13.2 非受限联合体</h2><p>在C++11之前我们使用的联合体是有局限性的，主要有以下三点：</p>
<ul>
<li>不允许联合体拥有非POD类型的成员</li>
<li>不允许联合体拥有静态成员</li>
<li>不允许联合体拥有引用类型的成员</li>
</ul>
<p>在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，规定任何<code>非引用类型</code>都可以成为联合体的数据成员，这样的联合体称之为非受限联合体(Unrestricted Union)。</p>
<h2 id="13-3-非受限联合体中静态成员的使用"><a href="#13-3-非受限联合体中静态成员的使用" class="headerlink" title="13.3 非受限联合体中静态成员的使用"></a>13.3 非受限联合体中静态成员的使用</h2><p>补充知识：</p>
<ul>
<li>如果在联合体里面出现了静态成员变量，那么它的初始化要放到联合体的外面(类和结构体也一样的)</li>
<li>静态成员是属于类的，而不是属于对象(类和结构体也一样的)</li>
<li>在联合体里面的静态成员和非静态成员使用的不是同一块内存(类和结构体也一样的)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//不允许出现静态成员(成员变量、成员函数)</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t1.num1 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num  value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;        <span class="comment">//结果为3 ---&gt;外部初始化的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num1 value: &quot;</span> &lt;&lt; t1.num1 &lt;&lt; endl;              <span class="comment">//结果为100</span></span><br><span class="line"></span><br><span class="line">    Test t2;</span><br><span class="line">    t2.num = <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t2.num &lt;&lt; endl;   <span class="comment">//结果为50</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static num value: &quot;</span> &lt;&lt; t1.num &lt;&lt; endl;   <span class="comment">//结果为50，静态成员被对象t2修改，t1和t2的静态成员是同一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-4-非受限联合体中非POD类型成员的使用"><a href="#13-4-非受限联合体中非POD类型成员的使用" class="headerlink" title="13.4 非受限联合体中非POD类型成员的使用"></a>13.4 非受限联合体中非POD类型成员的使用</h2><p>在c++11里面规定，如果在非受限联合体中使用了非POD里面的成员，编译器就会自动的删除这个联合体的构造函数和析构函数</p>
<p>placement new：一般情况下，使用new申请空间时，是从系统的堆(heap)中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做<code>placement new</code>即定位放置 new。</p>
<p>使用定位放置new申请内存空间：<code>ClassName* ptr = new (定位的内存地址)ClassName;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;         <span class="comment">//将该类定义为非TOB类型</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>() &#123;&#125;        <span class="comment">//不加这个就是TOB类型的类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="built_in">Student</span>() &#123;      <span class="comment">//手动创建一个构造函数</span></span><br><span class="line">        <span class="keyword">new</span> (&amp;name)string;         <span class="comment">//选择一块占用空间最大的变量来定义联合体的内存空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Teacher t;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s;</span><br><span class="line">    s.name = <span class="string">&quot;lxx&quot;</span>;</span><br><span class="line">    s.t.<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);         <span class="comment">//占用的都是同一块空间</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.name=&quot;</span> &lt;&lt; s.name &lt;&lt; endl;      <span class="comment">//打印的是hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>静态库与动态库</title>
    <url>/2024/07/06/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h1><blockquote>
<p>在linux中静态库由程序ar生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名如下：</p>
</blockquote>
<ul>
<li><p>在Linux中静态库以lib作为前缀，以.a作为后缀，中间是库的名字(自己指定即可)，即libxxx.a</p>
</li>
<li><p>在Windows中静态库一般以lib作为前缀，以lib作为后缀，中间是库的名字(自己指定即可)，即libxxx.lib</p>
</li>
</ul>
<h2 id="1-1生成静态库链接"><a href="#1-1生成静态库链接" class="headerlink" title="1.1生成静态库链接"></a>1.1生成静态库链接</h2><blockquote>
<p>生成静态库，需要先对源文件进行汇编操作(使用参数-c)得到二进制格式的目标文件(.o格式)。然后再通过ar工具将目标文件打包就可以得到静态库文件了(libxxx.a)。</p>
</blockquote>
<p>使用ar工具创建静态库的时候需要三个参数：</p>
<ul>
<li><p>参数c：创建一个库，不管库是否存在，都将创建。</p>
</li>
<li><p>参数s：创建目标文件索引，这在创建较大的库时能加快时间。</p>
</li>
<li><p>参数r：在库中插入模块(替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>对源文件进行汇编成二进制格式的目标文件(.o格式)：gcc -c add.c sub.c div.c mult.c</p>
</li>
<li><p>生成静态库(发送给对方时，需要发送静态库和头文件(有就发))：ar rcs libcalc.a *.o</p>
</li>
</ol>
<h2 id="1-2静态库的使用"><a href="#1-2静态库的使用" class="headerlink" title="1.2静态库的使用"></a>1.2静态库的使用</h2><p>参数-l：在程序编译的时候，指定使用的库(掐头去尾)</p>
<p>参数-L：指定编译的时候，搜索的库的路径———–&gt;空格空不空都可以</p>
<p>例子：假设文件夹里面有head.h、libcalc.a、main.c</p>
<p><code>gcc main.c -o calc -L ./ -lcalc</code></p>
<h1 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2.动态库"></a>2.动态库</h1><blockquote>
<p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为共享库。</p>
</blockquote>
<ul>
<li><p>在Linux中动态库以lib作为前缀，以.so作为后缀，中间是库的名字(自己指定即可)，即libxxx.so</p>
</li>
<li><p>在Windows中动态库一般以lib作为前缀，以dll作为后缀，中间是库的名字(自己指定)，即libxxx.dll</p>
</li>
</ul>
<h2 id="2-1生成动态链接库"><a href="#2-1生成动态链接库" class="headerlink" title="2.1生成动态链接库"></a>2.1生成动态链接库</h2><p>生成动态链接库是直接使用gcc命令并且需要添加-fPIC(-fpic)以及-shread参数</p>
<ul>
<li><p>-fPIC或-fpic参数：是使得gcc生成的代码是与位置无关的，也就是使用相对位置。</p>
</li>
<li><p>-shared参数：是告诉编译器生成一个动态链接库</p>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>gcc -c -fpic add.c sub.c mult.c div.c   &#x2F;&#x2F;生成.o文件</p>
</li>
<li><p>gcc -shared *.o -o libcalc.so       &#x2F;&#x2F;生成动态库文件libcalc.so</p>
</li>
<li><p>将动态库文件libcalc.so(一般是一些函数实现，不包括主函数文件)和头文件head.h放在文件夹two发送给客户即可</p>
</li>
</ol>
<h2 id="2-2使用步骤"><a href="#2-2使用步骤" class="headerlink" title="2.2使用步骤"></a>2.2使用步骤</h2><p>生成可执行文件app</p>
<p><code>gcc main.c -L . -lcalc -o app</code></p>
]]></content>
      <categories>
        <category>必备技能</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级数据库sqlite3</title>
    <url>/2024/07/01/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93sqlite3/</url>
    <content><![CDATA[<h1 id="1、安装sqlite环境"><a href="#1、安装sqlite环境" class="headerlink" title="1、安装sqlite环境"></a>1、安装sqlite环境</h1><p>进入sqlite官网：<a href="https://www.sqlite.org/index.html">https://www.sqlite.org/index.html</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/sqlite3/1.png"></p>
<h1 id="2、创建数据库"><a href="#2、创建数据库" class="headerlink" title="2、创建数据库"></a>2、创建数据库</h1><p>在linux系统又两种方式创建数据库，如下所示：</p>
<ul>
<li><p>shell终端：sqlite3 my.db</p>
</li>
<li><p>c文件里：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite3 *db;                             //是指向数据库文件的句柄指针(地址)</span><br><span class="line">sqlite3_open(“my.db”,&amp;db)                //成功返回SQLITE_OK</span><br></pre></td></tr></table></figure>

<h1 id="3、系统命令"><a href="#3、系统命令" class="headerlink" title="3、系统命令"></a>3、系统命令</h1><p>系统命令是非常主要的，通过这些系统目录可以很好的操作数据库sqlite。</p>
<ol>
<li><p>help：查看帮助信息</p>
</li>
<li><p>databases：查看数据库</p>
</li>
<li><p>tables：显示数据库中所有的表的表名</p>
</li>
<li><p>schema：查看表的结构</p>
</li>
<li><p>quit：退出数据库</p>
</li>
<li><p>exit：退出数据库</p>
</li>
</ol>
<h1 id="4、增删改查"><a href="#4、增删改查" class="headerlink" title="4、增删改查"></a>4、增删改查</h1><ol>
<li><p>创建一张表：create table 表名(字段名称1 字段类型, …);</p>
</li>
<li><p>删除一张表：drop table 表名;</p>
</li>
<li><p>向表中插入一条记录:insert into 表名 values(字段值1,字段值2,…);</p>
</li>
<li><p>查询记录：select * from 表名;</p>
</li>
<li><p>删除记录：delete from 表名 where 字段名称&#x3D;关键字;</p>
</li>
<li><p>更新记录：update 表名 set 字段名称1&#x3D;关键字 where 字段名称2&#x3D;关键字;</p>
</li>
</ol>
<h1 id="5、数据库表的维护"><a href="#5、数据库表的维护" class="headerlink" title="5、数据库表的维护"></a>5、数据库表的维护</h1><ol>
<li><p>数据库主键(设置的数据库将会是唯一存在的):PRIMARY KEY</p>
</li>
<li><p>自增字段(设置的字段值自动递增):AUTOINCREMENT</p>
</li>
</ol>
<ul>
<li>使用：关键字 AUTOINCREMENT —&gt; 只能用于整型(INTEGER)字段</li>
</ul>
<h1 id="6、API函数接口"><a href="#6、API函数接口" class="headerlink" title="6、API函数接口"></a>6、API函数接口</h1><ol>
<li><p>int sqlite2_open(const char *filename,sqlite3 **ppDb);</p>
<ul>
<li>功能：创建并打开一个数据库(存在就直接打开)</li>
<li>参数1：要打开的数据库名</li>
<li>参数2：操作数据库的二级指针</li>
<li>返回值：成功(SQLITE_OK)；失败(error_code)</li>
</ul>
</li>
<li><p>const char <em>sqlite3_errmsg(sqlite3</em> db);</p>
<ul>
<li>功能：获取错误信息描述</li>
</ul>
</li>
<li><p>int sqlite3_close(sqlite3* db);</p>
<ul>
<li>功能：关闭一个数据库</li>
</ul>
</li>
<li><p>int sqlite3_exec(sqlite3* db, const char* sql, int <em>callback(参数), void</em> arg, char **errmsg);</p>
<ul>
<li><p>功能：执行一条sql语句</p>
</li>
<li><p>1：数据库的句柄指针</p>
</li>
<li><p>参数2；将要被执行的sql语句(拼接)</p>
</li>
<li><p>参数3：回调函数，只有在查询的时候，才执行此函数</p>
</li>
<li><p>参数4：是回调函数参3的参数</p>
</li>
<li><p>参数5：存放错误信息的地址(传出参数)</p>
</li>
<li><p>返回值：成功(SQLITE_OK)；失败(errcode错误码)</p>
</li>
</ul>
</li>
<li><p>int (<em>callback)(void</em> arg,int ncolumn,char** f_value,char** f_name);</p>
<ul>
<li><p>功能：每找到一次记录自动执行一次回调函数，得到查询结果</p>
</li>
<li><p>参数1：是sqlite3_exec传递的参数为回调函数使用</p>
</li>
<li><p>参数2：记录中包含的字段的数目</p>
</li>
<li><p>参数3：包含每个字段值的指针数值</p>
</li>
<li><p>参数4：包含每个字段名称的指针数值</p>
</li>
<li><p>返回值：成功(0)；失败(非0)</p>
</li>
</ul>
</li>
</ol>
<p>注意：如果只是向看一下表，可以调用sqlite3_get_table()函数</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发网络编程libevent</title>
    <url>/2024/07/07/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Blibevent/</url>
    <content><![CDATA[<h1 id="1-libevent库介绍"><a href="#1-libevent库介绍" class="headerlink" title="1. libevent库介绍"></a>1. libevent库介绍</h1><h2 id="1-1-什么是libevent"><a href="#1-1-什么是libevent" class="headerlink" title="1.1 什么是libevent"></a>1.1 什么是libevent</h2><p>libevent也称为事件通知库，即所见皆事件，是一个用C语言实现的、基于事件驱动(event-driven)的轻量级高性能开源网络库，适用于Windows、Linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。libevent不一定是用到网络当中，本地的文件描述符都可以用。</p>
<h2 id="1-2-libevent特点"><a href="#1-2-libevent特点" class="headerlink" title="1.2 libevent特点"></a>1.2 libevent特点</h2><ul>
<li><p>事件驱动(event-driven)，高性能</p>
</li>
<li><p>轻量级，专注于网络，不如 NGINX 那么臃肿庞大</p>
</li>
<li><p>源代码相当精炼、易读</p>
</li>
<li><p>跨平台，支持 Windows、Linux、*BSD和Mac OS，但Windows支持不怎么好</p>
</li>
<li><p>支持多种I&#x2F;O多路复用技术，select、epoll、poll、dev&#x2F;poll、select、kqueue、evports等</p>
</li>
<li><p>支持I&#x2F;O，定时器和信号等事件</p>
</li>
<li><p>采用Reactor设计模式</p>
</li>
<li><p>支持HTTP(S)，DNS解析</p>
</li>
</ul>
<p>libevent是用于编写高速可移植非阻塞IO应用的库，其设计目标是：可移植性、高性能、便携和可扩展性</p>
<h1 id="2-libevent框架"><a href="#2-libevent框架" class="headerlink" title="2. libevent框架"></a>2. libevent框架</h1><h2 id="2-1-步骤流程"><a href="#2-1-步骤流程" class="headerlink" title="2.1 步骤流程"></a>2.1 步骤流程</h2><p>1.创建event_base</p>
<ul>
<li><p><code>struct event_base *event_base_new(void);</code></p>
</li>
<li><p><code>struct event_base *base = event_base_new();</code></p>
</li>
</ul>
<p>2.创建事件event</p>
<ul>
<li><p>常规事件event：<code>event_new();</code></p>
</li>
<li><p>bufferevent事件：<code>bufferevent_socket_new();</code></p>
</li>
</ul>
<p>3.将事件添加到base上</p>
<ul>
<li><code>int event_add(struct event *ev, const struct timeval *tv);</code></li>
</ul>
<p>4.循环监听事件满足</p>
<ul>
<li><code>int event_base_dispatch(struct event_base *base);</code></li>
</ul>
<p>5.释放event_base</p>
<ul>
<li><code>event_base_free(base);</code></li>
</ul>
<h2 id="2-2-event事件"><a href="#2-2-event事件" class="headerlink" title="2.2 event事件"></a>2.2 event事件</h2><p>1.<code>struct event *event_new(struct event_base *base, evutil_socket_t fd, short what, event_callback_fn cb, void *arg);</code></p>
<ul>
<li><p>参1：event_base_new()返回值</p>
</li>
<li><p>参2：绑定到event上的文件描述符，也是回调函数参数</p>
</li>
<li><p>参3：对应的事件(r,w,e)，也是回调函数参数</p>
<ul>
<li>EV_READ：一次读事件</li>
<li>EV_WRITE：一次写事件</li>
<li>EV_PERSIST： 持续触发，结合event_base_dispatch函数使用</li>
</ul>
</li>
<li><p>参4：一旦事件满足监听条件，就回调的函数</p>
<ul>
<li><code>typedef void(*event_callback_fn)(evutil_socket_t fd, short, void*);</code></li>
</ul>
</li>
<li><p>参5：回调函数的参数；</p>
<ul>
<li>返回值：成功创建的event；</li>
</ul>
</li>
</ul>
<p>2.添加事件到event_base</p>
<p><code>int event_add(struct event *ev, const struct timeval *tv);</code></p>
<ul>
<li><p>参1：event_new()的返回值</p>
</li>
<li><p>参2：NULL</p>
</li>
</ul>
<p>3.从event_base上摘下事件[了解即可]</p>
<p><code>int event_del(struct event *ev);</code></p>
<ul>
<li>参数：event_new()的返回值</li>
</ul>
<p>4.销毁事件</p>
<p><code>int event_free(struct event *ev);</code></p>
<ul>
<li>参数：event_new()的返回值</li>
</ul>
<p>注意：使用到libevent库的事件，编译时后面要加-levent</p>
<p>补：常规事件event的过程状态</p>
<ul>
<li><p>未决：有资格被处理，但还没有被处理(事件没有到来)</p>
</li>
<li><p>非未决：没有资格被处理</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/libevent/2_1.png"></p>
<p>案例：通过event事件对管道写内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="comment">//写管道</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面没有设置持续写的话，在这里加一个while(1)也可以</span></span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello,world_%d\n&quot;</span>,num++);   <span class="comment">//将要写的内容存到buf</span></span><br><span class="line">        write(fd,buf,<span class="built_in">strlen</span>(buf)+<span class="number">1</span>);             <span class="comment">//向管道发送buf数据</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//由于读操作那边已经创建管道了，所以这边不用创建了，它们是用同一个管道</span></span><br><span class="line">        <span class="comment">//打开管道</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;myfifo&quot;</span>,O_WRONLY | O_NONBLOCK);    <span class="comment">//以只写方式和非阻塞方式打开管道</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个event_base ---&gt; 相当于底座</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = event_base_new();</span><br><span class="line">        <span class="comment">//创建event事件ev</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//ev = event_new(base,fd,EV_WRITE,write_cb,NULL);       //只写一次,如果没有持续触发，那么下面的event_base_dispatch没有用</span></span><br><span class="line">        ev = event_new(base,fd,EV_WRITE | EV_PERSIST,write_cb,<span class="literal">NULL</span>);  <span class="comment">// 持续写。参数：底座；需要监听的fd；对fd做什么样的监听(写和持续触发)；回调函数；回调函数的参数</span></span><br><span class="line">        <span class="comment">//添加事件</span></span><br><span class="line">        event_add(ev,<span class="literal">NULL</span>);        <span class="comment">//将事件添加到base(底座)上</span></span><br><span class="line">        <span class="comment">//事件循环</span></span><br><span class="line">        event_base_dispatch(base);  <span class="comment">//接下来由内核处理 --&gt;相当于while(1)&#123; epoll(); &#125;; ---&gt;事件满足，自动回调</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        event_free(ev);</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过event事件对管道读内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="comment">//读管道</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));    <span class="comment">//从管道将读到的内容存放到buf</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read event:%s\n&quot;</span>,(what &amp; EV_READ?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data len = %d, buf = %s\n&quot;</span>,len,buf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        unlink(<span class="string">&quot;myfifo&quot;</span>);</span><br><span class="line">        <span class="comment">//创建命名管道----&gt;无血缘关系的进程间也可以通信</span></span><br><span class="line">        mkfifo(<span class="string">&quot;myfifo&quot;</span>,<span class="number">0664</span>);</span><br><span class="line">        <span class="comment">//打开管道</span></span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;myfifo&quot;</span>,O_RDONLY | O_NONBLOCK);    <span class="comment">//以只读方式和非阻塞方式打开管道</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个event_base ---&gt; 相当于底座</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        base = event_base_new();</span><br><span class="line">        <span class="comment">//创建事件</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        ev = event_new(base,fd,EV_READ | EV_PERSIST,read_cb,<span class="literal">NULL</span>);  <span class="comment">//底座；需要监听的fd；对fd做什么样的监听(读和持续触发)；回调函数；回调函数的参数</span></span><br><span class="line">        <span class="comment">//添加事件</span></span><br><span class="line">        event_add(ev,<span class="literal">NULL</span>);        <span class="comment">//将事件添加到base(底座)上</span></span><br><span class="line">        <span class="comment">//事件循环</span></span><br><span class="line">        event_base_dispatch(base); <span class="comment">//接下来由内核处理 --&gt;相当于while(1)&#123; epoll(); &#125;; ---&gt;事件满足，自动回调</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        event_free(ev);</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-bufferevent缓冲事件"><a href="#2-3-bufferevent缓冲事件" class="headerlink" title="2.3 bufferevent缓冲事件"></a>2.3 bufferevent缓冲事件</h2><p>原理：bufferevent有两个缓冲区，也是队列实现，读走就没了，先进先出</p>
<p>读过程：有数据—–&gt;读回调函数被调用—–&gt;使用bufferevent_read()—–&gt;有数据。</p>
<p>写过程：使用bufferevent_write()—–&gt;向写缓冲中写数据—–&gt;该缓冲区有数据就自动写出—–&gt;写完，回调函数被调用(鸡肋)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/libevent/2_2.png"></p>
<p>1.创建bufferevent事件</p>
<p><code>struct bufferevenet *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options);</code></p>
<ul>
<li><p>参1：event_base</p>
</li>
<li><p>参2：封装到bufferevent内的fd</p>
</li>
<li><p>参3：BEV_OPT_CLOSE_ON_FREE—&gt;释放bufferevent时关闭底层传输端口，这将关闭底层套接字(网络套接字)，释放底层bufferevent等</p>
</li>
<li><p>返回值：成功创建的bufferevent事件对象</p>
</li>
</ul>
<p>2.销毁bufferevent</p>
<p><code>void bufferevent_socket_free(struct bufferevent *ev);</code></p>
<p>3.给bufferevent设置回调</p>
<ul>
<li>区别：event事件设置回调 event_new(fd,callback)，一个函数就可以，而bufferevent事件设置回调则麻烦一点</li>
</ul>
<p>bufferevent_socket_new(fd); bufferevent_setcb(callback);</p>
<p>4.<code>void bufferevent_setcb(struct bufferevent* bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg);</code></p>
<ul>
<li><p>参1：bufferevent_socket_new()返回值</p>
</li>
<li><p>参2：设置bufferevent读缓冲，对应回调read_cb{bufferevent_read()读数据}</p>
</li>
<li><p>参3：设置bufferevent写缓冲，对应回调write_cb{ }–&gt;给调用者，发送写成功通知，可以写NULL</p>
</li>
<li><p>参4：设置事件回调，也可以传NULL</p>
</li>
<li><p>参5：上述回调函数使用的参数</p>
</li>
</ul>
<p>5.启动、关闭bufferevent的缓冲区</p>
<p><code>void bufferevent_enbale(struct bufferevent *bufev, short events);</code></p>
<ul>
<li>events：EV_READ、EV_WRITE、EV_READ|EV_WRITE</li>
</ul>
<p>注意：默认write缓冲是enable、read缓冲是disable，所以需要开启都缓冲</p>
<p>6.客户端实现</p>
<p><code>socket(); connect();</code></p>
<p><code>int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen);</code></p>
<ul>
<li><p>参1：bufferevent事件对象(封装了fd)</p>
</li>
<li><p>参2和参3：等同于connect()的参2和参3</p>
</li>
</ul>
<p>7.服务端实现</p>
<p><code>socket(); bind(); listen(); accept();</code></p>
<p><code>struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen);</code></p>
<ul>
<li><p>参1：event_base</p>
</li>
<li><p>参2：回调函数，一旦被回调，说明在其内部应该与客户端完成，数据读写操作，进行通信。</p>
</li>
<li><p>参3：回调函数的参数</p>
</li>
<li><p>参4：LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE</p>
</li>
<li><p>参5：listen的参2，-1表示最大值</p>
</li>
<li><p>参6：服务器自身的地址结构体</p>
</li>
<li><p>参7服务器自己的地址结构体大小</p>
</li>
<li><p>返回值：成功创建的监听器</p>
</li>
</ul>
<p>8.bufferevent的读事件回调触发时机：</p>
<blockquote>
<p>当数据由内核的读缓冲区到bufferevent的读缓冲区的时候，会触发bufferevent()的读事件回调。需要注意的是，数据由内核到bufferevent的过程不是由用户程序执行的，是由bufferevent内部操作的</p>
<p>被触发的回调函数是自己写的，可以在里面读bufferevent的数据了，也可以向bufferevent写缓冲区写数据</p>
</blockquote>
<p>9.bufferevent的写事件回调触发时机：</p>
<blockquote>
<p>当用户程序将数据写到bufferevent的写缓冲区之后，bufferevent会自动将数据写到内核的写缓冲区，最终由内核程序将数据发送出去。此时回调函数起到的是通知作用，向我们传达数据已经发送出去的信息。</p>
</blockquote>
<p>案例：用bufferevent来实现网络通信(服务端)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读缓冲区回调---&gt;当数据从内核缓冲区到bufferevent的读缓冲区时，触发该事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//只能用下面这个函数(bufferevent包里面的)代替read,因为没有文件描述符</span></span><br><span class="line">    bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从bufferevent读缓冲区中读数据到buf中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client say: %s\n&quot;</span>,buf);                <span class="comment">//打印buf中的内容，也就是客户端发的内容</span></span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;我是服务器，已经成功收到你发送的数据！\n&quot;</span>;</span><br><span class="line">    <span class="comment">//因为写入bufferevent写缓冲区的数据会自动发送到内核缓冲区，则读回调函数里面直接向bufferevent写数据相当于回应客户端</span></span><br><span class="line">    bufferevent_write(bev,p,<span class="built_in">strlen</span>(p)+<span class="number">1</span>);  <span class="comment">//向bufferevent写缓冲区写入数据，系统就会将信息发送给客户端</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写缓冲区回调---&gt;当bufferevent的写缓冲区的数据发送到内核缓冲区时，触发该函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//因为读回调向bufferevent写缓冲区写入了数据，并且由内核处理，数据发送给了内核缓冲区，最后客户端收到信息，这些事情写回调都不用做</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功写数据给客户端，写缓冲区回调函数被回调.....\n&quot;</span>);  <span class="comment">//写回调起到的作用就是通知，表示信息已经发送出去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">short</span> events,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events &amp; BEV_EVENT_EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some other error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);                    <span class="comment">//出现上面两种情况都释放bev(bufferevent)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffevent 资源已经被释放...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听回调 ---&gt;当客户端连上，会执行这个函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cb_listener</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,<span class="type">evutil_socket_t</span> fd,<span class="keyword">struct</span> sockaddr *addr,<span class="type">int</span> len,<span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect new client\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> (<span class="keyword">struct</span> event_base*)ptr;     <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">    <span class="comment">//创建bufferevent事件---&gt;然后就有了bufferevent的读写缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span>;</span></span><br><span class="line">    bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    <span class="comment">//给bufferevent缓冲区设置回调</span></span><br><span class="line">    bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>); <span class="comment">//设置了读回调函数、写回调函数和事件回调；最后NULL是传给三个的回调函数的参数，表示无</span></span><br><span class="line">    <span class="comment">//启用bufferevent的读缓冲，默认是disable的</span></span><br><span class="line">    bufferevent_enable(bev,EV_READ);       <span class="comment">//bufferevent的读缓存区默认是关闭的，所以需要打开</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span>           <span class="comment">//定义一个存放服务端信息的结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));      <span class="comment">//将改结构体清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体的信息</span></span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    serv.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//创建event_base---&gt;插座</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> event_base_new();</span><br><span class="line">    <span class="comment">//创建套接字、绑定、接收连接请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span>* <span class="title">listener</span>;</span>       <span class="comment">//监听器，下面函数第二个参数是创建监听回调函数</span></span><br><span class="line">    listener = evconnlistener_new_bind(base,cb_listener,base,LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE,<span class="number">36</span>,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv)); <span class="comment">//当客户端连接上的时候，cb_listener会被调用，其中需要传入参数base，里面会用到</span></span><br><span class="line">    <span class="comment">//启动循环监听</span></span><br><span class="line">    event_base_dispatch(base);    <span class="comment">//该函数循环监听那些事件对象(有回调函数的)，满足条件就激活对应的事件，进行回调</span></span><br><span class="line">    evconnlistener_free(listener);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：用bufferevent来实现网络通信(客户端)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读缓冲区回调---&gt;当数据从内核缓冲区到bufferevent的读缓冲区时，触发该事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    bufferevent_read(bev,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从bufferevent读缓冲区中读数据到buf中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server say: %s\n&quot;</span>,buf);                <span class="comment">//打印buf中的内容，也就是服务端发的内容</span></span><br><span class="line">    <span class="comment">//bufferevent_write(bev,buf,strlen(buf)+1);    //向bufferevent写缓冲区写入数据，系统就会将信息发送给对端</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写缓冲区回调---&gt;当bufferevent的写缓冲区的数据发送到内核缓冲区时，触发该函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//因为读回调向bufferevent写缓冲区写入了数据，并且由内核处理，数据发送给了内核缓冲区，最后客户端收到信息，这些事情写回调都不用做</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功写入数据给服务端，客户端回调起通知作用.....\n&quot;</span>);    <span class="comment">//写回调起到的作用就是通知，表示信息已经发送出去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev,<span class="type">short</span> events,<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events &amp; BEV_EVENT_EOF)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection closed\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_ERROR)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;some other error\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events &amp; BEV_EVENT_CONNECTED)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已经连接到服务器.......\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);            <span class="comment">//最上面两种情况就释放bev(bufferevent)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffevent 资源已经被释放...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端与用户交互，从终端读取数据写给服务器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_terminal</span><span class="params">(<span class="type">evutil_socket_t</span> fd, <span class="type">short</span> what, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = read(fd,buf,<span class="keyword">sizeof</span>(buf));      <span class="comment">//此时的fd是标准输入，即从标准输入数据到buf中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> (<span class="keyword">struct</span> bufferevent*)arg;   <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">    bufferevent_write(bev,buf,len+<span class="number">1</span>);    <span class="comment">//向服务端发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个event_base，底座</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    base = event_base_new();</span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);    <span class="comment">//通信描述符</span></span><br><span class="line">    <span class="comment">//通信的fd放到bufferevent中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    bev = bufferevent_socket_new(base,fd,BEV_OPT_CLOSE_ON_FREE); <span class="comment">//创建了bufferevent事件，将其的bufferevent读写缓冲区与内核文件描述符建立关系</span></span><br><span class="line">    <span class="comment">//定义服务端信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    serv.sin_family = AF_INET;</span><br><span class="line">    serv.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;serv.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    bufferevent_socket_connect(bev,(<span class="keyword">struct</span> sockaddr*)&amp;serv,<span class="keyword">sizeof</span>(serv));</span><br><span class="line">    <span class="comment">//设置回调</span></span><br><span class="line">    bufferevent_setcb(bev,read_cb,write_cb,event_cb,<span class="literal">NULL</span>);      <span class="comment">//设置了读回调、写回调和事件回调</span></span><br><span class="line">    <span class="comment">//设置读回调生效</span></span><br><span class="line">    bufferevent_enable(bev,EV_READ);          <span class="comment">//打开读缓冲区，不打开的话，服务器发信息来，这边不会执行读回调</span></span><br><span class="line">    <span class="comment">//创建事件 ---&gt; 有了bufferevent事件只是有了它的读写缓冲区与内核缓冲区建立关系，但作为客户端，需要主动给服务器发信息，就可以创建event事件来从终端向对端发信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">ev</span> =</span> event_new(base,STDIN_FILENO,EV_READ | EV_PERSIST,read_terminal,bev);  <span class="comment">//监听标准输入终端，读事件，持续触发，read_terminal是回调函数</span></span><br><span class="line">    <span class="comment">//添加事件</span></span><br><span class="line">    event_add(ev,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//启动循环监听</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    event_free(ev);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，需要注意的是，客户端在创建了bufferevent事件后，只是将其的读写缓冲区与内核的作了联系，若后面不创建event事件来主动向服务端发信息，将运行不起来程序，因为服务器和客户端的读缓冲区被激活的前提是有信息到自己的bufferevent读缓冲区，但没有event事件让客户端从终端的输入信息发送到对端，这个程序就不会执行下去。</p>
]]></content>
      <categories>
        <category>libevent网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>高并发</tag>
        <tag>libevent</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>c++并发编程(上)</title>
    <url>/2024/07/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="1-线程基础"><a href="#1-线程基础" class="headerlink" title="1. 线程基础"></a>1. 线程基础</h1><h2 id="1-1-线程发起"><a href="#1-1-线程发起" class="headerlink" title="1.1 线程发起"></a>1.1 线程发起</h2><p>线程发起就是指启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">thead_work1</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str is &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string hellostr = <span class="string">&quot;hello world!&quot;</span>;         <span class="comment">//定义一个字符串  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thead_work1, hellostr)</span></span>;         <span class="comment">//通过()初始化并启动一个线程</span></span><br><span class="line">    t1.<span class="built_in">join</span>();                                     <span class="comment">//主线程等待子线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，如果没有<code>t1.join()</code>;或用<code>std::this_thread::sleep_for(std::chrono::seconds(1));</code>代替，执行该程序都会报错。需要调用<code>t1.join();</code>来等t1子线程执行完了，主线程才往下执行。</p>
<h2 id="1-2-仿函数作为参数"><a href="#1-2-仿函数作为参数" class="headerlink" title="1.2 仿函数作为参数"></a>1.2 仿函数作为参数</h2><p>用仿函数作为参数传递给线程时，也可以当作线程的回调函数来使用。下面程序中，第1种执行方法，编译器会将t2当成一个函数对象, 返回一个std::thread类型的值, 即函数的参数被视为一个函数指针了，所以程序是由问题的，可以通过第2和第3种方式执行，用()或{}避免将background_task()视为一个函数指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">background_task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;     <span class="comment">//重载了一个()运算符</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;background_task called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.t1被当作函数对象的定义，其类型为返回std::thread, 参数为background_task</span></span><br><span class="line">    <span class="comment">//std::thread t1(background_task());</span></span><br><span class="line">    <span class="comment">//t1.join();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.可多加一层()</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">((background_task()))</span></span>;</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.可使用&#123;&#125;方式初始化</span></span><br><span class="line">    std::thread t3&#123; <span class="built_in">background_task</span>() &#125;;</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-lambda表达式"><a href="#1-3-lambda表达式" class="headerlink" title="1.3 lambda表达式"></a>1.3 lambda表达式</h2><p>lambda表达式也可以作为线程的参数传递给thread</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main&#123;</span><br><span class="line">    std::string hellostr = <span class="string">&quot;hello world!&quot;</span>;         <span class="comment">//定义一个字符串</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">([](std::string  str) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;str is &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;,  hellostr)</span></span>;     <span class="comment">//第1个参数是lambda回调函数,第2个参数是所要用的字符串</span></span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-detach使用"><a href="#1-4-detach使用" class="headerlink" title="1.4 detach使用"></a>1.4 detach使用</h2><p>detach允许子线程采用分离的方式在后台独自运行，但下面的程序仍然有隐患。因为<code>some_local_state</code>是局部变量, 当<code>oops</code>调用结束后局部变量<code>some_local_state</code>就可能被释放了，而子线程还在detach后台运行，容易出现崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">func</span> &#123;   <span class="comment">//结构体，相当于类，区别在于c++中结构体中所以的成员都是公有的</span></span><br><span class="line">    <span class="type">int</span>&amp; _i;                    <span class="comment">//引用的成员变量</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="type">int</span> &amp; i): _i(i)&#123;&#125;      <span class="comment">//将传进来的局部变量通过引用赋值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            _i = i;             <span class="comment">//模拟一直在使用局部变量的情况</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;_i is &quot;</span> &lt;&lt; _i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));    <span class="comment">//执行完一次，睡</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> some_local_state = <span class="number">0</span>;       <span class="comment">//定义了一个局部变量</span></span><br><span class="line">        <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;     <span class="comment">//将局部变量传给了结构体对象myfunc</span></span><br><span class="line">        <span class="function">std::thread <span class="title">functhread</span><span class="params">(myfunc)</span></span>;    <span class="comment">//子线程</span></span><br><span class="line">        <span class="comment">//隐患，访问局部变量，局部变量可能会随着&#125;结束而回收或随着主线程退出而回收</span></span><br><span class="line">        functhread.<span class="built_in">detach</span>();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// detach 注意事项</span></span><br><span class="line">    <span class="built_in">oops</span>();</span><br><span class="line">    <span class="comment">//防止主线程退出过快，需要停顿一下，让子线程跑起来detach</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当我们在子线程中使用主线程的一些局部变量，或通过引用或指针的方式使用了一些函数的局部变量，一定要关注这些局部变量是否会被释放掉。解决该方面问题的一些方法：</p>
<ul>
<li>通过智能指针传递参数，因为引用计数会随着赋值增加，可保证局部变量在使用期间不被释放，这也就是伪闭包策略。</li>
<li>将局部变量的值作为参数传递，这么做需要局部变量有拷贝复制的功能，而且拷贝耗费空间和效率。</li>
<li>将线程运行的方式用join代替detach，这样能保证局部变量被释放前线程已经运行结束。但是这么做可能会影响运行逻辑。</li>
</ul>
<h2 id="1-5-异常处理"><a href="#1-5-异常处理" class="headerlink" title="1.5 异常处理"></a>1.5 异常处理</h2><p>当我们启动一个线程后，如果主线程产生崩溃，会导致子线程也会异常退出，就是调用terminate，如果子线程在进行的是一些重要的操作，那么丢失这些信息是很危险的。所以常用的做法是捕获异常，即在主线程出现异常情况下需要保证子线程稳定运行结束后，主线程才抛出异常结束运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catch_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">myfunc</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    std::thread  functhread&#123; myfunc &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//本线程做一些事情,可能引发崩溃</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        functhread.<span class="built_in">join</span>();     <span class="comment">//主线程出现异常了，也要等待子线程执行完，才抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    functhread.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-线程管控"><a href="#2-线程管控" class="headerlink" title="2. 线程管控"></a>2. 线程管控</h1><h2 id="2-1-线程归属权"><a href="#2-1-线程归属权" class="headerlink" title="2.1 线程归属权"></a>2.1 线程归属权</h2><p>众所周知线程可以通过detach在后台运行或者通过join让开辟这个线程的父线程等待该线程完成。但每个线程都应该有其归属权，也就是归属给某个变量管理：</p>
<p>下面程序启动了一个线程，<code>t1</code>是线程的变量，这里可以理解为在定义完线程变量，系统就会帮我们去分配线程资源，让线程运行起来，线程就归属<code>t1</code>变量管理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>t1</code>是一个线程变量，管理一个线程，该线程执行<code>some_function()</code>。对于<code>std::thread</code> C++ 不允许其执行<strong>拷贝构造</strong>和<strong>拷贝赋值</strong>，所以只能通过移动和局部变量返回的方式将线程变量管理的线程转移给其他变量管理。在c++中，像<code>std::mutex</code>, <code>std::ifstream</code>, <code>std::unique_ptr</code>都是这样的类型。</p>
<p>在下面程序中，定义了一个<code>t1</code>变量管理一个线程，将<code>t1</code>管理的线程通过move的方式转移给了<code>t2</code>，move过后，<code>t1</code>变量就没有绑定线程了，即无效变量了。虽然<code>t1</code>无效了，但还可以继续赋值，通过<code>t1 = std::thread(some_other_function)</code>给<code>t1</code>绑定新的线程。为什么这种赋值方式可以？因为<code>std::thread</code>返回的是一个局部变量，且是右值，右值赋给<code>t1</code>，调用的就是thread的<code>移动赋值函数</code>，这种方式是可以的，<code>t1</code>就绑定了新的线程。如果这时再创建一个线程变量<code>t3</code>，将<code>t2</code>的线程转移给<code>t3</code>来用，<code>t3</code>再转移给<code>t1</code>，这时就会出现崩溃了。因为<code>t1</code>已经绑定了线程，再对起进行赋值，就会造成它原来的线程强行终止，触发线程内部<code>terminate</code>函数，该<code>terminate</code>就会引发程序的崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_other_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1 t1绑定some_function</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>; </span><br><span class="line"><span class="comment">//2 转移t1管理的线程给t2，转移后t1无效</span></span><br><span class="line">std::thread t2 =  std::<span class="built_in">move</span>(t1);</span><br><span class="line"><span class="comment">//3 但t1可继续绑定其他线程,执行some_other_function</span></span><br><span class="line">t1 = std::<span class="built_in">thread</span>(some_other_function);</span><br><span class="line"><span class="comment">//4  创建一个线程变量t3</span></span><br><span class="line">std::thread t3;</span><br><span class="line"><span class="comment">//5  转移t2管理的线程给t3</span></span><br><span class="line">t3 = std::<span class="built_in">move</span>(t2);</span><br><span class="line"><span class="comment">//6  转移t3管理的线程给t1</span></span><br><span class="line">t1 = std::<span class="built_in">move</span>(t3);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2000</span>));</span><br></pre></td></tr></table></figure>

<h2 id="2-2-局部变量返回值"><a href="#2-2-局部变量返回值" class="headerlink" title="2.2 局部变量返回值"></a>2.2 局部变量返回值</h2><p>对于返回一个局部变量给调用者，是当函数返回一个类类型的局部变量时会先调用移动构造，如果没有移动构造再调用拷贝构造。 所以对于一些没有拷贝构造但是实现了移动构造的类类型也支持通过函数返回局部变量。 在 C++11 之后，编译器会默认使用移动语义来提高性能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestCopy</span>()&#123;&#125;                             <span class="comment">//默认构造</span></span><br><span class="line">    <span class="built_in">TestCopy</span>(<span class="type">const</span> TestCopy&amp; tp) &#123;           <span class="comment">//拷贝构造</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Copy &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TestCopy</span>(TestCopy&amp;&amp; cp) &#123;                <span class="comment">//移动构造</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test Copy Move &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TestCopy <span class="title">TestCp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestCopy tp;            <span class="comment">//优先考虑移动构造</span></span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-容器存储"><a href="#2-3-容器存储" class="headerlink" title="2.3 容器存储"></a>2.3 容器存储</h2><p>容器存储线程时，比如<code>vector</code>,如果用<code>push_back</code>操作势必会调用<code>std::thread</code>，又因为<code>std::thread</code>没有拷贝构造函数，这样会引发编译错误。而采用emplace方式，可以直接根据线程构造函数需要的参数来构造(比如说threads容器里存的thread类型的变量，通过emplace方法，传入的参数就可以根据thread构造函数时需要的参数，参数就会生成一个右值，存到emplace里)，这样就避免了调用thread的拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//auto t = std::thread(param_function,i);</span></span><br><span class="line">        <span class="comment">//threads.push_back(std::move(t));</span></span><br><span class="line">        <span class="comment">//emplace_back内部相当于执行的就是上面两句代码</span></span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(param_function, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) &#123;</span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-其它函数"><a href="#2-4-其它函数" class="headerlink" title="2.4 其它函数"></a>2.4 其它函数</h2><p><code>std::thread::hardware_concurrency()</code>函数：它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量。</p>
<p><code>get_id()</code>函数：获取线程id。</p>
<h1 id="3-互斥与死锁"><a href="#3-互斥与死锁" class="headerlink" title="3. 互斥与死锁"></a>3. 互斥与死锁</h1><h2 id="3-1-锁的使用"><a href="#3-1-锁的使用" class="headerlink" title="3.1 锁的使用"></a>3.1 锁的使用</h2><p>对于一些共享的数据，可以通过<code>mutex</code>对共享数据进行加锁，防止多线程访问共享区造成数据不一致问题。</p>
<p>再下面程序中，初始化了一个共享变量<code>shared_data</code>，然后定义了一个互斥量<code>std::mutex</code>，接下来启动了两个线程，一个是<code>use_lock</code>函数增加数据，另一个lambda表达式减少数据。从最后执行的结果可以看到两个线程对于共享数据的访问是独占的，单位时间片只有一个线程访问并输出日志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx1;          <span class="comment">//定义的互斥量</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">100</span>;    <span class="comment">//共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();                 <span class="comment">//加锁</span></span><br><span class="line">        shared_data++;               <span class="comment">//对共享数据执行++操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;   <span class="comment">//输出当前的线程id</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;share data is &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;      <span class="comment">//打印修改的数据</span></span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();            <span class="comment">//解锁</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>)); <span class="comment">//睡眠一会，释放时间片。不睡眠的话，这是一个死循环，会一直抢占cpu的时间片(死循环对时间片的抢占严重)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(use_lock)</span></span>;                 <span class="comment">//启动了线程t1，参数是写好的函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;                     <span class="comment">//启动线程t2，参数是lambda表达式</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.lock();             <span class="comment">//加锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">            shared_data--;           <span class="comment">//对共享数据执行--操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;   <span class="comment">//输出当前的线程id</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;share data is &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;      <span class="comment">//打印修改的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">            mtx1.unlock();            <span class="comment">//解锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::microseconds(<span class="number">10</span>)); <span class="comment">//睡眠一会，释放时间片</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-lock-guard的使用"><a href="#3-2-lock-guard的使用" class="headerlink" title="3.2 lock_guard的使用"></a>3.2 lock_guard的使用</h2><p><code>lock_guard</code>可以自动地加锁和解锁，参数只需要传入互斥量即可，就没有必要手动的去加锁和解锁了。因为lock_guard解锁是要遇到右括号才自动解锁，所以需要把与访问共享区域有关的代码放入一个新的{}里面执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">            shared_data++;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sharad data is &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-保证数据安全"><a href="#3-3-保证数据安全" class="headerlink" title="3.3 保证数据安全"></a>3.3 保证数据安全</h2><p>有时候我们可以将对共享数据的访问和修改聚合到一个函数，在函数内加锁保证数据的安全性。但是对于读取类型的操作，即使读取函数是线程安全的，但是返回值抛给外边使用，可能就会存在不安全性。</p>
<p>对于下面这个程序，empty()函数内部对栈进行访问的时候，用了加锁，是安全的，但当将是否为空的结果传到外部后，外部将结果存到队列中，没有及时用。如果这段期间栈有所变化，则会造成程序崩溃。总的来说，就是empty()在返回true或false时，使用这个bool时机的一个问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt;data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;                 <span class="comment">//mutable可变的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>() &#123;&#125;               <span class="comment">//无参构造</span></span><br><span class="line">    <span class="built_in">threadsafe_stack1</span>(<span class="type">const</span> threadsafe_stack1&amp; other) &#123;     <span class="comment">//拷贝构造</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(other.m);      <span class="comment">//加锁，这里参数用的是参数的m，因为自己的m还没有产生</span></span><br><span class="line">        data = other.data;        <span class="comment">//data等于参数的data</span></span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack1&amp; <span class="keyword">operator</span> = (<span class="type">const</span> threadsafe_stack1&amp;) = <span class="keyword">delete</span>;   <span class="comment">//去除赋值构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(m);    <span class="comment">//对互斥量加锁</span></span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));        <span class="comment">//把元素添加进来(通过移动构造，添加进去，可以减少一次拷贝)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题代码</span></span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt;<span class="built_in">mutex</span>(m);</span><br><span class="line">        <span class="keyword">auto</span> element = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//危险</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;   <span class="comment">//这里是const，如果上面的锁没有声明为mutable,就不能在这个函数进行加锁</span></span><br><span class="line">        std::lock_guard&lt;std::mutex&gt;<span class="built_in">lock</span>(m);</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟的一个例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_threadsafe_stack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_stack1&lt;<span class="type">int</span>&gt;safe_stack;</span><br><span class="line">    safe_stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));   <span class="comment">//当判断不为空后，睡眠一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;safe_stack]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (!safe_stack.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::seconds(<span class="number">1</span>));   <span class="comment">//当判断不为空后，睡眠一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            safe_stack.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-死锁"><a href="#3-4-死锁" class="headerlink" title="3.4 死锁"></a>3.4 死锁</h2><p>死锁一般是由于调运顺序不一致导致的，比如两个线程循环调用。当线程1先加锁A，再加锁B，而线程2先加锁B，再加锁A。那么在某一时刻就可能造成死锁，因为它们彼此都想要占用对方的锁，又不释放自己占有的锁，这样就导致了死锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex t_lock1;</span><br><span class="line">std::mutex t_lock2;</span><br><span class="line"><span class="type">int</span> m_1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m_2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock1.<span class="built_in">lock</span>();             <span class="comment">//对m1加锁</span></span><br><span class="line">        m_1 = <span class="number">1024</span>;                 <span class="comment">//修改m1的值</span></span><br><span class="line">        t_lock2.<span class="built_in">lock</span>();             <span class="comment">//对m2加锁</span></span><br><span class="line">        m_2 = <span class="number">2048</span>;                 <span class="comment">//修改m2的值</span></span><br><span class="line">        t_lock2.<span class="built_in">unlock</span>();</span><br><span class="line">        t_lock1.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock1 end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dead_lock2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 begin &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_lock1.<span class="built_in">lock</span>();             <span class="comment">//对m1加锁</span></span><br><span class="line">        m_1 = <span class="number">1024</span>;                 <span class="comment">//修改m1的值</span></span><br><span class="line">        t_lock2.<span class="built_in">lock</span>();             <span class="comment">//对m2加锁</span></span><br><span class="line">        m_2 = <span class="number">2048</span>;                 <span class="comment">//修改m2的值</span></span><br><span class="line">        t_lock2.<span class="built_in">unlock</span>();</span><br><span class="line">        t_lock1.<span class="built_in">unlock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;dead_lock2 end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_dead_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(dead_lock1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(dead_lock2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-层级锁"><a href="#3-5-层级锁" class="headerlink" title="3.5 层级锁"></a>3.5 层级锁</h2><p>现实开发中常常很难规避同一个函数内部加多个锁的情况，我们要尽可能避免循环加锁。所以可以自定义一个层级锁，它是一种用于避免死锁的策略，它通过为锁分配优先级来减少死锁的可能性。在这种策略中，每个锁都被赋予一个唯一的优先级，并且规定只能按照优先级顺序获取锁，这样就保证实际项目中对多个互斥量加锁时是有序的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层级锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span> :_hierarchy_value(value),</span></span><br><span class="line"><span class="function">        _previous_hierarchy_value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">hierarchical_mutex</span>(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除拷贝构造</span></span><br><span class="line">    hierarchical_mutex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> hierarchical_mutex&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除赋值构造</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;           <span class="comment">//加锁</span></span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();     <span class="comment">//检测锁</span></span><br><span class="line">        _internal_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();            <span class="comment">//更新锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;      <span class="comment">//解锁</span></span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value != _hierarchy_value) &#123;  <span class="comment">//判断线程当前的层级值是否等于要解锁的互斥量的层级值</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex hierarchy violated&quot;</span>);    <span class="comment">//抛出错误</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果对了，就将之前存的层级值，赋值给当前线程的层级值</span></span><br><span class="line">        _this_thread_hierarchy_value = _previous_hierarchy_value;</span><br><span class="line">        _internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;      <span class="comment">//尝试锁：尝试一下，加不到锁也可以马上退出，不会阻塞</span></span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();        <span class="comment">//先检测锁</span></span><br><span class="line">        <span class="keyword">if</span> (!_internal_mutex.<span class="built_in">try_lock</span>()) &#123;      <span class="comment">//尝试锁失败，就直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果尝试锁成功的话就执行下面</span></span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();            <span class="comment">//更新锁，然后返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex  _internal_mutex;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> _hierarchy_value;           <span class="comment">//当前层级值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> _previous_hierarchy_value;        <span class="comment">//上一次层级值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">thread_local</span>  <span class="type">unsigned</span> <span class="type">long</span>  _this_thread_hierarchy_value;     <span class="comment">//本线程记录的层级值</span></span><br><span class="line">    <span class="comment">//检测锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_this_thread_hierarchy_value &lt;= _hierarchy_value) &#123;     <span class="comment">//如果线程的层级比要加的锁的层级低</span></span><br><span class="line">            <span class="keyword">throw</span>  std::<span class="built_in">logic_error</span>(<span class="string">&quot;mutex  hierarchy violated&quot;</span>);      <span class="comment">//抛出逻辑错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _previous_hierarchy_value = _this_thread_hierarchy_value;   <span class="comment">//将当前线程的层级值赋值到上一次层级值</span></span><br><span class="line">        _this_thread_hierarchy_value = _hierarchy_value;    <span class="comment">//将要加的锁的值赋值给线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> hierarchical_mutex::_this_thread_hierarchy_value(ULONG_MAX);</span><br><span class="line"><span class="comment">//下面模拟这个是有问题的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_hierarchy_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx1</span><span class="params">(<span class="number">1000</span>)</span></span>;         <span class="comment">//第1个互斥量的层级值是1000</span></span><br><span class="line">    <span class="function">hierarchical_mutex  <span class="title">hmtx2</span><span class="params">(<span class="number">500</span>)</span></span>;          <span class="comment">//第2个互斥量的层级值是500</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;      <span class="comment">//通过引用的方式来捕获，因为拷贝已经被去除了</span></span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx2.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx1.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx1.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        hmtx2.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要原理就是将当前锁的权重保存在线程变量中，这样该线程再次加锁时判断线程变量的权重和锁的权重是否大于，如果满足条件则继续加锁。</p>
<h2 id="3-6-unique-lock"><a href="#3-6-unique-lock" class="headerlink" title="3.6 unique_lock"></a>3.6 unique_lock</h2><p><code>unique_lock</code>和<code>lock_guard</code>基本用法相同，构造时默认加锁，析构时默认解锁，但<code>unique_lock</code>有个好处就是可以手动解锁。这一点尤为重要，方便我们控制锁住区域的粒度(加锁的范围大小)，也能支持和条件变量配套使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unique_lock 基本用法</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_unique</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lock可自动解锁，也可手动解锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lock success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    shared_data++;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();                    <span class="comment">//这行可以加也可以不加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，还可以通过<code>unique_lock</code>的<code>owns_lock</code>来判断是否持有锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可判断是否占有锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">owns_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lock可自动解锁，也可手动解锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;            <span class="comment">//这里加锁了</span></span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;         <span class="comment">//所以会打印这一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();                              <span class="comment">//解锁了</span></span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doesn&#x27;t own lock&quot;</span> &lt;&lt; std::endl;       <span class="comment">//所以会打印这行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unique_lock</code>也可以完成延迟加锁。这里的延迟加锁是指在 <code>std::unique_lock</code> 对象创建时不立即锁定互斥量，而是在之后显式调用 <code>lock.lock()</code> 时才锁定。因此，这个延迟加锁的时间并不是指一个具体的时间段，而是指在 <code>std::unique_lock</code> 对象创建后到显式调用 <code>lock.lock()</code> 之间的这段时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">defer_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;    <span class="comment">//这里还没有进行加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();       <span class="comment">//进行加锁</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();     <span class="comment">//解锁了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面综合运用<code>owns_lock</code>和<code>defer_lock</code>来实现一个例子，下面这个程序中会发生阻塞，阻塞在24行的<code>lock.lock()</code>。因为主线程在初始化时就加锁了，未释放，等待子线程执行完了自动释放；而子线程虽然是延迟加锁，但到了下面显示加锁时，加不了锁，就会阻塞在这里。因此就导致整个程序卡住。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_defer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;      <span class="comment">//因为没有使用延迟加锁，所以这里初始化时，就进行了加锁</span></span><br><span class="line">    <span class="comment">// 判断是否拥有锁</span></span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread has the lock.&quot;</span> &lt;&lt; std::endl;   <span class="comment">//会打印这一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread does not have the lock.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子线程再主线程里运行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::unique_lock&lt;std::mutex&gt; lock(mtx, std::defer_lock); <span class="comment">//这里设置了延迟加锁，所以等到下面显示加锁才算加锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 判断是否拥有锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (lock.owns_lock())</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread has the lock.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread does not have the lock.&quot;</span> &lt;&lt; std::endl; <span class="comment">//此时子线程还没有拥有锁，所以打印这行</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        lock.lock();       <span class="comment">// 这里进行加锁是不行的，会导致程序阻塞在这里</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 判断是否拥有锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (lock.owns_lock())</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread has the lock.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">else</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Thread does not have the lock.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 解锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">        lock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>lock_guard</code>一样，<code>unique_lock</code>也支持领养锁。下面的程序中，首先通过mtx互斥量进行加锁，然后创建了一个lock对象来接管这个锁，此时mtx就无效了，后面就可以通过手动的lock对象来释放锁，但通过<code>mtx.unlock()</code>来释放锁就会报错。如果开始没有先通过mtx来进行加锁，后面通过lock对象来接管锁也会报错，因为锁还没有加锁，接管不了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;                <span class="comment">//定义的互斥量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_own_adopt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();              <span class="comment">//通过互斥量进行了加锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::adopt_lock)</span></span>;   <span class="comment">//创建了一个lock对象来接管锁</span></span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;owns lock&quot;</span> &lt;&lt; std::endl;       <span class="comment">//会打印这行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;does not have the lock&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.<span class="built_in">unlock</span>();        <span class="comment">//通过lock对象来释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，一旦<code>mutex</code>被<code>unique_lock</code>管理，加锁和释放的操作就交给<code>unique_lock</code>，不能调用<code>mutex</code>加锁和解锁，因为锁的使用权已经交给<code>unique_lock</code>了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx1;                <span class="comment">//定义的互斥量</span></span><br><span class="line">std::mutex mtx2;                <span class="comment">//定义的互斥量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_swap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="comment">//需用lock1,lock2加锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line">    <span class="comment">//std::lock(mtx1, mtx2);        //错误用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>众所周知的<code>mutex</code>是不支持移动和拷贝的，但是<code>unique_lock</code>支持移动，当一个<code>mutex</code>被转移给<code>unique_lock</code>后，可以通过<code>unique_ptr</code>转移其归属权。</p>
<p>在下面程序中，<code>get_lock()</code>首先定义了一个局部的lock，执行相应操作后，返回该lock，因为到达了作用域末尾，所以自动解锁了。虽然解锁了，但该lock已经作为局部变量被返回了，在<code>use_return</code>函数中，因为返回的不是引用类型，所以先考虑拷贝构造和拷贝赋值，因为<code>unique_lock</code>没有这两种拷贝，所以就只能用移动构造，会把lock里所有的管理权交给<code>use_return</code>里的lock对象。这意味着互斥量mtx在 <code>use_return</code> 函数中的lock对象被销毁之前不会被解锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转移互斥量所有权,互斥量本身不支持move操作,但是unique_lock支持</span></span><br><span class="line">std::mutex mtx;                <span class="comment">//定义的互斥量</span></span><br><span class="line">std::unique_lock &lt;std::mutex&gt;  <span class="built_in">get_lock</span>() &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    shared_data++;</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_return</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(get_lock())</span></span>;    <span class="comment">//不是引用类型，所以先考虑拷贝构造和拷贝赋值</span></span><br><span class="line">    shared_data++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-线程安全的单例模式"><a href="#4-线程安全的单例模式" class="headerlink" title="4. 线程安全的单例模式"></a>4. 线程安全的单例模式</h1><h2 id="4-1-局部静态变量"><a href="#4-1-局部静态变量" class="headerlink" title="4.1 局部静态变量"></a>4.1 局部静态变量</h2><p>众所周知当一个函数中定义一个局部静态变量，那么这个局部静态变量只会初始化一次，就是在这个函数第一次调用的时候，以后无论调用几次这个函数，函数内的局部静态变量都不再初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single2</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Single2</span>()&#123;&#125;             <span class="comment">//无参构造是私有的</span></span><br><span class="line">    <span class="built_in">Single2</span>(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;               <span class="comment">//去除拷贝构造</span></span><br><span class="line">    Single2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Single2&amp;) = <span class="keyword">delete</span>;    <span class="comment">//去除拷贝赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Single2&amp; <span class="title">GetInst</span><span class="params">()</span>      <span class="comment">//公有的，让外部可以获取它的一个引用实例</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Single2 single;     <span class="comment">//定义了一个静态局部变量</span></span><br><span class="line">        <span class="keyword">return</span> single;             <span class="comment">//返回该变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//c++11之后，这种方式是可以的，它们打印的地址都是一样的。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_single2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;s1 addr is &quot;</span>&lt;&lt;&amp;Single2::<span class="built_in">GetInst</span>()&lt;&lt;std::endl;   <span class="comment">//打印地址</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;s2 addr is &quot;</span>&lt;&lt;&amp;Single2::<span class="built_in">GetInst</span>()&lt;&lt;std::endl;   <span class="comment">//打印地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述版本的单例模式在C++11 以前存在多线程不安全的情况，编译器可能会初始化多个静态变量。但是C++11推出以后，各厂商优化编译器，能保证线程安全。尽管是多个线程，多核机器实现，只要调用<code>GetInst()</code>接口，里面调用生成的局部变量都是统一的。</p>
<p>在C++11 推出以前，局部静态变量的方式实现单例存在线程安全问题，所以部分人推出了以下方案实现：</p>
<h2 id="4-2-饿汉模式"><a href="#4-2-饿汉模式" class="headerlink" title="4.2 饿汉模式"></a>4.2 饿汉模式</h2><p>饿汉模式就是指定义类的时候就创建了单例对象，创建出来后，什么时候用，时候什么就调用静态的成员函数(得到单例对象)，且在多线程的场景下，饿汉模式是没有线程安全问题的(多线程可以同时访问这个单例的对象)。但这种方法的缺点就是浪费空间资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;      <span class="comment">//通过类名来得到的对象是静态的，通过类名访问类里面的属性和方法，这个属性和方法是静态的</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//堵死在外部创建对象的方法,防止通过拷贝构造或赋值操作来创建多个实例</span></span><br><span class="line">	<span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;                   <span class="comment">//删除了拷贝构造函数</span></span><br><span class="line">	TaskQueue&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TaskQueue&amp; t) = <span class="keyword">delete</span>;      <span class="comment">//删除了拷贝赋值函数</span></span><br><span class="line">	<span class="comment">//静态的公共成员函数，把唯一的单例对象返回给调用者</span></span><br><span class="line">	<span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_taskQ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是单例对象的一个成员函数...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;    <span class="comment">//定义了一个无参构造，它与默认的无参构造具有相同的行为</span></span><br><span class="line">	<span class="comment">//只能通过类名访问静态属性或方法</span></span><br><span class="line">	<span class="type">static</span> TaskQueue* m_taskQ;      <span class="comment">//该静态成员指针只能通过静态成员方法访问</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;   <span class="comment">//类的作用域下，可以访问类的私有成员</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-懒汉模式"><a href="#4-3-懒汉模式" class="headerlink" title="4.3 懒汉模式"></a>4.3 懒汉模式</h2><p>懒汉模式就是指什么时候使用这个单例对象，在使用的时候再去创建对应的实例，这样就解决了饿汉模式下的空间资源浪费的问题。但在多线程的场景下，懒汉模式是有线程安全问题的(在多线程情况下，若干个线程同时访问单例的实例，会出问题)。<br>解决方式：通过互斥锁，阻塞线程，依次访问这个单例对象，就可以避免在懒汉模式下多线程同时访问单例对象而创建出多个类的实例这种问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SinglePointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SinglePointer</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SinglePointer</span>(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SinglePointer&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SinglePointer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SinglePointer* <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)     <span class="comment">//如果single已经被初始化</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;         <span class="comment">//直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();            <span class="comment">//如果还没有被初始化</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)     <span class="comment">//再确定一遍，防止期间被其它线程初始化了</span></span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();      <span class="comment">//如果被初始化了，就解锁，返回</span></span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还是没有被初始化，就初始化该类</span></span><br><span class="line">        single = <span class="keyword">new</span> <span class="built_in">SinglePointer</span>();</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();            <span class="comment">//解锁返回</span></span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SinglePointer* single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类里面的静态成员变量使用前，必须在类的外部对其进行初始化(不能在内部进行初始化)</span></span><br><span class="line">SinglePointer* SinglePointer::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SinglePointer::s_mutex;</span><br></pre></td></tr></table></figure>

<h1 id="5-条件变量"><a href="#5-条件变量" class="headerlink" title="5. 条件变量"></a>5. 条件变量</h1><p>在下面程序中，线程1负责打印1后++，线程2负责打印2后–，但当线程1打印完1后，如果2还没有打印，那么它将睡眠，线程2也是相同的情况，所以就导致打印时虽然是12…12这样打印的，但中间互发生停顿，这样就浪费就cpu的时间片。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">std::mutex mtx_num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PoorImpleman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);        <span class="comment">//先加锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;                                   <span class="comment">//如果num=1，就执行下面</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread A print 1.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num++;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//如果num不等于1，就睡一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::lock_guard&lt;std::mutex&gt; lock(mtx_num);            <span class="comment">//先加锁</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;                                       <span class="comment">//如果num=2，就执行下面</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::cout &lt;&lt; <span class="string">&quot;thread B print 2.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                    num--;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//如果num不等于2，就睡一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就可以通过条件变量的方式实现，就是当线程1在执行打印完1后，会将线程2唤醒；而当线程2打印完线程2后，有会唤醒线程1。这样执行的结果就不会出现中间停顿的现象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">std::mutex mtx_num;</span><br><span class="line">std::condition_variable cvA;           <span class="comment">//第1个条件变量</span></span><br><span class="line">std::condition_variable cvB;           <span class="comment">//第2个条件变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResonableImplemention</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//写法1</span></span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.wait(lock, []() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span> num == <span class="number">1</span>;    <span class="comment">//如果num不等于1，就会在这里挂起，把锁解开，交给其它线程，不会消耗cpu的资源</span></span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//如果num等于1，就执行下面</span></span></span></span><br><span class="line"><span class="params"><span class="function">            num++;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread A print 1.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvB.notify_one();           <span class="comment">//唤醒线程2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (;;) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lock(mtx_num);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//写法2</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span>(num!=<span class="number">2</span>)&#123;        <span class="comment">//如果num不等于2，就会发生阻塞</span></span></span></span><br><span class="line"><span class="params"><span class="function">                cvB.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            num--;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;thread B print 2.....&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            cvA.notify_one();          <span class="comment">//唤醒线程1</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//cvA.notify_all();        //唤醒多个线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-并发三剑客future-promise和async"><a href="#6-并发三剑客future-promise和async" class="headerlink" title="6. 并发三剑客future, promise和async"></a>6. 并发三剑客future, promise和async</h1><h2 id="6-1-async与future"><a href="#6-1-async与future" class="headerlink" title="6.1 async与future"></a>6.1 async与future</h2><p><code>std::async</code> 是一个用于异步执行函数的模板函数，它返回一个 <code>std::future</code> 对象，该对象用于获取函数的返回值。</p>
<p>在下面这个程序中，定义了一个需要耗费一定时间的任务函数，在主函数中，先启动一个异步执行的任务，通过<code>future</code>定义的变量来接收异步返回的一个结果，并可以使用<code>get()</code>来获取该结果。如果该异步执行的函数还没有完成，<code>get()</code>就会一直阻塞着，但由于任务函数是子线程异步执行的，所以在执行<code>get()</code>这期间，可以执行其它内容的程序，当需要调用异步任务的结果时，再直接通过<code>get()</code>获取。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一个异步任务函数，比如从数据库中获取数据</span></span><br><span class="line"><span class="function">std::string <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));    <span class="comment">//睡眠5秒，模拟查询</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Data: &quot;</span> + query;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用std::async 异步调用 fetchDataFromDB()函数。参数：一种启动策略(表示单独去启动一个子线程，去执行第二个参数函数)；任务函数；任务函数的参数</span></span><br><span class="line">    std::future&lt;std::string&gt; resultFromDB = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;Data&quot;</span>);</span><br><span class="line">    <span class="comment">// 在主线程中做其他事情(在异步执行和获取到值之间这段时间)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing something else...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 从 future 对象中获取数据</span></span><br><span class="line">    std::string dbData = resultFromDB.<span class="built_in">get</span>();  <span class="comment">//只有在上面启动子线程执行完，这里才能get到</span></span><br><span class="line">    std::cout &lt;&lt; dbData &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动策略：<code>std::async</code>函数可以接受几个不同的启动策略，这些策略在<code>std::launch</code>枚举中定义。除了上述使用的<code>std::launch::async</code><strong>异步执行</strong>之外，还有以下启动策略：</p>
<ul>
<li><p><code>std::launch::deferred</code>：延迟执行，这种策略意味着任务将在调用<code>std::future::get()</code>或<code>std::future::wait()</code>函数时才执行。即任务将在需要结果时<strong>同步执行</strong>。</p>
</li>
<li><p><code>std::launch::async | std::launch::deferred</code>：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。默认情况下，<code>std::async</code>使用的是这种策略，但需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。</p>
</li>
</ul>
<h2 id="6-2-future的wait和get"><a href="#6-2-future的wait和get" class="headerlink" title="6.2 future的wait和get"></a>6.2 future的wait和get</h2><p><code>std::future::get()</code> 和 <code>std::future::wait()</code> 是 C++ 中用于处理异步任务的两个方法。</p>
<ul>
<li><code>std::future::get()</code> 是一个阻塞调用，用于获取 <code>std::future</code> 对象表示的值或异常。如果异步任务还没有完成，<code>get()</code> 会阻塞当前线程，直到任务完成。如果任务已经完成，<code>get()</code> 会立即返回任务的结果。重要的是，<code>get()</code> 只能调用一次，因为它会移动或消耗掉 <code>std::future</code> 对象的状态。一旦 <code>get()</code> 被调用，<code>std::future</code> 对象就不能再被用来获取结果。</li>
<li><code>std::future::wait()</code> 也是一个阻塞调用，但它与 <code>get()</code> 的主要区别在于 <code>wait()</code> 不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，<code>wait()</code> 会立即返回。如果任务还没有完成，<code>wait()</code> 会阻塞当前线程，直到任务完成。与 <code>get()</code> 不同，<code>wait()</code> 可以被多次调用，它不会消耗掉 <code>std::future</code> 对象的状态。</li>
</ul>
<p>这两个方法的主要区别：</p>
<ol>
<li><p><code>std::future::get()</code> 用于获取并返回任务的结果，而 <code>std::future::wait()</code> 只是等待任务完成。</p>
</li>
<li><p><code>get()</code> 只能调用一次，而 <code>wait()</code> 可以被多次调用。</p>
</li>
<li><p>如果任务还没有完成，<code>get()</code> 和 <code>wait()</code> 都会阻塞当前线程，但 <code>get()</code> 会一直阻塞直到任务完成并返回结果，而 <code>wait()</code> 只是在等待任务完成。</p>
</li>
</ol>
<p>补：可以使用<code>std::future</code>的<code>wait_for()</code>或<code>wait_until()</code>方法来检查异步操作是否已完成。这些方法返回一个表示操作状态的<code>std::future_status</code>值。</p>
<h2 id="6-3-任务和future关联"><a href="#6-3-任务和future关联" class="headerlink" title="6.3 任务和future关联"></a>6.3 任务和future关联</h2><p><code>std::packaged_task</code>和<code>std::future</code>是C++11中引入的两个类，它们用于处理异步任务的结果。</p>
<p><code>std::packaged_task</code>是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在<code>std::future</code>对象中，以便以后使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_task</span><span class="params">()</span> </span>&#123;              <span class="comment">//模拟一个任务的函数</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;my task run 5 s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_package</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包装了任务的 std::packaged_task 对象  </span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(my_task)</span></span>;   <span class="comment">//将my_task函数封装到task里，&lt;int()&gt;表示返回值是int，参数是空</span></span><br><span class="line">    <span class="comment">// 获取与任务关联的 std::future 对象  </span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在另一个线程上执行任务  </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task))</span></span>;   <span class="comment">//将task传入到线程里时，必须要用移动构造，packaged_task只支持移动构造</span></span><br><span class="line">    t.<span class="built_in">detach</span>();    <span class="comment">// 将线程与主线程分离，以便主线程可以等待任务完成。将在执行任务的子线程与t解开了(t被回收，任务也不会中断)</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果  </span></span><br><span class="line">    <span class="type">int</span> value = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-promise-用法"><a href="#6-4-promise-用法" class="headerlink" title="6.4 promise 用法"></a>6.4 promise 用法</h2><p>C++11引入了<code>std::promise</code>和<code>std::future</code>两个类，用于实现异步编程。<code>std::promise</code>用于在某一线程中设置某个值或异常，而<code>std::future</code>则用于在另一线程中获取这个值或异常。</p>
<p>在下面的程序中，首先创建了一个<code>std::promise&lt;int&gt;</code>对象，然后通过调用<code>get_future()</code>方法获取与之相关联的<code>std::future&lt;int&gt;</code>对象。然后，我们在新线程中通过调用<code>set_value()</code>方法设置<code>promise</code>的值，并在主线程中通过调用<code>fut.get()</code>方法获取这个值。注意，在调用<code>fut.get()</code>方法时，如果<code>promise</code>的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="comment">// 设置 promise 的值</span></span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);    <span class="comment">//设置主线程需要的值，下面内容无论执行多久，都问题不大了，外部可以通过方法得到这个值</span></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;promise set value success&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    <span class="comment">// 获取与 promise 相关联的 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在新线程中设置 promise 的值</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_value, std::move(prom))</span></span>;       <span class="comment">//必须是移动构造的方式</span></span><br><span class="line">    <span class="comment">// 在主线程中获取 future 的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the value...\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value set by the thread: &quot;</span> &lt;&lt; fut.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;   <span class="comment">//获取子线程中的promise设置的值10</span></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>set_value()</code>方法外，<code>std::promise</code>还有一个<code>set_exception()</code>方法，用于设置异常。该方法接受一个<code>std::exception_ptr</code>参数，该参数可以通过调用<code>std::current_exception()</code>方法获取。在下面这个程序中，子线程是抛出异常，然后自己又捕获异常，捕获异常就是将异常值写入到prom里，这样主线程就可以通过<code>fut.get()</code>方法得到子线程的异常值了。但要注意的是，主线程必须要用<code>try-catch</code>来捕获该异常，不然系统会崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_exception</span><span class="params">(std::promise&lt;<span class="type">void</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出一个异常</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;An error occurred!&quot;</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//子线程在这里捕获抛出的异常</span></span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">//设置promise的异常，将异常的值写入到了prom里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; prom;</span><br><span class="line">    <span class="comment">// 获取与 promise 相关联的 future 对象</span></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">// 在新线程中设置 promise 的异常</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(set_exception, std::move(prom))</span></span>;</span><br><span class="line">    <span class="comment">// 在主线程中获取 future 的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Waiting for the thread to set the exception...\n&quot;</span>;</span><br><span class="line">        fut.<span class="built_in">get</span>();         <span class="comment">//主线程获取子线程抛出来的异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exception set by the thread: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5-共享类型的future"><a href="#6-5-共享类型的future" class="headerlink" title="6.5 共享类型的future"></a>6.5 共享类型的future</h2><p>当多个线程需要等待同一个执行结果时，可以使用<code>std::shared_future</code>，也就是多个线程去等待同一个执行结果，不会出现资源竞争的问题，也不用考虑是否加锁(天生线程安全的)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp;&amp; promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    promise.<span class="built_in">set_value</span>(<span class="number">42</span>);         <span class="comment">// 设置 promise 的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该线程负责获取promise设置的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(std::shared_future&lt;<span class="type">int</span>&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Future error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">use_shared_future</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; promise;</span><br><span class="line">    std::shared_future&lt;<span class="type">int</span>&gt; future = promise.<span class="built_in">get_future</span>(); <span class="comment">//std::future类型会自动转换为std::shared_future类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::thread <span class="title">myThread1</span><span class="params">(myFunction, std::move(promise))</span></span>; <span class="comment">// 将promise移动到线程1中</span></span><br><span class="line">    <span class="comment">// 使用share()方法获取新的shared_future对象，它们都可以获取promise设置的值</span></span><br><span class="line">    <span class="comment">//shared_future是支持拷贝的，所以可以直接传future,但这里也只能这样传值，不能移动构造，因为线程2用了，线程3还要继续用future</span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread2</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread3</span><span class="params">(threadFunction, future)</span></span>;</span><br><span class="line">    myThread1.<span class="built_in">join</span>();</span><br><span class="line">    myThread2.<span class="built_in">join</span>();</span><br><span class="line">    myThread3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补：std::shared_future是支持拷贝的，std::future不支持拷贝，只能移动构造</p>
<h1 id="7-并发设计模式Actor和CSP"><a href="#7-并发设计模式Actor和CSP" class="headerlink" title="7. 并发设计模式Actor和CSP"></a>7. 并发设计模式Actor和CSP</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>在发设计中有两种常用的设计模式，即Actor和CSP模式。传统的并发设计经常都是通过共享内存加锁保证逻辑安全，这种模式有几个缺点：如频繁加锁影响性能、 耦合度高等。而Actor和CSP设计模式恰好可以解决这些缺陷。</p>
<h2 id="7-2-Actor设计模式"><a href="#7-2-Actor设计模式" class="headerlink" title="7.2 Actor设计模式"></a>7.2 Actor设计模式</h2><p>actor通过消息传递的方式与外界通信。消息传递是异步的。每个Actor都有一个邮箱，用于接收其他Actor发送的消息，Actor可以按顺序处理邮箱中的消息。actor一次只能同步处理一个消息，处理消息过程中，除了可以接收消息，不能做任何其他操作。 每一个类独立在一个线程里称作Actor，Actor之间通过队列通信，比如Actor1 发消息给Actor2， Actor2 发消息给Actor1都是投递到对方的队列中。好像给对方发邮件，对方从邮箱中取出一样。</p>
<p>Actor模型的另一个好处就是可以消除共享状态，因为它每次只能处理一条消息，所以actor内部可以安全的处理状态，而不用考虑锁机制。一些网络编程中对于逻辑层的处理就采用了该模式，就是将要处理的逻辑消息封装成包投递给逻辑队列，逻辑类通过单线程的方式从队列中一条一条取出数据消费的思想。</p>
<h2 id="7-3-CSP模式"><a href="#7-3-CSP模式" class="headerlink" title="7.3 CSP模式"></a>7.3 CSP模式</h2><p>CSP称为通信顺序进程，是一种并发编程模型，也是一个很强大的并发数据模型，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于Actor模型，CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。</p>
<p>CSP和Actor类似，只不过CSP将消息投递给channel，不关注谁从channel中取数据和发送的一方是谁。而Actor在发送消息前是知道接收方是谁，接受方收到消息后也知道发送方是谁，更像是邮件的通信模式。而csp是完全解耦合的。</p>
<p>但它们有一个共同的特性：<strong>不要通过共享内存来通信；相反，通过通信来共享内存</strong>。</p>
<h2 id="7-4-CSP模式的实现"><a href="#7-4-CSP模式的实现" class="headerlink" title="7.4 CSP模式的实现"></a>7.4 CSP模式的实现</h2><p>因为go是天然支持csp模式的语言，所以实现起来简单。但c++是一种比较全能的的语言，也可以实现出一种类似于go的channel。下面实现的是类似于生产者和消费者问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">//因为channel可以存放任意类型的数据，所以这里用模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; queue_;              <span class="comment">//存放数据的队列</span></span><br><span class="line">    std::mutex mtx_;                   <span class="comment">//互斥量，用来维护队列的安全性</span></span><br><span class="line">    std::condition_variable cv_producer_;    <span class="comment">//生产者条件变量</span></span><br><span class="line">    std::condition_variable cv_consumer_;    <span class="comment">//消费者条件变量</span></span><br><span class="line">    <span class="type">size_t</span> capacity_;                  <span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">bool</span> closed_ = <span class="literal">false</span>;              <span class="comment">//Channel是否被关闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Channel</span>(<span class="type">size_t</span> capacity = <span class="number">0</span>) : <span class="built_in">capacity_</span>(capacity) &#123;&#125;   <span class="comment">//初始化时，可以先显示的设置容量为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">send</span><span class="params">(T value)</span> </span>&#123;          <span class="comment">//向Channel去投递数据</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;        <span class="comment">//对互斥量进行加锁操作</span></span><br><span class="line">        <span class="comment">//等待锁，判断条件是否满足，不满足就挂起在这里</span></span><br><span class="line">        cv_producer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="comment">// 对于无缓冲的channel，我们应该等待直到有消费者准备好</span></span><br><span class="line">            <span class="built_in">return</span> (capacity_ == <span class="number">0</span> &amp;&amp; queue_.<span class="built_in">empty</span>()) || queue_.<span class="built_in">size</span>() &lt; capacity_ || closed_;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="comment">//当队列没有数据并且初始化了一个无缓冲的channel 或 初始化的容量不为0并且队列长度还没有达到容量 或 close 都不挂起</span></span><br><span class="line">        <span class="keyword">if</span> (closed_) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//如果是关闭了，说明要退出，直接返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有关闭，就往队列里放数据</span></span><br><span class="line">        queue_.<span class="built_in">push</span>(value);</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_one</span>();      <span class="comment">//通知消费者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">receive</span><span class="params">(T&amp; value)</span> </span>&#123;           <span class="comment">//向Channel去取数据</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;          <span class="comment">//对互斥量加速</span></span><br><span class="line">        <span class="comment">//等待锁，判断条件是否满足，不满足就挂起在这里</span></span><br><span class="line">        cv_consumer_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>() || closed_; &#125;);</span><br><span class="line">        <span class="comment">//当队列不为空 或 关闭了 都不挂起</span></span><br><span class="line">        <span class="keyword">if</span> (closed_ &amp;&amp; queue_.<span class="built_in">empty</span>()) &#123;      <span class="comment">//如果关闭了，并且队列为空，就直接退出，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有关闭，就直接从队列取数据消费</span></span><br><span class="line">        value = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        cv_producer_.<span class="built_in">notify_one</span>();      <span class="comment">//提醒生产者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        closed_ = <span class="literal">true</span>;            <span class="comment">//将关闭置为true</span></span><br><span class="line">        <span class="comment">//通知所有的生产者和消费者，要退出了</span></span><br><span class="line">        cv_producer_.<span class="built_in">notify_all</span>();</span><br><span class="line">        cv_consumer_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Channel&lt;<span class="type">int</span>&gt; <span class="title">ch</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 10缓冲的channel，如果是0的话，即无容量，就是同步应用了，生产者放，消费者马上就取</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;]() &#123;              <span class="comment">//启动一个生产者线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            ch.send(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Sent: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        ch.close();      <span class="comment">//向channel投递数据，投递完了就关闭</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;]() &#123;              <span class="comment">//启动一个消费者线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">500</span>)); <span class="comment">// 故意延迟消费者开始消费</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> val;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//当消费者生成完指定数据后就不生产了，而close为true了，所以receive会返回false，退出循环、消费者线程</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (ch.receive(val)) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-原子操作和内存模型"><a href="#8-原子操作和内存模型" class="headerlink" title="8. 原子操作和内存模型"></a>8. 原子操作和内存模型</h1><h2 id="8-1-改动序列"><a href="#8-1-改动序列" class="headerlink" title="8.1 改动序列"></a>8.1 改动序列</h2><p>在一个C++程序中，每个对象都具有一个改动序列，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。 大部分情况下，这个序列会随程序的多次运行而发生变化，但是在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列(要么都从头开始修改，要么都从尾开始修改)。</p>
<p>改动序列基本要求如下：</p>
<ul>
<li>只要某线程看到过某个对象，则该线程的后续读操作必须获得相对最近的值，并且，该线程就同一对象的后续写操作，必然出现在改动序列后方(基于上一次的改动)。</li>
<li>如果某线程先向一个对象写数据，过后再读取它，那么必须读取前面写的值。</li>
<li>若在改动序列中，上述读写操作之间还有别的写操作，则必须读取最后写的值。</li>
<li>在程序内部，对于同一个对象，全部线程都必须就其形成相同的改动序列，并且在所有对象上都要求如此。</li>
<li>多个对象上的改动序列只是相对关系，线程之间不必达成一致。</li>
</ul>
<h2 id="8-2-原子类型"><a href="#8-2-原子类型" class="headerlink" title="8.2 原子类型"></a>8.2 原子类型</h2><p>标准原子类型的定义位于头文件<code>&lt;atomic&gt;</code>内。可以通过<code>atomic&lt;&gt;</code>定义一些原子类型的变量，如<code>atomic&lt;bool&gt;</code>,<code>atomic&lt;int&gt;</code> 这些类型的操作全是原子化的。</p>
<p>从C++17开始，所有的原子类型都包含一个静态常量表达式成员变量<code>std::atomic::is_always_lock_free</code>，它能够返回一个结构在任意给定的目标硬件上是否支持不加锁(无锁结构形式实现)。如果在所有支持该程序运行的硬件上，原子类型X都以无锁结构形式实现，那么这个成员变量的值就为true；否则为false。</p>
<p><code>std::atomic_flag</code> 是唯一一个不提供<code>is_lock_free()</code>成员函数的原子类型。因为 <code>std::atomic_flag</code> 本身就是设计为一个简单的、无锁的原子操作。它的操作(设置和清除)总是无锁的，因此不需要 <code>is_lock_free()</code> 函数来查询是否可以无锁执行。</p>
<p>类型<code>std::atomic_flag</code>的对象在初始化时清零，随后即可通过成员函数<code>test_and_set()</code>查值并设置成立，或者由<code>clear()</code>清零。整个过程只有这两个操作。其他的<code>atomic&lt;&gt;</code>的原子类型都可以基于其实现。</p>
<p>总的来说，<code>std::atomic_flag</code>的<code>test_and_set</code>成员函数是一个原子操作，他会先检查<code>std::atomic_flag</code>当前的状态是否被设置过。如果没有被设置过(比如初始状态或者清除后)，将<code>std::atomic_flag</code>当前的状态设置为<code>true</code>，并返回<code>false</code>；如果被设置过则直接返回<code>true</code>。</p>
<p>对于<code>std::atomic&lt;T&gt;</code>类型的原子变量，还支持<code>load()</code>和<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>等操作。</p>
<h2 id="8-3-内存次序"><a href="#8-3-内存次序" class="headerlink" title="8.3 内存次序"></a>8.3 内存次序</h2><p>对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类<code>std::memory_order</code>中取值，用于设定所需的内存次序语义。枚举类<code>std::memory_order</code>具有6个可能的值，包括<code>std::memory_order_relaxed</code>、<code>std:: memory_order_acquire</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acq_rel</code>、<code>std::memory_order_release</code>和 <code>std::memory_order_seq_cst</code>。</p>
<ol>
<li><p>存储（<code>store</code>）操作，可选用的内存次序有：</p>
<ul>
<li><code>std::memory_order_relaxed</code>、<code>std::memory_order_release</code>、<code>std::memory_order_seq_cst</code></li>
</ul>
</li>
<li><p>载入（<code>load</code>）操作，可选用的内存次序有：</p>
<ul>
<li><code>std::memory_order_relaxed</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acquire</code>、<code>std::memory_order_seq_cst</code></li>
</ul>
</li>
<li><p>读-改-写(<code>read-modify-write</code>)操作，可选用的内存次序有：</p>
<ul>
<li><code>std::memory_order_relaxed</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acquire</code>、<code>std::memory_order_release</code>、<code>std::memory_order_acq_rel</code>、<code>std::memory_order_seq_cst</code></li>
</ul>
</li>
</ol>
<p>原子操作默认使用的是<code>std::memory_order_seq_cst</code>次序。这六种内存顺序相互组合可以实现三种顺序模型：</p>
<ul>
<li><p><code>Sequencial consistent ordering</code>：实现同步, 且保证全局顺序一致的模型，是一致性最强的模型, 也是默认的顺序模型</p>
</li>
<li><p><code>Acquire-release ordering</code>：实现同步, 但不保证保证全局顺序一致的模型</p>
</li>
<li><p><code>Relaxed ordering</code> ：不能实现同步, 只保证原子性的模型</p>
</li>
</ul>
<h2 id="8-4-自旋锁的实现"><a href="#8-4-自旋锁的实现" class="headerlink" title="8.4 自旋锁的实现"></a>8.4 自旋锁的实现</h2><p>自旋锁是一种在多线程环境下保护共享资源的同步机制。它的基本思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，那么该线程就会不断地循环检查锁的状态，直到成功获取到锁为止。</p>
<p>下面程序是使用<code>std:atomic_flag</code>实现的一个自旋锁，flag初始化为0，当线程1先获得锁后，它会将flag的值设为1，并返回false，这样就不会进入循环，表示加锁成功。当线程2准备进行加锁时，发现flag的值已经被设置为1，所以就返回true，进入循环，不断的检查flag的值来判断。只有当线程1执行完任务后，解锁将flag的值重新设为0时，线程2检查到flag的值为0后，将其设为1，并返回false，才退出循环，表示它加锁成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//test_and_set相当于是读改写，可以通过memory_order_acquire来设置</span></span><br><span class="line">        <span class="comment">//逻辑：先检查当前的一个值flag，如果是初始状态，就设置为成立状态(1),并返回false(不循环);如果是成立状态，就不用设置1了，直接返回true(要循环)</span></span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));      <span class="comment">//自旋等待，直到成功获取到锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);    <span class="comment">//释放锁，将flag清0</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//定义了一个最基础的原子类型flag，并初始化为一个无效的状态(0)，</span></span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是测试函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestSpinLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SpinLock spinlock;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;*&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;spinlock]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.lock();</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;?&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        spinlock.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-5-宽松内存序-memory-order-relaxed"><a href="#8-5-宽松内存序-memory-order-relaxed" class="headerlink" title="8.5 宽松内存序(memory_order_relaxed)"></a>8.5 宽松内存序(memory_order_relaxed)</h2><p>下面是CPU的一个内存结构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_1.jpg"></p>
<p>其中<code>StoreBuffer</code>就是一级Cache，<code> Catche</code>是二级Cache，<code>Memory</code>是三级Cache。每个CPU都有一个专属的<code>StoreBuffer</code>，其对<code>StoreBuffer</code>的操作对其它的CPU是不可见的。</p>
<p>每个标识CPU的块就是core，上图画的就是4核结构。每两个core构成一个bank，共享一个cache。四个core共享memory。</p>
<p>每个CPU会在任何时刻将<code>StoreBuffer</code>中结果写入到cache或者memory中。如果CPU1往Catche里面写数据，CPU2也往Catche里面写数据，并且写的是同一个变量，数据就乱了。所以就得通过<code>MESI</code>一致性协议来保证数据一致性。</p>
<p><code>MESI</code>协议，是一种叫作写失效的协议。在写失效协议里，只有一个 CPU 核心负责写入数据，其他的核心，只是同步读取到这个写入。在这个 CPU 核心写入 cache 之后，它会去广播一个“失效”请求告诉所有其他的 CPU 核心。</p>
<p>MESI 协议对应的四个不同的标记，分别是：</p>
<ul>
<li><p>M：代表已修。用来告诉其他CPU已经修改完成，其他CPU可以向cache中写入数据</p>
</li>
<li><p>E：代表独占。表示数据只是从Catche加载到当前CPU核的storebuffer中，其他的CPU核，并没有加载对应的数据到自己的storebuffer里。这个时候，如果要向独占的storebuffer写入数据，我们可以自由地写入数据，而不需要告知其他CPU核。</p>
</li>
<li><p>S：代表共享。就是在多核中同时加载了同一份数据到自己的StoreBuffer。所以在共享状态下想要修改数据要先向所有的其他CPU核心广播一个请求，要求先把其他CPU核心里面的cache，都变成无效的状态，然后再更新当前cache里面的数据。</p>
</li>
<li><p>I：代表已失效。如果变量a此刻在各个cpu的StoreBuffer中，那么CPU1核修改这个a的值，放入cache时通知其他CPU核写失效，因为同一时刻仅有一个CPU核可以写数据，但是其他CPU核是可以读数据的，那么其他核读到的数据可能是CPU1核修改之前的。这就涉及我们提到的改动序列了。</p>
</li>
</ul>
<p>关于两个改动序列的术语：</p>
<ol>
<li><p>“<code>synchronizes-with</code>“ : 同步, “A <code>synchronizes-with</code> B” 的意思就是 A和B同步，简单来说如果多线程环境下，有一个线程先修改了变量m，我们将这个操作叫做A，之后有另一个线程读取变量m，我们将这个操作叫做B，那么B一定读取A修改m之后的最新值。也可以称作 A “<code>happens-before</code>“ B，即A操作的结果对B操作可见。</p>
</li>
<li><p>“<code>happens-before</code>“ : 先行，”A <code>happens-before</code> B” 的意思是如果A操作先于B操作，那么A操作的结果对B操作可见。”<code>happens-before</code>“包含很多种境况，不仅仅是上面提到的”<code>synchronizes-with</code>“。</p>
</li>
</ol>
<p> 关于<code>std::memory_order_relaxed</code>具备如下几个功能：</p>
<ol>
<li>作用于原子变量</li>
<li>不具有<code>synchronizes-with</code>关系，即如果线程1对m进行写，由0变成1，线程2读到的很有可能是0</li>
<li>对于同一个原子变量，在同一个线程中具有<code>happens-before</code>关系；<strong>在同一线程中不同的原子变量不具有<code>happens-before</code>关系，可以乱序执行</strong></li>
<li>多线程情况下不具有<code>happens-before</code>关系</li>
</ol>
<p>在下面程序中，<code>write_x_then_y()</code>是先写x再写y，都写为true；<code>read_y_then_x()</code>是先读y，再读x，最后通过<code>TestOrderRelaxed()</code>来调用实现，看是否会出现断言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;     <span class="comment">//定义bool类型的原子变量</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;         <span class="comment">//定义int类型的原子变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;             <span class="comment">//存储x和y</span></span><br><span class="line">    <span class="comment">//对于store的处理，为什么对x的处理不能先于y，因为设置的内存序是宽松的，不能保证线程按照这个顺序依次去执行，在cpu底层会对这两条代码进行编排，很有可能y会先被执行</span></span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);      <span class="comment">//1.先把x值存为true</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);      <span class="comment">//2.再把y值存为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;             <span class="comment">//读取y和x</span></span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;   <span class="comment">//3.取出y值</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;       <span class="comment">//4.取出x值</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是函数调用实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;            <span class="comment">//初始化为false</span></span><br><span class="line">    y = <span class="literal">false</span>;            <span class="comment">//初始化为false</span></span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;     <span class="comment">//启动线程1，表示先写x再写y</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;      <span class="comment">//启动线程2，表示先读y再度x</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">//5.()里面等于false时，就会崩掉，弹出一个断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从CPU架构分析：假设线程t1运行在CPU1上，t2运行在CPU3上，那么t1对x和y的操作，t2是看不到的。比如当线程t1运行至1处将x设置为true，t1运行至2处将y设置为true。这些操作仅在CPU1的storebuffer中，还未放入cache和memory中，CPU2和CPU3自然不知道。如果CPU1先将y放入memory，那么CPU3就会读取y的值为true。那么t2就会运行至3处从while循环退出，进而运行至4处，此时CPU1还未将x的值写入memory，t2读取的x值为false，进而线程t2运行结束，然后CPU1将x写入true，t1结束运行，最后主线程运行至5处，因为z为0，所以触发断言。</p>
<p>从宽松内存序分析：因为<code>memory_order_relaxed</code>是宽松的内存序列，它只保证操作的原子性，并不能保证多个变量之间的顺序性，也不能保证同一个变量在不同线程之间的可见顺序。可以理解为不能保证可见的及时性，但如果有修改，迟早是可见的。</p>
<p>在下面程序中，线程1和线程2往里面去写值，线程3和线程4往a里面去读值分别存到v3和v4中。需要注意的是，虽然线程1和线程2是抢着去修改a，但它们的操作一定是满足原子性的，即两个线程去修改，只有其中一个线程修改完，另一个线程才会去修改。而读也能保证一个原子性，即线程3和线程4读出来的数据a，一定是某一时刻线程1或线程2对a修改的一个值，但读到的可能不是最新的，所以就可能是一堆乱序的效果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOderRelaxed2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; a&#123;<span class="number">0</span>&#125;;              <span class="comment">//定义一个原子变量a</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v3, v4;            <span class="comment">//用来读取存储到的值</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;a]() &#123;             <span class="comment">//线程1往a存0,2,4,6,8</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;    </span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;a]() &#123;                       <span class="comment">//线程2往a存1,3,5,7,9</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">            a.store(i, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;v3, &amp;a]() &#123;                 <span class="comment">//线程3是从a里面取10个值，存到v3里</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v3.push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">([&amp;v4, &amp;a]() &#123;                <span class="comment">//线程4是从a里面取10个值，存到v4里</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">            v4.push_back(a.load(std::memory_order_relaxed));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>(); </span><br><span class="line">    t3.<span class="built_in">join</span>(); </span><br><span class="line">    t4.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v3) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : v4) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序，如果v3中7先于6，8，9等，那么v4中也是7先于6，8，9。总的来说，<code>memory_order_relaxed</code>保证了多线程对同一个变量的原子操作的安全性，只是可见性会有延迟。</p>
<h2 id="8-6-先行-Happens-before"><a href="#8-6-先行-Happens-before" class="headerlink" title="8.6 先行(Happens-before)"></a>8.6 先行(Happens-before)</h2><p><code>Happens-before</code> 是一个非常重要的概念。如果操作 a “<code>happens-before</code>” 操作 b，则操作 a 的结果对于操作 b 可见。<code>happens-before</code> 的关系可以建立在用一个线程的两个操作之间，也可以建立在不同的线程的两个操作之间。</p>
<p>顺序先行(sequenced-before)：单线程情况下前面的语句先执行，后面的语句后执行。操作a先于操作b，那么操作b可以看到操作a的结果。我们称操作a顺序先行于操作b。也就是”a sequenced-before b”。</p>
<p>线程间先行：</p>
<p>依赖关系：单线程情况下a “sequenced-before” b, 且 b 依赖 a 的数据, 则 a “carries a dependency into” b. 称作 a 将依赖关系带给 b, 也理解为b依赖于a。</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++并发编程(中)</title>
    <url>/2024/07/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="1-内存顺序和内存模型使用实现"><a href="#1-内存顺序和内存模型使用实现" class="headerlink" title="1. 内存顺序和内存模型使用实现"></a>1. 内存顺序和内存模型使用实现</h1><h2 id="1-1-sequencial-consistent模型-最严格的"><a href="#1-1-sequencial-consistent模型-最严格的" class="headerlink" title="1.1 sequencial consistent模型(最严格的)"></a>1.1 sequencial consistent模型(最严格的)</h2><p><code>memory_order_seq_cst</code>代表全局一致性顺序，可以用于 <code>store</code>、 <code>load</code> 和 <code>read-modify-write</code> 操作实现 <code>sequencial consistent</code>的顺序模型。在这个模型下, 所有线程看到的所有操作都有一个一致的顺序，即使这些操作可能针对不同的变量，运行在不同的线程。</p>
<p>在下面程序中，线程1修改完x和y的值，线程2立刻就能见到x和y修改的值，所以当线程2读到y为true时就会退出循环，然后读到的x也一定为true。因为需要保证与线程1修改顺序是一致的，线程1修改了x再修改y，当线程1修改完y的时候，x早就被修改为true了，所以当线程2读到了y为true时，接下来读到的x也一定为true。这样的话，z就是从0变为1，就不会发生断言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;       <span class="comment">//定义两个bool类型的原子变量</span></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;           <span class="comment">//定义一个int类型的原子变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先写x再写y，采用的顺序是全局一次性顺序</span></span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);       <span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);       <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先读y再读x，采用的顺序也是全局一次性顺序，</span></span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;       <span class="comment">// 3.当y得到的是false时，就退出循环</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;y load false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;      <span class="comment">//4.如果x为true的情况，就++z</span></span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);                <span class="comment">// 5.当z还为0的时候，就会触发断言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>sequencial consistent</code>模型有一定的开销，现代 CPU 通常有多核，每个核心还有自己的缓存。为了做到全局顺序一致，每次写入操作都必须同步给其他核心(也就是一个核心写的时候，其它核心读都不能读，必须等该核心写完后同步到memory中，其它核心才能读)。为了减少性能开销，如果不需要全局顺序一致，我们应该考虑使用更加宽松的顺序模型，比如<code>Acquire-release</code>和<code>Relaxed</code>模型。</p>
<h2 id="1-2-relaxed模型-最宽松的"><a href="#1-2-relaxed模型-最宽松的" class="headerlink" title="1.2 relaxed模型(最宽松的)"></a>1.2 relaxed模型(最宽松的)</h2><p><code>memory_order_relaxed</code>可以用于<code>store</code>、<code>load</code>和<code>read-modify-write</code>操作, 实现<code>relaxed</code>的顺序模型。在这种模型下只能保证操作的原子性和修改顺序(modification order)一致性(但改完了不一定立刻能见到)，无法实现<code>synchronizes-with</code>的关系。</p>
<p>在下面程序中，是存在隐患的，即可能会发生断言，但因为现在c++尽可能的帮外面规避了这些问题，所以执行结果很难会出现断言崩溃，但还是尽量不这样编写程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestOrderRelaxed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_relaxed); <span class="comment">// 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_relaxed));   <span class="comment">//3.当ry被修改为true时，会执行循环里面的语句</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed));    <span class="comment">//4.虽然ry被修改为true，但rx因为某些原因还是可能为false</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Acquire-Release模型-最常用的"><a href="#1-3-Acquire-Release模型-最常用的" class="headerlink" title="1.3 Acquire-Release模型(最常用的)"></a>1.3 Acquire-Release模型(最常用的)</h2><p>在 <code>acquire-release</code>模型中, 会使用<code>memory_order_acquire</code>、<code>memory_order_release</code>和<code>memory_order_acq_rel</code>这三种内存顺序。它们的具体用法：</p>
<ul>
<li><p>对原子变量的 load 可以使用 memory_order_acquire 内存顺序，这称为 acquire 操作</p>
</li>
<li><p>对原子变量的 store 可以使用 memory_order_release 内存顺序，这称为 release 操作</p>
</li>
<li><p>read-modify-write 操作即读(load)又写(store)，它可以使用memory_order_acquire, memory_order_release 和 memory_order_acq_rel：</p>
<ul>
<li>如果使用 memory_order_acquire，则作为 acquire 操作</li>
<li>如果使用 memory_order_release，则作为 release 操作</li>
<li>如果使用 memory_order_acq_rel，则同时为两者</li>
</ul>
</li>
</ul>
<p><code>Acquire-release</code>可以实现<code>synchronizes-with</code>的关系。如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值，则这个 release 操作 “synchronizes-with” 这个 acquire 操作。</p>
<p>在下面的程序中，对rx进行story和load使用的都是宽松的内存顺序，但对ry采用的是同步的内存顺序。如果线程2先运行，由于ry还是false，所以会一直执行循环，直到ry为true。当ry为true时，3处会退出循环，执行4处，由于线程1中ry都已经修改，所以rx也被修改，则4处的断言就不会发生。由于release在acquire之前，就构成了同步关系，2同步给了3，即2在3之前执行。</p>
<p>从cpu指令角度理解，如果编译器发现了一个store操作，且是release内存顺序，也发现了之前操作也是store，不管该store操作是什么内存顺序，编译器都会先把该store写入内存，再把该release的store写入内存。所以当线程2中把ry读到为true时，rx也一定被修改为了true，这样就不会发生断言的情况了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestReleaseAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; rx, ry;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        rx.store(<span class="literal">true</span>, std::memory_order_relaxed);      <span class="comment">// 1.写，对rx进行releaxed操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ry.store(<span class="literal">true</span>, std::memory_order_release);      <span class="comment">// 2.写，对ry进行release操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!ry.load(std::memory_order_acquire));     <span class="comment">//3读，进行的是acquire操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(rx.load(std::memory_order_relaxed));      <span class="comment">//4读，进行的是relaxed操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Acquire-release</code>的开销比<code>sequencial consistent</code>小。在 x86 架构下，<code>memory_order_acquire</code>和<code>memory_order_release</code>的操作不会产生任何其他的指令(它们两个操作的中间是原子化的)，只会影响编译器的优化。<strong>任何指令都不能重排到acquire操作的前面，且不能重排到release操作的后面</strong>。否则会违反 acquire-release 的语义。因此很多需要实现<code>synchronizes-with</code>关系的场景都会使用 <code>acquire-releas</code>。</p>
<p>还有一种情况，多个线程对同一个变量release操作，另一个线程对这个变量acquire，那么只有一个线程的release操作和这个acquire线程构成同步关系。在下面程序中，线程1对xd和yd都做了存储操作，线程2只对yd进行存储操作，而在线程3中，断言语句是可能被触发的，因为操作2和操作4是构成同步关系的，操作3和操作4也是构成同步关系的，这种情况下，只有一个会与操作4构成同步关系。如果是操作3和操作4构成同步关系，断言就会触发；如果是操作2和操作4构成同步关系，断言就不会触发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleasAcquireDanger2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; xd&#123;<span class="number">0</span>&#125;, yd&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; zd;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        xd.store(<span class="number">1</span>, std::memory_order_release);  <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//  (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        yd.store(<span class="number">2</span>, std::memory_order_release);  <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!yd.load(std::memory_order_acquire)); <span class="comment">//（4）</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(xd.load(std::memory_order_acquire) == <span class="number">1</span>); <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-release-sequence"><a href="#1-4-release-sequence" class="headerlink" title="1.4 release sequence"></a>1.4 release sequence</h2><p>针对一个原子变量M的<code>release</code>操作A完成后，接下来M上可能还会有一连串的其他操作。如果这一连串操作是由同一线程上的写操作或任意线程上的<code>read-modify-write</code>操作这两种构成的，则称这一连串的操称为以<code>release</code>操作A为首的<code>release sequence</code>。 这里的写操作和<code>read-modify-write</code>操作可以使用任意内存顺序。</p>
<p>如果一个<code>acquire</code>操作在同一个原子变量上读到了一个<code>release</code>操作写入的值，或者读到了以这个<code>release</code>操作为首的<code>release sequence</code>写入的值，那么这个release操作 “synchronizes-with” 这个acquire操作。</p>
<p>在下面程序中，可以知道操作2和操作3构成release sequence，而操作4也需要读到这个操作的最后一个结果(flag为2)，则操作2和操作4构成同步关系。有因为操作1在操作2之前，操作5在操作4之后，所以最后不会触发断言问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReleaseSequence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; flag&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        data.push_back(<span class="number">42</span>);  <span class="comment">//(1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        flag.store(<span class="number">1</span>, std::memory_order_release); <span class="comment">//(2)对flag进行修改为1，以下是以操作2为首的release sequence</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//对flasg进行读改写，如果flag不等于expected,就返回false,循环一直执行；相等的时候，就会把flag改为2，并返回true，退出循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_relaxed)) <span class="comment">// (3)</span></span></span></span><br><span class="line"><span class="params"><span class="function">            expected = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>); <span class="comment">// (4)当flag等于2时，循环会退出</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data.at(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// (5)判断断言</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-memory-order-consume"><a href="#1-5-memory-order-consume" class="headerlink" title="1.5 memory_order_consume"></a>1.5 memory_order_consume</h2><p><code>memory_order_consume</code> 其实是 <code>acquire-release</code> 模型的一部分，但是它比较特殊，它涉及到数据间相互依赖的关系，也可以理解为是同步关系。</p>
<p><code>memory_order_consume</code>可以用于 load 操作，使用 memory_order_consume 的 load 称为 consume 操作。如果一个 consume 操作在同一个原子变量上读到了一个 release 操作写入的值，或以其为首的 release sequence 写入的值，则这个 release 操作 “dependency-ordered before” 这个 consume 操作。</p>
<p>在下面程序中，操作3和操作4构成了依赖关系，也就是操作3在操作4之前执行的，也可以理解为同步关系。因为操作1发生在操作3之前，操作5发生在操作6之后，所以操作5不会发生断言问题；而memory_order_consumer要考虑依赖关系，data并不依赖p，所以data可能不等于42，所以操作6可能触发断言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConsumeDependency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p = <span class="keyword">new</span> std::string(<span class="string">&quot;Hello World&quot;</span>);    <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        data = <span class="number">42</span>;                                          <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        ptr.store(p, std::memory_order_release);            <span class="comment">// (3)把p的值写入ptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::string* p2;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (!(p2 = ptr.load(std::memory_order_consume))); <span class="comment">// (4)对ptr进行读取，空就执行循环，不空就退出循环</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(*p2 == <span class="string">&quot;Hello World&quot;</span>);                        <span class="comment">// (5)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        assert(data == <span class="number">42</span>);                                  <span class="comment">// (6)</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-内存模式实现单例模式"><a href="#1-6-内存模式实现单例模式" class="headerlink" title="1.6 内存模式实现单例模式"></a>1.6 内存模式实现单例模式</h2><p>之前用智能指针双重检测方式实现的单例模式是存在线程安全问题的，但可以通过内存模式来实现单例模式，这样可以解决改弊端。在底层，new一个对象再赋值给变量时会存在多个指令顺序。</p>
<p>第一种情况：</p>
<ol>
<li>为对象allocate一块内存空间</li>
<li>调用construct构造对象</li>
<li>将构造到的对象地址返回</li>
</ol>
<p>第二种情况：</p>
<ol>
<li>为对象allocate一块内存空间</li>
<li>先将开辟的空间地址返回</li>
<li>调用construct构造对象</li>
</ol>
<p>如果是第二种情况，当还未构造对象就将地址返回赋值给single，而此时有线程运行至1处判断single不为空直接返回单例实例，如果该线程调用这个单例的成员函数就会崩溃(结合代码看)。</p>
<p>下面就分别是通过智能指针和内存模型的方法实现单例模式：</p>
<div class="tabs" id="test4"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="test4-1">智能指针方法</button><button type="button" class="tab " data-href="test4-2">内存模式方法</button></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>在下面这个程序，在4处虽然allocate开辟了一块空间，并返回给single(不为空了)，但还没有调用construct，如果其它线程此时在1处用了single，因为不为空，就直接返回了single，并且调用了成员函数，就会出现系统崩溃。所以，实际上，1处和4处是会出现线程安全的，即4处还没有完全结束，就会返回一个还没有构造好的对象把地址返回了，而其它线程判断不为空，就会使用这个没有构造好的对象，就会产生崩溃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleAuto</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleAuto</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleAuto</span>(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleAuto&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleAuto&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleAuto</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">// 3处</span></span><br><span class="line">        <span class="keyword">if</span> (single != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleAuto&gt;(<span class="keyword">new</span> SingleAuto);</span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleAuto&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content" id="test4-2"><p>在下面程序中，因为锁的权力是最大的，它能保证所有看到的线程是一致的，所以3处有宽松的模型没有问题的。最后，因为是在4处的代码完全执行后，_b_init才会被设置为true，其它线程才能通过1处进入函数执行(对1处有加锁)。而智能指针的方式就是因为没有这种方法对1处加锁，所以其它线程随时都可以判断single是否为空，这样4处还没有完全执行完时，其它线程就可能判断single不为空，而直接返回使用没有完全构造好的对象了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用智能指针解决释放问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMemoryModel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">SingleMemoryModel</span>(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingleMemoryModel&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMemoryModel&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">SingleMemoryModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;single auto delete success &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; <span class="title">GetInst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1处 在这里，只有读到_b_init为true,才会返回single使用</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//如果为true，说明之前初始化过，直接返回使用即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2处</span></span><br><span class="line">        s_mutex.<span class="built_in">lock</span>();    <span class="comment">//如果多个线程经过1都为false，在这里就只有一个线程会加锁，加锁成功就执行下面</span></span><br><span class="line">        <span class="comment">// 3处 由于锁的保护(锁要求全局看到的都是一致的)，在其它线程将_b_init设为true后，另外一个线程在这里不管用什么内存序，读到的都是true</span></span><br><span class="line">        <span class="keyword">if</span> (_b_init.<span class="built_in">load</span>(std::memory_order_relaxed))    <span class="comment">//进来的线程判断，如果变为true了，就解锁返回，直接使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4处</span></span><br><span class="line">        single = std::<span class="built_in">shared_ptr</span>&lt;SingleMemoryModel&gt;(<span class="keyword">new</span> SingleMemoryModel);</span><br><span class="line">        _b_init.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);    <span class="comment">//这里是只有在4处执行完后，才将_b_init设为true</span></span><br><span class="line">        s_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::shared_ptr&lt;SingleMemoryModel&gt; single;</span><br><span class="line">    <span class="type">static</span> std::mutex s_mutex;</span><br><span class="line">    <span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; _b_init ;         <span class="comment">//定义一个原子类型的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;SingleMemoryModel&gt; SingleMemoryModel::single = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex SingleMemoryModel::s_mutex;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; SingleMemoryModel::_b_init = <span class="literal">false</span>;       <span class="comment">//将改变量初始化为false，没有还没有实例化指针</span></span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<h1 id="2-无锁队列实现"><a href="#2-无锁队列实现" class="headerlink" title="2. 无锁队列实现"></a>2. 无锁队列实现</h1><p>下面主要是通过无锁队列的方式来实现无锁并发。</p>
<h2 id="2-1-无锁队列"><a href="#2-1-无锁队列" class="headerlink" title="2.1 无锁队列"></a>2.1 无锁队列</h2><p>要实现无锁并发，经常会用到一种结构无锁队列，而无锁队列和在数据结构经常使用的队列颇有不同，它采用的是环状的队列结构，至于为什么成环？主要有两个好处，一个是成环的队列大小是固定的，另外一个我们通过移动头和尾就能实现数据的插入和取出。</p>
<h2 id="2-2-用锁实现环形队列"><a href="#2-2-用锁实现环形队列" class="headerlink" title="2.2 用锁实现环形队列"></a>2.2 用锁实现环形队列</h2><p>下面就是用锁实现环形队列，在push和pop时分别加锁，并通过head和tail计算队列是否为满或者空。最后通过测试代码，在添加完5个元素后，已经满了，再添加，是添加不进去的；弹出完5个元素后，再弹出，也是弹不出来的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="comment">//继承自 std::allocator&lt;T&gt;，这意味着可以管理内存分配和释放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueLk</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;   <span class="comment">//定义一个模板类 CircularQueLk，接受类型参数T和大小参数Cap</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//初始化最大大小、使用分配器的allocate函数分配队列的内存、将头指针和尾指针设置为0。</span></span><br><span class="line">    <span class="built_in">CircularQueLk</span>() :_max_size(Cap + <span class="number">1</span>),_data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//删除拷贝构造和拷贝赋值运算符</span></span><br><span class="line">    <span class="built_in">CircularQueLk</span>(<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueLk&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueLk&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CircularQueLk</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt;  <span class="title">lock</span><span class="params">(_mtx)</span></span>;    <span class="comment">//获取锁，以确保线程安全</span></span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;                    <span class="comment">//依次销毁队列中的元素</span></span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head+<span class="number">1</span>）% _max_size;               <span class="comment">//销毁完当前元素，head++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);    <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;    <span class="comment">//emplace 是一个模板函数，接受可变参数列表 Args，允许插入不同类型的参数</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;     <span class="comment">//加锁</span></span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;             <span class="comment">//判断队列是否满了</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                  <span class="comment">//满了就直接退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//插入成功就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);                <span class="comment">//左值引用的插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));     <span class="comment">//右值引用的插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mtx)</span></span>;          <span class="comment">//加锁</span></span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;                    <span class="comment">//判断是否为空</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                        <span class="comment">//为空就直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);        <span class="comment">//这行不添加也可以</span></span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;        <span class="comment">//出队了，头部指针++</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;                  <span class="comment">//存储队列的最大容量</span></span><br><span class="line">    T* _data;                          <span class="comment">//是一个指向队列元素的指针</span></span><br><span class="line">    std::mutex _mtx;                   <span class="comment">//是一个互斥锁，用于同步访问队列</span></span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;                  <span class="comment">//头部指针</span></span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;                  <span class="comment">//尾部指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------下面是测试-------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestCircularQue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建了一个CircularQueLk类型的实例cq_lk，模板参数MyClass表示队列存储的元素类型，5 表示队列的最大容量。</span></span><br><span class="line">    CircularQueLk&lt;MyClass, <span class="number">5</span>&gt; cq_lk;</span><br><span class="line">    <span class="comment">//创建了两个 MyClass 类型的对象 mc1 和 mc2，分别初始化为值 1 和 2。</span></span><br><span class="line">    <span class="function">MyClass <span class="title">mc1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">mc2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc1);                 <span class="comment">//通过左值引用的方式添加元素</span></span><br><span class="line">    cq_lk.<span class="built_in">push</span>(std::<span class="built_in">move</span>(mc2));      <span class="comment">//通过右值引用的方式添加元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="function">MyClass <span class="title">mc</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">push</span>(mc);      <span class="comment">//通过左值引用的方式添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cq_lk.<span class="built_in">push</span>(mc2);              <span class="comment">//左值添加元素，但满了，添加不进行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        MyClass mc1;</span><br><span class="line">        <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);     <span class="comment">//弹出元素5次</span></span><br><span class="line">        <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pop success, &quot;</span> &lt;&lt; mc1 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> res = cq_lk.<span class="built_in">pop</span>(mc1);      <span class="comment">//继续弹出元素，但空了，弹不成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-无锁队列"><a href="#2-3-无锁队列" class="headerlink" title="2.3 无锁队列"></a>2.3 无锁队列</h2><p>如果用原子变量而不是用锁实现环形队列，那就是无锁并发的队列了。下面是之前用过的原子变量的读改写操作，<code>compare_exchange_strong</code>会比较原子变量<code>atomic&lt;T&gt;</code>的值和<code>expected</code>的值是否相等，如果相等则执行交换操作，将<code>atomic&lt;T&gt;</code>的值换为<code>desired</code>并且返回true，否则将expected的值修改为<code>atomic&lt;T&gt;</code>的值，并且返回false。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_weak</span>(T &amp;expected, T desired);</span><br><span class="line"><span class="type">bool</span> std::atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired);</span><br></pre></td></tr></table></figure>

<p>用代码来理解就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> atomic&lt;T&gt;::<span class="built_in">compare_exchange_strong</span>(T &amp;expected, T desired) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_val == expected)&#123;</span><br><span class="line">        m_val = desired;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        expected = m_val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>compare_exchange_weak</code>功能比<code>compare_exchange_strong</code>弱一些，他不能保证<code>atomic&lt;T&gt;</code>的值和<code>expected</code>的值相等时也会做交换，很可能原子变量和预期值相等也会返回false，所以使用要多次循环使用。</p>
<p>下面程序中，将类的成员变量<code>mutex</code>换成<code>atomic</code>类型的原子变量，利用自旋锁的思路将锁替换为原子变量循环检测的方式，进而达到锁住互斥逻辑的效果。在析构函数中，因为<code>_atomic_using</code>初始化时为false，当线程1到到操作1处时，<code>_atomic_using</code>会被赋值为<code>use_desired</code>的值(true)，并且返回false，退出循环，完成队列类<code>CircularQueSeq</code>的销毁和空间回收。在这个过程中，如果有其它线程要进入，当来到操作1处时，因为<code>_atomic_using</code>已经为true了，与<code>use_expected</code>不相等，就会让<code>use_expected</code>赋值为<code>_atomic_using</code>的值(这是不希望的，所以do里面会每次都重新设置，就是防止这种情况)，并返回false，继续循环，只有当线程1执行完2处后，<code>_atomic_using</code>为false时，其它线程才能够退出循环1处，进入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> Cap&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircularQueSeq</span> :<span class="keyword">private</span> std::allocator&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CircularQueSeq</span>() :_max_size(Cap + <span class="number">1</span>), _data(std::allocator&lt;T&gt;::<span class="built_in">allocate</span>(_max_size)), _atomic_using(<span class="literal">false</span>),_head(<span class="number">0</span>), _tail(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//删除拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">CircularQueSeq</span>(<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    CircularQueSeq&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CircularQueSeq&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CircularQueSeq</span>() &#123;</span><br><span class="line">        <span class="comment">//循环销毁</span></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired)); <span class="comment">// 1处</span></span><br><span class="line">        <span class="comment">//调用内部元素的析构函数</span></span><br><span class="line">        <span class="keyword">while</span> (_head != _tail) &#123;</span><br><span class="line">            std::allocator&lt;T&gt;::<span class="built_in">destroy</span>(_data + _head);</span><br><span class="line">            _head = （_head+<span class="number">1</span>）% _max_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用回收操作</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocate</span>(_data, _max_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));   <span class="comment">//2处</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先实现一个可变参数列表版本的插入函数最为基准函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">emplace</span><span class="params">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> ((_tail + <span class="number">1</span>) % _max_size == _head) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que full ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在尾部位置构造一个T类型的对象，构造参数为args...</span></span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">construct</span>(_data + _tail, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        <span class="comment">//更新尾部元素位置</span></span><br><span class="line">        _tail = (_tail + <span class="number">1</span>) % _max_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//push 实现两个版本，一个接受左值引用，一个接受右值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受左值引用版本</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push const T&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受右值引用版本，当然也可以接受左值引用，T&amp;&amp;为万能引用</span></span><br><span class="line">    <span class="comment">// 但是因为我们实现了const T&amp;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called push T&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">emplace</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> use_expected = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> use_desired = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_desired = <span class="literal">true</span>;</span><br><span class="line">            use_expected = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;circular que empty ! &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                use_expected = <span class="literal">true</span>;</span><br><span class="line">                use_desired = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出头部指针指向的数据</span></span><br><span class="line">        val = std::<span class="built_in">move</span>(_data[_head]);</span><br><span class="line">        <span class="comment">//更新头部指针</span></span><br><span class="line">        _head = (_head + <span class="number">1</span>) % _max_size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            use_expected = <span class="literal">true</span>;</span><br><span class="line">            use_desired = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!_atomic_using.<span class="built_in">compare_exchange_strong</span>(use_expected, use_desired));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> _max_size;</span><br><span class="line">    T* _data;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; _atomic_using;</span><br><span class="line">    <span class="type">size_t</span> _head = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> _tail = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这种方式虽然通过原子变量的方式解决线程安全问题，但当某一线程线程通过do-while后，其它线程都得像自旋锁一样一直轮询检查，就造成了不必要的开销，下面是对这种方法的一种改进。</p>
<p>对于pop逻辑代码：先在1处取出头部的下标索引，进行判断，如果头部的下标与尾部下标相等，说明为空，就直接返回false退出，否则就通过头部的下标取出数据，然后在3处，如果线程1先到达这里，因为<code>_head</code>等于h，所以就将<code>_head</code>进行+1，这样其它线程来到这里的时候，由于<code>_head</code>不等于h了，就返回false，继续循环。这时继续循环时，由于<code>_head</code>已经等于h+1了，所以改线程在1处获得的下标就是h+1，那么它要pop的是h+1，不是h，就不会出现多次弹出同一个数据的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> h;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = _head.<span class="built_in">load</span>();  <span class="comment">//1处 先获得头部的一个下标索引</span></span><br><span class="line">        <span class="comment">//判断头部和尾部指针是否重合，如果重合则队列为空</span></span><br><span class="line">        <span class="keyword">if</span>(h == _tail.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//相等就返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        val = _data[h]; <span class="comment">// 2处 就从头部取出要pop的数据</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!_head.<span class="built_in">compare_exchange_strong</span>(h, (h+<span class="number">1</span>)% _max_size)); <span class="comment">//3处 !_head等于h的时候就+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>push逻辑代码：push逻辑与pop逻辑处理在这里是一样的，但push的这种处理是存在线程安全问题的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T&amp; val)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> t;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = _tail.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span>( (t+<span class="number">1</span>)%_max_size == _head.<span class="built_in">load</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _data[t] = val; <span class="comment">//2</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!_tail.<span class="built_in">compare_exchange_strong</span>(t, (t + <span class="number">1</span>) % _max_size)); <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-利用栅栏实现同步模型"><a href="#3-利用栅栏实现同步模型" class="headerlink" title="3. 利用栅栏实现同步模型"></a>3. 利用栅栏实现同步模型</h1><h2 id="3-1-线程可见顺序"><a href="#3-1-线程可见顺序" class="headerlink" title="3.1 线程可见顺序"></a>3.1 线程可见顺序</h2><p>有时候我们线程1对A的store操作采用release内存序，而线程2对B的load采用acquire内存序，并不能保证A 一定比 B先执行。因为两个线程并行执行无法确定先后顺序，我们指的先行不过是说如果B读取了A操作的结果，则称A先行于B。</p>
<p>在下面这段程序中，看似断言是不会触发，但在一些极端的情况下，还是可能触发断言的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x, y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//3</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_acquire))   <span class="comment">//4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------下面是测试--------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestAR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="literal">false</span>;</span><br><span class="line">    y = <span class="literal">false</span>;</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>); <span class="comment">//5</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z value is &quot;</span> &lt;&lt; z.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在一个4核CPU结构的主机上，a,b,c,d分别运行在不同的CPU内核上，如下图所示。线程a执行<code>x.store(true)</code>先被线程c读取，而此时线程b对y的store还没有被线程c读取到新的值，所以此时c读取的x为true，y为false。同样的道理，d可以读取b修改y的最新值，但是没来的及读取x的最新值，那么读取到y为true，x为false。这样在上面程序中就会出现断言的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_2.jpg"></p>
<p>所以即使采用release和acquire方式也不能保证全局顺序一致。如果一个线程对变量执行release内存序的store操作，另一个线程不一定会马上读取到。</p>
<h2 id="3-2-栅栏"><a href="#3-2-栅栏" class="headerlink" title="3.2 栅栏"></a>3.2 栅栏</h2><p>其实也可以通过栅栏机制保证指令的写入顺序，栅栏的机制和<code>memory_order_release</code>类似。</p>
<p>下面程序中，在1和3中间添加了一个release内存序的栅栏2，这样可以确保该指令2之前的指令(什么内存序都包括)的编排不会编排到该指令2之后。在4和6之间又定义了一个acquire内存序的栅栏5，那么如果操作2被操作5读取到了，它们就构成了一个同步关系，所有执行操作6时，就一定可以读到操作1执行后的数据，也就不会发生断言。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//1 对x存储为true</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">//2 添加一个栅栏，执行了release的内存序</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x_fence</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">//4</span></span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire); <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">//6</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-基于锁实现线程安全的栈"><a href="#4-基于锁实现线程安全的栈" class="headerlink" title="4. 基于锁实现线程安全的栈"></a>4. 基于锁实现线程安全的栈</h1><p>下面程序实现了基于锁控制push和pop操作的一个栈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span> : std::exception         <span class="comment">//定义了员工异常的结构(类)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;       <span class="comment">//出问题直接抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span>                    <span class="comment">//模板类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;                 <span class="comment">//存放T数据类型的员工栈</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;               <span class="comment">//互斥量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>() &#123;&#125;              <span class="comment">//默认构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)        <span class="comment">//拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;      <span class="comment">//先对other对象加锁，防止其它线程还在使用other对象</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;       <span class="comment">//栈不支持赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;       <span class="comment">//先加锁</span></span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));       <span class="comment">//1.用移动构造来push一个元素，这样就免去了再构造一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>          <span class="comment">//pop返回智能指针的版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;    <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();  <span class="comment">//2.判断栈是否为空，为空就抛出异常</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">//3.将栈顶元素取出来，构造了一个智能指针</span></span><br><span class="line">        data.<span class="built_in">pop</span>();                  <span class="comment">//4.弹出栈定元素</span></span><br><span class="line">        <span class="keyword">return</span> res;                  <span class="comment">//返回栈顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span>                  <span class="comment">//pop返回引用的版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">//5.直接移动操作即可,存到传进来的参数中</span></span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;      <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();                      <span class="comment">//返回栈是否为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码虽然不会出现线程安全问题，但依然存在着不足，比如说在操作2处，当栈为空的时候，也会抛出异常，这是不会合理的。下面程序是解决栈为空就抛出异常的一个问题优化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack_waitable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    std::condition_variable cv;                 <span class="comment">//条件变量，当栈为空的时候，就挂起</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>() &#123;&#125;             <span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_stack_waitable</span>(<span class="type">const</span> threadsafe_stack_waitable&amp; other)       <span class="comment">//拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;       <span class="comment">//先锁住other对象，防止其它线程再访问</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadsafe_stack_waitable&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack_waitable&amp;) = <span class="keyword">delete</span>;   <span class="comment">//无拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));    <span class="comment">//1.通过移动构造的方式push一个元素</span></span><br><span class="line">        cv.<span class="built_in">notify_one</span>();                    <span class="comment">//添加完一个元素后，唤醒通知其它线程栈里有元素了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span>      <span class="comment">//pop智能指针版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()   </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(data.<span class="built_in">empty</span>())       <span class="comment">//如果栈为空，返回fasle，就在这里挂起，释放锁，其它线程就可以往栈放数据</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//如果不为空，就返回true，继续往下执行(还是加锁状态)</span></span><br><span class="line">            &#125;); <span class="comment">//  ⇽-- - 2</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;   <span class="comment">// ⇽-- - 3</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 4</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span>            <span class="comment">//pop引用版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]()</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());   <span class="comment">// ⇽-- - 5</span></span><br><span class="line">        data.<span class="built_in">pop</span>();   <span class="comment">// ⇽-- - 6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span>       <span class="comment">//pop引用的另一个版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span>     <span class="comment">//pop智能指针的另一个版本</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();     <span class="comment">//为空，就返回一个空的智能指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5-实现线程安全的查找表"><a href="#5-实现线程安全的查找表" class="headerlink" title="5. 实现线程安全的查找表"></a>5. 实现线程安全的查找表</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><p>下面实现了一个线程安全的查找结构，类似线程安全的map结构，但由于map基于红黑树的，实现难度就较大，而且需要加锁地方的粒度也不是很精细，所以这里就考虑用散列表实现。</p>
<p>散列表，它是根据键(Key)而直接访问在存储器存储位置的数据结构。 也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。 这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<h2 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h2><p>在下面程序中，将查找表封装为<code>threadsafe_lookup_table</code>类，该类将hash值存入到一个vector容器中，每个hash值都又一个属于自己的桶,，因此vector容器里存了指定数量的桶，可以理解为一条链表。在<code>threadsafe_lookup_table</code>类中，又封装了一个桶的类<code>bucket_type</code>，它相当于是一条链表，用list容器存储，里面存储的类型是<code>pair&lt;Key,Value&gt;</code>。然后<code>bucket_type</code>类也实现了一系列的增删改查的功能(需要加锁)供外部调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个模板类，接受三个模板参数：键的类型(Key)、值的类型(value)、哈希函数类型，默认使用std::hash&lt;Key&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> threadsafe_lookup_table &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> bucket_type &#123;       <span class="comment">//桶</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> threadsafe_lookup_table;    <span class="comment">//将threadsafe_lookup_table定义为bucket_type的友缘</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::pair&lt;Key, Value&gt; bucket_value;      <span class="comment">//一个键值对别名，类型为 std::pair&lt;Key, Value&gt;。</span></span><br><span class="line">        <span class="keyword">typedef</span> std::list&lt;bucket_value&gt; bucket_data;     <span class="comment">//一个链表别名，用于存储键值对</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> bucket_data::iterator bucket_iterator;     <span class="comment">//链表的迭代器类型别名</span></span><br><span class="line">        bucket_data data;          <span class="comment">//实际存储键值对的链表</span></span><br><span class="line">        <span class="keyword">mutable</span> std::shared_mutex mutex;        <span class="comment">//一个共享互斥锁，用于保证线程安全</span></span><br><span class="line">        <span class="comment">//在桶中查找键，返回迭代器。</span></span><br><span class="line">        <span class="function">bucket_iterator <span class="title">find_entry_for</span><span class="params">(<span class="type">const</span> Key&amp; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从begin()开始找，找到end()，传递一个谓词(用lambda表示)</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">find_if</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), [&amp;](bucket_value <span class="type">const</span>&amp; item) &#123;    <span class="comment">//从桶里面开始找</span></span><br><span class="line">                <span class="keyword">return</span> item.first == key;       <span class="comment">//在桶中等于key就返回</span></span><br><span class="line">                &#125;);         <span class="comment">//找到了就返回迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//查找key值，找到返回对应的value，未找到则返回默认值</span></span><br><span class="line">        <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; default_value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;   <span class="comment">//共享锁，都来查找的话，可以并发查找，不用造成互斥的效果</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);       <span class="comment">//返回一个迭代器，用auto也可以</span></span><br><span class="line">            <span class="keyword">return</span> (found_entry == data.<span class="built_in">end</span>()) ? default_value : found_entry-&gt;second;  <span class="comment">//如果找到了，就放回找到的结果value值，没有找到就返回默认值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加key和value，找到则更新，没找到则添加</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;           <span class="comment">//加锁</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry == data.<span class="built_in">end</span>())                <span class="comment">//如果没有找到</span></span><br><span class="line">            &#123;</span><br><span class="line">                data.<span class="built_in">push_back</span>(<span class="built_in">bucket_value</span>(key, value));    <span class="comment">//向data里面添加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                found_entry-&gt;second = value;        <span class="comment">//通过key找到了，就更新该key的value值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除对应的key</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;              <span class="comment">//加锁</span></span><br><span class="line">            bucket_iterator <span class="type">const</span> found_entry = <span class="built_in">find_entry_for</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (found_entry != data.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                data.<span class="built_in">erase</span>(found_entry);        <span class="comment">//找到了就直接通过迭代器来删除该key和value</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets;    <span class="comment">//用vector存储桶类型，每个vector的值都是一个桶类型</span></span><br><span class="line">    Hash hasher;        <span class="comment">//hash&lt;Key&gt; 哈希表 用来根据key生成哈希值</span></span><br><span class="line">    <span class="comment">//根据key生成数字，并对桶的大小取余得到下标，根据下标返回对应的桶智能指针</span></span><br><span class="line">    <span class="function">bucket_type&amp; <span class="title">get_bucket</span><span class="params">(Key <span class="type">const</span>&amp; key)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将key值传给hasher，它会自动计算，返回一个散列值，然后取余，让其映射在bucket上</span></span><br><span class="line">        std::<span class="type">size_t</span> <span class="type">const</span> bucket_index = <span class="built_in">hasher</span>(key) % buckets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> *buckets[bucket_index];      <span class="comment">//解引用，得到该下标对应的一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//桶的大小默认为19(最好取质数)；哈希也默认是系统提供的哈希，这些都可以外部自己指定</span></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(<span class="type">unsigned</span> num_buckets = <span class="number">19</span>, Hash <span class="type">const</span>&amp; hasher_ = <span class="built_in">Hash</span>()) :<span class="built_in">buckets</span>(num_buckets), <span class="built_in">hasher</span>(hasher_) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; num_buckets; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buckets[i].<span class="built_in">reset</span>(<span class="keyword">new</span> bucket_type);       <span class="comment">//创建好每一个桶  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_lookup_table</span>(threadsafe_lookup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;         <span class="comment">//删除拷贝构造</span></span><br><span class="line">    threadsafe_lookup_table&amp; <span class="keyword">operator</span>=(threadsafe_lookup_table <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;   <span class="comment">//删除拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Value <span class="title">value_for</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; default_value = Value())</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">value_for</span>(key, default_value); <span class="comment">//提供key找到对应的桶，再在该桶下通过key找到对应的value。这里不需要加锁，因为value_for里有加锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_or_update_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key, Value <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">add_or_update_mapping</span>(key, value);   <span class="comment">//往对应桶里面添加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_mapping</span><span class="params">(Key <span class="type">const</span>&amp; key)</span>           <span class="comment">//删除对应桶里的key和value</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get_bucket</span>(key).<span class="built_in">remove_mapping</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将查找表里面的数据存储到map容器</span></span><br><span class="line">    <span class="function">std::map&lt;Key, Value&gt; <span class="title">get_map</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; locks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//里面查找表里面的数据时，需要对每一个桶都加锁</span></span><br><span class="line">            locks.<span class="built_in">push_back</span>(std::<span class="built_in">unique_lock</span>&lt;std::shared_mutex&gt;(buckets[i]-&gt;mutex));</span><br><span class="line">        &#125;</span><br><span class="line">        std::map&lt;Key, Value&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i)   <span class="comment">//遍历每一个桶</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//需用typename告诉编译器bucket_type::bucket_iterator是一个类型，以后再实例化</span></span><br><span class="line">            <span class="comment">//当然此处可简写成auto it = buckets[i]-&gt;data.begin();</span></span><br><span class="line">            <span class="keyword">typename</span> bucket_type::bucket_iterator it = buckets[i]-&gt;data.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (; it != buckets[i]-&gt;data.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(*it);    <span class="comment">//对于每一个桶，只要没有到最后一个元素，都往res里面存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       <span class="comment">//最后返回res</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自定义了一个MyClass类，用来表示Value类型值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i) :_data(i) &#123;&#125;</span><br><span class="line">    <span class="comment">//重写了&lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; os, <span class="type">const</span> MyClass&amp; mc) &#123;</span><br><span class="line">        os &lt;&lt; mc._data;</span><br><span class="line">        <span class="keyword">return</span> os;    <span class="comment">//输出参数的值</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用于测试的函数：创建了一个查找表，并定义了三个线程，线程1负责向查找表添加0到99；线程2负责从查找表删除0到99；线程3负责向从查找表添加100到199。三个线程并发执行，执行完后，通过removeSet打印删除的那些数据，和打印出查找表里还剩下的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestThreadSafeHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; removeSet;         <span class="comment">//用来存储移出的数据</span></span><br><span class="line">    <span class="comment">//创建模板类查找表，Key是int，Value是std::shared_ptr&lt;MyClass&gt;</span></span><br><span class="line">    threadsafe_lookup_table&lt;<span class="type">int</span>, std::shared_ptr&lt;MyClass&gt;&gt; table;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;         <span class="comment">//往查找表里加元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;                   <span class="comment">//从查找表里移出元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; )&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> find_res = table.value_for(i, <span class="literal">nullptr</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (find_res)</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                table.remove_mapping(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                removeSet.insert(i);</span></span></span><br><span class="line"><span class="params"><span class="function">                i++;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">//因为是多线程一起运行，所以也有可能删除比添加快，导致要删除的元素，还没有添加进来，所以就先睡眠一会</span></span></span></span><br><span class="line"><span class="params"><span class="function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="number">10</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">([&amp;]() &#123;              <span class="comment">//往查找表里加元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100</span>; i &lt; <span class="number">200</span>; i++)</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> class_ptr = std::make_shared&lt;MyClass&gt;(i);</span></span></span><br><span class="line"><span class="params"><span class="function">            table.add_or_update_mapping(i, class_ptr);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : removeSet)&#123;                  <span class="comment">//打印移出的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;remove data is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> copy_map = table.<span class="built_in">get_map</span>();      <span class="comment">//将查找表里面的元素转为map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : copy_map)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy data is &quot;</span> &lt;&lt; *(i.second) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestThreadSafeHash</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-缺陷"><a href="#5-3-缺陷" class="headerlink" title="5.3 缺陷"></a>5.3 缺陷</h2><ol>
<li>首先我们的查找表可以支持并发读，并发写，并发读的时候不会阻塞其他线程。但是并发写的时候会卡住其他线程。基本的并发读写没有问题。 </li>
<li>但是对于bucket_type中链表的操作加锁精度并不精细，因为我们采用的是std提供的list容器，所以增删改查等操作都要加同一把锁，导致锁过于粗糙。</li>
</ol>
<h1 id="6-基于锁实现线程安全的链表"><a href="#6-基于锁实现线程安全的链表" class="headerlink" title="6. 基于锁实现线程安全的链表"></a>6. 基于锁实现线程安全的链表</h1><h2 id="6-1-简介"><a href="#6-1-简介" class="headerlink" title="6.1 简介"></a>6.1 简介</h2><p>对于做一个支持多线程并发访问的链表，首先想到的是用一个互斥量控制整个链表，达到多线程访问时串行的效果。但是这么做精度不够，需要分化互斥量的功能。所以下面让每个节点都维护一个互斥量，这样能保证多个线程操作不同节点时加不同的锁，减少耦合性。</p>
<p>首先需要将head独立为一个虚节点，即不存储数据，只做头部标记。这样每次从头部插入就只需要修将新的节点的next指针指向原来head的next指向的节点，再将head的next指针指向新的节点。具体图像如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_3.jpg"></p>
<h2 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h2><p>头节点函数：定义了一个智能指针指向的数据域和unique智能指针指向下一个节点的地址，同时定义了默认构造函数和拷贝构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typname T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    std::mutex m;                <span class="comment">//每个节点独有的互斥量</span></span><br><span class="line">    std::shared_ptr&lt;T&gt; data;     <span class="comment">//data为智能指针,存储的是T类型的数据域</span></span><br><span class="line">    std::unique_ptr&lt;node&gt; next;   <span class="comment">//unique类型的智能指针，存储的是下一个节点的地址</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">node</span>() :<span class="built_in">next</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; value):<span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value))&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义链表的函数：链表类中将拷贝构造和拷贝赋值函数删除，同时链表中初始状态包含了一个头节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex m;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;</span><br><span class="line">        std::unique_ptr&lt;node&gt; next;</span><br><span class="line">        <span class="built_in">node</span>():<span class="built_in">next</span>()&#123;&#125;</span><br><span class="line">        <span class="built_in">node</span>(T <span class="type">const</span>&amp; value):<span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value))&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    node head;          <span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_list</span>()&#123;&#125;            <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">threadsafe_list</span>()&#123;&#125;           <span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">threadsafe_list</span>(threadsafe_list <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;              <span class="comment">//删除拷贝构造</span></span><br><span class="line">    threadsafe_list&amp; <span class="keyword">operator</span>=(threadsafe_list <span class="type">const</span>&amp; other) = <span class="keyword">delete</span>;   <span class="comment">//删除拷贝赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数：在remove_if函数中，将Predicate p中的p可以理解为一个lambda表达式或者是一个函数的功能，通过p来判断，如果p返回了true，说明满足条件，把满足条件的节点删除掉；如果p返回的是false，就不满足条件，就不删除该节点。而析构函数调用remove_if，p谓词就是一个lambda表达式，始终返回true，这样就可以保证删除链表所有的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;                   <span class="comment">//将head头节点(虚节点)赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;         <span class="comment">//对头节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())   <span class="comment">//循环取出当前节点的下一个节点(裸指针)，为空就不执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;   <span class="comment">//对下一个指针进行加锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*next-&gt;data))   <span class="comment">//用谓词p操作下一个节点，判断是否为true，如果为true，则条件满足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将当前节点的下一个节点移动到old_next里，则其下一个节点已经失效</span></span><br><span class="line">            std::unique_ptr&lt;node&gt; old_next = std::<span class="built_in">move</span>(current-&gt;next);</span><br><span class="line">            current-&gt;next = std::<span class="built_in">move</span>(next-&gt;next);   <span class="comment">//将当前节点的下一个的下一个节点赋值给当前节点</span></span><br><span class="line">            next_lk.<span class="built_in">unlock</span>();        <span class="comment">//将当前节点的下一个节点解锁(已经要删除)</span></span><br><span class="line">        &#125;        <span class="comment">//当局部作用域结束的时候，old_next就会被回收掉(unique_ptr类型)，这样就删除了该节点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//如果为false，则条件不满足，不用删除，跳过当前节点</span></span><br><span class="line">            lk.<span class="built_in">unlock</span>();              <span class="comment">//将当前节点解锁</span></span><br><span class="line">            current = next;           <span class="comment">//将下一个节点赋值给当前节点(相当于当前节点向右移)</span></span><br><span class="line">            lk = std::<span class="built_in">move</span>(next_lk);    <span class="comment">//将下一个节点的锁移动给当前节点的锁，这样当前节点就可以保持一直锁着</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_if</span>([](node <span class="type">const</span>&amp;) &#123;<span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入节点函数：通过头插法的方式插入新的节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T <span class="type">const</span>&amp; value)</span>             <span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;   <span class="comment">//创建了一个新节点</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;            <span class="comment">//锁住头部节点</span></span><br><span class="line">    new_node-&gt;next = std::<span class="built_in">move</span>(head.next);             <span class="comment">//将头部的下一个节点地址赋值给新节点的下一个节点</span></span><br><span class="line">    head.next = std::<span class="built_in">move</span>(new_node);                   <span class="comment">//头部节点的下一个节点地址改为新节点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找对应节点的函数：该函数是结合谓词p来在链表中一个一个寻找第一个满足条件的节点，找到了就直接返回该data的一个指针，没有找到就返回空指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">find_first_if</span><span class="params">(Predicate p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;           <span class="comment">//从头节点开始，赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;     <span class="comment">//当前节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())&#123;     <span class="comment">//循环取当前节点的下一个节点，为空则退出循环</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;   <span class="comment">//对当前节点的下一个节点加锁</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">p</span>(*next-&gt;data))&#123;    <span class="comment">//将next的数据域传给p，判断是否为true，为true就说明找到了，返回next的数据源data</span></span><br><span class="line">            <span class="keyword">return</span> next-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果改节点不满足，继续判断下一个</span></span><br><span class="line">        current = next;     <span class="comment">//将下一个节点地址赋值给当前节点</span></span><br><span class="line">        lk = std::<span class="built_in">move</span>(next_lk);     <span class="comment">//next的锁也移动给当前节点，则lk永远锁定的是当前节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();    <span class="comment">//如果最后都没有找到对应的节点，就返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历所有节点函数：该函数是结合谓词函数f来完成的，从头节点开始遍历，到最后空时，就退出循环，停止遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* current = &amp;head;            <span class="comment">//从头节点开始，赋值给当前节点</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;      <span class="comment">//当前节点加锁</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = current-&gt;next.<span class="built_in">get</span>())&#123;    <span class="comment">//循环取当前节点的下一个节点，为空则退出循环</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;    <span class="comment">//把下一个节点加锁</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();                 <span class="comment">//当前节点解锁</span></span><br><span class="line">        <span class="built_in">f</span>(*next-&gt;data);              <span class="comment">//执行谓词函数f，</span></span><br><span class="line">        current = next;              <span class="comment">//把下一个节点更新为当前节点</span></span><br><span class="line">        lk = std::<span class="built_in">move</span>(next_lk);     <span class="comment">//把下一个节点的锁移动给当前节点的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-线程安全的无锁栈实现"><a href="#7-线程安全的无锁栈实现" class="headerlink" title="7. 线程安全的无锁栈实现"></a>7. 线程安全的无锁栈实现</h1><h2 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h2><p>之前通过锁的互斥机制实现了并发安全的栈，队列，查找表，以及链表等结构。接下来是通过无锁的原子变量的方式实现栈。</p>
<p>单线程情况下添加节点步骤：</p>
<ol>
<li>创建新节点</li>
<li>将元素入栈，将新节点的next指针指向现在的head节点。</li>
<li>将head节点更新为新节点的值。</li>
</ol>
<p>而在多线程情况下，假设线程1执行到第2步，即将元素入栈后，没来得及更新head节点的值为新节点的值。此时线程2也执行完第2步，将head更新为线程2插入的新节点，之后线程1又将head更新为线程1的新插入节点，那么此时head的位置就是错的。</p>
<p>单线程情况下删除节点步骤：</p>
<ol>
<li>取出头节点元素</li>
<li>更新head为下一个节点。</li>
<li>返回取出头节点元素的数据域。</li>
</ol>
<p>而在多线程情况下，第1，2步同样存在线程安全问题。此外我们返回节点数据域时会进行拷贝赋值，如果出现异常会造成数据丢失，这一点也要考虑。 </p>
<p>所以为了解决这些问题，可以通过原子变量的<code>compare_exchange</code>(比较交换操作)来控制更新head节点，以此来达到线程安全的目的。</p>
<h2 id="7-2-代码实现"><a href="#7-2-代码实现" class="headerlink" title="7.2 代码实现"></a>7.2 代码实现</h2><p>头节点函数：创建了一个模板类，在该类中，定义了一个T类型的数据域、node*类型的指针，指向下一个节点的地址和一个拷贝构造的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;              <span class="comment">//数据域</span></span><br><span class="line">    node* next;          <span class="comment">//下一个节点的地址</span></span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_):<span class="built_in">data</span>(data_)&#123;&#125;     <span class="comment">//拷贝构造</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无锁栈结构：下面程序定义了一个无锁栈的结构，结构中定义了一个采用原子变量表示的头部节点。需要注意的是，对于栈和队列，如果想要实现线程安全，都不能进行拷贝，不然管理不了。所以得删除拷贝构造和拷贝赋值，采用默认构造即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>(<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;                  <span class="comment">//删除拷贝构造</span></span><br><span class="line">    lock_free_stack&amp; <span class="keyword">operator</span> = (<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;     <span class="comment">//删除拷贝赋值</span></span><br><span class="line">    std::atomic&lt;node*&gt; head;       <span class="comment">//node*类型的原子变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>入栈函数：在多线程情况下，当线程1创建新节点node1并指向了下一个头节点，但没有来得及更新head，这时线程2也创建了新节点node2执行到1处，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_4.png"></p>
<p>然后线程2更新了head节点，即head指向了node2。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_5.png"></p>
<p>当时间片回到线程1，线程1执行2处代码时，发现head的值与node1的next的值不一样，就将head的值赋值给node1的next，并返回false，继续执行循环，那么node1的next就指向了head节点(node2)，再执行2处代码时，head与node1-&gt;next值相等了，就将node1的值赋值给head了(head进行了更新)，然后返回ture，退出循环。如下图所示;</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/concurrent/7_6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(value)              <span class="comment">//创建一个新的节点</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        new_node-&gt;next = head.<span class="built_in">load</span>();            <span class="comment">//1.将头节点的值赋值给新节点的next指针</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_strong</span>(new_node-&gt;next, new_node));  <span class="comment">//2.当返回false时就相当于执行了1处的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出栈函数：下面程序是一个单线程的版本，当线程1执行完1处时，即线程1的old_head指向了头节点，但还没有来得及执行2处代码，线程2就将它的old_head指向了头节点，并将头节点往下移动了，此时线程1再来执行2处代码时，就会出现问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">    node* old_head = head.<span class="built_in">load</span>(); <span class="comment">//1</span></span><br><span class="line">    head = head-&gt;next; <span class="comment">//2</span></span><br><span class="line">    value = old_head-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以为了解决上面问题，对代码进行了改进，当线程2执行完2处代码后，即head指向了线程2<code>old_head</code>的next，此时线程1再执行到2处时，因为head指向的节点和线程1<code>old_head</code>指向的不一样了，就将线程1<code>old_head</code>指向head节点(修改删除节点)，当在执行2处代码时，就能取出当前head所值的节点(要弹出的节点)，并将head的指向往下移，退出线程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        node* old_head = head.<span class="built_in">load</span>(); <span class="comment">//1. 将头部节点加载出来，old_head指向了头部节点</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//2</span></span><br><span class="line">    value = old_head-&gt;data; <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码存在的问题：</p>
<ol>
<li>未判断空栈的情况，当old_head为空时，在2处还有old_head-&gt;next操作，就很危险。</li>
<li>将数据域赋值给引用类型的value时存在拷贝赋值(3处)，我们都知道拷贝赋值会存在异常的情况，当异常发生时元素已经从栈定移除了，破坏了栈的结构，这一点和锁处理时不一样，锁处理的时候是先将元素数据域取出赋值再出栈，所以不会有问题，但是无锁的方式就会出现栈被破坏的情况。解决方式也比较简单，数据域不再存储T类型数据，而是存储<code>std::shared_ptr&lt;T&gt;</code>类型的数据。智能指针在赋值的时候不会产生异常。</li>
<li>未释放弹出的节点的内存。</li>
</ol>
<p>先解决未判断栈未空的问题，如下程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lock_free_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;T&gt; data;      <span class="comment">//用T类型的智能指针指向data</span></span><br><span class="line">        node* next;</span><br><span class="line">        <span class="built_in">node</span>(T <span class="type">const</span>&amp; data_) : <span class="comment">//⇽-- - 1</span></span><br><span class="line">            <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(data_))</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lock_free_stack</span>(<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_free_stack&amp; <span class="keyword">operator</span> = (<span class="type">const</span> lock_free_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    std::atomic&lt;node*&gt; head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lock_free_stack</span>() &#123;&#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        node* old_head = <span class="literal">nullptr</span>; <span class="comment">//1        </span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            old_head = head.<span class="built_in">load</span>(); <span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;      <span class="comment">//如果加载出来的节点是空节点，就返回空，退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//3        </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> old_head-&gt;data;  <span class="comment">//4    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于资源回收问题，可以先实现一个简单的回收处理逻辑，通过临时智能指针与要删除的数据进行交换的方法来回收资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* old_head = <span class="literal">nullptr</span>;        </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        old_head = head.<span class="built_in">load</span>();     <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">//2        </span></span><br><span class="line">    std::shared_ptr&lt;T&gt; res;   <span class="comment">//3 定义一个临时智能指针</span></span><br><span class="line">    res.<span class="built_in">swap</span>(old_head-&gt;data); <span class="comment">//4 将res与old_head的data做交换，这样old_head就会变成空指针</span></span><br><span class="line">    <span class="keyword">delete</span> old_head;  <span class="comment">//5 直接去除掉old_head</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">//6 返回删除的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序虽然解决了资源回收的问题，但还是存在很大的问题，当线程1走到1处时，时间片被分配到线程2，然后线程2直接执行到第5处，把old_head删除了，但此时线程1的old_head与线程2删除的old_head是一样的，这样就会导致线程1继续执行，到执行第2处时，取old_head的next时，就会导致系统崩溃。所以就不能把old_head直接删除，其实能不能删除old_head，取决于其它线程是否还用old_head，就像如果是单线程的，就完全可以删除。所以考虑多线程的情况，就需要引入延迟删除节点的机制来解决该问题。</p>
<p>设计思路：</p>
<ol>
<li>如果head已经被更新，且旧head不会被其他线程引用，那旧head就可以被删除。否则放入待删列表。</li>
<li>如果仅有一个线程执行pop操作，那么待删列表可以被删除，如果有多个线程执行pop操作，那么待删列表不可被删除。</li>
</ol>
<p>我们需要用一个原子变量threads_in_pop记录有几个线程执行pop操作。在pop结束后再减少threads_in_pop。 我们需要一个原子变量to_be_deleted记录待删列表的首节点。程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++threads_in_pop;        <span class="comment">//1 计数器首先自增，然后才执行其他操作</span></span><br><span class="line">    node* old_head = <span class="literal">nullptr</span>;     </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//2 加载head节点给旧head存储</span></span><br><span class="line">        old_head = head.<span class="built_in">load</span>();  </span><br><span class="line">        <span class="keyword">if</span> (old_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            --threads_in_pop;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(old_head, old_head-&gt;next)); <span class="comment">// 3    </span></span><br><span class="line">    <span class="comment">//3处 比较更新head为旧head的下一个节点    </span></span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;T&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (old_head)      <span class="comment">//old_head不为空，就执行下面</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4 只要有可能，就回收已删除的节点数据</span></span><br><span class="line">        res.<span class="built_in">swap</span>(old_head-&gt;data);     <span class="comment">//将要删除的节点于res进行交换， </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5 从节点提取数据，而非复制指针</span></span><br><span class="line">    <span class="built_in">try_reclaim</span>(old_head);       <span class="comment">//old_head已经是空节点了，通过该函数来判断。old_head是否要删除</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_reclaim</span><span class="params">(node* old_head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threads_in_pop == <span class="number">1</span>)    <span class="comment">//1 原子变量判断仅有一个线程进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2 当前线程把待删列表取出</span></span><br><span class="line">        node* nodes_to_delete = to_be_deleted.<span class="built_in">exchange</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">//3 更新原子变量获取准确状态，判断pop是否仅仅正被当前线程唯一调用</span></span><br><span class="line">        <span class="keyword">if</span>(!--threads_in_pop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">delete_nodes</span>(nodes_to_delete);   <span class="comment">//4 如果唯一调用则将待删列表删除</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nodes_to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5 如果pop还有其他线程调用且待删列表不为空，则将待删列表首节点更新给to_be_deleted</span></span><br><span class="line">            <span class="built_in">chain_pending_nodes</span>(nodes_to_delete);     <span class="comment">//将本地的待删列表还原成全局待删列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> old_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//多个线程pop会访问该节点(不会用该节点的数据，因为数据值已经通过交换删除了，但之前存该数据的节点没有删)</span></span><br><span class="line">        <span class="built_in">chain_pending_node</span>(old_head);      <span class="comment">//将其放入待删列表，此时不能删除old_head</span></span><br><span class="line">        --threads_in_pop;       <span class="comment">//线程用完了，计数器减1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">delete_nodes</span><span class="params">(node* nodes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nodes)    <span class="comment">//遍历链表删除即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        node* next = nodes-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> nodes;</span><br><span class="line">        nodes = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_node</span><span class="params">(node* n)</span></span>&#123;     <span class="comment">//将单个节点放入待删列表</span></span><br><span class="line">    <span class="built_in">chain_pending_nodes</span>(n, n);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* first, node* last)</span></span>&#123;  <span class="comment">//接受两个参数，分别为链表的头和尾</span></span><br><span class="line">    <span class="comment">//1 先将last的next节点更新为待删列表的首节点</span></span><br><span class="line">    last-&gt;next = to_be_deleted;    </span><br><span class="line">    <span class="comment">//2  借循环保证 last-&gt;next指向正确</span></span><br><span class="line">    <span class="comment">// 将待删列表的首节点更新为first节点</span></span><br><span class="line">    <span class="keyword">while</span> (!to_be_deleted.<span class="built_in">compare_exchange_weak</span>(</span><br><span class="line">        last-&gt;next, first));     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">chain_pending_nodes</span><span class="params">(node* nodes)</span></span>&#123;    <span class="comment">//将nodes_to_delete为首的链表还原到待删列表中，接受一个参数为待还原的链表的首节点</span></span><br><span class="line">    node* last = nodes;</span><br><span class="line">    <span class="comment">//1 沿着next指针前进到链表末端</span></span><br><span class="line">    <span class="keyword">while</span> (node* <span class="type">const</span> next = last-&gt;next)    </span><br><span class="line">    &#123;</span><br><span class="line">        last = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 将链表放入待删链表中</span></span><br><span class="line">    <span class="built_in">chain_pending_nodes</span>(nodes, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程</title>
    <url>/2024/07/06/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-基础入门"><a href="#1-基础入门" class="headerlink" title="1.基础入门"></a>1.基础入门</h1><h2 id="1-1基本函数"><a href="#1-1基本函数" class="headerlink" title="1.1基本函数"></a>1.1基本函数</h2><p>open()函数：打开一个文件</p>
<p>int open(char *pathname , int flags , mode_t mode)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pathname：想要打开的文件路径名</p>
</li>
<li><p>flags(头文件#include <fcntl>)：文件打开方式：O_CREAT|OAPPEND|… </fcntl></p>
</li>
<li><p>mode：权限，当第二个参数设置了O_CREAT，就需要写该参数</p>
</li>
</ul>
</li>
</ul>
<p>mode:设置文件的权限(参数3使用前提：参数2指定了O_CREAT)</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：打开文件所得到对应的文件描述符(整数)</p>
</li>
<li><p>失败：-1,设置errno</p>
</li>
</ul>
</li>
</ul>
<p>read()函数：往一个文件读内容</p>
<p>ssize_t read(int fd , void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：存数据的缓冲区</p>
</li>
<li><p>count设置读字节数大小</p>
</li>
</ul>
</li>
</ul>
<p>count：缓冲区大小</p>
<ul>
<li><p>返回值：</p>
<ul>
<li><p>成功：读到的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>write()函数</p>
<p>ssize_t write(int fd , const void *buf , size_t count)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：文件描述符</p>
</li>
<li><p>buf：待写出数据的缓冲区</p>
</li>
<li><p>count：写入数据字节数大小</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：写入的字节数</p>
</li>
<li><p>失败：-1，设置errno</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将文件cp一份</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">3</span>];                           <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDONLY);      <span class="comment">//只读方式打开文件argv[1]</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR|O_CREAT|O_TRUNC,<span class="number">0664</span>);  <span class="comment">//读写|文件不存在就创建出来|文件存储就覆盖；权限</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd1,buf,<span class="number">3</span>)) != <span class="number">0</span>)&#123;     <span class="comment">//一次循环最多读3字节，n是每次读到的字节数</span></span><br><span class="line">                write(fd2,buf,n);              <span class="comment">//一次循环写入n个字节，也就是上面读到的字节数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd2 = %d\n&quot;</span>,fd2);              <span class="comment">//通过文件描述符打印内容</span></span><br><span class="line">        close(fd1);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        close(fd2);                            <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2基本知识"><a href="#1-2基本知识" class="headerlink" title="1.2基本知识"></a>1.2基本知识</h2><p>1.PCB进程控制块：本质是结构体</p>
<ul>
<li>成员：文件描述符表——&gt;文件描述符：0&#x2F;1&#x2F;2&#x2F;3&#x2F;…&#x2F;1023</li>
</ul>
<p>key   value(指针：指向一个结构体)</p>
<p>0 – STDIN_FILENO ——–&gt;标准输入</p>
<p>1 – STDOUT_FILENO —–&gt;标准输出</p>
<p>2 – STDERR_FILENO ——&gt;标准错误</p>
<p>注意：每次得到的文件描述符默认是表中可用最小的</p>
<p>2.阻塞、非阻塞</p>
<p>是设备文件、网络文件的属性。产生阻塞的场景：读设备文件、读网络文件(读常规文件无阻塞概念)</p>
<p>dev&#x2F;tty：终端文件。标准输入、标准输出、标准错误都在终端显示</p>
<p>非阻塞设置：open(“&#x2F;dev&#x2F;tty”,..|O_NONBLOCK)</p>
<ul>
<li>此时若返回-1，并且errno &#x3D; EAGIN或EWOULDBLOCK，说明不是read失败，而是read在以非阻塞方式读一个设备文件或网络文件，并且文件无数据(默认是阻塞状态)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];                         <span class="comment">//定义一个buf,用来存放读和写的内容</span></span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/tty&quot;</span>,O_RDONLY|O_NONBLOCK);    <span class="comment">//以只读方式|非阻塞方式 打开文件/dev/tty</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open /dev/tty&quot;</span>);              <span class="comment">//如果fd&lt;0，说明打开文件失败，打印错误信息，并退出</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(fd,buf,<span class="number">10</span>);                <span class="comment">//从/dev/tty读数据存到buf(最多读10字节),/dev/tty是键盘输入</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，某些异常造成</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                   <span class="comment">//=EAGAIN是阻塞情况下无数据读，输出try again到终端继续等待键盘输入</span></span><br><span class="line">                        write(STDOUT_FILENO,<span class="string">&quot;try again\n&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;try again\n&quot;</span>));</span><br><span class="line">                        sleep(<span class="number">2</span>);        <span class="comment">//2秒钟执行一次</span></span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);      <span class="comment">//在2秒钟内读到数据就直接输出到终端</span></span><br><span class="line">        close(fd);                       <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.参数</p>
<ul>
<li><p>传入参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>有const关键字修饰</p>
</li>
<li><p>指针指向有效区域，在函数内部做读操作</p>
</li>
</ul>
</li>
<li><p>传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间可以无意义，但必须有效</p>
</li>
<li><p>在函数内部，做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
<li><p>传入传出参数：</p>
<ul>
<li><p>指针作为函数参数</p>
</li>
<li><p>在函数调用之前，指针指向的空间有实际意义</p>
</li>
<li><p>在函数内部，先做读操作，后做写操作</p>
</li>
<li><p>函数调用结束后，充当函数返回值</p>
</li>
</ul>
</li>
</ul>
<p>4.文件存储</p>
<ul>
<li><p>dentry：目录项，其本质是结构体，重要成员变量有两个{文件名，inode,…}，而文件内容(data)保存在磁盘块中。</p>
</li>
<li><p>inode：其本质是结构体，存储文件的属性信息。如权限、类型、大小、盘块位置…。大多数的inode都存储在磁盘上，少数常用、近期使用的inode会被存储在内存上。</p>
</li>
</ul>
<h2 id="1-3进阶函数"><a href="#1-3进阶函数" class="headerlink" title="1.3进阶函数"></a>1.3进阶函数</h2><p>1.fcntl函数</p>
<ul>
<li><p>获取文件状态：F_GETFL</p>
</li>
<li><p>设置文件状态：F_SETFL</p>
</li>
</ul>
<p>获取fd描述符的stdin属性信息：int flgs &#x3D; fcntl(fd,F_GETFL);</p>
<p>添加非阻塞状态：flgs |&#x3D; O_NONBLOCK;</p>
<p>把设置的状态信息设置到终端设备的状态信息中：fcntl(fd,F_SETFL,flgs)；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TRY <span class="string">&quot;try again\n&quot;</span>               <span class="comment">//定义宏变量</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> flags,n;</span><br><span class="line">        flags = fcntl(STDIN_FILENO,F_GETFL); <span class="comment">//获取stdin属性信息(获取标准输入对应的终端设备的状态信息) STDIN_FILENO对应终端设备</span></span><br><span class="line">        <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flags |= O_NONBLOCK;     <span class="comment">//添加非阻塞状态</span></span><br><span class="line">        <span class="type">int</span> ret = fcntl(STDIN_FILENO,F_SETFL,flags);    <span class="comment">//把设置的状态信息设置到终端设备的状态信息中</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">tryagain:</span><br><span class="line">        n=read(STDIN_FILENO,buf,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errno != EAGAIN)&#123;      <span class="comment">//说明read读取失败，不是因为没有数据</span></span><br><span class="line">                        perror(<span class="string">&quot;read /dev/tty&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        sleep(<span class="number">3</span>);</span><br><span class="line">                        write(STDOUT_FILENO,MSG_TRY,<span class="built_in">strlen</span>(MSG_TRY));</span><br><span class="line">                        <span class="keyword">goto</span> tryagain;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到数据情况</span></span><br><span class="line">        write(STDOUT_FILENO,buf,n);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.lseek函数</p>
<p>off_t lseek(int fd , off_t offset , int whence);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd: 文件描述符</p>
</li>
<li><p>offset：偏移量</p>
</li>
<li><p>whence：偏移位置：SEEK_SET(起点)&#x2F;SEEK_CUR(当前位置)&#x2F;SEEK_END(终点)</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：较起始位置偏移量</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li><p>文件的读和写使用同一偏移位置(读和写都改变偏移位置)</p>
</li>
<li><p>使用lseek获取文件大小</p>
</li>
<li><p>使用lseek拓展文件大小(要想使文件大小真正拓展，必须引起IO操作)</p>
</li>
</ul>
<p>补：可以使用truncate函数，直接拓展文件大小 </p>
<ul>
<li>如int ret &#x3D; truncate(“dict.txt”,250);</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试文件的读和写使用同一偏移位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,n;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;It&#x27;s a test4 for lseek\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR|O_CREAT,<span class="number">0644</span>);     <span class="comment">//以读写方式打开|不存在就创建</span></span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open lseek.txt error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        write(fd,msg,<span class="built_in">strlen</span>(msg));     <span class="comment">//使用fd对打开文件进行写操作，此时读写位置位于文件结尾处</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时读写指针位于结尾处了，没有下面这行，将只能写数据到文件中，但不能执行下面的读(读出数据)</span></span><br><span class="line">        lseek(fd,<span class="number">0</span>,SEEK_SET);         <span class="comment">//将读写指针设置到文件开头-----&gt;读写指针；偏移量为0；开始偏移的位置为起始位置</span></span><br><span class="line">        <span class="keyword">while</span>((n = read(fd,&amp;ch,<span class="number">1</span>)))&#123;    <span class="comment">//读，以一个变量为缓冲区，缓冲区大小为1</span></span><br><span class="line">                <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,&amp;ch,n);     <span class="comment">//将文件内容按字节读出，写到屏幕上</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用lseek获取文件大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;lseek.txt&quot;</span>,O_RDWR);    <span class="comment">//以读写打开文件</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时读写指针位于文件开头</span></span><br><span class="line">        <span class="type">int</span> lenth = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//偏移量为0，偏移位置为文件末，所以读写指针从文件头到文件尾，返回偏移了多少 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%d\n&quot;</span>,lenth);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.stat&#x2F;lstat函数</p>
<p>stat底层是一个结构体，里面有文件的信息</p>
<p>int stat(const char *path , struct stat *buf);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path:文件或目录路径 </p>
</li>
<li><p>buf：(传出参数)存放文件属性</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>成功：0</p>
</li>
<li><p>失败：-1 设置errno</p>
</li>
</ul>
</li>
</ul>
<p>系统提供函数</p>
<ul>
<li><p>获取文件大小：buf.st_size</p>
</li>
<li><p>获取文件类型：buf.st_mode</p>
</li>
<li><p>获取文件权限：buf.st_mode</p>
</li>
</ul>
<p>符号穿透：stat会；lstat不会</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = stat(<span class="string">&quot;document&quot;</span>,&amp;sbuf);     <span class="comment">//查看的目录文件路径；传出参数(接受该文件的stat结构体)</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file size:%ld\n&quot;</span>,sbuf.st_size);    <span class="comment">//打印该文件的st_size信息</span></span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a regular\n&quot;</span>);    <span class="comment">//这是一个普通文件</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a dir\n&quot;</span>);         <span class="comment">//这是一个目录</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a pipe\n&quot;</span>);      <span class="comment">//这是一个管道</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(sbuf.st_mode))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s a sym link\n&quot;</span>);    <span class="comment">//这是一个软连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.link&#x2F;unlink函数</p>
<p>link函数：可以为已经存在的文件创建目录项(硬链接)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">link(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&quot;b.txt&quot;</span>);    <span class="comment">//旧文件；新文件</span></span><br><span class="line">unlink(<span class="string">&quot;a.txt&quot;</span>);          <span class="comment">//删除旧的,新的可以继续用</span></span><br></pre></td></tr></table></figure>

<p>unlink函数：删除一个文件的目录项。从某种意义上说，只是让文件具备了释放的条件。</p>
<p>unlink函数的特征：清除文件时，如果文件的硬链接数到0了，没有dentry对应，但该文件仍不会马上被释放(只是目录中我们看不到该文件了而已)，要等到所有打开该文件的进程关闭该文件，系统才会挑时间将该文件释放掉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> *p = <span class="string">&quot;test of unlink\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> *p2 = <span class="string">&quot;after write something\n&quot;</span>;</span><br><span class="line">        fd = open(<span class="string">&quot;temp.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);    <span class="comment">//打开文件temp.txt，没有就创建出来</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open temp error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">5</span>);                            <span class="comment">//这些时间可以看到该文件</span></span><br><span class="line">        <span class="type">int</span> ret = unlink(<span class="string">&quot;temp.txt&quot;</span>);        <span class="comment">//具备了被释放的条件，在目录中我们看不到了</span></span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;unlink error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;                                        <span class="comment">//虽然unlink了，但后面还能进行写内容</span></span><br><span class="line">        ret = write(fd,p,<span class="built_in">strlen</span>(p));             <span class="comment">//往fd里面写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;--------write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hi! I&#x27;m lxx\n&quot;</span>);</span><br><span class="line">        ret = write(fd,p2,<span class="built_in">strlen</span>(p2));          <span class="comment">//往fd里面继续写内容</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;------Write error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;enter anykey continue\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.readlink()函数</p>
<p>作用：读取符号链接(软链接)文件本身内容，得到链接所指向的文件名。</p>
<p>如有软链接：t.soft -&gt; &#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>终端执行：readlink t.soft    得到：&#x2F;home&#x2F;hoem1&#x2F;test</p>
<p>6.目录操作函数</p>
<p>DIR * opendir(char *name);</p>
<p>int closedir(DIR *dp)</p>
<p>struct dirent *readdir(DIR *dp);</p>
<p>其中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">	inode</span><br><span class="line">	<span class="type">char</span> dname[<span class="number">256</span>]</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span>       <span class="comment">//dirent是目录项类型，相当于dentry</span></span><br><span class="line">        dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            	<span class="comment">//去掉目录项文件名是.和..的目录项</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span>)||(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)) </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>,sdp-&gt;d_name);      <span class="comment">//打印每个目录项的文件名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：递归遍历目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>;    <span class="comment">//申明isFile函数</span></span><br><span class="line"><span class="comment">//打开目录读取，处理目录</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_dir</span><span class="params">(<span class="type">char</span> *dir)</span>&#123;   <span class="comment">//是目录，就打开其目录项</span></span><br><span class="line">        <span class="type">char</span> path[<span class="number">256</span>];    <span class="comment">//用于后面拼接路径</span></span><br><span class="line">        DIR *dp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">sdp</span>;</span></span><br><span class="line">        dp = opendir(dir);</span><br><span class="line">        <span class="keyword">if</span>(dp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;opendir error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取目录项</span></span><br><span class="line">        <span class="keyword">while</span>((sdp = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(sdp-&gt;d_name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)&#123;   </span><br><span class="line">                        <span class="keyword">continue</span>;       <span class="comment">////不排除这个，会进入死循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//目录项本身不可访问，拼接目录</span></span><br><span class="line">                <span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,dir,sdp-&gt;d_name);</span><br><span class="line">                <span class="comment">//判断文件类型，目录递归进入，文件显示名字/大小</span></span><br><span class="line">                isFile(path);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">isFile</span><span class="params">(<span class="type">char</span> *name)</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span>            <span class="comment">//stat是应该结构体，里面包含对应文件的信息</span></span><br><span class="line">        ret = stat(name,&amp;sb);      <span class="comment">//获取文件属性，判断文件类型</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(S_ISDIR(sb.st_mode))&#123;   <span class="comment">//是否目录</span></span><br><span class="line">                read_dir(name);    <span class="comment">//是目录，进入read_dir函数，继续处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是普通文件，打印名字和大小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%ld\n&quot;</span>,name,sb.st_size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;               <span class="comment">//如果没有传入参数，就遍历当前目录下的内容</span></span><br><span class="line">                isFile(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                isFile(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.dup&#x2F;dup2函数</p>
<p>int dup(int oldfd);</p>
<ul>
<li><p>参数：oldfd：已有文件描述符</p>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<p>int dup2(int oldfd,int newfd);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>oldfd：原文件描述符 </p>
</li>
<li><p>newfd：新文件描述符—–&gt;指向源文件描述符所指向的文件</p>
</li>
</ul>
</li>
<li><p>返回值：新文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd1--&gt;3</span></span><br><span class="line">        <span class="type">int</span> fd2 = open(argv[<span class="number">2</span>],O_RDWR);   <span class="comment">//读写方式打开文件   fd2--&gt;4</span></span><br><span class="line">        <span class="type">int</span> fdret = dup2(fd1,fd2);        <span class="comment">//fd2与fd1指向的是同一个内存空间了,返回新文件描述符fd2</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdret = %d\n&quot;</span>,fdret);</span><br><span class="line">        <span class="type">int</span> ret = write(fd2,<span class="string">&quot;1234567&quot;</span>,<span class="number">7</span>);  <span class="comment">//通过fd2来写内容，内容写在的是第一个文件中</span></span><br><span class="line">        dup2(fd1,STDOUT_FILENO);   <span class="comment">//令屏幕输入(fd=1)重定向给fd1所指向的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------886\n&quot;</span>);  <span class="comment">//向屏幕输出的内容都写到文件描述符3所在的内存空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fcntl函数是实现dup</p>
<p>int fcntl(int fd,int cmd,…);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd：原文件描述符</p>
</li>
<li><p>cmd：F_DUPFD(特定参数)</p>
</li>
<li><p>参数3：指定文件描述符号。被占用的，返回最小可用的；未被占用的，返回&#x3D;该值的文件描述符</p>
</li>
</ul>
</li>
<li><p>返回值：返回新的文件描述符</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fcntl也可以像dup那些使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>],O_RDWR);      <span class="comment">//读写方式打开文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd1 = %d\n&quot;</span>,fd1);            <span class="comment">//打印文件描述符fd1的值，是3</span></span><br><span class="line">        <span class="comment">//原文件描述符；特定参数；新的文件描述符号(已经存在的话，系统就按正常给)</span></span><br><span class="line">        <span class="type">int</span> newfd = fcntl(fd1,F_DUPFD,<span class="number">0</span>); <span class="comment">//0被占用，fcntl使用文件描述符表中可用的最小文件描述符来返回，即newfd=4</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd);       <span class="comment">//newfd的值是4</span></span><br><span class="line">        <span class="type">int</span> newfd2 = fcntl(fd1,F_DUPFD,<span class="number">7</span>);  <span class="comment">//7未被占用，返回文件描述符7(如果存在7，就返回更大的号)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;newfd = %d\n&quot;</span>,newfd2);</span><br><span class="line">        <span class="type">int</span> ret = write(newfd2,<span class="string">&quot;yyyyyy&quot;</span>,<span class="number">6</span>);    <span class="comment">//写在的是fd1文件描述符所在的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h1><h2 id="2-1进程与程序"><a href="#2-1进程与程序" class="headerlink" title="2.1进程与程序"></a>2.1进程与程序</h2><p>程序：死的，只占用磁盘空间    —剧本</p>
<p>进程：活的，运行起来的程序，占用内存、cpu等系统资源   —戏剧</p>
<p>1.进程控制块PCB</p>
<p>我们知道，每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>内部成员：</p>
<ul>
<li><p>进程id：系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数；</p>
</li>
<li><p>进程的状态：有初试、就绪、运行、挂起和停止五种状态</p>
</li>
<li><p>进程切换时想要保存和恢复的一些CPU寄存器；(了解)</p>
</li>
<li><p>描述虚拟地址空间的信息；(了解)</p>
</li>
<li><p>描述控制终端的信息；(了解)</p>
</li>
<li><p>当前所处工作目录；</p>
</li>
<li><p>umask掩码：rwx对应124，当umask为022时，在你创建文件和目录时，默认权限是777-022&#x3D;755，即rwxr_xr_x；(了解)</p>
</li>
<li><p>文件描述符表：是map结构，key为正整数，value为指针，指针指向结构体；它包含很多指向file结构体的指针(每个进程都有文件描述符表)</p>
</li>
<li><p>和信号相关的信息；</p>
</li>
<li><p>用户id和组id；</p>
</li>
<li><p>会话和进程组；(了解)</p>
</li>
<li><p>进程可用使用的资源上限；(了解)</p>
</li>
</ul>
<p>2.进程共享</p>
<p>父进程在fork()之后：</p>
<p>相同：全局变量、data段、text段、栈、堆、环境变量、用户id、宿主目录、进程工作目录、信号处理方式…</p>
<p>不相同：进程id、fork返回值、父进程id、进程运行时间、闹钟(定时器)、未决信号集</p>
<p>注：对于全局变量，父子进程间遵循<strong>读时共享写时复制</strong>的原则</p>
<p>3.孤儿进程&#x2F;僵尸进程</p>
<ul>
<li><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程(回收)</p>
</li>
<li><p>僵尸进程：子进程终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程。(kill对其无效)</p>
</li>
</ul>
<h1 id="3-相关函数"><a href="#3-相关函数" class="headerlink" title="3.相关函数"></a>3.相关函数</h1><h2 id="3-1fork-函数"><a href="#3-1fork-函数" class="headerlink" title="3.1fork()函数"></a>3.1fork()函数</h2><p>功能：是创建一个新的进程</p>
<p>pid_t fork(void);</p>
<ul>
<li>返回值：对应文件的子进程id号</li>
</ul>
<p>注意：创建出来的子进程可用执行父进程中fork()函数下面的代码。在父进程中，fork返回的是子进程id号；在子进程中，fork返回的是0；</p>
<p>补：getpid()返回的是当前进程；getppid()返回的是父进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过fork()函数来生成子进程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程会执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child is created,pid = %d,parent-pid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//fork成功的话，父进程里返回的是子线程的id，所以父线程执行该行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent process: my child is %d,my pid = %d,my parent pid = %d\n&quot;</span>,pid,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======================end of file\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);  <span class="comment">//防止父进程结束了，子进程还没有打印内容，当父进程结束后，退出程序，而子进程就没有父进程了，打印的父进程就为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，子进程和父进程都会执行sleep(3)这行代码，不是说只有让父进程执行，而子进程不执行，sleep(3)只是防止父进程结束退出程序了，子进程还没有打印父进程。如果父进程结束了，子进程才打印父进程，则父进程是1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环创建5个子线程，且有序打印出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;   <span class="comment">//子线程创建好了与0做对比，直接跳出循环，但父进程还需要继续执行</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;    <span class="comment">//当第1个子进程创建好后，此时i=0;当第2个子进程创建好后，此时的i=1;.....</span></span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2execlp-函数"><a href="#3-2execlp-函数" class="headerlink" title="3.2execlp()函数"></a>3.2execlp()函数</h2><p>功能：指定进程执行相应的程序</p>
<p>int execlp(const *file , const *arg , …);</p>
<ul>
<li><p>参数:</p>
<ul>
<li><p>file：要加载(执行)的程序名字</p>
</li>
<li><p>arg以及后面：调用该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数常用来调用系统程序。如ls、date、cp、cat等命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execlp()：是让子线程不执行父线程的代码，而是执行/execlp所指定的代码或函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">//ls：要执行的系统函数名；ls -l -d -h：是执行的代码(命令)；NULL：是哨兵，代表着-l、-d等参数的结束</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="literal">NULL</span>);   <span class="comment">//当子线程调用execlp失败时，执行下面代码</span></span><br><span class="line">                <span class="comment">//execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-3execl函数"><a href="#3-3execl函数" class="headerlink" title="3.3execl函数"></a>3.3execl函数</h2><p>功能：既可以执行自己写的程序，也可用执行系统程序</p>
<p>int execl(const char* path , const char *arg , ….);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>path：程序的路径</p>
</li>
<li><p>arg以及后面：执行该程序的命令</p>
</li>
</ul>
</li>
<li><p>返回值：成功无返回(执行指定程序去了)，失败返回-1</p>
</li>
</ul>
<p>该函数是通过 路径+程序名 来加载进程</p>
<p>案例：将ps aux打印的内容写到一个文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//execl()：是让子线程不执行父线程的代码，而是执行execl所指定的文件</span></span><br><span class="line"><span class="comment">//注：execl()也能像execlp()函数那些去执行系统的一些程序，如date、ls等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();      <span class="comment">//生成一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;      <span class="comment">//子进程</span></span><br><span class="line">                <span class="comment">// ./execlp：是路径；./execlp是命令</span></span><br><span class="line">                <span class="comment">//execlp(&quot;./execlp&quot;,&quot;./execlp&quot;,NULL);    //子线程去执行execlp程序里面的代码</span></span><br><span class="line">                execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;       <span class="comment">//父进程</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程： %d\n&quot;</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4wait-函数"><a href="#3-4wait-函数" class="headerlink" title="3.4wait()函数"></a>3.4wait()函数</h2><blockquote>
<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态；如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个过程。</p>
</blockquote>
<p>该函数的三个功能：</p>
<ul>
<li><p>阻塞等待子进程退出；</p>
</li>
<li><p>回收子进程残留资源</p>
</li>
<li><p>获取子进程结束状态(退出原因)</p>
</li>
</ul>
<p>pid_t wait(int *status);</p>
<ul>
<li><p>参数：status是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>返回值：成功：回收子进程的id号；失败：-1(没有子进程)</p>
</li>
</ul>
<p>可使用wait函数传出的参数status来保存进程的退出状态：</p>
<ul>
<li><p>WIFEXITED(status)为非0，表示进程正常结束</p>
<ul>
<li>如上正常退出，使用WEXITSTATUS(status)来获取进程的退出状态(正常的参数)</li>
</ul>
</li>
<li><p>WIFSIGNALED(status)为非0，表示进程异常终止</p>
<ul>
<li>如上异常退出，使用WTERMSIG(status)来获取使进程终止的那个信号的编号</li>
</ul>
</li>
<li><p>WIFSTOPPED(status)为非0，表示进程处于暂停状态</p>
<ul>
<li>如上为暂停状态，使用WSTOPSIG(status)来取得使进程暂停的那个信号的编号</li>
</ul>
</li>
<li><p>WIFCONTINUED(status)为真，表示进程暂停后已经继续运行</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：wait函数只有在子线程执行完后才会回收，然后继续向下执行；否则就阻塞在该处，等子线程执行完</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---child,my id = %d,going to sleep 3s\n&quot;</span>,getpid());</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---parent wait finish:%d\n&quot;</span>,wpid);    <span class="comment">//等子线程执行完后，才会执行该函数</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：通过系统提供的宏函数来查看子线程的退出状态信息等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        pid = fork();      <span class="comment">//创建一个子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子线程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------------child die------------------\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">93</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//wpid = wait(NULL);      //不关心子进程结束的原因</span></span><br><span class="line">                wpid = wait(&amp;status);     <span class="comment">//参数是一个传出参数；返回值是回收的子线程id</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))&#123;    <span class="comment">//该子线程是否正常终止</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;我是正常终止,返回%d\n&quot;</span>,WEXITSTATUS(status));<span class="comment">//打印的值是93，即子线程执行完的返回值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(status))&#123;   <span class="comment">//该子线程是否被信号终止(一切异常终止都是因为信号)</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;child kill with signal %d\n&quot;</span>,WTERMSIG(status));  <span class="comment">//打印导致异常退出的信号编号</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;父线程等待完毕，回收的子线程是%d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5waitpid-函数"><a href="#3-5waitpid-函数" class="headerlink" title="3.5waitpid()函数"></a>3.5waitpid()函数</h2><p>pid_t waitpid(pid_t pid , int *status , int optains)</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>pid：指定某个子进程进行回收(大于0：回收指定ID的子进程；-1：回收任意子进程，相当于wait；0：回收和当前调用waitpid一个组的所有子进程；小于-1：回收指定进程组内的任意子进程)</p>
</li>
<li><p>status：是传出参数，结合系统提供的宏函数，可以得到子进程的一些信息</p>
</li>
<li><p>options：通过特定参数，可以完成特定功能，如WNOHANG指以非阻塞方式回收</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><p>大于0：表示成功回收的子进程pid</p>
</li>
<li><p>等于0：参3指定了WNOHANG，并且没有子进程结束会返回0(非阻塞方式)</p>
</li>
<li><p>-1：失败，设置errno</p>
</li>
</ul>
</li>
</ul>
<p>waitpid()与wait()的区别是：waitpid能指定某个进程进行回收</p>
<p>注意：一次wait&#x2F;waitpid函数调用，只能回收一个子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：指定回收某个子线程，且子线程有序打印</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid,tmpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                        tmpid = pid;    <span class="comment">//此时pid是第三个子线程的pid</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;指定回收的子线程 = %d\n&quot;</span>,tmpid);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                sleep(<span class="number">5</span>);   <span class="comment">//如果是不阻塞状态，给主线程添加睡眠，会成功回收指定子线程</span></span><br><span class="line">                <span class="comment">//wpid = waitpid(tmpid,NULL,WNOHANG);   //指定回收子进程tmpid,并且不阻塞</span></span><br><span class="line">                wpid = waitpid(tmpid,<span class="literal">NULL</span>,<span class="number">0</span>);   <span class="comment">//指定回收子进程tmpid,并且是阻塞状态</span></span><br><span class="line">                <span class="keyword">if</span>(wpid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;成功回收子线程：%d\n&quot;</span>,wpid);  <span class="comment">//如果不阻塞状态，指定回收的子线程没有结束，则回收没有成功，waitpid会返回0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);    <span class="comment">//有序打印</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试：回收多个子线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pid_t</span> pid,wpid;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//子线程不用循环，所以直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="comment">/*while(wpid = waitpid(-1,NULL,0))&#123;   //循环回收每个子线程,并且是阻塞状态 后面回收完，会返回-1，一直循环</span></span><br><span class="line"><span class="comment">                        printf(&quot;成功回收子线程：%d\n&quot;,wpid);</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">                <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG)) != <span class="number">-1</span>)&#123;    <span class="comment">//以非阻塞状态进行回收</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)&#123;    <span class="comment">//当成功回收时</span></span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;成功回收：%d\n&quot;</span>,wpid);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;    <span class="comment">//当没有成功回收时，先睡眠1秒</span></span><br><span class="line">                                sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sleep(i);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是第%d个子线程%d\n&quot;</span>,i+<span class="number">1</span>,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-IPC方法"><a href="#4-IPC方法" class="headerlink" title="4.IPC方法"></a>4.IPC方法</h1><blockquote>
<p>Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信(IPC)。</p>
</blockquote>
<p>在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。现在常用的进程间通信方式有：</p>
<ul>
<li><p>管道(使用最简单)</p>
</li>
<li><p>信号(开销最小)</p>
</li>
<li><p>共享映射区(无血缘关系)</p>
</li>
<li><p>本地套接字(最稳定)</p>
</li>
</ul>
<h2 id="4-1管道"><a href="#4-1管道" class="headerlink" title="4.1管道"></a>4.1管道</h2><blockquote>
<p>管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：</p>
</blockquote>
<ul>
<li><p>其本质是一个伪文件(实为内核缓冲区)</p>
</li>
<li><p>由两个文件描述符引用，一个表示读端(可以有多个)，一个表示写端</p>
</li>
<li><p>规定数据从管道的写端流入管道，借助内核缓冲区(4k)实现</p>
</li>
</ul>
<p>1.管道的局限性：</p>
<ul>
<li><p>数据不能进程自己写，自己读</p>
</li>
<li><p>管道中数据不可以反复读取，一旦读走，管道中不再存在</p>
</li>
<li><p>采用半双工通信方式，数据只能在单方向上流动</p>
</li>
<li><p>只能在有公共祖先的进程间使用管道。</p>
</li>
</ul>
<p>2.常见的通信方式有：单工通信、半双工通信、全双工通信</p>
<p>3.pipe函数</p>
<p>int pipe(int fd[2]);   —&gt; 创建，并打开管道</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>fd[0]：读端</p>
</li>
<li><p>fd[1]：写端</p>
</li>
</ul>
</li>
<li><p>返回值：成功：0；失败：-1，设置errno</p>
</li>
</ul>
<p>4.管道的读写行为：</p>
<ul>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据：(A)管道写端被全部关闭，read返回0(表示读到文件结尾)；(B)写端没有全部被关闭，read阻塞等待(不久的将来可能有数据写入)，此时会让出CPU</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道读端全部被关闭：进程异常终止(也可以使用SIGPIPE信号，使进程不终止)</p>
</li>
<li><p>管道读端没有全部关闭：若管道已满，write阻塞；若管道未满，write将数据写入，并返回实际写入的字节数。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试pipe管道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello pipe\n&quot;</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;           <span class="comment">//主线程负责写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);    <span class="comment">//关闭读端</span></span><br><span class="line">                write(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">                sleep(<span class="number">1</span>);        <span class="comment">//主线程睡眠1秒，防止主线程先结束</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//写完后，关闭写端</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子线程负责读</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);    <span class="comment">//子线程关闭写端</span></span><br><span class="line">                ret = read(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));     <span class="comment">//将主线程写在缓冲区的内容读到buf里面    </span></span><br><span class="line">                write(STDOUT_FILENO,buf,ret);         <span class="comment">//将buf的内容打印到屏幕，其中ret为buf读到的字节数</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);     <span class="comment">//结束后，关闭读端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用管道实现父子进程间通信，完成ls | wc -l，假定父进程实现ls，子进程实现wc</p>
<p>ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;    <span class="comment">//负责出错时，打印错误</span></span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="comment">//当父进程执行ls时，子进程会永远执行在后面，所以父进程会先结束</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;       <span class="comment">//子线程</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);       <span class="comment">//关闭读端</span></span><br><span class="line">                <span class="comment">//重定向，相当于屏幕上的内容输入到管道的写端</span></span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);    <span class="comment">//重定向，让标准输出指向管道的读端，这样输出在屏幕上的就可以写到管道中</span></span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);       <span class="comment">//父进程执行ls命令</span></span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;        <span class="comment">//父线程</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);      <span class="comment">//关闭写端</span></span><br><span class="line">                <span class="comment">//重定向，相当于从管道读端读到的内容写到了标准输入(相当于键盘输入)</span></span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);     <span class="comment">//重定向，让标准输入指向管道的读端，从管道读取数据</span></span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：ls命令正常会将结果集写出到stdout，但现在会写入管道的写端；wc -l正常应该会从stdin读取数据，但此时会从管道的读端读。</p>
<p>案例：使用管道实现兄弟进程间通信，兄：ls，弟：wc -l，父：等待回收子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用兄弟进程实现</span></span><br><span class="line"><span class="comment">//ls | wc -l 的含义是将ls命令的输出通过管道传递给wc -l命令，然后统计输出的行数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        ret = pipe(fd);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pipe error&quot;</span>);   <span class="comment">//一个出错处理函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;    <span class="comment">//父进程回收两个子线程</span></span><br><span class="line">                <span class="comment">//父进程必须关闭管道的读和写端，因为管道是单向的，而两个子线程已经占用了读和写</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;    <span class="comment">//兄线程执行</span></span><br><span class="line">                close(fd[<span class="number">0</span>]);</span><br><span class="line">                dup2(fd[<span class="number">1</span>],STDOUT_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp ls error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;    <span class="comment">//弟进程执行</span></span><br><span class="line">                close(fd[<span class="number">1</span>]);</span><br><span class="line">                dup2(fd[<span class="number">0</span>],STDIN_FILENO);</span><br><span class="line">                execlp(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">                sys_err(<span class="string">&quot;exclp wc error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2FIFO"><a href="#4-2FIFO" class="headerlink" title="4.2FIFO"></a>4.2FIFO</h2><blockquote>
<p>FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程；但通过FIFO，不相关的进程也能交换数据。FIFO是Linux基础文件类型中的一种。但FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read&#x2F;write，实际上是在读写内核通道，这样就实现了进程间通信，并且可以有多个写端和多个读端。</p>
</blockquote>
<p>创建管道方式：</p>
<ul>
<li><p>终端：mkfifo 命名管道文件名</p>
</li>
<li><p>代码：int ret &#x3D; mkfifo(“my_mkfifo”,0664);返回-1未成功创建</p>
</li>
</ul>
<p>注意：可以通过终端mkfifo 命名管道文件名 来创建，也可以通过c程序</p>
<p>写端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,i;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_WRONLY);     <span class="comment">// 以只写的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello lxx %d\n&quot;</span>,i++);     <span class="comment">//将要写的内容存入buf</span></span><br><span class="line">                write(fd,buf,<span class="built_in">strlen</span>(buf));             <span class="comment">//将buf中的内容写到命名管道(文件)中</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读端的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过命名管道对两个无血缘关系的进程进行通信</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> fd,len;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;    <span class="comment">//因为这里面没有定义管道，所以传参时必须要传命名管道</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ENter like this:./a.out fifoname\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>],O_RDONLY);     <span class="comment">// 以只写的方式打开命名管道的写端</span></span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                len = read(fd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//将从命名管道中读到的数据放到buf中</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);      <span class="comment">//将buf中的内容读到标准输出(屏幕)</span></span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3存储映射I-O"><a href="#4-3存储映射I-O" class="headerlink" title="4.3存储映射I&#x2F;O"></a>4.3存储映射I&#x2F;O</h2><blockquote>
<p>存储映射I&#x2F;O使一个磁盘文件与存储空间中的一个缓冲区相映射。于是当从缓冲区中取数据，就相当于读文件中的相应字节。于此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样就可以在不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作。</p>
<p>使用这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现</p>
</blockquote>
<p>1.创建映射区</p>
<p>void *mmap(void * addr , size_t length , int prot , int flags , int fd , off_t offset);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>addr：指定映射区的首地址。通常传NULL，表示让系统自动分配</p>
</li>
<li><p>length：共享内存映射区的大小。(&lt;&#x3D;文件的实际大小)</p>
</li>
<li><p>prot：共享内存映射区的读写属性。PROT_READ、PROT_WRITE</p>
</li>
<li><p>flags：标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE(私有：对内存的操作不会反映到物理磁盘上)</p>
</li>
<li><p>fd：用于创建共享内存映射区的那个文件的文件描述符。</p>
</li>
<li><p>offset：默认0，表示映射文件全部。偏移位置需是4K的整数倍。</p>
</li>
</ul>
</li>
<li><p>返回值：成功：映射区的首地址；失败：MAP_FAILED，设置errno</p>
</li>
</ul>
<p>2.释放映射区</p>
<p>int munmap(void *addr  , size_t length);</p>
<p>参数：</p>
<ul>
<li><p>addr：mmap的返回值</p>
</li>
<li><p>length：大小</p>
</li>
</ul>
<p>3.使用注意事项：</p>
<ul>
<li><p>用于创建映射区的文件大小为0，实际指定非0大小创建映射区，出“总线错误”；</p>
</li>
<li><p>用于创建映射区的文件大小为0，实际指定0大小创建映射区，出“无效参数”；</p>
</li>
<li><p>用于创建映射区的文件读写属性为只读，映射区属性为读、写，出“无效参数”；</p>
</li>
<li><p>创建映射区，需要read权限(因为创建时，需要查看映射指定的文件)；当访问权限指定为MAP_SHARED(共享)时，mmap的读写属性应该&lt;&#x3D;文件的open权限(只给mmap写属性不可以)–&gt;因为共享时，对内存操作都会同样的对磁盘(文件)操作；</p>
</li>
<li><p>文件描述符fd，在mmap创建映射区完成即可关闭，后续访问文件用地址访问；</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上</p>
</li>
<li><p>映射区访问权限为MAP_PRIVATE(私有)时，在需要open文件时，有读权限来创建映射区即可；</p>
</li>
</ul>
<p>4.mmap函数的保险调用：</p>
<ul>
<li><p>fd &#x3D; open(“文件名”,O_RDWR);</p>
</li>
<li><p>mmap(NULL,有效文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试创建一个映射区</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        fd = open(<span class="string">&quot;testmap&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*lseek(fd,19,SEEK_END);</span></span><br><span class="line"><span class="comment">        write(fd,&quot;\0&quot;,1);    */</span>        <span class="comment">//这两行函数与下面的ftruncate()一样</span></span><br><span class="line">        ftruncate(fd,<span class="number">20</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//系统自动分配映射区首地址；映射区的大小；创建的映射区可读可写；映射区是共享的(内存内改，磁盘也改)；文件描述符；默认0</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用p对文件进行读写操作</span></span><br><span class="line">        <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello mmap&quot;</span>);         <span class="comment">//写操作,将hello maap写到映射区(磁盘)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-----------%s\n&quot;</span>,p);     <span class="comment">//将映射区内的东西写到屏幕</span></span><br><span class="line">        <span class="type">int</span> ret = munmap(p,len);          <span class="comment">//对映射区进行释放</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;imunmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.mmap进程通信</p>
<ul>
<li><p>父子进程通信</p>
<ul>
<li>父子等有血缘关系的进程之间也可以提供mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：<ul>
<li>MAP_PRIVATE(私有映射)：父子进程各自独占映射区(修改，互相都看不到)；</li>
<li>MAP_SHARED(共享映射)：父子进程共享映射区；</li>
</ul>
</li>
</ul>
</li>
<li><p>无血缘关系间的进程通信</p>
<ul>
<li>两个进程打开同一个文件(创建的映射区)；一个进程写入，另外一个进程读出。</li>
</ul>
</li>
</ul>
<p>mmap：数据可以重复读取(当创建的映射区为4字节时，只要读的速度快于写的速度，那么可以重复读同一个正整数多次，直到新数据写入)；而fifo只能读取数据一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父子进程实现mmap映射区之间的通信</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> fd = open(<span class="string">&quot;temp&quot;</span>,O_RDWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">                <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ftruncate(fd,<span class="number">4</span>);       <span class="comment">//对文件扩容  注意：需要有写权限才能扩容</span></span><br><span class="line">        <span class="type">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);      <span class="comment">//得出文件的大小</span></span><br><span class="line">        p = mmap(<span class="literal">NULL</span>,<span class="number">4</span>,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); <span class="comment">//MAP_SHARED如果是私有的话，表示映射区归父进程私有,也归子进程私有，对其修改，互相都收不到</span></span><br><span class="line">        <span class="keyword">if</span>(p == MAP_FAILED)&#123;     <span class="comment">//系统提供的默认宏</span></span><br><span class="line">                sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);      <span class="comment">//映射区建立完毕，即可关闭文件</span></span><br><span class="line">        pid = fork();      <span class="comment">//创建子线程</span></span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                *p = <span class="number">2000</span>;      <span class="comment">//子进程写共享内存</span></span><br><span class="line">                var = <span class="number">1000</span>;     <span class="comment">//对全部变量，读时共享，写时复制</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sleep(<span class="number">1</span>);   <span class="comment">//等子进程写完</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,*p = %d,var = %d\n&quot;</span>,*p,var);</span><br><span class="line">                wait(<span class="literal">NULL</span>);     <span class="comment">//回收子进程</span></span><br><span class="line">                <span class="type">int</span> ret = munmap(p,<span class="number">4</span>);     <span class="comment">//释放映射区</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">                       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的结果是：</span></span><br><span class="line">child,*p = <span class="number">2000</span>,var = <span class="number">1000</span></span><br><span class="line">parent,*p = <span class="number">2000</span>,var = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h1 id="5-信号"><a href="#5-信号" class="headerlink" title="5.信号"></a>5.信号</h1><blockquote>
<p>信号是一种软件中断，通知程序某种事件的发生。常见的信号有SIGABRT(当进程调用abort函数的时候自动发送), SIGALRM(当timer被触发的时候自动发送)，等等。</p>
</blockquote>
<h2 id="5-1常识"><a href="#5-1常识" class="headerlink" title="5.1常识"></a>5.1常识</h2><p>1.信号的共性：简单、不能携带大量信息、满足条件才发送</p>
<p>2。信号的特质：信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。所有信号的产生及处理全部都是由内核完成的</p>
<p>3.产生信号</p>
<ul>
<li><p>按键产生，如Ctrl+c、Ctrl+z、Ctrl+\</p>
</li>
<li><p>系统调用产生，如kill、raise、abort</p>
</li>
<li><p>软件条件产生，如定时器alarm</p>
</li>
<li><p>硬件异常产生，如非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</p>
</li>
<li><p>命令产生：如kill命令</p>
</li>
</ul>
<p>4.信号的状态</p>
<ul>
<li><p>递达：产生并且到达进程，可以直接被内核处理掉</p>
</li>
<li><p>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态</p>
</li>
</ul>
<p>5.信号处理的方式：执行默认动作、忽略(丢弃)、捕抓(自定义)</p>
<p>6.阻塞信号集(信号屏蔽字)：本质就是位图。用来记录信号的屏蔽状态。一旦被屏蔽的信号，再解除屏蔽前，就一直处于未决态</p>
<p>7.未决信号集：本质就是位图。用来记录信号的处理状态，该信号集中的信号表示已经产生，但尚未被处理</p>
<h2 id="5-2信号四要素及常规信号"><a href="#5-2信号四要素及常规信号" class="headerlink" title="5.2信号四要素及常规信号"></a>5.2信号四要素及常规信号</h2><p>信号使用之前，应先确定其四要素，而后再用。即信号编号、信号名称、信号对应事件、信号默认处理动作。</p>
<p>1.常规信号：</p>
<ul>
<li><p>1)SIGHUP：当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程。</p>
</li>
<li><p>2)SIGINT：当用户按下了&lt;Ctrl+c&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>3)SIGQUIT：当用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出此信号，默认动作为终止进程。</p>
</li>
<li><p>5)SIGTRAP：该信号由断点指令或其他trap指令产生，默认动作为终止进程，并产生core文件。</p>
</li>
<li><p>6)SIGABRT：调用abort函数时产生该信号，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>7)SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>8)SIGFPE：在发生致命的运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>9)SIGKILL：无条件终止进程，本信号不能被忽略处理和阻塞，默认动作为终止进程，它向系统管理员提供了可以杀死任何进程的方法。</p>
</li>
<li><p>10)SIGUSR1：用户定义的信号，即程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>11)SIGSEGV：指示进程进行了无效内存访问，默认动作为终止进程并产生core文件。</p>
</li>
<li><p>12)SIGUSR2：用户自定义信号，程序员可以在程序中定义并使用该信号，默认动作为终止进程。</p>
</li>
<li><p>13)SIGPIPE：Broken pipe向一个没有读端的管道写数据，默认动作为终止进程。</p>
</li>
<li><p>14)SIGALRM：定时器超时，超时的时间由系统调用alarm设置，默认动作为终止进程。</p>
</li>
<li><p>15)SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止，通常用来要示程序正常退出，执行shell命令kill时，缺省产生这个信号，默认动作为终止进程。</p>
</li>
<li><p>17)SIGCHLD：子进程状态发生变化时，父进程会收到这个信号，默认动作为忽略这个信号。</p>
</li>
<li><p>18)SIGCONT：如果进程已停止，则使其继续运行，默认动作为继续&#x2F;忽略。</p>
</li>
<li><p>19)SIGSTOP：停止进程的执行，信号不能被忽略处理和阻塞，默认动作为暂停进程。</p>
</li>
</ul>
<p>注意：只有每个信号所对应的事情发生了，该信号才会被递送(但不一定递达)，不应该乱发信号。</p>
<p>2.kill函数与kill命令</p>
<ul>
<li>kill函数：给指定进程发送指定信号(不一定是杀死)</li>
</ul>
<p>int kill(pid_t pid , int signum);</p>
<ul>
<li>参数pid：   &gt;0：发送信号给指定进程。&#x3D;0：发送信号给跟调用kill函数的那个进程处于同一进程组的进程。&lt;-1：取绝对值，发送信号给该绝对值所对应的进程组的所有组员。&#x3D;-1：发送信号给，有权限发送的所有进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试用kill杀死子进程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent,pid = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);    <span class="comment">//父进程一直循环</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child pid = %d,ppid = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">                kill(getppid(),SIGKILL);      <span class="comment">//发送 SIGKILL 信号给其父进程</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kill命令：如杀死一个进程(kill -9 进程号)</p>
<h2 id="5-3alarm函数"><a href="#5-3alarm函数" class="headerlink" title="5.3alarm函数"></a>5.3alarm函数</h2><blockquote>
<p>设置定时器(闹钟)，在指定seconds后，内核会给当前进程发送SIGALRM(14)信号，进程收到该信号，默认终止动作。</p>
<p>每个进程都有且只有唯一个定时器。</p>
</blockquote>
<p>unsigned int alarm(unsigned int seconds);</p>
<ul>
<li><p>参数：定时秒数</p>
</li>
<li><p>返回值：上次定时剩余秒数，无错误现象。</p>
</li>
</ul>
<p>常用：取消定时器alarm(0)，返回旧闹钟剩余的秒数</p>
<p>注意：定时与进程状态无关，无论进程处于何种状态，alarm都计时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用alarm测试1秒可以数多少次</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        alarm(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;;i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[补]使用time命令查看程序执行的时间(如time .&#x2F;alarm_count)，alarm_count是上面代码的函数</p>
<p>得出：实际执行时间 &#x3D; 系统时间+用户时间+等待时间(最多)—-&gt;程序运行的瓶颈在于IO，优化程序，首选优化IO。</p>
<h2 id="5-4setitimer函数"><a href="#5-4setitimer函数" class="headerlink" title="5.4setitimer函数"></a>5.4setitimer函数</h2><blockquote>
<p>setitimer函数可以替代alarm函数，精度到微妙，还可以实现周期定时</p>
</blockquote>
<p>int setitimer(int which,const struct itimerval *new_value,struct itimerval *old_value);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>new_value：定时秒数(结构体类型见代码)</p>
</li>
<li><p>old_value：传出参数，上次定时剩余时间</p>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：0；失败：-1，设置errno</li>
</ul>
</li>
</ul>
<p>提示：</p>
<ul>
<li><p>it_interval：用来设定两次定时任务之间间隔时间</p>
</li>
<li><p>it_value：定时的时长</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>,<span class="title">oldit</span>;</span></span><br><span class="line">        signal(SIGALRM,myfunc);      <span class="comment">//注册SIGALRM 信号的捕抓处理函数</span></span><br><span class="line"></span><br><span class="line">        it.it_value.tv_sec = <span class="number">2</span>;      <span class="comment">//设置定时器闹钟为2秒</span></span><br><span class="line">        it.it_value.tv_usec = <span class="number">0</span>;     <span class="comment">//这是设置微妙的</span></span><br><span class="line"></span><br><span class="line">        it.it_interval.tv_sec = <span class="number">5</span>;   <span class="comment">//周期为5秒，每5秒提醒一次</span></span><br><span class="line">        it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(setitimer(ITIMER_REAL,&amp;it,&amp;oldit) == <span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//循环一直停留在终端,方便观看</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5信号集和未决信号集"><a href="#5-5信号集和未决信号集" class="headerlink" title="5.5信号集和未决信号集"></a>5.5信号集和未决信号集</h2><p>1.信号集操作函数</p>
<ul>
<li><p>自定义信号集(用于和mask发生或与关系)：sigset_t set; </p>
</li>
<li><p>清空信号集(全置为0)：sigemptyset(sigset_t *set);   </p>
</li>
<li><p>信号集全置1：sigfillset(sigset_t *set);</p>
</li>
<li><p>将一个信号添加到集合中：sigaddset(sigset_t *set,int signum);</p>
</li>
<li><p>将一个信号从集合中移除：sigdelset(sigset_t *set,int signum);</p>
</li>
<li><p>判断一个信号是否在集合中(在是1，不在是0)：sigismember(const sigset_t *set,int signum);</p>
</li>
</ul>
<p>2.设置信号屏蔽字和解除屏蔽</p>
<p>int sigprocmask(int how , const sigset_t *set , sigset_t *oldset);</p>
<ul>
<li><p>how：SIG_BLOCK是设置阻塞；SIG_UNBLOCK是取消阻塞；SIG_SETMASK是用自定义set替换mask</p>
</li>
<li><p>set：自定义set</p>
</li>
<li><p>oldset： 旧有的mask</p>
</li>
</ul>
<p>用来屏蔽信号、解除屏蔽也使用该函数。其本质是读取或修改进程的信号屏蔽字(PCB中)</p>
<p>注意：屏蔽信号只是将信号处理延后执行(延至解除屏蔽)；而忽略是表示将信号丢弃处理</p>
<p>3.查看未决信号集</p>
<p>int sigpending(sigset_t *set);</p>
<ul>
<li>set：传出的未决参数</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/System_programming/1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对信号2设置了阻塞，并查看了未决信号集,Ctrl+c可以进行查看</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>&#123;     <span class="comment">//自定义函数打印位图</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sigismember(<span class="built_in">set</span>,i))&#123;     <span class="comment">//信号i是否在信号集set上</span></span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>,oldset,pedset;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);    <span class="comment">//清空信号集(置为0)</span></span><br><span class="line">        <span class="comment">//将信号添加到自定义集合中(在自定义集合中，将对应信号置为1)</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGINT);      <span class="comment">// Ctrl+c对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);     <span class="comment">// Ctrl+\对应信号置为1</span></span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGKILL);     <span class="comment">// 由于信号9不能被修改，所以不能被处理,可以通过kill -9 该程序对应进程号 来终止该进程</span></span><br><span class="line">        ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);     <span class="comment">//设置阻塞；自定义集合的地址，传出参数</span></span><br><span class="line">        <span class="comment">//通过上一行代码，对信号2进行了阻塞，只有解除阻塞，否则信号2一直未决，即在未决信号集中，信号2一直为1</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">                ret = sigpending(&amp;pedset);   <span class="comment">//查看未决信号集,参数是传出参数，是该进程的一个未决信号集</span></span><br><span class="line">                <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                print_set(&amp;pedset);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;  <span class="comment">//当i执行到10的时候，解除屏蔽字的阻塞，此时ctrl+c信号递达，退出程序</span></span><br><span class="line">                        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6sigaction函数"><a href="#5-6sigaction函数" class="headerlink" title="5.6sigaction函数"></a>5.6sigaction函数</h2><blockquote>
<p>signal函数和sigaction函数都是只注册一个信号的捕抓函数，捕抓是有内核来完成的</p>
</blockquote>
<p>int sigaction (int signum , const struct sigaction *act , struct sigaction *oldact);</p>
<ul>
<li><p>参数：</p>
<ul>
<li><p>singum：捕抓的信号</p>
</li>
<li><p>act：传入参数，新的处理方式</p>
</li>
<li><p>oldact：传出参数，旧的处理方式</p>
</li>
</ul>
</li>
</ul>
<p>信号捕抓的特性：</p>
<ul>
<li><p>进程正常运行时，默认PCB中有一个信号屏蔽字，假定为#，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉，捕捉到该信号之后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由#来指定，而是用sa_mask来指定，调用完信号处理函数，再恢复为#。</p>
</li>
<li><p>捕捉函数执行期间，本信号自动被屏蔽(sa_flgs&#x3D;0)。</p>
</li>
<li><p>捕捉函数执行期间，被屏蔽信号多次发生，解除屏蔽后只处理一次</p>
</li>
</ul>
<p>案例：用signal()函数对信号2进行捕抓</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        signal(SIGINT,sig_cath);      <span class="comment">//当信号SIGINT产生时，对其捕抓，去执行对应捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：用sigaction()函数对信号2进行捕抓(可以设置多个函数的捕抓)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_cath</span><span class="params">(<span class="type">int</span>  signo)</span>&#123;     <span class="comment">//自定义捕抓函数，当指定信号产生，就会执行</span></span><br><span class="line">        <span class="keyword">if</span>(signo == SIGINT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;catch you!%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(signo == SIGQUIT)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---catch you---%d\n&quot;</span>,signo);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span>     <span class="comment">//定义两个结构体</span></span><br><span class="line">        act.sa_handler = sig_cath;     <span class="comment">//设置回调函数(捕抓函数)</span></span><br><span class="line">        sigemptyset(&amp;(act.sa_mask));    <span class="comment">//将sa_mask屏蔽字置为0，这个只在sig_catch函数工作时有效</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;               <span class="comment">//默认值(在一个信号的捕抓函数执行时，默认蒙蔽该信号，防止再来)</span></span><br><span class="line">        <span class="type">int</span> ret = sigaction(SIGINT,&amp;act,&amp;oldact);     <span class="comment">//注册信号捕抓函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = sigaction(SIGQUIT,&amp;act,&amp;oldact);   <span class="comment">//注册第二个信号捕抓函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过信号捕捉回收子进程(当一个时间点有多个进程死亡时，此时只能处理一个，其他死亡的子进程没有回收就会是僵尸进程)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signo)</span>&#123;      <span class="comment">//有子进程终止，发送SIGCHLD信号时，该函数会被内核回调</span></span><br><span class="line">        <span class="type">pid_t</span> wpid;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>))!=<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;---catch child id %d,ret = %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="comment">//阻塞(防止父线程还没有注册完成，部分子线程就已经结束了，这样就来不及回收那些结束的子进程)</span></span><br><span class="line">        <span class="type">sigset_t</span> <span class="built_in">set</span>;    <span class="comment">//自定义阻塞信号集</span></span><br><span class="line">        sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);   <span class="comment">//将自定义阻塞信号集的SIGCHLD信号置1，使其与pcd里面的阻塞信号集作用，让该信号阻塞</span></span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);     <span class="comment">//使其与pcd的阻塞信号集作用</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                <span class="comment">//初始化act结构体</span></span><br><span class="line">                act.sa_handler = catch_child;     <span class="comment">//捕捉函数</span></span><br><span class="line">                sigemptyset(&amp;act.sa_mask);        <span class="comment">//设置捕捉函数执行期间的屏蔽信号集，全置为0</span></span><br><span class="line">                act.sa_flags = <span class="number">0</span>;                 <span class="comment">//设置默认属性，本信号自动屏蔽</span></span><br><span class="line">                sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);     <span class="comment">//子进程状态发生改变就触发捕捉函数</span></span><br><span class="line">                <span class="comment">//解除阻塞(父进程注册完毕，可以开始接收子线程结束后，内核传给父进程的信号了)</span></span><br><span class="line">                sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);   <span class="comment">//如果没有解除阻塞步骤，回调函数没有执行的机会(因为pcd的mask对该信号是屏蔽状态)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是父进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;我是子进程%d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">                <span class="comment">//sleep(i);    //可以用sleep进行一个一个回收</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-会话与守护进程"><a href="#6-会话与守护进程" class="headerlink" title="6.会话与守护进程"></a>6.会话与守护进程</h1><h2 id="6-1进程组和会话"><a href="#6-1进程组和会话" class="headerlink" title="6.1进程组和会话"></a>6.1进程组和会话</h2><blockquote>
<p>进程组，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid和kill函数的参数中都曾使用过。操作系统设计的进程组的概念，是为了简化对多个进程的管理。当父进程，创建子进程的时候，默认子进程与父进程属于同一个进程组。进程组ID &#x3D; 第一个进程ID(组长进程)。所以，组长进程标识，其进程组ID &#x3D; 其进程ID。</p>
<p>而会话就是进程组的集合。</p>
</blockquote>
<p>1.创建一个会话需要注意以下6点：</p>
<ul>
<li>调用进程不能是进程组组长，该进程变成新会话的首进程</li>
<li>该进程成为一个新进程组的组长进程</li>
<li>需要root权限 (Ubuntu不需要)</li>
<li>新会话丢弃原有的控制终端，该会话没有控制终端</li>
<li>如果该进程调用的是组长进程，则出错返回</li>
<li>建立新会话时，先调用fork，父进程终止，子进程调用setsid（）</li>
</ul>
<p>2.getsid()函数：获取进程所属的会话ID</p>
<p>pid_t getsid(pid_t pid);</p>
<ul>
<li><p>参数：pid为所需要获取的进程</p>
</li>
<li><p>返回值：成功(返回调用进程的会话ID)；失败(返回-1，设置errno)</p>
</li>
</ul>
<p>注意：组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程</p>
<p>3.setsid()函数：创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</p>
<p>pid_t setsid(void); </p>
<p>返回值：成功(返回调用进程的会话ID)；失败(返回-1)</p>
<p>注意：调用setsid函数的进程，既是新的会长，也是新的组长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子进程成立新会话(父进程不能创建会话)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;     <span class="comment">//子进程执行</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id(父进程的)---&gt;0为默认调用该程序的进程组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id(有可能是父进程的，也可能是父进程的父进程的)</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                setsid();   <span class="comment">//子进程非组长进程，故其成为新会话首进程，且成为组长进程。该进程组id即为会话进程(子进程id=组进程id=会话进程id)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;changed:\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process PID is %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Group ID of child is %d\n&quot;</span>,getpgid(<span class="number">0</span>));  <span class="comment">//组id</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Session ID of child is %d\n&quot;</span>,getsid(<span class="number">0</span>));   <span class="comment">//会话id</span></span><br><span class="line">               sleep(<span class="number">20</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2守护进程"><a href="#6-2守护进程" class="headerlink" title="6.2守护进程"></a>6.2守护进程</h2><blockquote>
<p>daemon进程。通常运行于操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发送或周期性执行某一动作。不受用户登录注销影响，通常采用以d结尾的命名方式。</p>
</blockquote>
<p>1.创建守护进程，最关键的一步是调用setsid函数，创建一个新的Session，并成为Session leader。</p>
<p>2.守护进程的创建步骤：</p>
<ul>
<li><p>fork子进程，让父进程终止</p>
</li>
<li><p>子进程调用setsid()创建新会话</p>
</li>
<li><p>通常根据需要，改变工作目录位置chdir()</p>
</li>
<li><p>通常根据需要，重设umask文件权限掩码</p>
</li>
<li><p>通常根据需要，关闭&#x2F;重定向文件描述符012</p>
</li>
<li><p>守护进程 业务逻辑。—-&gt;while()</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//守护进程的创建(运行在后台)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(<span class="string">&quot;str&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> ret,fd;</span><br><span class="line">        <span class="comment">//1、创建子进程，父进程终止</span></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//父进程终止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、子进程创建新会话</span></span><br><span class="line">        <span class="comment">//printf(&quot;---------------------\n&quot;);</span></span><br><span class="line">        pid = setsid();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、改变工作目录位置</span></span><br><span class="line">        ret = chdir(<span class="string">&quot;/home/c_c++后端/系统编程/session_dir&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、改变文件访问权限掩码</span></span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line">        <span class="comment">//5、关闭文件描述符 (此时就可用的最小文件描述符是3)</span></span><br><span class="line">        close(STDIN_FILENO);     <span class="comment">//关闭文件描述符0</span></span><br><span class="line">        fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);   <span class="comment">//读写打开dev/null文件 -----&gt;fd=0</span></span><br><span class="line">        <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd,STDOUT_FILENO);    <span class="comment">//将文件描述符1指向fd</span></span><br><span class="line">        dup2(fd,STDERR_FILENO);    <span class="comment">//将文件描述符2指向fd</span></span><br><span class="line">        <span class="comment">//6 一直运行，等待接收命令</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//模拟守护进程业务</span></span><br><span class="line">        <span class="comment">//printf(&quot;------------------\n&quot;);       </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-线程"><a href="#7-线程" class="headerlink" title="7.线程"></a>7.线程</h1><blockquote>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位，同一进程中的多条线程将共享该进程中的全部系统资源，但同一进程中的多个线程有各自的调用栈、寄存器环境和线程本地存储。</p>
</blockquote>
<p>1.线程与进程区别：</p>
<ul>
<li><p>进程：有独立的进程地址空间，有独立的pcb</p>
</li>
<li><p>线程：有独立的pcb，没有独立的进程地址空间—&gt;是轻量级进程LWP</p>
</li>
</ul>
<p>注意：线程是最小的执行单位；进程是最小分配资源单位，可看成是只有一个线程的进程。进程里创建线程后，进程也叫线程了</p>
<p>2.查看某个进程里的线程：</p>
<ul>
<li>ps -Lf 进程pid：线程号是LWP那一栏(相当于进程号，线程号是接在进程号后面的)</li>
</ul>
<p>3.线程共享资源：文件描述符、每种信号的处理的方式、当前工作目录、用户ID和组ID、内存地址空间(.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)、全局变量；</p>
<p>4.线程非共享资源：线程id、处理器现场和栈指针(内核栈)、独立的栈空间(用户空间栈)、errno变量、信号屏蔽字、调度优先级</p>
<p>5.线程优缺点</p>
<ul>
<li><p>优点：提高程序并发性、开销小、数据通信、共享数据方便；</p>
</li>
<li><p>缺点：是库函数，不稳定、调试、编写困难、对信号支持不好</p>
</li>
</ul>
<h2 id="7-1线程控制原语"><a href="#7-1线程控制原语" class="headerlink" title="7.1线程控制原语"></a>7.1线程控制原语</h2><p>1.线程函数</p>
<p><code>pthread_t pthread_self(void);</code></p>
<ul>
<li><p>返回值：本线程id号</p>
</li>
<li><p>作用：获取线程id，线程id是在进程地址空间内部用来标识线程身份的</p>
</li>
</ul>
<p>注意：线程ID是在进程中来标识线程身份的，进程通过线程ID来对其加以区分；而LWP是线程号，标识线程身份给CPU用的(CPU用线程号来划分时间片)</p>
<p>2.创建线程</p>
<p><code>int pthread_create(pthread_t *tid, const pthread_attr_t *attr, void *(*start_rountn)(void*),void *arg);</code></p>
<ul>
<li><p>参1：传出参数，表示新创建的子线程id</p>
</li>
<li><p>参2：线程属性，传NULL表示使用默认属性</p>
</li>
<li><p>参3：子线程回调函数，若创建成功，pthread_create函数返回时，该函数会被自动调用</p>
</li>
<li><p>参4：参数3函数的参数，没有的话就传NULL</p>
</li>
<li><p>返回值：成功(返回0)；失败(errno)</p>
</li>
</ul>
<p>注意：主函数利用pthread_create()创建新线程时，主函数会立即返回值并执行下面代码，不会因为新线程没有执行完回调函数而阻塞。</p>
<p>当新线程启动后，它会在后台执行回调函数，同时主线程继续执行自己的任务。如果回调函数执行时间较长，主线程仍然不会被阻塞，它会继续往下执行，直到遇到需要等待新线程完成任务的代码段。</p>
<p>3.退出当前线程</p>
<p><code>void pthread_exit(void *retval);</code></p>
<ul>
<li>参数：退出值，无退出值时，NULL</li>
</ul>
<p>注意：exit()是退出当前进程；return;是返回到调用者那里去</p>
<p>pthread_exit(NULL)的作用是在线程中显式地退出线程的函数调用。它用于终止当前线程的执行，并将线程的退出状态设置为NULL。当调用pthread_exit(NULL)时，当前线程会立即退出，并将控制返回给创建该线程的线程。这意味着线程的执行会终止，但其他线程仍然可以继续执行。</p>
<p>4.阻塞等待线程退出，获取线程退出状态</p>
<p><code>int pthread_join(pthread_t thread,void** retval);</code></p>
<ul>
<li><p>参1：要回收的线程id</p>
</li>
<li><p>参2：传出参数，存储线程退出的状态，线程正常退出，得到来自该线程在回调函数中返回的信息；线程异常退出，返回-1.</p>
</li>
<li><p>返回值：成功回收(返回0)，失败(errno)</p>
</li>
</ul>
<blockquote>
<p>注意：在进程中，进程结束是exit(1)，退出状态是int型，所以回收进程wait的参数是<code>int*</code>型；在线程中，线程结束是<code>pthread_exit(void*)</code>，退出状态是<code>void*</code>型，所以回收线程pthread_join参数是<code>void**</code>型。</p>
</blockquote>
<p>5.杀死(取消)线程，类似于进程中的kill()</p>
<p><code>int pthread_cancel(pthread_t thread);</code></p>
<ul>
<li><p>参数：待杀死的线程id</p>
</li>
<li><p>返回值：成功(0)；失败(errno)</p>
</li>
</ul>
<p>注意：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>如果子线程没有到达取消点，那么使用pthread_cancel无效。我们可以在程序中。手动添加应该取消点，使用pthread_testcancel()。</p>
<p>取消点：通常是一些系统调用creat,open,pause,close,read,write。(可以理解为是线程有进入内核，如果线程执行的内容是if,while,for这些则不能用pthread_cancel()杀死)</p>
<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<p>6.线程出错要用这个函数打印</p>
<p><code>char *strerror(int errnum);</code></p>
<ul>
<li>使用：fprintf(stderr,”pthread_join error:%s”,strerror(ret));</li>
</ul>
<p>7.实现线程分离</p>
<p><code>int pthread_detach(pthread_t thread); </code></p>
<ul>
<li><p>参数：待分离的线程id</p>
</li>
<li><p>返回值：成功(0),失败(errno)</p>
</li>
</ul>
<p>注意：pthread_detach不能与pthread_join一起用，当使用线程分离时，被分离的子线程就不归主线程管了，子线程执行完由系统回收，不需要主线程再调用pthread_join来回收，如果调用，会回收失败。</p>
<p>8.线程属性，用来设置分离属性</p>
<ul>
<li><p><code>pthread_attr_t attr;            //创建一个线程属性结构体变量</code></p>
</li>
<li><p><code>pthread_attr_init(&amp;attr);       //初始化线程属性</code></p>
</li>
<li><p><code>pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);    //设置</code></p>
</li>
<li><p><code>pthread_create(&amp;tid,&amp;attr,tfn,NULL);                //设置线程属性，创建为分离态</code></p>
</li>
<li><p><code>pthread_attr_destroy(&amp;attr);                       //销毁线程属性</code></p>
</li>
</ul>
<p>案例：创建一个线程执行回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子线程，先慢慢执行\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程，先结束了\n&quot;</span>);</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：循环创建多个子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传过来的参数进行转换</span></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：使用pthread_exit()函数来退出子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译时：最后面要加-pthread</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;       <span class="comment">//子线程执行部分</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//exit(0);      //表示退出进程，所以i=2后的线程都执行不了</span></span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);    <span class="comment">//将当前线程退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是第%d子线程：pid=%d,tid=%lu\n&quot;</span>,i+<span class="number">1</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">                ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)i);</span><br><span class="line">                <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程里面，pid=%d,tid=%lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_join()回收子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thrd</span>&#123;</span></span><br><span class="line">        <span class="type">int</span> var;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;     <span class="comment">//方法2：通过在主函数中定义一个结构体变量来实现</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">tval</span> =</span> (<span class="keyword">struct</span> thrd *)arg;</span><br><span class="line">        tval-&gt;var = <span class="number">93</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(tval-&gt;str,<span class="string">&quot;hello lxx&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)tval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="comment">/*struct thrd *retval;  </span></span><br><span class="line"><span class="comment">        int ret = pthread_create(&amp;tid,NULL,tfn,NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> <span class="title">arg</span>;</span>     <span class="comment">//定义一个结构体变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">thrd</span> *<span class="title">retval</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,(<span class="type">void</span> *)&amp;arg);</span><br><span class="line">    	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(tid,(<span class="type">void</span> **)&amp;retval);    <span class="comment">//回收子线程(阻塞)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;pthread_join error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child thread exit with var = %d,str = %s\n&quot;</span>,retval-&gt;var,retval-&gt;str);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);   <span class="comment">//线程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_cancel()终止子线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        ret = pthread_cancel(tid);       <span class="comment">//终止子线程</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_cancel error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//while(1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过pthread_detach()设置线程分离</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_detach(tid);            <span class="comment">//设置线程分离</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_detach error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        ret = pthread_join(tid,<span class="literal">NULL</span>);     <span class="comment">//接收失败会返回非0值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;join ret = %d\n&quot;</span>,ret);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_join error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：通过线程属性设置分离属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过线程属性设置来使子线程分离，这样就可以创建一个是一个了，而不需要后面手动一个一个设置</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        <span class="type">pthread_attr_t</span> attr;     <span class="comment">//定义属性结构体</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = pthread_attr_init(&amp;attr);    <span class="comment">//初始化属性结构体(传出参数)</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_init error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);      <span class="comment">//设置线程属性为 分离属性</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_setdetachastate error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;pthread_create error:%s&quot;</span>,strerror(ret));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main:pid = %d,tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        ret = pthread_attr_destroy(&amp;attr);    <span class="comment">//销毁属性结构体</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;attr_destroy error:%s\n&quot;</span>,strerror(ret));</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_exit((<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：终止线程的三种方法，注意取消点的概念。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">tfn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">111</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 returning\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn3</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 3 returning\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pthread_testcancel();   //自动添加取消点</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">void</span> *tret = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code = %d\n\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn3,<span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread 3 exit code = %d\n&quot;</span>,(<span class="type">int</span>)tret);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2线程使用注意事项"><a href="#7-2线程使用注意事项" class="headerlink" title="7.2线程使用注意事项"></a>7.2线程使用注意事项</h2><p>线程使用注意事项：</p>
<ul>
<li><p>主线程退出其他线程不退出，主线程应该调用pthread_exit()</p>
</li>
<li><p>避免僵尸线程，使用pthread_join、pthread_detach、pthread_create(指定分离属性)</p>
</li>
<li><p>malloc和mmap申请的内存可以被其他线程释放(线程共享堆)</p>
</li>
<li><p>应该避免在多线程模型中调用fork。除非马上exec。因为如果调用fork，则子进程中只有调用fork的线程存在，其他线程在子进程中均默认被pthread_exit</p>
</li>
<li><p>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</p>
</li>
</ul>
<h1 id="8-线程同步"><a href="#8-线程同步" class="headerlink" title="8.线程同步"></a>8.线程同步</h1><p>协同步调，对公共区域数据按序访问。防止数据混乱，产生与时间有关的错误。</p>
<p>锁的使用：建议锁，对公共数据进行保护。所有线程应该在访问公共数据前先拿锁再访问。但锁本身不具备强制性。</p>
<h2 id="8-1互斥锁mutex"><a href="#8-1互斥锁mutex" class="headerlink" title="8.1互斥锁mutex"></a>8.1互斥锁mutex</h2><p>1.使用互斥锁的一般步骤：</p>
<ul>
<li><p><code>pthread_mutex_t lock;         //创建锁</code></p>
</li>
<li><p><code>pthread_mutex_init;           //初始化</code></p>
</li>
<li><p><code>pthread_mutex_lock;           //加锁</code></p>
</li>
<li><p>访问共享数据(stdout)</p>
</li>
<li><p><code>pthread_mutex_unlock();      //解锁</code></p>
</li>
<li><p><code>pthread_mutex_destroy;       //销毁锁</code></p>
</li>
</ul>
<p>补：restrict关键字：用来限定指针变量。被该关键字限定的指针变量所指向的内存操作，必须由本指针完成。</p>
<p>2.初始化互斥锁的两种方法： </p>
<ul>
<li><p><code>pthread_mutex_t mutex;                             //定义一把锁</code></p>
</li>
<li><p><code>pthread_mutex_t_init(&amp;mutex,NULL);                 //动态初始化</code></p>
</li>
<li><p><code>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER;   //静态初始化</code></p>
</li>
</ul>
<p>注意：尽量保证锁的粒度(范围)，越小越好。访问共享数据前加锁，访问结束立即解锁。</p>
<p>方便记忆：互斥锁，本质是结构体。我们可以看成整数，初值为1，即pthread_mutex_init()调用成功；加锁理解为–操作，阻塞线程；解锁理解为++操作，唤醒阻塞在锁上的线程。</p>
<p>try锁：尝试加锁，成功–操作；失败就返回，同时设置错误号EBUSY。</p>
<p>案例：通过互斥锁进行对公共区域的访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;          <span class="comment">//定义一把互斥锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">tfn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);        <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);            <span class="comment">//模拟长时间操作共享资源，导致cpu易主，产生与时间有关的错误</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;lxx\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);      <span class="comment">//解锁              </span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> ret = pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);     <span class="comment">//对锁进行初始化</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;mutex init error:%s\n&quot;</span>,strerror(ret));  <span class="comment">//打印错误信息</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);     <span class="comment">//创建线程执行回调函数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);     <span class="comment">//加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;HELLO &quot;</span>);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                <span class="comment">//这里睡眠了1到3秒，但因为有加锁，输出依然是完整的HELLO WORLD</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;WORLD\n&quot;</span>);</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);   <span class="comment">//解锁</span></span><br><span class="line">            	sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);         <span class="comment">//销毁锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2读写锁"><a href="#8-2读写锁" class="headerlink" title="8.2读写锁"></a>8.2读写锁</h2><blockquote>
<p>锁只有一把，以读方式给数据加锁为读锁；以写方式给数据加锁为写锁。相较于互斥量(互斥锁)而言，当读线程多的时候，读写锁可以提高访问效率。</p>
</blockquote>
<p>1.读写锁的特性</p>
<ul>
<li><p>读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞</p>
</li>
<li><p>读写锁是“读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求，优先满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。</p>
</li>
</ul>
<p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。即写独占，读共享</p>
<p>2.主要应用函数</p>
<ul>
<li><p><code>pthread_rwlock_init                  //自定义读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_destroy               //销毁读写锁</code></p>
</li>
<li><p><code>pthread_rwlock_rdlock                //读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_wrlock                //写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_tryrdlock            //尝试读模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_trywrlock            //尝试写模式加锁</code></p>
</li>
<li><p><code>pthread_rwlock_unlock               //读写锁解锁(通用)</code></p>
</li>
</ul>
<p>以上函数的返回值都是：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_rwlock_t rwlock             //定义一个读写锁变量rwlock</code></li>
</ul>
<p>3.死锁</p>
<p>是使用锁不恰当导致的现象，如：</p>
<ul>
<li><p>对一个锁反复lock</p>
</li>
<li><p>两个线程，各自持有一把锁，请求另一把</p>
</li>
</ul>
<p>案例：模拟3个线程不定时写同一个全局资源，5个线程不定时读同一个全局资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> counter;                  <span class="comment">//定义一个全局变量</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;      <span class="comment">//全局的读写锁</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_write</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;    <span class="comment">//写的回调函数</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;     <span class="comment">//将传进来的参数进行转换</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_wrlock(&amp;rwlock);   <span class="comment">//写锁加锁</span></span><br><span class="line">                t = counter;    <span class="comment">//方便后面打印先前一个数</span></span><br><span class="line">                usleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;======Write %d:%lu:counter = %d ++counter = %d\n&quot;</span>,i,pthread_self(),t,++counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);   <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_read</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;           <span class="comment">//读的回调函数</span></span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pthread_rwlock_rdlock(&amp;rwlock);    <span class="comment">//读锁加锁</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------Read %d: %lu: %d\n&quot;</span>,i,pthread_self(),counter);</span><br><span class="line">                pthread_rwlock_unlock(&amp;rwlock);    <span class="comment">//读锁解锁</span></span><br><span class="line">                usleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">pthread_t</span> tid[<span class="number">8</span>];                     <span class="comment">//定义一个线程组</span></span><br><span class="line">        pthread_rwlock_init(&amp;rwlock,<span class="literal">NULL</span>);    <span class="comment">//初始化读写锁</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i],<span class="literal">NULL</span>,th_write,(<span class="type">void</span> *)i);         <span class="comment">//前面三个线程负责写</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                pthread_create(&amp;tid[i+<span class="number">3</span>],<span class="literal">NULL</span>,th_read,(<span class="type">void</span> *)(i+<span class="number">3</span>));    <span class="comment">//后面五个线程负责读</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">                pthread_join(tid[i],<span class="literal">NULL</span>);                 <span class="comment">//主线程回收子线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        pthread_rwlock_destroy(&amp;rwlock);                   <span class="comment">//销毁读写锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3条件变量"><a href="#8-3条件变量" class="headerlink" title="8.3条件变量"></a>8.3条件变量</h2><blockquote>
<p>条件变量本身不是锁，但它也可以造成线程阻塞，通常与互斥锁配合使用。</p>
</blockquote>
<p>1.主要应用函数：</p>
<ul>
<li><p><code>pthread_cond_init函数      //初始化条件变量</code></p>
</li>
<li><p><code>pthread_cond_destroy函数   //销毁条件变量</code></p>
</li>
<li><p><code>pthread_cond_wait函数      //等待条件满足</code></p>
</li>
<li><p><code>pthread_cond_timewait函数  //等待条件满足(超时不等)</code></p>
</li>
<li><p><code>pthread_cond_signal函数    //唤醒阻塞在条件变量的线程(一个)</code></p>
</li>
<li><p><code>pthread_cond_broadcast函数   //唤醒阻塞在条件变量的线程(多个)</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(返回错误号)</p>
<ul>
<li><code>pthread_cond_t cond;       //定义一个条件变量cond</code></li>
</ul>
<p>2.初始化条件变量的两种方法：</p>
<p><code>pthread_cond_t cond;                     //定义一个条件变量</code></p>
<ul>
<li><p><code>pthread_cond_t_init(&amp;cond,NULL);                //动态初始化</code></p>
</li>
<li><p><code>pthread_cond_t cond=PTHREAD_MUTEX_INITIALIZER; //静态初始化</code></p>
</li>
</ul>
<p>3.pthread_cond_wait函数作用：</p>
<ul>
<li><p>阻塞等待条件变量cond(参1)满足</p>
</li>
<li><p>释放已掌握的互斥锁，相当于pthread_mutex_unlock(&amp;mutex)。</p>
</li>
</ul>
<p>注意：上面两步为一个原子操作(中间不会分开执行)</p>
<ul>
<li>当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex)</li>
</ul>
<p>案例：模拟一个消费者-生产者模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">err_thread</span><span class="params">(<span class="type">int</span> ret,<span class="type">char</span>*str)</span>&#123;        <span class="comment">//线程创建失败调用的打印错误信息的函数</span></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s:%s\n&quot;</span>,str,strerror(ret));</span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span>                      <span class="comment">//定义一个结构体来存放信息</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;     <span class="comment">//定义并初始化一个互斥锁</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_data = PTHREAD_COND_INITIALIZER;     <span class="comment">//定义并初始化一个条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">produser</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//生产者的回调函数：生产数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));    <span class="comment">//创建一个节点</span></span><br><span class="line">                mp-&gt;num = rand()%<span class="number">1000</span>+<span class="number">1</span>;                        <span class="comment">//模拟随机产生一个数值</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;--------produce %d\n&quot;</span>,mp-&gt;num);         <span class="comment">//打印生产者产生的数据</span></span><br><span class="line">                <span class="comment">//后插法生产数据(将数据结点连起来)</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);                    <span class="comment">//加锁，互斥锁</span></span><br><span class="line">                mp-&gt;next = head;</span><br><span class="line">                head = mp;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);                  <span class="comment">//解锁互斥锁</span></span><br><span class="line"></span><br><span class="line">                pthread_cond_signal(&amp;has_data);                <span class="comment">//唤醒阻塞在条件变量 has_data上的线程</span></span><br><span class="line">                sleep(rand()%<span class="number">3</span>);                               <span class="comment">//随机睡眠</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;      <span class="comment">//消费者的回调函数：消费数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);           <span class="comment">//加锁，互斥量</span></span><br><span class="line">                <span class="keyword">while</span>(head == <span class="literal">NULL</span>)&#123;    <span class="comment">//当是空的时候，才对消费者进行阻塞等待，阻塞期间，会解锁，让生产者拿锁生产数据(如果是只有一个消费者可以是if，多个消费者则需要while)</span></span><br><span class="line">                        pthread_cond_wait(&amp;has_data,&amp;mutex);   <span class="comment">//阻塞等待条件变量，当有数据时，消费者就会被激活，且自动加锁</span></span><br><span class="line">                &#125;  <span class="comment">//如果有多个消费者，而用的是if，则会出现没有数据时，消费者还在消费，即吐核问题</span></span><br><span class="line">                mp = head;</span><br><span class="line">                head = mp-&gt;next;</span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-------------cconsumer id:%lu : %d\n&quot;</span>,pthread_self(),mp-&gt;num);</span><br><span class="line">                <span class="built_in">free</span>(mp);</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid1,cid2;</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;pid,<span class="literal">NULL</span>,produser,<span class="literal">NULL</span>);     <span class="comment">//创建一个生产者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create produser error&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid1,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第一个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer1 error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = pthread_create(&amp;cid2,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);     <span class="comment">//创建第二个消费者线程</span></span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create consumer2 error&quot;</span>);</span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);          <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid1,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        pthread_join(cid2,<span class="literal">NULL</span>);         <span class="comment">//回收线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-信号量"><a href="#9-信号量" class="headerlink" title="9.信号量"></a>9.信号量</h1><blockquote>
<p>应用于线程、进程间同步，因为互斥锁对于多个线程访问同一个公共内存空间时，只能一个一个访问，虽然保证了数据正确性的目的，但导致了线程的并发性下降。</p>
<p>信号量是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</p>
</blockquote>
<p>1.主要应用函数</p>
<ul>
<li><p><code>sem_init           //信号量初始化</code></p>
</li>
<li><p><code>sem_destroy        //信号量销毁</code></p>
</li>
<li><p><code>sem_wait           //信号量加锁</code></p>
</li>
<li><p><code>sem_trywait  </code></p>
</li>
<li><p><code>sem_timedwait</code></p>
</li>
<li><p><code>sem_post          //信号量解锁</code></p>
</li>
</ul>
<p>以上函数返回值：成功(返回0)；失败(-1)</p>
<p>2.int sem_init(sem_t *sem,int pshared,unsigned int value);</p>
<ul>
<li><p>参1：信号量</p>
</li>
<li><p>参2：0—&gt;用于线程间同步；1—&gt;用于进程间同步</p>
</li>
<li><p>参3：N值(指定同时访问的线程数)</p>
</li>
</ul>
<p>3.sem_wait()：一次调用，做一次–操作，当信号量的值为0时，再次–就会阻塞(对比pthread_mutex_lock)</p>
<p>4.sem_post()：一次调用，做一次++操作，当信号量的值为N时，再次++就会阻塞(对比pthread_mutex_unlock)</p>
<p>案例：用信号量实现生产者-消费者模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 5</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[NUM];                      <span class="comment">//全局数值实现环形队列</span></span><br><span class="line"><span class="type">sem_t</span> blank_number,product_number;   <span class="comment">//空格子信号量，产品信号量</span></span><br><span class="line"><span class="comment">//开始时，空格子为N，产品格子为0</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;blank_number);   <span class="comment">//生产者将格子数--，为0则阻塞等待(说明产品满了)</span></span><br><span class="line">                <span class="built_in">queue</span>[i]=rand()%<span class="number">100</span>+<span class="number">1</span>;     <span class="comment">//生产一个产品</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;------produce------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                sem_post(&amp;product_number);     <span class="comment">//将产品数++</span></span><br><span class="line"></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;        <span class="comment">//借助下标实现环形</span></span><br><span class="line">                sleep(rand()%<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;product_number);   <span class="comment">//消费者将产品数--，为0则阻塞等待(说明还没有产品可以消费)</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-----consumer------%d\n&quot;</span>,<span class="built_in">queue</span>[i]);</span><br><span class="line">                <span class="built_in">queue</span>[i]=<span class="number">0</span>;                 <span class="comment">//消费一个产品</span></span><br><span class="line">                sem_post(&amp;blank_number);    <span class="comment">//消费掉以后，将空格子数++</span></span><br><span class="line">                i = (i+<span class="number">1</span>)%NUM;</span><br><span class="line">                sleep(rand()%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">pthread_t</span> pid,cid;</span><br><span class="line">        sem_init(&amp;blank_number,<span class="number">0</span>,NUM);    <span class="comment">//初始化空格子信号量为5，0表示线程间同步</span></span><br><span class="line">        sem_init(&amp;product_number,<span class="number">0</span>,<span class="number">0</span>);    <span class="comment">//初始化产品数信号量为0</span></span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;pid,<span class="literal">NULL</span>,producer,<span class="literal">NULL</span>);   <span class="comment">//创建生产者</span></span><br><span class="line">        pthread_create(&amp;cid,<span class="literal">NULL</span>,consumer,<span class="literal">NULL</span>);   <span class="comment">//创建消费者</span></span><br><span class="line"></span><br><span class="line">        pthread_join(pid,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(cid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;blank_number);</span><br><span class="line">        sem_destroy(&amp;product_number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>管道</tag>
        <tag>信号</tag>
        <tag>pthread</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>结合epoll和http实现B/S模式</title>
    <url>/2024/07/26/%E7%BB%93%E5%90%88epoll%E5%92%8Chttp%E5%AE%9E%E7%8E%B0BS%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>epoll 是linux下的一个 I&#x2F;O 多路复用机制，用于高效地监听多个文件描述符上的 I&#x2F;O 事件。相较于 select 和 poll，epoll 在处理大量连接时具有更好的性能。而HTTP是应用层协议，同其他应用层协议一样，是为了实现某一类具体应用的协议，并由某一运行在用户空间的应用程序来实现其功能。它也是基于B&#x2F;S架构进行通信的，下面就结合epoll来实现一个能够给浏览器提供服务，供用户借助浏览器访问服务器主机中文件的B&#x2F;S模式。</p>
<h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h1><h2 id="2-1-主函数"><a href="#2-1-主函数" class="headerlink" title="2.1 主函数"></a>2.1 主函数</h2><p>主函数主要负责把启动程序时，传进来的参数用变量来接收，并检测，当传进来的参数不满3个时，就会报错，最后传入端口，来调用一个监听函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//命令行参数获取 端口和server提供的目录</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server port path\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取用户输入的端口</span></span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);  <span class="comment">//字符串转化为端口形式</span></span><br><span class="line">    <span class="comment">//改变进程工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">chdir</span>(argv[<span class="number">2</span>]);    <span class="comment">//将你要打开的文件路径作为工作目录，到时候遍历目录内容时就比较方便了</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动epoll监听</span></span><br><span class="line">    <span class="built_in">epoll_run</span>(port);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-核心函数"><a href="#2-2-核心函数" class="headerlink" title="2.2 核心函数"></a>2.2 核心函数</h2><p>这部分负责了小项目的大部分代码任务，监听连接、创建红黑树、向红黑树上添加监听描述符和通信描述符、以及建立连接后，对协议头的检查、创建发送协议头等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">epoll_run</span><span class="params">(<span class="type">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> all_events[MAXSIZE];</span><br><span class="line">    <span class="comment">//创建一个epoll红黑数根节点</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span>(epfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建监听描述符,并将其添加到红黑树上</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">init_listen_fd</span>(port, epfd);    <span class="comment">//这是一个自定义的函数，返回创建好的监听描述符(已添加到红黑树上)</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//监听节点对应事件 ---&gt;返回满足条件的事件个数</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd,all_events,MAXSIZE,<span class="number">-1</span>);   <span class="comment">//阻塞等待，有事件满足的文件描述符都在all_events数组里</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ret; i++)&#123;     <span class="comment">//开始遍历就绪的事件，一个一个处理</span></span><br><span class="line">            <span class="comment">//只处理读事件，其它事件默认不处理</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> *pev = &amp;all_events[i];   <span class="comment">//取出每一个事件</span></span><br><span class="line">            <span class="keyword">if</span>(!(pev-&gt;events &amp; EPOLLIN))&#123;       <span class="comment">//不是读事件</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">//直接跳出该事件的处理继续下一个事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pev-&gt;data.fd == lfd)&#123;          <span class="comment">//是监听描述符的读事件，即有客户端请求连接</span></span><br><span class="line">                <span class="built_in">do_accept</span>(lfd,epfd);          <span class="comment">//自定义函数，建立连接客户端，并挂上红黑树epoll</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                            <span class="comment">//是通信描述符的读事件，对端有信息发来</span></span><br><span class="line">                <span class="built_in">do_read</span>(pev-&gt;data.fd, epfd);  <span class="comment">//自定义函数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<code>init_listen_fd()</code>函数的实现，服务端绑定以及将监听的文件描述符挂到红黑数epoll上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">init_listen_fd</span><span class="params">(<span class="type">int</span> port,<span class="type">int</span> epfd)</span></span>&#123;            <span class="comment">//参数是端口和红黑树的根节点</span></span><br><span class="line">    <span class="comment">//创建监听的套接字lfd</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建服务器地址结构ip+port</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> srv_addr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;srv_addr,<span class="built_in">sizeof</span>(srv_addr));</span><br><span class="line">    srv_addr.sin_family = AF_INET;</span><br><span class="line">    srv_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    srv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);   <span class="comment">//INADDR_ANY指的是本地的ip</span></span><br><span class="line">    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="built_in">sizeof</span>(opt));</span><br><span class="line">    <span class="comment">//给lfd绑定地址结构</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;srv_addr,<span class="built_in">sizeof</span>(srv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置监听上限</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lfd添加到epoll数上，以监听连接的客户端信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN;      <span class="comment">//设置读事件</span></span><br><span class="line">    ev.data.fd = lfd;         <span class="comment">//监听文件描述符</span></span><br><span class="line">    <span class="comment">//将监听描述符的读事件添加到了红黑树上</span></span><br><span class="line">    ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add lfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lfd;         <span class="comment">//返回监听描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理连接的函数：该函数负责与对端建立连接，由于是监听到有加内特描述符的读事件已就绪，所以执行该函数时，是不会阻塞的。与对端连接好连接后，就将与对端的通信描述符添加到epoll树上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_accept</span><span class="params">(<span class="type">int</span> lfd,<span class="type">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clt_addr;</span><br><span class="line">    <span class="type">socklen_t</span> clt_addr_len = <span class="built_in">sizeof</span>(clt_addr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clt_addr, &amp;clt_addr_len);  <span class="comment">//与对端连接，这里不会阻塞</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印客户端ip+port</span></span><br><span class="line">    <span class="type">char</span> client_ip[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//打印客户端的内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;New client ip: %s, port: %d, cfd = %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET,&amp;clt_addr.sin_addr.s_addr,client_ip,<span class="built_in">sizeof</span>(client_ip)), <span class="built_in">ntohs</span>(clt_addr.sin_port),cfd);</span><br><span class="line">    <span class="comment">//设置cfd阻塞</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(cfd,F_GETFL);</span><br><span class="line">    flag |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(cfd,F_SETFL,flag);</span><br><span class="line">    <span class="comment">//将新节点cfd挂到epoll数上，来监听对端通信</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.data.fd = cfd;</span><br><span class="line">    <span class="comment">//边沿非阻塞模式</span></span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl add cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通信函数实现：该函数负责的就是与对端的通信，其中需要判断对端发来的是什么类型请求，过程有点复杂。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//读取一行http协议，拆分，获取get 文件名 协议号</span></span><br><span class="line">    <span class="type">char</span> line[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">get_line</span>(cfd,line,<span class="built_in">sizeof</span>(line));   <span class="comment">//读http请求协议首行---&gt; GET 客户需要获取的文件 http的协议号</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;服务器，检查到客户端关闭....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">disconnect</span>(cfd,epfd);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;      <span class="comment">//有数据可以读</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;================请求头================&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请求行数据：%s&quot;</span>,line);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;      <span class="comment">//清除剩下的数据，下次传来信息，可以继续读第一行</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            len = <span class="built_in">get_line</span>(cfd,buf,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===============The end===============\n&quot;</span>);</span><br><span class="line">        <span class="comment">//判断啥类型请求</span></span><br><span class="line">        <span class="comment">//if(strncasecmp(method,&quot;GET&quot;,3) == 0)&#123;   //确定用户传来的是啥类型命令---&gt;这里是GET</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncasecmp</span>(<span class="string">&quot;get&quot;</span>, line, <span class="number">3</span>)==<span class="number">0</span>)&#123;       <span class="comment">//忽略大小写比较n个字符</span></span><br><span class="line">            <span class="built_in">http_request</span>(line, cfd);        <span class="comment">//处理http请求</span></span><br><span class="line">            <span class="comment">//关闭套接字，cfd从epoll上del</span></span><br><span class="line">            <span class="comment">//disconnect(cfd, epfd);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在得到对端传来的请求后，通过请求的第一行来查看对端需要的文件是什么类型，并检查看当前文件有无对端需要的文件，不同情况。采取不同处理方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理http请求，判断文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_request</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* request, <span class="type">int</span> cfd)</span></span>&#123;     <span class="comment">//请求http协议第一行；客户端fd</span></span><br><span class="line">    <span class="comment">//拆分http请求行</span></span><br><span class="line">    <span class="type">char</span> method[<span class="number">12</span>], path[<span class="number">1024</span>], protocol[<span class="number">12</span>];     <span class="comment">//三个字符数组分别装GET、文件名、HTTP协议号</span></span><br><span class="line">    <span class="built_in">sscanf</span>(request, <span class="string">&quot;%[^ ] %[^ ] %[^ ]&quot;</span>, method, path, protocol);       <span class="comment">//正则表达式的方式获取各类容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;method = %s, path = %s, protocol = %s\n&quot;</span>, method, path, protocol);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转码 将不能识别的中文乱码 --&gt;中文</span></span><br><span class="line">    <span class="comment">//解码 将浏览器发来的文件名(unicode编码)转为中文，方便后台处理找到，后面回发给浏览器时，在对其进行编码</span></span><br><span class="line">    <span class="built_in">decode_str</span>(path,path);         <span class="comment">//参数1是存解码好的内容，参数2是要解码的内容</span></span><br><span class="line">    <span class="comment">//用户有请求是get /hello.txt HTTP1.1 ；无请求是get / HTTP1.1</span></span><br><span class="line">    <span class="type">char</span> *file = path + <span class="number">1</span>;     <span class="comment">//取出 客户端要访问的文件名---&gt;path是\video.mp4,而+1是为了移动下标位置，最前面的\不需要</span></span><br><span class="line">    <span class="comment">//如果没有指定访问的资源，默认就显示资源目录中的内容</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(path,<span class="string">&quot;/&quot;</span>)==<span class="number">0</span>)&#123;   <span class="comment">//如果是无请求，path就是/，file就是空 ---&gt;浏览器输入192.168.88.93:9527 ---&gt;就是这种情况，访问的是dir目录下的内容</span></span><br><span class="line">        file = <span class="string">&quot;./&quot;</span>;   <span class="comment">//设置file的值，资源目录的当前位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sbuf;</span><br><span class="line">    <span class="comment">//判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">stat</span>(file,&amp;sbuf);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;                      <span class="comment">//表示没有找到该文件</span></span><br><span class="line">        <span class="comment">//回发浏览器404错误页面</span></span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;No such file or direntry&quot;</span>);</span><br><span class="line">        <span class="comment">//printf(&quot;错误页面啊----------------------------&quot;);</span></span><br><span class="line">        <span class="keyword">return</span>;                   <span class="comment">//不能exit(1);请求文件不存在，没有必要退出服务器，可以等待对方下一个请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是目录还是文件</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(sbuf.st_mode))&#123;     <span class="comment">//是目录</span></span><br><span class="line">        <span class="comment">//发送头信息</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd, <span class="number">200</span>, <span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(<span class="string">&quot;.html&quot;</span>), <span class="number">-1</span>);   <span class="comment">//-1表示系统自己获取文件大小</span></span><br><span class="line">        <span class="comment">//发送目录信息</span></span><br><span class="line">        <span class="built_in">send_dir</span>(cfd,file);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(sbuf.st_mode))&#123;         <span class="comment">//是一个普通文件</span></span><br><span class="line">        <span class="built_in">send_respond_head</span>(cfd,<span class="number">200</span>,<span class="string">&quot;OK&quot;</span>, <span class="built_in">get_file_type</span>(file), sbuf.st_size);</span><br><span class="line">        <span class="comment">//回发给客户端请求的文件内容</span></span><br><span class="line">        <span class="built_in">send_file</span>(cfd, file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在得到对端请求文件的类型后，作为服务器，发送给对端内容，也需要创建一个响应头，其中下面程序就针对对端请求的文件类型，生成了对应的响应头，并先发送给对端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应答客户端协议头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_respond_head</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> no, <span class="type">const</span> <span class="type">char</span> *desp, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">long</span> len)</span></span>&#123;  <span class="comment">//客户端的fd；错误号；错误描述；回发文件类型；文&gt;件长度</span></span><br><span class="line">    <span class="comment">//拼接协议头</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, no, desp);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//信息报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, type);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%ld\r\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);     <span class="comment">//拼接好后存在buf里面，直接通过buf发给对端</span></span><br><span class="line">    <span class="comment">//空行</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送完响应头后，也知道了对端请求的是一个目录，而本地也存在该目录，接下来就是将该目录内容在满足http协议的前提下发送给对端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送服务器本地目录给浏览器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_dir</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span>* dirname)</span></span>&#123;     <span class="comment">//发送目录内容函数</span></span><br><span class="line">    <span class="type">int</span> i, ret;</span><br><span class="line">    <span class="comment">//拼一个html页面&lt;table&gt;&lt;/table&gt;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4094</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;目录名：%s&lt;/title&gt;&lt;/head&gt;&quot;</span>, dirname);   <span class="comment">//这一行是给网页取名</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;&lt;body&gt;&lt;h1&gt;当前目录：%s&lt;/h1&gt;&lt;table&gt;&quot;</span>, dirname);  <span class="comment">//---&gt;这一行是显示在页面上</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> enstr[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//后面将文件名编码后，存放的位置</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目录项二级指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>** ptr;      <span class="comment">//---&gt;结构体里面重要的两项是inode编号，和文件名</span></span><br><span class="line">    <span class="comment">//scandir是把dirname目录的下的目录项例出来</span></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">scandir</span>(dirname, &amp;ptr, <span class="literal">NULL</span>, alphasort);    <span class="comment">//要访问的文件目录名；目录项的字符指针数组(传出)；过滤器(没有用到)；内容按字符排序</span></span><br><span class="line">    <span class="comment">//得到dirname下的所有目录项存放在ptr字符数组中，num是返回该数组中的个数</span></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">        <span class="type">char</span>* name = ptr[i]-&gt;d_name;</span><br><span class="line">        <span class="comment">//拼接文件的完整路径</span></span><br><span class="line">        <span class="built_in">sprintf</span>(path, <span class="string">&quot;%s/%s&quot;</span>, dirname, name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;path = %s =================\n&quot;</span>, path);  <span class="comment">//---&gt;这一行输入是终端看的</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">        <span class="built_in">stat</span>(path,&amp;st);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编码生成 %E5 %E6之类的东西(在浏览器搜索哪里中文和某类编码是一一对应的，回发给浏览器，要将中文转编码)</span></span><br><span class="line">        <span class="built_in">encode_str</span>(enstr, <span class="built_in">sizeof</span>(enstr), name);    <span class="comment">//name是目录项下的文件名(传入)；enstr是传出，存放文件名编码后的unicode编码</span></span><br><span class="line">        <span class="comment">//如果是文件</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">S_ISREG</span>(st.st_mode))&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">S_ISDIR</span>(st.st_mode))&#123;        <span class="comment">//如果是目录</span></span><br><span class="line">            <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;tr&gt;&lt;td&gt;&lt;a href=\&quot;%s/\&quot;&gt;%s/&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%ld&lt;/td&gt;&lt;/tr&gt;&quot;</span>, enstr, name, (<span class="type">long</span>)st.st_size);</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);    <span class="comment">//将拼接好的内容发给对端</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR)&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));      <span class="comment">//清0，下一个循环继续用(一个目录下有多个子目录和子文件)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);  <span class="comment">//发送完对端请求目录下所有内容后，进行结尾拼接</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);               <span class="comment">//将结尾拼接的内容发给对端</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dir message send OK!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在发送完响应头后，也知道了对端请求的是一个具体文件，而本地也存在该文件，接下来服务器就是打开该文件读取，将文件内容在满足http协议的前提下发送给对端。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送服务器本地文件给浏览器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_file</span><span class="params">(<span class="type">int</span> cfd, <span class="type">const</span> <span class="type">char</span> *file)</span></span>&#123;     <span class="comment">//cfd是访问的客户端的socket；file是要访问的文件</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//打开的服务器本地文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(file, O_RDONLY);      <span class="comment">//以只读打开用户需要的文件</span></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//打开文件失败，回发404错误页面</span></span><br><span class="line">        <span class="built_in">send_error</span>(cfd, <span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>, <span class="string">&quot;No such file or direntry&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">send</span>(cfd, buf, n, <span class="number">0</span>);        <span class="comment">//从fd向buf写内容(用户需要的文件)</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;errno = %d\n&quot;</span>,errno);</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;                          <span class="comment">//不算错误，直接continue</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;----------------EAGAIN\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(errno == EINTR)&#123;                     <span class="comment">//不算错误，直接continue</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;---------------EINTR\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">4096</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;----------send ret: %d\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-辅助函数"><a href="#2-3-辅助函数" class="headerlink" title="2.3 辅助函数"></a>2.3 辅助函数</h2><p>断开连接的函数：当对端请求关闭时，会调用该函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//断开链接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> epfd)</span></span>&#123;            <span class="comment">//参数：要断开的描述符；红黑树根节点</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,cfd,<span class="literal">NULL</span>);   <span class="comment">//将cfd从红黑树上摘下</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl del cfd error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cfd);                 <span class="comment">//关闭该描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>404错误页面函数：当服务器在本地没有找到对端的请求目录文件时或服务器打开本地文件出错都会调用该函数，会发送给对端一个404页面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_error</span><span class="params">(<span class="type">int</span> cfd, <span class="type">int</span> status, <span class="type">char</span> *title, <span class="type">char</span> *text)</span></span>&#123;        <span class="comment">//错误页面404</span></span><br><span class="line">    <span class="comment">//应答协议的协议头</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);    <span class="comment">//http协议号；错误号；错误描述</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);    <span class="comment">//类型一定是html类型(固定的)---&gt;因为是错误页面</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Content-Length:%d\r\n&quot;</span>, <span class="number">-1</span>);           <span class="comment">//内容长度不晓得是多大就写-1</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;Connection: close\r\n&quot;</span>);              <span class="comment">//http协议是：服务器完成一次与客户端的应答，就主动断开(不写这个也可&gt;以)</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);     <span class="comment">//拼接好后存在buf里面，直接通过buf发给对端</span></span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;\r\n&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);            <span class="comment">//应答协议头的结尾标记</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;%d %s&lt;/title&gt;&lt;/head&gt;\n&quot;</span>, status, title);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;body bgcolor=\&quot;#cc99cc\&quot;&gt;&lt;h4 align=\&quot;center\&quot;&gt;%d %s&lt;/h4&gt;\n&quot;</span>, status,title);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;%s\n&quot;</span>,text);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf), <span class="string">&quot;&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">send</span>(cfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------------------错误页面啊----------------------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取协议第一行的函数：该函数是服务器在接收到对端发来的请求时，为了得到请求头的第一行而调用的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一行 http的内容结构末尾是以/r/n换行的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_line</span><span class="params">(<span class="type">int</span> cfd, <span class="type">char</span> *buf, <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;size<span class="number">-1</span>) &amp;&amp; (c!=<span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">        n = <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,<span class="number">0</span>);    <span class="comment">//每次只读一个字符存到c中，有数据就读，没有数据就阻塞，读完就没有了</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">                n = <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,MSG_PEEK);</span><br><span class="line">                <span class="keyword">if</span>((n&gt;<span class="number">0</span>) &amp;&amp; (c==<span class="string">&#x27;\n&#x27;</span>))&#123;</span><br><span class="line">                    <span class="built_in">recv</span>(cfd,&amp;c,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    c=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            buf[i] = c;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码和解码函数：编码是服务器将本地找到的文件目录(中文)转为浏览器的一些编码格式(unicode编码)，发给对端；而解码就是从对端(浏览器)请求中显示的文件(unicode编格式)转为中文，这样服务器在本地也方便搜索寻找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编码：汉字--&gt;unicode码 -----&gt;服务端回发给浏览器时使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encode_str</span><span class="params">(<span class="type">char</span>* to, <span class="type">int</span> tosize, <span class="type">const</span> <span class="type">char</span>* from)</span></span>&#123;      <span class="comment">//from是传进来的，to是编码后传出去的</span></span><br><span class="line">    <span class="type">int</span> tolen;</span><br><span class="line">    <span class="keyword">for</span>(tolen = <span class="number">0</span>; *from != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; tolen+<span class="number">4</span> &lt; tosize; from++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalnum</span>(*from) || <span class="built_in">strchr</span>(<span class="string">&quot;/_.-~&quot;</span>, *from) != (<span class="type">char</span>*)<span class="number">0</span>)&#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">            to++;</span><br><span class="line">            tolen++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(to, <span class="string">&quot;%%%02x&quot;</span>,(<span class="type">int</span>) *from&amp;<span class="number">0xff</span>);</span><br><span class="line">            to += <span class="number">3</span>;</span><br><span class="line">            tolen += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码：unicode码--&gt;汉字 -----&gt;浏览器发给服务器时使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decode_str</span><span class="params">(<span class="type">char</span> *to, <span class="type">char</span> *from)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; *from != <span class="string">&#x27;\0&#x27;</span>; to++, from++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">1</span>]) &amp;&amp; <span class="built_in">isxdigit</span>(from[<span class="number">2</span>]))&#123;</span><br><span class="line">            *to = <span class="built_in">hexit</span>(from[<span class="number">1</span>])*<span class="number">16</span> + <span class="built_in">hexit</span>(from[<span class="number">2</span>]);</span><br><span class="line">            from += <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *to = *from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *to = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制数转化为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hexit</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件类型函数：通过对端请求头的请求文件，来得到该请求文件的文件类型(响应头需要文件的类型)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过文件名获取文件的类型</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">get_file_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> *dot;</span><br><span class="line">    <span class="comment">//自右向左查找‘.’字符，如不存在返回NULL</span></span><br><span class="line">    dot = <span class="built_in">strrchr</span>(name,<span class="string">&#x27;.&#x27;</span>);      <span class="comment">//获取文件的类型。---&gt;.后面的就为文件类型</span></span><br><span class="line">    <span class="keyword">if</span>(dot == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.html&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.htm&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html; charset=utf-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.jpg&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.jpeg&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/jpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.gif&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/gif&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.png&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;image/png&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.css&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.au&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/basic&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.wav&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/wav&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.avi&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/x-msvideo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mov&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.qt&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/quicktime&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mpeg&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mpe&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;video/mpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.vrml&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.wrl&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;model/vrml&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.midi&quot;</span>)==<span class="number">0</span> || <span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mid&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/midi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.mp3&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;audio/mpeg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.ogg&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/ogg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dot,<span class="string">&quot;.pac&quot;</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application/x-ns-proxy-autoconfig&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text/plain; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-执行效果"><a href="#3-执行效果" class="headerlink" title="3. 执行效果"></a>3. 执行效果</h1><p>这是服务器本地的一个文件，具体有这些文件内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_5.png"></p>
<p>当服务器启动后，在本地的浏览器输入服务器ip和设置的端口，就能得到如下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_6.png"></p>
<p>上面页面的所有内容都可以通过在浏览器端口后面输入对应的文件名或直接点击页面文件获得，如：</p>
<p>点击document3_文档就可以进入如下页面，当然，还可以再点击a.txt或b.txt，访问该txt文件里面的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_7.png"></p>
<p>点击图片就会显示如下页面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_8.png"></p>
<p>点击歌曲也可以播放：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/project/6_9.png"></p>
<p>对于视频，因为这个centos系统没有下载对于的视频插件，所以不能播放。</p>
]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>epoll</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2024/07/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h1><p>从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。</p>
<h2 id="1-1-协议"><a href="#1-1-协议" class="headerlink" title="1.1 协议"></a>1.1 协议</h2><p>1.典型的协议</p>
<ul>
<li><p>传输层：常见协议有TCP&#x2F;UDP协议</p>
</li>
<li><p>应用层：常见的协议有HTTP协议、FTP协议</p>
</li>
<li><p>网络层：常见的协议有IP协议、ICMP协议、IGMP协议</p>
</li>
<li><p>网络接口层：常见的协议有ARP协议、RARP协议</p>
</li>
</ul>
<p>2.分层模型结构</p>
<ul>
<li><p>OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
</li>
<li><p>TCP&#x2F;IP四层模型：网络接口层(链路层)、网路层、传输层、应用层</p>
</li>
</ul>
<p>3.网络传输流程</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_1.png"></p>
<p>注意：数据没有封装之前，是不能在网络中传递的。</p>
<p>4.ARP协议</p>
<blockquote>
<p>在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用，源主机发出ARP协议，询问IP地址是192.168.0.1的主机的硬件地址是多少，并将这个请求广播到本地网段，目的主机接收到广播ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_2.png"></p>
<p>ARP协议：根据IP地址获取mac地址</p>
<p>以太网帧协议：根据mac地址，完成数据包传输</p>
<p>5.IP协议：</p>
<ul>
<li><p>版本：IPv4、IPv6</p>
</li>
<li><p>TTL:time to live。设置数据包在路由节点中的跳转上限，每经过一个路由节点，该值-1，减为0的路由，有义务将该数据包丢弃</p>
</li>
<li><p>源IP&#x2F;目的IP：32位—&gt;4字节</p>
</li>
</ul>
<p>补：IP地址：可以在网络环境中，唯一标识一台主机</p>
<p>端口号：可以网络的一台主机上，唯一标识一个进程</p>
<p>IP地址+端口号：可以在网络环境中，唯一标识一个进程</p>
<h2 id="1-2-C-S模型与B-S模型"><a href="#1-2-C-S模型与B-S模型" class="headerlink" title="1.2 C&#x2F;S模型与B&#x2F;S模型"></a>1.2 C&#x2F;S模型与B&#x2F;S模型</h2><p>1.C&#x2F;S模型(client-server)</p>
<ul>
<li><p>优点：缓存大量数据、协议选择灵活、速度快</p>
</li>
<li><p>缺点：安全性低、不能跨平台、开发工作量较大</p>
</li>
</ul>
<p>2.B&#x2F;S模型</p>
<ul>
<li><p>优点：安全性高、跨平台、开发工作量较小</p>
</li>
<li><p>缺点：不能缓存大量数据、严格遵守HTTP</p>
</li>
</ul>
<h1 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h1><h2 id="2-1-网络套接字socket"><a href="#2-1-网络套接字socket" class="headerlink" title="2.1 网络套接字socket"></a>2.1 网络套接字socket</h2><blockquote>
<p>一个文件描述符指向一个套接字(该套接字内部由内核借助两个缓冲区实现)。在通信过程中，套接字一定是成对出现的。</p>
</blockquote>
<p>1.网络字节序</p>
<ul>
<li><p>小端法(pc本地地址)：高位存高位地址，低位存低位地址</p>
</li>
<li><p>大端法(网络存储)：高位存低位地址，低位存高位地址</p>
</li>
</ul>
<p>2.转换函数</p>
<ul>
<li><p>htonl：本地(IP) ——–&gt; 网络(IP)</p>
</li>
<li><p>htons：本地(port) ——-&gt; 网络(port)</p>
</li>
<li><p>ntohl：网络(IP) ——–&gt; 本地(IP)</p>
</li>
<li><p>ntohs：网络(port) ——-&gt; 本地(port)</p>
</li>
</ul>
<p>3.IP地址转换函数</p>
<p>本地字节序(string IP) ——-&gt; 网络字节序</p>
<p><code>int inet_pton(int af , const char *src , void *dst);</code></p>
<ul>
<li><p>参1：AF_INET、AF_INET6</p>
</li>
<li><p>参2：传入参数，IP地址(点分十进制)</p>
</li>
<li><p>参3：传出参数，转换后的网络字节序的IP地址</p>
</li>
<li><p>返回值：成功(1)；异常(0，说明src指向的不是一个有效的ip地址)；失败(-1)</p>
</li>
</ul>
<p>网络字节序—&gt;本地字节序(string IP)</p>
<p><code>const char *inet_ntop(int af , const void *src , char *dst , socklen_t size);</code></p>
<ul>
<li><p>参1：AF_INET、AF_INET6</p>
</li>
<li><p>参2：网络字节序IP地址</p>
</li>
<li><p>参3：本地字节序(string IP)</p>
</li>
<li><p>参4：参3的大小</p>
</li>
<li><p>返回值：成功(参3)；失败(NULL)；</p>
</li>
</ul>
<p>4.sockaddr地址结构(查看：man 7 ip)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET/AF_INET6</span><br><span class="line">addr.sin_port = htons(<span class="number">9527</span>);                <span class="comment">//端口号</span></span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);   <span class="comment">//取出系统中有效的任意IP地址(获取默认本地IP地址)，二进制类型</span></span><br><span class="line">bind(fd,(<span class="keyword">struct</span> sockaddr *)&amp;addr,size);     <span class="comment">//进行绑定，需要转换成sockaddr</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-网络相关函数"><a href="#2-2-网络相关函数" class="headerlink" title="2.2 网络相关函数"></a>2.2 网络相关函数</h2><p>1.创建一个套接字</p>
<p>头文件：#include &lt;sys&#x2F;socket.h&gt;</p>
<p><code>int socket(int domain , int type , int protocol); </code></p>
<ul>
<li><p>参1：AF_INET(IPV4)、AF_INET6(IPV6)、AF_UNIX(本地套接字)</p>
</li>
<li><p>参2：SOCK_STREAM(流式协议)、SOCK_DGRAM(报式协议)</p>
</li>
<li><p>参3：0即可</p>
</li>
<li><p>返回值：成功(新套接字所对应文件描述符)；失败(-1)</p>
</li>
</ul>
<p>2.给socket绑定一个地址结构(IP+port)</p>
<p>头文件：include &lt;arpa&#x2F;inet.h&gt;</p>
<p><code>int bind(int sockfd , const struct sockaddr *addr , socklen_t addrlen);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传入参数，自己的地址结构(IP+port)</p>
</li>
<li><p>参3：地址结构的大小</p>
</li>
<li><p>返回值：成功(0)，失败(-1)</p>
</li>
</ul>
<p>3.设置同时与服务器建立连接的上限数(同时进行三次握手的客户端数量)</p>
<p><code>int listen(int socket , int backlog);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：上限数值。最大值为128</p>
</li>
<li><p>返回值：成功(0)；失败(-1)</p>
</li>
</ul>
<p>4.阻塞等待客户端建立连接，成功的话，返回一个与客户端成功连接的socket文件描述符</p>
<p><code>int accept(int sockfd , struct sockaddr *addr , socklen_t *addrlen);</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传出参数，得到成功与服务器建立连接的那个客户端的地址结构</p>
</li>
<li><p>参3：传入传出参数，传入参2的大小，传出客户端地址结构实际大小</p>
</li>
<li><p>返回值：成功(能与服务器进行数据通信的socket对应的文件描述符)；失败(-1)</p>
</li>
</ul>
<p>5.使用现有的socket与服务器建立连接</p>
<p><code>int connect(int sockfd , const struct sockaddr *addr , socklen_t addrlen)</code></p>
<ul>
<li><p>参1：socket函数返回值</p>
</li>
<li><p>参2：传入参数，服务器的地址结构</p>
</li>
<li><p>参3：服务器的地址结构的大小</p>
</li>
<li><p>返回值：成功(0)；失败(-1)</p>
</li>
</ul>
<p>补：如果不使用bind绑定客户端地址结构，系统采用“隐式绑定”。</p>
<p>服务端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527                         <span class="comment">//固定一个端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;                 <span class="comment">//打印错误信息函数</span></span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> lfd = <span class="number">0</span>,cfd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clit_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ],client_IP[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> ret ,i;</span><br><span class="line">    <span class="type">socklen_t</span> clit_addr_len;</span><br><span class="line">    <span class="comment">//服务端结点信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);       <span class="comment">//得到一个监听描述符</span></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//与本地进行绑定</span></span><br><span class="line">    listen(lfd,<span class="number">128</span>);                          <span class="comment">//设置一次性最大监听数128</span></span><br><span class="line">    clit_addr_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">    cfd = accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clit_addr,&amp;clit_addr_len);   <span class="comment">//监听连接客户端，连接成功得到一个它们之间通信的描述符</span></span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印建立连接的客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip:%s port:%d\n&quot;</span>,</span><br><span class="line">           inet_ntop(AF_INET,&amp;clit_addr.sin_addr.s_addr,client_IP,<span class="keyword">sizeof</span>(client_IP)),</span><br><span class="line">           ntohs(clit_addr.sin_port));    <span class="comment">//打印客户端的地址结构信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//将客户端发来的信息存到buf</span></span><br><span class="line">        write(STDOUT_FILENO,buf,ret);      <span class="comment">//打印在屏蔽上</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ret; i++)&#123;          <span class="comment">//将得到的字母转为大写</span></span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        write(cfd,buf,ret);                <span class="comment">//发送给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);                            <span class="comment">//关闭监听描述符</span></span><br><span class="line">    close(cfd);                            <span class="comment">//关闭通信描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9527                 <span class="comment">//定义一个要连接的服务端的端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_err</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>&#123;         <span class="comment">//打印错误信息</span></span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> cfd;</span><br><span class="line">        <span class="type">int</span> conter = <span class="number">10</span>;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//服务器地址结构</span></span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_port = htons(SERV_PORT);      <span class="comment">//要连接服务端的端口</span></span><br><span class="line">        inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;serv_addr.sin_addr.s_addr);   <span class="comment">//要连接服务端的ip地址</span></span><br><span class="line">        cfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);        <span class="comment">//得到一个通信描述符</span></span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>)&#123;</span><br><span class="line">                sys_err(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ret = connect(cfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//连接服务端</span></span><br><span class="line">        <span class="keyword">while</span>(--conter)&#123;</span><br><span class="line">                write(cfd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);           <span class="comment">//向服务端发送信息</span></span><br><span class="line">                ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));  <span class="comment">//读取服务端发来的信息，存到buf</span></span><br><span class="line">                write(STDOUT_FILENO,buf,ret);     <span class="comment">//将buf的信息打印到终端屏幕</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);              <span class="comment">//关闭通信描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-三次握手和四次挥手"><a href="#2-3-三次握手和四次挥手" class="headerlink" title="2.3 三次握手和四次挥手"></a>2.3 三次握手和四次挥手</h2><p>1.三次握手</p>
<ul>
<li><p>主动发起连接请求端：发送SYN标志位，请求建立连接。携带序号号、数据字节数(0)、滑动窗口大小win。</p>
</li>
<li><p>被动接受连接请求端：发送ACK(应答)标志位，同时携带SYN请求标志位。携带序号、确认序号、数据字节数(0)、滑动窗口大小win。</p>
</li>
<li><p>主动发起连接请求端：发送ACK标志位，应答服务器连接请求，携带确认序号。</p>
</li>
</ul>
<p>2.四次挥手</p>
<ul>
<li><p>主动关闭连接请求端：发送FIN标志位</p>
</li>
<li><p>被动关闭连接请求端：应答ACK标志位  —&gt;半关闭完成</p>
</li>
<li><p>被动关闭连接请求端：发送FIN标志位</p>
</li>
<li><p>主动关闭连接请求端：应答ACK标志位  —&gt;连接全部关闭</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_3.png"></p>
<p>3.滑动窗口：发送给连接的对端，本端的缓冲区大小(实时)，保证数据不会丢失。</p>
<p>4.read函数的返回值：</p>
<ul>
<li><p>大于0：实际读到的字节数</p>
</li>
<li><p>等于0：已经读到结尾(对端已经关闭)</p>
</li>
<li><p>-1：应进一步判断errno的值</p>
</li>
<li><p>errno&#x3D;EAGAIM or EWOULDBLOCK：设置了非阻塞方式读，但没有数据到</p>
</li>
<li><p>errno&#x3D;EINTR：慢速系统调用被中断</p>
</li>
<li><p>errno&#x3D;”其他情况”：异常</p>
</li>
</ul>
<h2 id="2-3-多进程多线程的并发服务器"><a href="#2-3-多进程多线程的并发服务器" class="headerlink" title="2.3 多进程多线程的并发服务器"></a>2.3 多进程多线程的并发服务器</h2><p>案例：多进程并发服务器实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_child</span><span class="params">(<span class="type">int</span> signum)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(waitpid(<span class="number">0</span>,<span class="literal">NULL</span>,WNOHANG)&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> lfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);      <span class="comment">//得到一个监听的描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span>                  <span class="comment">//存服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));            <span class="comment">//将地址结构清0</span></span><br><span class="line">        srv_addr.sin_family = AF_INET;</span><br><span class="line">        srv_addr.sin_port = htons(<span class="number">9527</span>);              <span class="comment">//定义端口</span></span><br><span class="line">        srv_addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">//使用本地ip地址</span></span><br><span class="line">        Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;srv_addr,<span class="keyword">sizeof</span>(srv_addr));    <span class="comment">//绑定</span></span><br><span class="line">        Listen(lfd,<span class="number">128</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clit_addr</span>;</span>              <span class="comment">//存放连接客户端信息的结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> clit_len;</span><br><span class="line">        clit_len = <span class="keyword">sizeof</span>(clit_addr);</span><br><span class="line">        <span class="type">pid_t</span> pid;        <span class="comment">//进程id</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> cfd;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                cfd = Accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;clit_addr,&amp;clit_len);   <span class="comment">//监听连接</span></span><br><span class="line">                pid = fork();        <span class="comment">//建立连接成功才创建子线程，这样父子进程使用的文件描述符底层是同一套</span></span><br><span class="line">                <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;     <span class="comment">//子线程负责通信</span></span><br><span class="line">                        close(lfd);   <span class="comment">//父进程集合子进程都有lfd和cfd，在子进程中，lfd没有什么作用，可以直接关闭，因为子进程只完成任务，不需要监听连接</span></span><br><span class="line">                        <span class="keyword">break</span>;    <span class="comment">//跳出外面做，也可以全部写在这里面    </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;                <span class="comment">//父进程负责回收线程</span></span><br><span class="line">                        close(cfd);   <span class="comment">//在父进程中，父进程负责监听连接客户端，所以通信描述符cfd在父进程中没有用</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">                        act.sa_handler = catch_child;    <span class="comment">//捕抓函数</span></span><br><span class="line">                        sigemptyset(&amp;act.sa_mask);       <span class="comment">//将阻塞信号集置为0</span></span><br><span class="line">                        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">                        <span class="type">int</span> ret = sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);   <span class="comment">//当子进程状态发送变化，就触发捕捉函数</span></span><br><span class="line">                        <span class="keyword">if</span>(ret!=<span class="number">0</span>)&#123;</span><br><span class="line">                                perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;     <span class="comment">//下面是子进程负责通信</span></span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                        <span class="type">int</span> ret = read(cfd,buf,<span class="keyword">sizeof</span>(buf));   <span class="comment">//读取客户端发来的信息</span></span><br><span class="line">                        <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;    <span class="comment">//说明客户端那边请求断开</span></span><br><span class="line">                                close(cfd);</span><br><span class="line">                                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ret;i++)&#123;</span><br><span class="line">                                buf[i]=<span class="built_in">toupper</span>(buf[i]);     <span class="comment">//小写转大写</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        write(cfd,buf,ret);                 <span class="comment">//将转换好的发送给客户端</span></span><br><span class="line">                        write(STDOUT_FILENO,buf,ret);       <span class="comment">//将转换好的发送到屏幕</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4多线程并发服务器实现"><a href="#2-4多线程并发服务器实现" class="headerlink" title="2.4多线程并发服务器实现"></a>2.4多线程并发服务器实现</h2><p>案例：多线程并发服务器实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_info</span>&#123;</span>     <span class="comment">//定义一个结构体，作为参数传给回调函数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> connfd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">do_work</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">        <span class="type">int</span> n,i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> *<span class="title">ts</span> =</span> (<span class="keyword">struct</span> s_info*)arg;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">char</span> clie_ip[<span class="number">16</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                n = read(ts-&gt;connfd,buf,<span class="number">1024</span>);    <span class="comment">//读客户端发送来的信息存到buf</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;the client %d closed ....\n&quot;</span>,ts-&gt;connfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="comment">//打印客户端的信息</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                        inet_ntop(AF_INET,&amp;(*ts).cliaddr.sin_addr.s_addr,clie_ip,<span class="keyword">sizeof</span>(clie_ip)),</span><br><span class="line">                        ntohs((*ts).cliaddr.sin_port));   <span class="comment">//打印客户端信息</span></span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);    <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,buf,n);  <span class="comment">//写到屏幕上</span></span><br><span class="line">                write(ts-&gt;connfd,buf,n);     <span class="comment">//写给客户端</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(ts-&gt;connfd);    <span class="comment">//跳出循环，说明客户端端口了连接，关闭于客户端的通信描述符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">0</span>;   <span class="comment">//函数返回，相当于子线程结束，这里等价与pthread_exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);       <span class="comment">//得到监听描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>                        <span class="comment">//存放服务端信息结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));                  <span class="comment">//对结构体清0</span></span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        servaddr.sin_port = htons(<span class="number">9527</span>);                              <span class="comment">//指定端口号</span></span><br><span class="line">        servaddr.sin_addr.s_addr = htonl(INADDR_ANY);                 <span class="comment">//指定本地任意IP</span></span><br><span class="line">        Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));     <span class="comment">//绑定</span></span><br><span class="line">        Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept client connect ....\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>                 <span class="comment">//存放客户端信息结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> cliaddr_len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s_info</span> <span class="title">ts</span>[256];</span>                   <span class="comment">//定义一个结构体数组，用来存放每一个子线程信息</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">pthread_t</span> tid;     <span class="comment">//定义一个线程变量</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                cliaddr_len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;cliaddr_len); <span class="comment">//阻塞监听客户端连接请求</span></span><br><span class="line">                ts[i].cliaddr = cliaddr;     <span class="comment">//将客户端结构体信息存放在管理结构体中</span></span><br><span class="line">                ts[i].connfd = connfd;       <span class="comment">//将与客户端通信描述符存放在管理结构体中</span></span><br><span class="line">                pthread_create(&amp;tid,<span class="literal">NULL</span>,do_work,(<span class="type">void</span> *)&amp;ts[i]);    <span class="comment">//创建线程，执行回调函数</span></span><br><span class="line">                pthread_detach(tid);        <span class="comment">//分离子线程，父线程不会阻塞在这里等待子线程结束，而是由内核释放子线程</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-TCP状态转换"><a href="#2-5-TCP状态转换" class="headerlink" title="2.5 TCP状态转换"></a>2.5 TCP状态转换</h2><p>1.查看网络状态</p>
<ul>
<li><p>netstat -apn</p>
</li>
<li><p>netstat -apn | grep client ———-&gt; 查看对应进程(client也可以写成对应端口号)</p>
</li>
</ul>
<p>2.TCP状态转换图</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_4.png"></p>
<ul>
<li><p>主动发送请求连接端：CLOSED —– 发送SYN —– SYN_SEND —– 接收ACK、SYN —– SYN_SEND —– 发送ACK —– ESTABLISHED(数据通信态)</p>
</li>
<li><p>主动关闭请求连接端：ESTABLISHED(数据通信态) —– 发送FIN —– FIN_WAIT_1 —– 接收ACK —– FIN_WAIT_2(半关闭) —– 接收对端发送FIN —– FIN_WAIT_2(半关闭) —– 回发ACK —– TIME_WAIT(只有主动关闭连接方，会经历该状态) —– 等2MSL时长(40秒) —–CLOSED</p>
</li>
<li><p>被动接收连接请求端：CLOSK —– LISTEN —– 接收SYN —– LISTEN —– 发送ACK、SYN(对方收到) —– SYN_RCVD —– 接收ACK —– ESTABLISHED(数据通信态)</p>
</li>
<li><p>被动关闭连接请求端：ESTABLISHED(数据通信态)—–接收FIN —– ESTABLISHED —– 发送ACK —– CLOSE_WAIT(说明主动连接端处于半关闭状态) —– 发送FIN —– LAST_ACK —– 接收ACK —– CLOSED</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lxx93/tuchuang@main/picture/Network_programming/1_5.png" alt="1_5"></p>
<p>注意：如果是客户端先关闭，服务端后关闭，则客户端会TIME_WAIT，服务端不会，所以又可以马上对服务端进行开启；如果是服务端先关闭，客户端后关闭，则服务端会进入TIME_WAIT状态，此时还没有进入完全关闭状态，会占用端口40秒，所以你这段时间内又开服务端会失败，因为端口号还被占用着。</p>
<p>补：2 MSL时长：一定出现在主动关闭连接请求端(TIME_WAIT)；保证最后一个ACK能成功被对端接收(等待期间，对端没收到我发的ACK，对端会再次发送FIN请求)。</p>
<p>3.端口复用</p>
<blockquote>
<p>在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为TCP连接没有完全断开指的是connfd没有完全断开，而我们重新的是listenfd，虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。</p>
</blockquote>
<p>在server.c代码的socket()和bind()调用之间插入如下代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int opt = 1;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br></pre></td></tr></table></figure>

<p>4.半关闭</p>
<p>通信双方中，只有一端关闭通信。———&gt; FIN_WAIT_2</p>
<p>close(fd);</p>
<p>shutdown(int fd,int how);</p>
<ul>
<li>参2：SHUT_RD(关读端)；SHUT_WR(关写端)；SHUT_RDWR(关读写端)；</li>
</ul>
<p>注意：shutdown在关闭多个文件描述符应用的文件时(dup2重定向，多个文件描述符指向一个文件)，采用全关闭方法(关闭一个相当于关闭了全部)；close只关闭一个文件描述符，其他指向该文件的文件描述符还可以使用</p>
<h1 id="3-多路IO转接服务器"><a href="#3-多路IO转接服务器" class="headerlink" title="3. 多路IO转接服务器"></a>3. 多路IO转接服务器</h1><blockquote>
<p>多路IO转接服务器也叫多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接取而代之由内核应用程序监视文件。主要使用的方法有三种：select、epoll、poll。</p>
<p>服务端accept客户端的三种方式：阻塞、非阻塞忙轮询、响应式(多路IO转接)</p>
</blockquote>
<h2 id="3-1-select多路IO转接"><a href="#3-1-select多路IO转接" class="headerlink" title="3.1 select多路IO转接"></a>3.1 select多路IO转接</h2><p>原理：借助内核，select来监听客户端连接、数据通信事件。</p>
<p>1.清空一个文件描述符集合</p>
<ul>
<li><code>void FD_ZERO(fd_set *set);</code><ul>
<li>使用：fd_set rset;  FD_ZERO(&amp;rset);</li>
</ul>
</li>
</ul>
<p>2.将待监听的文件描述符，添加到监听集合中</p>
<ul>
<li><code>void FD_SET(int fd, fd_set *set); </code><ul>
<li>使用：FD_SET(3,&amp;rset);   FD_SET(5,&amp;rset);  FD_SET(6,&amp;rset);</li>
</ul>
</li>
</ul>
<p>3.将一个文件描述符从监听集合中移除</p>
<ul>
<li><code>void FD_CLR(int fd, fd_set *set);</code> <ul>
<li>使用：FD_CLR(4, &amp;rset);</li>
</ul>
</li>
</ul>
<p>4.判断一个文件描述符是否在监听集合中</p>
<ul>
<li><p><code>int FD_ISSET(int fd, fd_set *set); </code></p>
<ul>
<li><p>使用：FD_ISSET(4, &amp;rset);</p>
</li>
<li><p>+返回值：在(1)；不在(0)；</p>
</li>
</ul>
</li>
</ul>
<p>5.select监听</p>
<ul>
<li><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code></p>
<ul>
<li><p>参1：监听的所有文件描述符中，最大文件描述符+1；</p>
</li>
<li><p>参2：读文件描述符监听集合(传入传出参数)；</p>
</li>
<li><p>参3：写文件描述符监听集合(传入传出参数)； —&gt;不用就NULL</p>
</li>
<li><p>参4：异常文件描述符监听集合(传入传出参数)； —&gt;不用就NULL</p>
</li>
<li><p>参5：大于0(设置监听超时时长)；NULL(阻塞监听)；0(非阻塞监听，轮询)；</p>
</li>
<li><p>返回值：</p>
<ul>
<li><p>大于0：所有监听集合(3个)中，即读集合、写集合、异常集合，满足对应事件的总数</p>
</li>
<li><p>等于0：没有满足监听条件的文件描述符</p>
</li>
<li><p>等于-1：errno</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>6.select优缺点：</p>
<ul>
<li><p>缺点：(a)监听上限受文件描述符限制，最大1024；(b)检测满足条件的fd，只有自己添加业务逻辑提高效率，提高了编码难度</p>
</li>
<li><p>优点：跨平台。Windows、linux、macOS、Unix、类Unix、mips</p>
</li>
</ul>
<p>案例：使用select完成服务端的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);           <span class="comment">//得到监听连接的文件描述符</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));  <span class="comment">//实现端口复用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                           <span class="comment">//定义一个存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));                    <span class="comment">//将该结构体清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体的信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);        <span class="comment">//使用本地ip</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);                     <span class="comment">//端口使用9527</span></span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//服务端绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    fd_set rset,allset;                     <span class="comment">//定义读集合，备份集合allset</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> i,j,n;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span>          <span class="comment">//定义一个存放客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="type">int</span> maxfd = listenfd;                  <span class="comment">//将最大fd定义伪监听的fd(刚开始)</span></span><br><span class="line">    FD_ZERO(&amp;allset);                      <span class="comment">//清空监听集合</span></span><br><span class="line">    FD_SET(listenfd,&amp;allset);              <span class="comment">//将监听fd添加到监听集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        rset = allset;                 <span class="comment">//备份需要监听的fd集合</span></span><br><span class="line">        <span class="comment">//使用select监听，得到的传出rset集合里面都是就绪的文件描述符(需要处理的)，得到的ret是该集合的个数(满足处理的个数)</span></span><br><span class="line">        ret = select(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;select error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(listenfd,&amp;rset))&#123;      <span class="comment">//判断listenfd监听描述符是否满足监听的读事件</span></span><br><span class="line">            <span class="comment">//如果满足，说明有客户端发送来了请求连接</span></span><br><span class="line">            clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">            connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,&amp;clie_addr_len);  <span class="comment">//建立连接，不会阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创建连接成功connfd = %d\n&quot;</span>,connfd);</span><br><span class="line">            FD_SET(connfd,&amp;allset);           <span class="comment">//将新产生的通信文件描述符fd添加到监听集合中(下一论监听)</span></span><br><span class="line">            <span class="keyword">if</span>(maxfd&lt;connfd)&#123;                 <span class="comment">//修改最大文件描述符</span></span><br><span class="line">                maxfd = connfd;           </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span>(ret==<span class="number">1</span>)&#123;    <span class="comment">//说明select只返回一个，并且是listenfd，后续执行无须执行</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=listenfd+<span class="number">1</span>;i&lt;=maxfd;i++)&#123;         <span class="comment">//处理满足读事件的通信文件描述符</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;rset))&#123;              <span class="comment">//找到满足读事件的那个通信文件描述符</span></span><br><span class="line">                n = read(i,buf,<span class="keyword">sizeof</span>(buf));    <span class="comment">//接收它发来的数据</span></span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;                       <span class="comment">//检测到客户端是否已经关闭连接</span></span><br><span class="line">                    close(i);               </span><br><span class="line">                    FD_CLR(i,&amp;allset);         <span class="comment">//将关闭的fd移除监听集合</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;read error&quot;</span>);      <span class="comment">//处于异常</span></span><br><span class="line">                &#125;       </span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    buf[j] = <span class="built_in">toupper</span>(buf[j]);  <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;       </span><br><span class="line">                write(i,buf,n);                <span class="comment">//通过通信描述符，发送处理好的信息给客户端</span></span><br><span class="line">                write(STDOUT_FILENO,buf,n);    <span class="comment">//将处理的信息打印到终端</span></span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;       </span><br><span class="line">    close(listenfd);         <span class="comment">//关闭监听描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-poll多路IO转接"><a href="#3-2-poll多路IO转接" class="headerlink" title="3.2 poll多路IO转接"></a>3.2 poll多路IO转接</h2><p>1.poll监听函数</p>
<p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></p>
<ul>
<li><p>参1：监听的文件描述符(数组)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> fd;         <span class="comment">//待监听的文件描述</span></span><br><span class="line">	<span class="type">short</span> events;   <span class="comment">//监听对应的事件(POLLIN、POLLOUT、POLLERR)</span></span><br><span class="line">	<span class="type">short</span> revnets;  <span class="comment">//传入时给0，则返回满足对应事件POLLIN、//POLLOUT、POLLERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参2：监听结构体数组的实际有效监听个数(刚开始为1，只有监听描述符)</p>
</li>
<li><p>参3：大于0(超时时长，单位：毫秒)；等于-1(阻塞等待)；等于0(不阻塞)。</p>
</li>
<li><p>返回值：返回满足对应监听事件的文件描述符总个数</p>
</li>
</ul>
<p>2.poll的优缺点</p>
<ul>
<li><p>优点：自带数组结构，可以将监听事件集合和返回事件集合分离；拓展监听上限；可以突破1024。</p>
</li>
<li><p>缺点：不能跨平台，只能 inux系统；无法直接定位满足监听事件的文件描述符，编码难度较大。</p>
</li>
</ul>
<p>3.突破1024文件描述符限制(对select不管用)</p>
<ul>
<li><p>cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max  ——-&gt;当前计算机所能打开的最大文件个数，受硬件影响</p>
</li>
<li><p>ulimit -a   ——–&gt;查看当前用户下的进程默认打开文件描述符个数(不改为1024)</p>
</li>
</ul>
<p>修改：打开vim &#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<p>写入： </p>
<ul>
<li><em>soft nofile 65536  ———-&gt;设置默认值，可以直接借助命令修改</em></li>
<li>hard nofile 100000 ———–&gt;命令修改上限</li>
</ul>
<p>修改后需要注销用户，使其生效，相当于重新启动</p>
<p>案例：使用poll实现多路IO转接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);         <span class="comment">//得到监听描述符</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                  <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));           <span class="comment">//清0</span></span><br><span class="line">    <span class="comment">//初始化服务端的结构体信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//服务端绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[1024];</span>    <span class="comment">//定义一个文件描述符的结构体(还包含其他内容)</span></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;       <span class="comment">//要监听的第一个文件描述符存入client[0]位置</span></span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;     <span class="comment">//监听listenfd文件描述符的读事件</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1024</span>;i++)&#123;    <span class="comment">//因为listenfd文件描述符已经占了0位置，所以从1位置开始</span></span><br><span class="line">        client[i].fd = <span class="number">-1</span>;     <span class="comment">//初始化文件描述符结构体数组，fd=-1意味着该位置未被占用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">0</span>;        <span class="comment">//初始化client[]数组有效元素中最大元素下标(刚开始只有listenfd文件描述符结构体)</span></span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>  <span class="comment">//存放客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line">    <span class="type">char</span> client_ip[<span class="number">16</span>];    <span class="comment">//客户端的ip地址(一般在要打印客户端信息时，才会用到)</span></span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        nready = poll(client,maxi+<span class="number">1</span>,<span class="number">-1</span>);   <span class="comment">//监听是否有客户端连接请求。结构体数组；有效文件描述符个数；阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(client[<span class="number">0</span>].revents &amp; POLLIN)&#123;    <span class="comment">//为真，说明listenfd有读事件就绪(客户端有连接请求)</span></span><br><span class="line">            clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">            connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;clilen);  <span class="comment">//接收客户端请求，不会阻塞</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,</span><br><span class="line">                   inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,client_ip,<span class="keyword">sizeof</span>(client_ip)),</span><br><span class="line">                   ntohs(cliaddr.sin_port));</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1024</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(client[i].fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    client[i].fd = connfd;  <span class="comment">//找到client[]中空闲的位置，存放通信描述符connfd</span></span><br><span class="line">                    <span class="keyword">break</span>;    <span class="comment">//找到后直接跳出循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1024</span>)&#123;      <span class="comment">//检测client是否满了</span></span><br><span class="line">                perror(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            client[i].events = POLLIN;    <span class="comment">//将刚刚得到的通信文件描述符设为检测读事件</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;maxi)&#123;</span><br><span class="line">                maxi = i;   <span class="comment">//设置client文件描述符结构体数组的最大有效下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--nready&lt;=<span class="number">0</span>)&#123; <span class="comment">//当只有一个就绪事件时，这个事件必为监听文件描述符的，所以就没有通信描述符的就绪事件，就不用执行下面，继续回到poll</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//开始通信文件描述符</span></span><br><span class="line">       <span class="type">int</span> sockfd;</span><br><span class="line">       <span class="type">int</span> i,j,n;</span><br><span class="line">       <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxi;i++)&#123; <span class="comment">//前面的if没有满足，说明有通信文件描述符满足读事件就绪，检测client[]，看是哪个connfd就绪</span></span><br><span class="line">           <span class="keyword">if</span>((sockfd = client[i].fd)&lt;<span class="number">0</span>)&#123;  <span class="comment">//从通信文件描述符第一个找到最后，如果是&lt;0,说明对应通信描述符没有收到客户端的信息，</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(client[i].revents &amp; POLLIN)&#123;</span><br><span class="line">               <span class="keyword">if</span>((n=read(sockfd,buf,<span class="number">1024</span>))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(errno==ECONNRESET)&#123;   <span class="comment">//收到RST标志</span></span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;client[%d] aborted connection\n&quot;</span>,i);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;   <span class="comment">//还有其他情况的错误，这里就统一这种了，没有一一列出来</span></span><br><span class="line">                       perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   close(sockfd);</span><br><span class="line">                   client[i].fd = <span class="number">-1</span>;  <span class="comment">//poll中不监控该文件描述符，直接置为-1即可，不用像select中那样移除</span></span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>,i);  <span class="comment">//客户端断开连接</span></span><br><span class="line">                   close(sockfd);</span><br><span class="line">                   client[i].fd = <span class="number">-1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                       buf[j] = <span class="built_in">toupper</span>(buf[j]);   <span class="comment">//小写转大写</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   write(sockfd,buf,n);</span><br><span class="line">                   write(STDOUT_FILENO,buf,n);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(--nready&lt;=<span class="number">0</span>)&#123;   <span class="comment">//每次执行完通信描述符，都--了，当为0的时候，说明就没有了，直接跳出循环，不用再找了</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-epoll多路IO转接"><a href="#3-3-epoll多路IO转接" class="headerlink" title="3.3 epoll多路IO转接"></a>3.3 epoll多路IO转接</h2><p>1.<code>int epoll_create(int size);</code></p>
<ul>
<li><p>参数：创建的红黑树的监听节点数量。(仅供内核参考)</p>
</li>
<li><p>返回值：成功(指向新创建的红黑树的根节点的fd)；失败(-1,errno)</p>
</li>
</ul>
<p>2.<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p>
<ul>
<li><p>参1：epoll_create函数的返回值</p>
</li>
<li><p>参2：对该监听红黑树所做的操作</p>
<ul>
<li>EPOLL_CTL_ADD：添加fd到监听红黑树</li>
<li>EPOLL_CTL_MOD：修改fd在监听红黑树上的监听事件</li>
<li>EPOLL_CTL_DEL：将一个fd从监听红黑树上摘下(取消监听)</li>
</ul>
</li>
<li><p>参3：待监听的fd</p>
</li>
<li><p>参4：本质是struct epoll_event结构体地址。结构体内有events包括EPOLLIN、EPOLLOUT、EPOLLERR；有data，它是共用体，包括fd，(void *)ptr等。</p>
</li>
</ul>
<p>3.<code>int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</code></p>
<ul>
<li><p>参1：epoll_create函数的返回值</p>
</li>
<li><p>参2：传出参数，是数组，满足监听条件的哪些fd结构体</p>
</li>
<li><p>参3：数组元素的总个数</p>
</li>
<li><p>参4：等于-1(阻塞)；等于0(不阻塞)；大于0：超时时间(毫秒)</p>
</li>
<li><p>返回值：大于0(满足监听的总个数，可以用作循环上限)；等于0(没有fd满足监听事件)；等于-1(失败，errno)；</p>
</li>
</ul>
<p>案例：使用epoll实现多路IO转接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面代码对网络的函数进行了封装，所以直接调用的是封装的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> listenfd = Socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);           <span class="comment">//得到监听描述符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listenfd = %d\n&quot;</span>,listenfd);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span>(opt));      <span class="comment">//端口复用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>                      <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));               <span class="comment">//清0</span></span><br><span class="line">    <span class="comment">//初始化服务端结构体信息</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">    Bind(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));     <span class="comment">//绑定</span></span><br><span class="line">    Listen(listenfd,<span class="number">128</span>);</span><br><span class="line">    <span class="type">int</span> efd = epoll_create(<span class="number">39</span>);   <span class="comment">//创建epoll模型，efd指向红黑树的根节点。参数为设定又几个红黑树(大于0即可)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;efd = %d\n&quot;</span>,efd);</span><br><span class="line">    <span class="keyword">if</span>(efd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>,<span class="title">ep</span>[1024];</span>    <span class="comment">//tep为epoll_ctl的参数，ep[]为epoll_wait的参数</span></span><br><span class="line">    tep.events = EPOLLIN;         <span class="comment">//读监听事件</span></span><br><span class="line">    tep.data.fd = listenfd; <span class="comment">//指定了listenfd的监听事件为读</span></span><br><span class="line">    <span class="type">int</span> res = epoll_ctl(efd,EPOLL_CTL_ADD,listenfd,&amp;tep);   <span class="comment">//epoll_create返回值；是添加(选项)；添加的描述符；添加的ifd所对应的事件(结构体类型);</span></span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>  <span class="comment">//装客户端信息的结构体</span></span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">//epoll为server阻塞监听事件，ep为struct epoll_event类型数组(传出参数，返回满足监听的那些描述符)；参数3为数组容量；-1表示永久阻塞</span></span><br><span class="line">        <span class="type">int</span> nready = epoll_wait(efd,ep,<span class="number">1024</span>,<span class="number">-1</span>);  <span class="comment">//返回的是所有就绪的描述符的个数，与ep数组里面的个数一样</span></span><br><span class="line">        <span class="keyword">if</span>(nready == <span class="number">-1</span>)&#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nready;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ep[i].data.fd == listenfd)&#123;  <span class="comment">//如果成立，说明是监听事件</span></span><br><span class="line">                clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">char</span> client_ip[<span class="number">16</span>];</span><br><span class="line">                <span class="type">int</span> connfd = Accept(listenfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,&amp;clilen);  <span class="comment">//与客户端建立连接</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>,inet_ntop(AF_INET,&amp;cliaddr.sin_addr.s_addr,client_ip,<span class="keyword">sizeof</span>(client_ip)),ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cfd %d----client %d\n&quot;</span>,connfd,++num);</span><br><span class="line">                tep.events = EPOLLIN;      <span class="comment">//往红黑树上添加新的结点</span></span><br><span class="line">                tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd,EPOLL_CTL_ADD,connfd,&amp;tep);  <span class="comment">//将新产生的通信描述符加入到红黑树</span></span><br><span class="line">                <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl_error&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果不是监听描述符就绪，就是通信描述符</span></span><br><span class="line">                <span class="type">int</span> sockfd = ep[i].data.fd;</span><br><span class="line">                <span class="type">int</span> n = read(sockfd,buf,<span class="number">1024</span>);     <span class="comment">//读取从客户端发来的信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;         <span class="comment">//客户端请求断开</span></span><br><span class="line">                    res = epoll_ctl(efd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);  <span class="comment">//将该文件描述符从红黑树摘除</span></span><br><span class="line">                    <span class="keyword">if</span>(res == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>,sockfd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;        <span class="comment">//出现异常</span></span><br><span class="line">                    perror(<span class="string">&quot;read n&lt;0 error:&quot;</span>);</span><br><span class="line">                    res = epoll_ctl(efd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);  <span class="comment">//摘除节点</span></span><br><span class="line">                    close(sockfd);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> j;</span><br><span class="line">                    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                        buf[j] = <span class="built_in">toupper</span>(buf[j]);    <span class="comment">//转大写</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    write(STDOUT_FILENO,buf,n);    <span class="comment">//将处理的信息打印到终端</span></span><br><span class="line">                    write(sockfd,buf,n);           <span class="comment">//将处理的信息发送给客户端</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);         <span class="comment">//关闭监听描述符</span></span><br><span class="line">    close(efd);              <span class="comment">//关闭红黑树的根结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.epoll事件模式</p>
<p>ET模式：边沿触发，缓冲区剩余未读尽的数据不会导致epoll_wait返回。新的事件满足，才会触发。</p>
<p>FT模式：水平触发(默认模式)，缓冲区剩余未读尽的数据会导致epoll_wait返回。</p>
<p>注意：像select和epoll它们监听的都是文件描述符，不是套接字，所以可以结合管道来使用。</p>
<p>比较：FT是缺省的工作方式，并且同时支持阻塞和非阻塞；ET是高速工作方式，只支持非阻塞(所以ET常与非阻塞一起用)–&gt;非阻塞通常搭配忙轮询。</p>
<p>结论：epoll的ET模式，高效模式，但是只支持非阻塞模式(no black)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&amp;event);</span><br><span class="line"><span class="type">int</span> flag = fcntl(cfd,F_GETFL);</span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(cfd,F_SETFL,flg);</span><br></pre></td></tr></table></figure>

<p>5.epoll的优缺点</p>
<ul>
<li><p>epoll优点：高效，突破1024文件描述符</p>
</li>
<li><p>epoll缺点：不能跨平台，只能linux系统</p>
</li>
</ul>
<p>案例：通过epoll和管道测试ET和FT模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> efd,i;</span><br><span class="line">        <span class="type">int</span> pfd[<span class="number">2</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;       <span class="comment">//定义一个进程变量</span></span><br><span class="line">        <span class="type">char</span> buf[MAXLINE],ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        pipe(pfd);       <span class="comment">//创建一个管道</span></span><br><span class="line">        pid = fork();    <span class="comment">//创建一个子进程</span></span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;                             <span class="comment">//子进程负责写端</span></span><br><span class="line">                close(pfd[<span class="number">0</span>]);                  <span class="comment">//关闭读端</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXLINE/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                                buf[i] = ch;</span><br><span class="line">                        &#125;                      <span class="comment">//这时为aaaaa</span></span><br><span class="line">                        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">//为aaaa\n</span></span><br><span class="line">                        ch++;                  <span class="comment">//ch变为b</span></span><br><span class="line">                        <span class="keyword">for</span>(;i&lt;MAXLINE;i++)&#123;   <span class="comment">//i从5开始继续循环</span></span><br><span class="line">                                buf[i] = ch;</span><br><span class="line">                        &#125;                     <span class="comment">//这时为aaaa\nbbbbb</span></span><br><span class="line">                        buf[i<span class="number">-1</span>] = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">//为aaaa\nbbbb\n</span></span><br><span class="line">                        ch++;                    <span class="comment">//ch变为c</span></span><br><span class="line">                        write(pfd[<span class="number">1</span>],buf,<span class="keyword">sizeof</span>(buf));     <span class="comment">//将buf里面的内容写到管道的写端</span></span><br><span class="line">                        sleep(<span class="number">5</span>);         <span class="comment">//睡眠5秒后，继续上面循环</span></span><br><span class="line">                &#125;</span><br><span class="line">                close(pfd[<span class="number">1</span>]);               <span class="comment">//执行完后，关闭写端</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;         <span class="comment">//父进程负责读</span></span><br><span class="line">                <span class="keyword">struct</span> epoll_event event;              <span class="comment">//定义一个epoll_event的结构体</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">resevent</span>[10];</span>       <span class="comment">//定义一个epoll_event的结构体数组</span></span><br><span class="line">                <span class="type">int</span> res ,len;</span><br><span class="line">                close(pfd[<span class="number">1</span>]);                        <span class="comment">//关闭写端</span></span><br><span class="line">                efd = epoll_create(<span class="number">10</span>);               <span class="comment">//efd也是文件描述符，创建一个容纳10个节点的红黑树</span></span><br><span class="line">                <span class="comment">//event.events = EPOLLIN | EPOLLET;   //ET边沿触发：未读完的数据不会再次提醒，除非有新数据写入</span></span><br><span class="line">                event.events = EPOLLIN;               <span class="comment">//水平触发(默认)。这种模式下，没有读完的数据，马上又会进行读</span></span><br><span class="line">                event.data.fd = pfd[<span class="number">0</span>];              <span class="comment">//将fd定义为管道的读端</span></span><br><span class="line">                epoll_ctl(efd,EPOLL_CTL_ADD,pfd[<span class="number">0</span>],&amp;event);    <span class="comment">//将管道的读端挂到红黑树上</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                        res = epoll_wait(efd,resevent,<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;res %d\n&quot;</span>,res);              <span class="comment">//打印满足就绪的文件描述符结构</span></span><br><span class="line">                        <span class="keyword">if</span>(resevent[<span class="number">0</span>].data.fd == pfd[<span class="number">0</span>])&#123;        <span class="comment">//如果是读端满足就绪</span></span><br><span class="line">                                len = read(pfd[<span class="number">0</span>],buf,MAXLINE/<span class="number">2</span>);     <span class="comment">//从管道的读端读一半数据到buf,还有一半数据留在了管道</span></span><br><span class="line">                                write(STDOUT_FILENO,buf,len);       <span class="comment">//将读到的内容写到屏幕上</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                close(pfd[<span class="number">0</span>]);   <span class="comment">//关闭管道的读端</span></span><br><span class="line">                close(efd);      <span class="comment">//关闭红黑树的根节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-其它通信方式"><a href="#4-其它通信方式" class="headerlink" title="4. 其它通信方式"></a>4. 其它通信方式</h1><h2 id="4-1-TCP通信和UDP通信各自的优缺点"><a href="#4-1-TCP通信和UDP通信各自的优缺点" class="headerlink" title="4.1 TCP通信和UDP通信各自的优缺点"></a>4.1 TCP通信和UDP通信各自的优缺点</h2><p>TCP：面向连接的，可靠数据报传输。对于不稳定的网络层，采取完全弥补的通信方式。丢包重传。</p>
<ul>
<li><p>优点：数据流量稳定、传输速度稳定、顺序稳定</p>
</li>
<li><p>缺点：传输速度慢、效率低、资源开销大</p>
</li>
</ul>
<p>使用场景：数据的完整型要求较高，不追求效率。(大数据传输、文件传输)</p>
<p>2.UDP：无连接的，不可靠的数据报传递。对于不稳定的网络层，采取完全不弥补的通信方式。默认还原网络状况。</p>
<ul>
<li><p>优点：传输速度快、效率高、资源开销小</p>
</li>
<li><p>缺点：数据流量不稳定、传输速度不稳定、顺序不稳定</p>
</li>
</ul>
<p>使用场景：对时效性要求较高的场合，稳定性其次。(游戏、视频会议、视频电话)—–&gt;腾讯、华为、阿里：应用层数据校验协议，弥补UDP的不足。</p>
<h2 id="4-2-UDP通信"><a href="#4-2-UDP通信" class="headerlink" title="4.2 UDP通信"></a>4.2 UDP通信</h2><p>1.UDP中负责读数据函数</p>
<p><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code></p>
<ul>
<li><p>参1：套接字</p>
</li>
<li><p>参2：缓冲区地址</p>
</li>
<li><p>参3：缓冲区大小</p>
</li>
<li><p>参4：0</p>
</li>
<li><p>参5：传出参数，对端的地址结构</p>
</li>
<li><p>参6：传入传出</p>
</li>
<li><p>返回值：成功(接收数据字节数)；失败：-1(errno),0(对端关闭)</p>
</li>
</ul>
<p>2.UDP中负责写数据函数</p>
<p><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code></p>
<ul>
<li><p>参1：套接字</p>
</li>
<li><p>参2：存储数据的缓冲区</p>
</li>
<li><p>参3：数据长度</p>
</li>
<li><p>参4：0</p>
</li>
<li><p>参5：传入参数，目标地址结构</p>
</li>
<li><p>参6：地址结构长度</p>
</li>
<li><p>返回值：成功(写出数据字节数)；失败：-1(errno)</p>
</li>
</ul>
<p>UDP服务端实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);      <span class="comment">//第2个参数表示是报式协议</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//存放服务端数据的结点</span></span><br><span class="line">        bzero(&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));        <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化服务端结构体</span></span><br><span class="line">        serv_addr.sin_family = AF_INET;</span><br><span class="line">        serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">        serv_addr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">        bind(sockfd,(<span class="keyword">struct</span> sockaddr *)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));    <span class="comment">//绑定</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clie_addr</span>;</span>               <span class="comment">//存放客户端数据结构体</span></span><br><span class="line">        <span class="type">socklen_t</span> clie_addr_len;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="type">char</span> str_ip[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepting connections.....\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                clie_addr_len = <span class="keyword">sizeof</span>(clie_addr);</span><br><span class="line">                n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,&amp;clie_addr_len);   <span class="comment">//接收客户端传来的信息，得到客户端的地址结构信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at port %d\n&quot;</span>,</span><br><span class="line">                        inet_ntop(AF_INET,&amp;clie_addr.sin_addr.s_addr,str_ip,<span class="keyword">sizeof</span>(str_ip)),</span><br><span class="line">                        ntohs(clie_addr.sin_port));</span><br><span class="line">                <span class="type">int</span> i;</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);      <span class="comment">//小写转大写</span></span><br><span class="line">                &#125;</span><br><span class="line">                n = sendto(sockfd,buf,n,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;clie_addr,<span class="keyword">sizeof</span>(clie_addr));      <span class="comment">//向客户端发送数据</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);         <span class="comment">//关闭文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UDP客户端实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZ 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> sockfd = socket(AF_INET,SOCK_DGRAM,<span class="number">0</span>);         <span class="comment">//第2个参数表示是报式协议</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span>             <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));       <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化服务端信息</span></span><br><span class="line">        servaddr.sin_family = AF_INET;</span><br><span class="line">        inet_pton(AF_INET,<span class="string">&quot;192.168.88.93&quot;</span>,&amp;servaddr.sin_addr);</span><br><span class="line">        servaddr.sin_port = htons(<span class="number">9527</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf,BUFSIZ,<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;      <span class="comment">//从键盘输入存到buf中</span></span><br><span class="line">                n = sendto(sockfd,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));   <span class="comment">//将buf里的信息发送给服务端，地址结构信息是服务端的</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;sendto error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                n = recvfrom(sockfd,buf,BUFSIZ,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">//接收服务端发来的信息，NULL：表示不关心对端信息</span></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">-1</span>)&#123;</span><br><span class="line">                        perror(<span class="string">&quot;recvfrom error&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                write(STDOUT_FILENO,buf,n);          <span class="comment">//将服务端写来的信息(buf里面)打印到屏幕</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-本地套接字-domain"><a href="#4-3-本地套接字-domain" class="headerlink" title="4.3 本地套接字(domain)"></a>4.3 本地套接字(domain)</h2><p>本地套接字与网络套接字使用的区别：</p>
<ul>
<li><p>网络套接字中用的AF_INET；本地套接字是用AF_UNIX&#x2F;AF_LOCAL</p>
</li>
<li><p>网络套接字中的地址结构是sockaddr_in；本地套接字是用sockaddr_un</p>
</li>
<li><p>网络套接字中是绑定ip和端口，本地套接字是绑定socket文件即可(伪文件)，类似于管道(但不是)</p>
</li>
</ul>
<p>补：本地套接字只能用于本机的两个进程通信。稳定性强，双向全双工。</p>
<p>注意：bind()函数调用成功，会创建一个socket,因此为保证bind成功，通常我们在bind之前，可以使用unlink(“serv.socket”)；本地套接字中的客户端不能依赖隐式绑定，需要自己创建一个socke文件后绑定。</p>
<p>本地套接字的服务端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR <span class="string">&quot;serv.socket&quot;</span>       <span class="comment">//服务端用到的socetk文件</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> lfd = Socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建本地套接字的第一个参数是AF_UNIX；第二个参数是报式还是流式都可以，返回一个本地套接字</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span>            <span class="comment">//存放服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));      <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化本地套接字的服务端信息</span></span><br><span class="line">        servaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);     <span class="comment">//定义的文件名，相当于本地套接字的地址结构</span></span><br><span class="line">        <span class="type">int</span> len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);   <span class="comment">//结构体大小等于2(AF_UNIX的大小)+文件名大小</span></span><br><span class="line">        unlink(SERV_ADDR);      <span class="comment">//确保bind之前serv.sock文件(伪文件)不存在当前目录(执行过程序后，会在当前目录下创建该文件，用于传数据)，bind会创建该文件</span></span><br><span class="line">        Bind(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;servaddr,len);       <span class="comment">//参3不能是sizeof(servaddr)</span></span><br><span class="line">        Listen(lfd,<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept .....\n&quot;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = Accept(lfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,(<span class="type">socklen_t</span> *)&amp;len);  <span class="comment">//套接字；客户端地址结构(传出)；传入传出</span></span><br><span class="line">                len -= offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path);     <span class="comment">//得到文件名大小(传出来的len-偏移位置(AF_UNIX)大小)</span></span><br><span class="line">                cliaddr.sun_path[len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//确保打印时没有乱码出现</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client bind filename %s\n&quot;</span>,cliaddr.sun_path);</span><br><span class="line">                <span class="keyword">while</span>((size = read(cfd,buf,<span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        write(cfd,buf,size);</span><br><span class="line">                &#125;</span><br><span class="line">                close(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">        close(lfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地套接字的客户端实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_ADDR <span class="string">&quot;serv.socket&quot;</span>       <span class="comment">//服务端用到的socetk文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIE_ADDR <span class="string">&quot;clie.socket&quot;</span>       <span class="comment">//客户端用到的socket文件</span></span></span><br><span class="line"><span class="comment">//本地套接字通信</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> cfd = Socket(AF_UNIX,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建本地套接字的第一个参数是AF_UNIX；第二个参数是报式还是流式都可以，返回一个本地套接字</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span>       <span class="comment">//存放客户端信息的结构体</span></span><br><span class="line">        bzero(&amp;cliaddr,<span class="keyword">sizeof</span>(cliaddr));   <span class="comment">//清0</span></span><br><span class="line">    	<span class="comment">//初始化客户端结构体信息</span></span><br><span class="line">        cliaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(cliaddr.sun_path,CLIE_ADDR);     <span class="comment">//定义的文件名，相当于本地套接字的地址结构</span></span><br><span class="line">        <span class="type">int</span> len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(cliaddr.sun_path);   <span class="comment">//结构体大小等于2(AF_UNIX的大小)+文件名大小</span></span><br><span class="line">        unlink(CLIE_ADDR);          <span class="comment">//确保bind之前clie.sock文件(伪文件)不存在，bind会创建该文件</span></span><br><span class="line">        Bind(cfd,(<span class="keyword">struct</span> sockaddr *)&amp;cliaddr,len);       <span class="comment">//参3不能是sizeof(cliaddr)</span></span><br><span class="line">   		</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span>           <span class="comment">//存到服务端信息的结构体</span></span><br><span class="line">        bzero(&amp;servaddr,<span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">        servaddr.sun_family = AF_UNIX;</span><br><span class="line">        <span class="built_in">strcpy</span>(servaddr.sun_path,SERV_ADDR);   <span class="comment">//这些是要连的服务端的信息</span></span><br><span class="line">        len = offsetof(<span class="keyword">struct</span> sockaddr_un,sun_path) + <span class="built_in">strlen</span>(servaddr.sun_path);     <span class="comment">//计算服务端地址结构的有效长度</span></span><br><span class="line">        Connect(cfd, (<span class="keyword">struct</span> sockaddr *)&amp;servaddr,len);     <span class="comment">//连接服务端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(fgets(buf,<span class="keyword">sizeof</span>(buf),<span class="built_in">stdin</span>) != <span class="literal">NULL</span>)&#123;            <span class="comment">//从输入端输入信息到buf</span></span><br><span class="line">                write(cfd,buf,<span class="built_in">strlen</span>(buf));              <span class="comment">//从buf将信息传给服务端</span></span><br><span class="line">                len = read(cfd,buf,<span class="keyword">sizeof</span>(buf));         <span class="comment">//从服务端得到的信息存在buf</span></span><br><span class="line">                write(STDOUT_FILENO,buf,len);            <span class="comment">//将buf里的信息写到屏幕</span></span><br><span class="line">        &#125;</span><br><span class="line">        close(cfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux知识</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>epoll</tag>
        <tag>协议</tag>
        <tag>套接字</tag>
        <tag>多路io转接</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
        <tag>多进程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
